<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="MySQL高级特性">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL高级特性">
<meta property="og:url" content="https://wenslo.github.io/2020/12/31/Book Nodes/高性能MySQL/5-MySQL高级特性/index.html">
<meta property="og:site_name" content="温海林的博客">
<meta property="og:description" content="MySQL高级特性">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-12-31T13:03:04.758Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL高级特性">
<meta name="twitter:description" content="MySQL高级特性">

<link rel="canonical" href="https://wenslo.github.io/2020/12/31/Book Nodes/高性能MySQL/5-MySQL高级特性/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>MySQL高级特性 | 温海林的博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">温海林的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">技术，工作，生活，随笔</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wenslo.github.io/2020/12/31/Book Nodes/高性能MySQL/5-MySQL高级特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/images/fbb1.jpg">
      <meta itemprop="name" content="温海林">
      <meta itemprop="description" content="Fake it, make it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温海林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL高级特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-31 21:03:04" itemprop="dateCreated datePublished" datetime="2020-12-31T21:03:04+08:00">2020-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          
            <div class="post-description">MySQL高级特性</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ol>
<li><p>分区表</p>
<p> 对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。所以分区对于SQL层爱说是一个完全封装底层实现的黑盒，对应用是透明的，但是从底层的文件系统来看就很容易发现，每一个分区表都有一个使用#分割命名的表空间。</p>
<p> MySQL在创建表时使用PARTITION BY 子句定义每个分区存放的数据。在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区——只需要查找包含需要数据的分区就可以了。</p>
<p> 分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中。这样做科技将相关的数据存放在一起，另外，如果想一次批量删除整个分区的数据也会变得方面。下面的场景中，分区可以起到非常大的作用。</p>
<ul>
<li>表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。</li>
<li>分区表的数据更容易维护。例如，想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作</li>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li>
<li>可以使用分区表来避免某些特殊的瓶颈，例如innodb的单个索引的互斥访问、ext3文件系统的inode锁竞争等。</li>
<li><p>如果需要，还可以备份和恢复独立的分区，这在非常大的数据集下的场景下效果非常好</p>
<p>分区的一些限制：</p>
</li>
<li><p>一个表最多只能有1024个分区</p>
</li>
<li>MySQL5.1中，分区表达式必须是证书买或者是返回整数的表达式。在MySQL5.5中，某些场景汇总可以直接使用列来进行分区。</li>
<li>如果分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li>
<li>分区表中无法使用外键约束</li>
</ul>
</li>
</ol><a id="more"></a>
<p>1.1 分区表的原理</p>
<p>分区表由多个相关的底层表实现，这些底层表由句柄对（Handler object）表示，所以我们也可以直接访问各分区。存储引擎管理分区的各个底层表和管理普通表一样（有的底层表都必须使用相同的存储引擎），分区表的索引知在各个底层表上各自加上一个完全相同的索引。<br>分区表操作的逻辑如下：</p>
<p><strong>select查询</strong><br>当查询一个分区表的时候，分区层先打开并锁住所有的底表，优化器先判断是否可以过滤部分分区，然后在调用对应存储引擎接口访问各个分区的数据。</p>
<p><strong>insert操作</strong><br>当写入一条记录时，分区层先打开并锁住所有的底层表，然确定那个分区接收这条记录，再将记录写入对应底层表。</p>
<p><strong>delete操作</strong><br>当写入一条记录时，分区层先打开并锁住所有的底层表，然确定数据对应的分区，最后对底层表进行删除操</p>
<p><strong>update操作</strong><br>当写入一条记录时，分区层先打开并锁住所有的底层表MySQL先确定需要更新的记录在哪个分区，然后取出数据并新，再判断更新后的数据应该放在哪个分区，最后对底层表行写入操作，并对原数据所在的底层表进行删除操作。</p>
<p>有些操作是支持过滤的。例如，当删除一条记录时，MySQL要先找到这条记录，如果where条件恰好和分区表达式匹配就可以将所有不包含这条记录的分区都过滤掉。针对udpat语句同样有效。如果是insert操作，则本身就是知名中一分区，其他分区都会被过滤掉。MySQL先确定这条记录属于个分区，然后再将记录写入对应的底层分区表，无需对任何他分区进行操作。</p>
<p>如果存储引擎能够自己实现行级锁，则会在分区层释放对应表锁。</p>
<p>1.2 分区表的类型</p>
<p>支持多种分区表，最多的是根据范围进行分区，每个分区存储落在某个范围的记录，分区表达式可以是列，也可以使包含列的表达式，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sales(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    order_date datetime <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">RANGE</span> (<span class="keyword">year</span>(order_date))(</span><br><span class="line">    <span class="keyword">partition</span> p_2010 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2010</span>),</span><br><span class="line">    <span class="keyword">partition</span> p_2011 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2011</span>),</span><br><span class="line">    <span class="keyword">partition</span> p_2012 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2012</span>),</span><br><span class="line">    <span class="keyword">partition</span> P_catchall <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>partition分区子句中可以使用各种函数。但是有一个要求，表达式返回的值要是一个确定的正数，而不能是一个常数。根据时间间隔进行分区，是一种很常见的分区方式。</p>
<p>MySQL还支持键值、哈希和列表分区，这其中还有些支持子分区，不生产环境中很少见到。</p>
<p>1.3 如何使用分区表</p>
<p>假设我们希望从一个非常大的表中查询出一段时间的记录，而这个表中包含了很多年的历史数据，数据是按照时间排序的，例如，希望查询最近几个月的数据，这大约有10亿条记录，而原表中有10TB的数据，这个数据量远大于内存，并确实用的是传统硬盘。</p>
<p>首先很肯定：<strong>因为数据量巨大，肯定不嗯给你在每次查询的时候都扫描全表</strong>。考虑到索引在空间和维护上的消耗，也不希望使用索引。即使真的使用索引，会发现数据并不是按照想要的方式聚集的，而且会有大量的碎片产生，最终会导致一个查询产生成千上万的随机IO，应用程序也随之僵死。情况好一点的时候，也许可以通过一两个索引结局一些问题。不过多数情况下，索引不会有任何作用。这时候只有两条路可选：**让所有的查询都只在数据表上做顺序扫描，或者将数据表和索引全部缓存在内存里。</p>
<p><strong>在数据量超大的时候，b-tree索引就无法起作用了</strong>。除非是索引覆盖查询，否则数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，如果数据量巨大，者将产生大量随机IO，随之，数据库的响应时间将大刀不可接受的程度。另外，索引维护（磁盘空间，IO操作）的代价也非常高。</p>
<p>分区可以当做索引的最初形态，以代价非常小的方式定位到需要的数据在哪一片区域，在这片区域中，可以做顺序扫描，可以做索引，还可以将数据全都缓存到内存，等等。因为分区无需额外的数据结构记录每个分区有哪些数据，分区不需要正确定位每套数据的位置，也就无需额外的数据结构，所以代价非常低，只需要一个简单的表达式就可以表达每个分区存放的是什么数据。</p>
<p>为了保证大数据量的可扩展性，一般有下面两个策略：</p>
<ul>
<li><p>全量扫描数据，不要任何索引</p>
<p>  可以使用简单的分区方式存放表，不要任何索引，根据分区的规则大致定位需要的数据位置。只要能使用where条件，将需要的数据限制在少数分区中，则效率是很高的。当然，也需要做一些简单的运算保证查询的响应时间能够满足需求。使用该策略假设不用将数据完全放入到内存中，同时还假设需要的数据全都在硬盘上，因为内存相对很小，数据很快会被挤出内存，索引缓存起不了任何作用。这个策略适用于已正常的方式访问大量数据的时候。警告：必须将查询需要扫描的分区个数限制在一个很小的数量。</p>
</li>
<li><p>索引数据，并分离热点</p>
<p>  如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效地使用缓存。</p>
</li>
</ul>
<p>1.4 什么情况下会出问题</p>
<ul>
<li><p>null值会使分区过滤无效</p>
<p>  分区表达式不能为null，如果为null或者是一个非法值的时候，记录都会被存放到第一个分区，然后MySQL会同时检查两个分区。5.5以后可以直接基于列进行分区。</p>
</li>
<li><p>分区列和索引不匹配</p>
<p>  如果定义的索引和分区列不匹配，会导致查询无法进行分区锅炉工。假设在列a上定义了索引，而在列b上进行分区。因为每个分区都有其独立的索引，所以扫描列上的索引就需要扫描每一个分区对应的宿营。如果每个分区内对应缩影的飞叶子节点都会在内存中，那么扫描的速度还可以接收，如果能跳过某些分区索引当然会更好。要避免这个问题，应该避免简历和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。</p>
<p>  听起来避免这个问题很简单，不过有时候也会遇到一些意想不到的问题。例如，在一个关联查询中，分区表在管理按顺序中是第二个表，并且关联使用的索引和分区条件不匹配。那么关联时对第一个IE表符合条件的每一行，都需要访问并搜索第二个表的所有分区。</p>
</li>
<li><p>选择分区的成本可能很高</p>
<p>  不同类型分区的实现方式不同，性能也不同。尤其是范围分区，对于回答这一行属于哪个分区、这些符合查询条件的分区的行在哪些分区这样的问题的成本可能会非常高，因为服务器需要扫描所有的分区定义的列表来找到正确的答案。类似这样的线性搜索的效率不高，所以随着分区数的增长，成本会越来越高。</p>
<p>  示例：按行写入大量数据的时候，每写入一行数据到范围分区的表时，都需要扫描分区定义列表来找到合适的目标分区。可以通过限制分区的数量来缓解此问题，大多数系统来说，100个左右的分区毫无问题。</p>
</li>
<li><p>打开并锁住所有底层表的成本可能很高</p>
<p>  当查询访问分区表的时候，MySQL需要打开并锁柱所有的底层表，这是分区表的另一个开销。这个开销也在分区过滤之前发生，所以无法通过分区过滤降低此开销，并且该开销也和分区类型无关，会影响所有的查询。这一点对一些本身操作非常快的查询，比如根据主键查找单行，会带来明显的额外开销。可以用批量操作的方式来降低单个操作的此类开销，比如使用批量插入或者load data infile，一次删除多行数据等等，淡然爱过同时还是要限制分区的个数</p>
</li>
<li><p>维护分区的成本可能很高</p>
<p>  某些分区维护操作的速度会非常快，例如新增或删除分区。而有些操作，例如重组分区或者类似alter语句的操作：这类操作需要复制数据。重组分区的原理与alter类似，县创建一个临时的分区，然后将数据复制到其中，随后在删除原分区。</p>
</li>
</ul>
<p>分区不是”银弹”，下面是目前分区实现中的一些其他限制：</p>
<ul>
<li>所有分区都必须使用相同的存储引擎</li>
<li>分区函数中可以使用的函数和表达式也有一些限制</li>
<li>某些存储引擎不支持分区</li>
<li>对于myisam的分区表，不能使用load index info cache操作</li>
<li>对于myisam的表，使用分区表时需要打开更多的文件描述符。虽然看起来是一个表，但是背后有很多独立的分区，每一个分区对于存储引擎来说都是一个独立的表。这样即使分区表只占用一个表缓存条目，文件描述符还是需要多个。因此，即使已经配置了合适的表缓存，以确保不会超过操作系统的单个进程可以打开的文件描述符的个数，但对于分区表而言，还是会出现文件描述符限制的问题。</li>
</ul>
<p>1.5 查询优化</p>
<p>对于分区表来说，很重要的一点就是要在where条件中带入分区列。这样可以让优化器能够过滤掉无需访问的分区。如果没有这些条件，MySQL就需要让对应存储引擎访问这个表的所有分区，如果表非常大的话，就肯能会非常慢</p>
<p>1.6 合并表</p>
<p>不写了， 未来会被删除</p>
<ol>
<li>视图</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> Oceania <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> Continent = <span class="string">'Oceania'</span> <span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span> ;</span><br></pre></td></tr></table></figure>
<p>实现视图最简单的方法就是将select语句的结果存放到临时表中。当需要访问视图的时候，直接访问这个临时表就可以了，看下面的查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Oceania <span class="keyword">where</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure>
<p>下面是使用临时表来模拟视图的方法，这里临时表的名字是为演示用的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> TMP_Oceania_123 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> Continent = <span class="string">'Oceania'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> code,<span class="keyword">name</span> <span class="keyword">from</span> TMP_Oceania_123 <span class="keyword">where</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure>
<p>这样做会有明显的性能问题，优化器也很难优化在这个临时表上的查询。实现视图更好的方法是，重写含有视图的查询，将视图的定义SQL直接包含进查询的SQL中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> code,<span class="keyword">name</span> <span class="keyword">from</span> country <span class="keyword">where</span> Continent = <span class="string">'Oceania'</span> <span class="keyword">and</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure>
<p>MySQL可以使用这两种办法的任何一种来处理视图。这两种算法分别被称为<strong>合并算法（Merge）和临时表算法（Temptable）</strong>，如果可能，会尽可能的使用合并算法。MySQL甚至可以嵌套地定义视图，也就是在一个视图上再定义另一个视图。可以再explain extended 之后使用 show warnings来查看使用视图的查询重写后的结果。</p>
<p>如果视图中包含group by 、 distinct、任何聚合函数、union、子查询等，只要无法在原表记录和视图记录中建立一一映射的场景中，MySQL都将使用临时表算法来实现视图。如果想确定MySQL到底是使用合并算法还是临时表算法，可以explain一条针对视图的简单查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> TMP_Oceania_123;</span><br></pre></td></tr></table></figure>
<p>如果这里的select_type为DERIVED，说明该视图是采用临时表算法实现的。视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> algorithm = temptable <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> v1;</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+</span></span><br><span class="line">|id|select_type|table     |partitions|type|possible_keys|key |key_len|ref |rows|filtered|Extra|</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+</span></span><br><span class="line">|1 |PRIMARY    |&lt;derived2&gt;|NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |</span><br><span class="line">|2 |DERIVED    |actor     |NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>
<p>实现该视图的SQL本身并不需要临时表，但基于盖世兔无论执行什么样的查询，视图都会生成一个临时表。</p>
<p>2.1 可更新视图</p>
<p>可更新视图（updatable view）是指可以通过更新这个视图来更新视图涉及的相关表。只要制定了合适的条件，就可以更新、删除甚至向视图中写入数据。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> oceanic <span class="keyword">set</span> population = population *<span class="number">1.1</span> <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'Australia'</span></span><br></pre></td></tr></table></figure>
<p>如果视图定义中包含了group by , union , 聚合函数，以及其他一些特殊情况，就不能被更新了。更新视图的查询也可以是一个关联语句，但是有一个限制，被更新的列必须来自同一个表中。另外，所有使用临时表算法实现的视图都无法被更新。</p>
<p>2.2 视图对性能的影响，总的来说是不推荐使用</p>
<p>2.3 视图的限制</p>
<p>MySQL不支持物化视图，也不支持在视图中创建索引。也无法通过 show create view 查看视图创建的原始SQL语句</p>
<ol>
<li>外键约束</li>
</ol>
<p>innodb是MySQL中唯一支持外间的内置存储引擎。</p>
<p>使用外键是有成本的。比如外键通常都要求每次在修改数据时都要在另外一张表中多执行一次查找操作。虽然innodb强制外键使用索引，但还是无法消除这种约束检查的开销。如果外键列的选择性很低，泽会导致一个非常大且选择性很低的索引。例如，在一个非常大的表上有status列，并希望限制这个状态列的取值，如果该列只能取三个值，虽然这个列本身很小，但是如果主键很大，那么这个索引就会很大，而且这个所引出了做这个外键限制，也没有其他任何的作用。</p>
<p>不过，在某些场景下，外键会提升一些性能。如果想确保两个相关表始终有一致的数据，那么使用外键比在应用程序中检查一致性的性能要高得多，此外，外键在相关数据的删除和更欣赏，也比在应用中维护要更高效，不过，外键维护操作时逐行进行的，所以这样的更新会比批量删除和更新要慢一些。</p>
<p>外键约束使得查询需要额外访问一些别的表，这也意味着需要额外的锁。如果向子表中写入一条记录，外键约束会让innodb检查对应的父表的记录，也就需要对父表对应记录进行枷锁操作，来确保这条记录不会在这个事务完成之时就被删除了。这会导致额外的锁等待，甚至会导致一些死锁。因为没有直接访问这些表，所以这类死锁问题往往难以排查。</p>
<p>如果只是用外键做约束，那么通常在应用程序里实现约束会更好。外键会带来很大的额外消耗，这里没有相关的基准测试的数据，不过有很多案例，发现外键约束就是瓶颈所在，删除外键后性能立即大幅提升。</p>
<ol>
<li>在MySQL内部存储代码</li>
</ol>
<p>优点有：</p>
<ul>
<li>它在服务器内部执行，离数据最近，另外在服务器上执行还可以节省贷款和网络延迟。</li>
<li>这是一种代码重用。可以方便地统一业务规则，保证某些行为总是一致，所以也可以为应用提供一定的安全性</li>
<li>它可以简化代码的维护和版本更新</li>
<li>他可以帮助提升安全，比如提供更细粒度的权限控制。一个常见的例子是银行用于转移资金的存储过程：这个存储过程可以在一个事务中完成资金转移和记录用于审计的日志。应用程序也可以通过存储过程的接口访问那些没有权限的表。</li>
<li>服务器端可以缓存存储过程的执行计划，这对于需要反复调用的过程，会大大降低消耗。</li>
<li>因为是在服务器端部署的，所以备份，维护都可以在服务器端完成。索引存储程序的维护工作会很简单。它没有什么外部依赖，例如，不依赖任何Perl包和其他不想在服务器上部署的外部软件</li>
<li>他可以在应用开发和数据库开发人员之间更好的分工。不过最好是由数据库专家来开发存储过程，因为不是每个应用开发人员都能写出高效的SQL查询。</li>
</ul>
<p>缺点有：</p>
<ul>
<li>MySQL本身没有提供好用的开发和调试工具，所以写起来要难一些</li>
<li>存储代码效率要稍微差一些，使用的函数有限，所以也很难编写复杂的字符串维护功能，也很难实现太复杂的逻辑</li>
<li>存储代码可能会给应用程序代码的部署带来额外的复杂性。原本只需要部署应用代码和库表结构变更，现在还需要额外地部署MySQL内部的存储代码</li>
<li>因为存储程序都部署在服务器内，所以可能有安全隐患。如果将非标准的加密功能放在存储程序中，那么若是数据库被攻破，数据也就泄露了。但是若将加密函数放在应用程序代码中，那么攻击者必须同时攻破程序和数据库才能获得数据</li>
<li>存储过程会给数据库服务器增加额外的压力，而数据库服务器的扩展性相比应用服务器要差很多</li>
<li>MySQL并没有什么选项可以控制存储程序的资源消耗，所以在存储过程中的一个小错误，可能直接把服务器拖死</li>
<li>存储代码在MySQL中的实现也有很多限制，执行计划缓存是连接级别的，游标的物化和临时表相同，在MySQL5.5版本之前，异常处理也非常困难，等等。</li>
<li>调试MySQL的存储过程是一件很困那的事情。</li>
<li>它和基于语句的二进制日志复制合作的并不好。在基于语句的复制中，使用存储代码有很多的坑</li>
</ul>
<p>4.1 存储过程和函数</p>
<p>存储过程在替代很多小查询的时候要快很多，因为查询很小，相对于查询执行的成本，解析和网络开销就变得非常明显。存储过程无需网络通信开销、解析开销和优化器开销等。</p>
<p>4.2 触发器</p>
<p>可以减少客户端和服务器之间的通信。需要注意一下几点</p>
<ul>
<li>对每一个表的每一个事件，最多只能定义一个触发器（也就是说，不能再after insert 上定义两个触发器）</li>
<li>MySQL只支持基于行的触发，也就是受，触发器始终是针对一条记录的，而不是针对整个SQL语句的。如果变更的数据集非常大的话，效率会很低。</li>
<li>触发器可以掩盖服务器背后的工作，一个简单的SQL语句背后，因为触发器，可能包含了很多看不见的工作。例如，触发器可能会更新另一个相关表，那么这个触发器会让这条SQL影响的记录数翻一倍</li>
<li>触发器的问题也很难排查，如果某个性能问题和触发器相关，会很难分析和定位。</li>
<li>触发器可能导致死锁和锁等待。如果触发器失败，那么原来的SQL语句也会失败。如果没有意识到这其中是触发器在搞鬼，那么很难理解服务器抛出的错误代码时什么意思</li>
</ul>
<p>如果只考虑性能，那么MySQL触发器的实现中，对服务器限制最大的就是它的基于行的触发设置。因为性能的原因，很多时候无法使用触发器来维护汇总和缓存表。使用触发器而不是批量更新的一个原因就是，使用触发器可以保证数据总是一致的。</p>
<p>innodb的触发器是在同一个事务中完成的，所以它们的操作是原子的，原操作和触发器操作会同时失败或者成功。不过，如果再innodb表上建立触发器去检查数据的一致性，要特别小心MVCC，稍不小心，可能会获得错误的结果。假设，想实现外键约束，但是不打算使用innodb的外键约束，打算编写一个before insert触发器来检查写入的数据对应列在另一个表中是存在的，但是若你在触发器中没有使用select for update，那么并发的更新语句可能会立刻更新对应记录，导致数据不一致。</p>
<ol>
<li>游标</li>
</ol>
<p>MySQL在服务端能提供只读的、单向的游标，而且只能在存储过程或者更底层的客户端API中使用。因为MySQL游标中指向的对象都是存储在临时表中而不是实际查询到的数据，所以MySQL游标总是只读的。它可以逐行指向查询结果，然后让程序做进一步的处理。在一个存储过程中，可以有多个游标，也可以在循环中嵌套地使用游标。</p>
<p>因为游标是使用临时表实现的，所以在效率上给开发人员一个错觉。需要记住的一点是，当打开一个游标的时候，需要执行整个查询。看下面的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> bad_cursor()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> film_id <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> f <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> film_id <span class="keyword">from</span> film;</span><br><span class="line">    open f;</span><br><span class="line">    fetch f into film_id;</span><br><span class="line">    close f;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子可以看到，不用处理完所有的数据就可以立刻返回游标。在MySQL中，会带来很多的不必要的额外操作。使用show status诊断这个存储过程，可以看到它需要做1000个索引页的读取，做1000个写入。这是因为在表film中有1000条记录，而这些读和写都发生在第五行的打开游标动作。</p>
<p>如果在关闭游标的时候，只是扫描一个大结果集的一小部分，那么存储过程可能不仅没有减少开销，相反带来了大量的额外开销。这时，你需要考虑使用limit来限制返回的结果集。</p>
<p>游标也会让MySQL执行一些额外的IO操作，而这些操作的效率可能非常低。因为临时内存表不支持blob和text类型，如果游标返回的结果包含这样的列的话，MySQL就必须创建临时磁盘表来存放，这样性能可能会很糟。即使没有这样的列，当临时表大于tmp_table_size的时候，MySQL还是会在磁盘上创建临时表。</p>
<p>MySQL不支持客户端的游标，不过客户端API可以通过缓存全部查询结果的方式模拟客户端的游标.这和直接将结果放在一个内存数组中来维护并没有什么不同。</p>
<ol>
<li>字符集和校对</li>
</ol>
<p><strong>只有基于字符的值真正的有字腹肌的概念。</strong>对其他类型的值，字符集只是一个设置，指定用哪一种字符集来比较或者其他操作。基于字符的值能存在某列中、某查询的字段中、表达式的计算结果中或者某个用户变量中，等等。</p>
<p>MySQL的设置可以分为两类：创建对象时的默认值、在服务器和客户端通信时的设置。</p>
<p>MySQL服务器有默认的字符集和校对规则，每个数据库也有自己的默认值，每个表也有自己的默认值。这是一个逐层继承的默认设置，最终最靠底层的默认设置将影响你创建的对象，这些默认值，自上而下的告诉MySQL应该使用什么字符集来存储某个列。</p>
<ul>
<li>创建数据库的时候，将根据服务器上的character_set_server来指定该数据库的默认字符集</li>
<li>创建表的时候，将根据数据库的字符集设置指定这个表的字符集设置</li>
<li>创建列的时候，将根据标的设置指定列的字符集设置</li>
</ul>
<p>需要记住的是，真正存放数据的事列，所以更高阶梯的设置只是指定默认值。一个表的默认字符集设置无法影响存储在这个表中某个列的值。只有当创建列而美欧为列指定字符集的时候，如果没有指定字符集，表的默认字符集才有作用。</p>
<p>当服务器和客户端通信的时候，它们可能使用不同的字符集。这时，服务器端将进行必要的翻译转换工作：</p>
<ul>
<li>服务器端总是假设客户端是按照character_set_client设置的字符来传输数据和SQL语句的.</li>
<li>当服务器收到客户端的SQL语句时，它先将其转换成自负其character_set_connection。它还是用这个设置来决定如何将数据转换成字符串</li>
<li>当服务器端返回数据或者错误信息给客户端时，它会将其转换成character_set_result。</li>
</ul>
<p><strong>MySQL如何比较两个字符串的大小</strong></p>
<p>如果比较的两个字符串的字符集不同，MySQL会先将其转成同一个字符集再进行比较。如果两个字符集不兼容的话，则会抛出错误。这种情况下需要通过函数convert()显式地将其中一个字符串的字符集转成一个兼容的字符集。MySQL5.0经常会有这样的隐式转换。</p>
<p>还可以使用前缀和collate子句来制定字符串的字符集或校对字符集。例如，下面的实例中使用了前缀来指定字符集，还使用了collate子句制定了使用二进制校对规则：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> _utf8 <span class="string">'hello world'</span> <span class="keyword">collate</span> utf8_bin;</span><br></pre></td></tr></table></figure>
<p>一些特殊情况</p>
<ul>
<li><p>诡异的character_set_database设置</p>
<p>  当使用load data infile的时候，数据库总是将文件中的字符按照字符集aharacter_set_database来解析。在MySQL5.0之后，可以再load file infile 中使用子句character set来设定字符集，不过最好不要依赖这个设定。我们发现使用字符集最好的方式是先试用use 指定数据库，在执行 set names 来设定字符集，最后再夹在数据。MySQL在夹在数据的时候，总是以同样的字符集处理所有数据，而不管表中的列是否有不同的字符集设定</p>
</li>
<li><p>select into outfile</p>
<p>  MySQL会将select into outfile的结果不做任何转码写入文件。目前除了使用函数convert()将所有的列都做一次换吗外，还没有什么办法可以指定输出的字符集。</p>
</li>
<li><p>嵌入式转义序列</p>
<p>  MySQL会根据character_set_client的设置来解析转义序列，即使是字符串中包含前缀或者collate子句也一样。这是因为解析器在处理字符串中的转义字符时，完全不关心校对规则，对于解析器来说，前缀并不是一个指定，他只是一个关键字而已。</p>
</li>
</ul>
<p><strong>字符集和校对规则</strong></p>
<p>可以使用命令show characterset 和 show collation 来查看MySQL支持的字符集和校对规则。</p>
<p>对于校对规则通常需要考虑的一个问题是，是否已大小写敏感的方式比较字符串，或者是以字符串编码的二进制值来比较大小。它们对应的校对规则的前缀分别是_cs、_ci和_bin，根据需要很容易选择。大小写敏感和二进制校对规则的不同之处在于，二进制校对规则直接使用字符的字节进行比较，而大小写敏感的校对规则在多字节字符集时，比如德语，有更复杂的比较规则。</p>
<p><strong>字符集和校对规则如何影响查询</strong></p>
<p>不同的字符集和校对规则之间的转换可能会带来额外的系统开销。例如，film在列title上有索引，可以加速下面的order by 查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> title ,release_year <span class="keyword">from</span> sakila.film <span class="keyword">order</span> <span class="keyword">by</span> title;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> title <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">collate</span> utf8mb4_bin;</span><br></pre></td></tr></table></figure>
<p>只有排序要求的字符集和服务器数据的字符集相同的时候，才能使用索引进行排序。索引根据数据列的校对规则进行排序，这里使用的是utf8_general_ci。如果希望使用别的校对规则进行排序，那么MySQL就需要使用文件排序。MySQL8测试发现，依然使用了索引</p>
<p>为了能够适应各种字符集，包括客户端字符集、在查询中显式指定的字符集，MySQL会在需要的时候进行字符集转换。例如，当使用两个字符集不同的列来关联两个表的时候，MySQL会尝试转换其中一个列的字符集。这和在数据列外面风装一个函数一样，会让MySQL无法使用这个列上的索引。如果你不确定MySQL内部是否做了这种转换，可以再explain extended 后使用show warnings来查看MySQL是如何处理的。丛输出中可以看到查询中使用的字符集，也可以看到MySQL是否做了字符集转换操作。</p>
<p>UTF-8是一种多字节编码,它存储一个字符会使用变长的字节数，在MySQL内部，通常使用一个定长的空间来存储字符串，再进行相关操作，这样做的目的是希望总是保证缓存中有足够的空间来存储字符串。例如，一个编码是utf8的char(10)需要30个字节，即使最终存储的时候没有存储任何多字节字符串也是一样。变长的字段类型存储在磁盘上时不会有这个困扰，但是当它存储在临时表中或者用来处理排序时，也总是会分配最大可能的长度。</p>
<p>在多字节字符集众，一个字符不再是一个字节。所以，在MySQL中有两个函数length 和 char_length来计算字符串的长度，在多字节字符集众，这两个函数的返回结果会不同。如果是用的是多字节字符集，那么确保在统计字符集的时候使用char_length。</p>
<p>还有个地方是索引方面：<strong>如果要索引一个UTF8字符集的列，MySQL会假定每一个字符都是三个字节，所以最长索引前缀的限制一下缩短到原来的三分之一了</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> big_string(</span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">varchar</span>(<span class="number">500</span>),</span><br><span class="line">    <span class="keyword">key</span>(<span class="keyword">str</span>)</span><br><span class="line">)<span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span> ;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> big_string;</span><br></pre></td></tr></table></figure>
<p>得了，MySQL 8 中，没有复现，说明这些问题已经被修复</p>
<ol>
<li>分布式事务</li>
</ol>
<p>XA事务，需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）。如果协调器收到所有的参与者都准备好的消息，就会告诉所有的事务可以提交了，这是第二阶段。MySQL在这个XA事务中扮演的是一个参与者的角色，而不是协调者。</p>
<p>实际上，MySQL中有两种XA事务。一方面，MySQL可以参与到外部的分布式事务中；另一方面，还可以通过XA事务来协调存储引擎和二进制日志。</p>
<p>TODO，从其他地方找资料进行补充吧。</p>
<ol>
<li>查询缓存</li>
</ol>
<p>MySQL查询缓存保存查询返回的完整结果。当查询命中该缓存，MySQL会立即返回结果，跳过了解析。优化和执行阶段。</p>
<p>查询缓存系统会追踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的查询缓存都将失效。这种机制效率看起来比较低，因为数据表变化时很有可能对应的查询结果并没有变更，但是这种简单实现代价很小， 而这点对于一个非常繁忙的系统来说非常重要。</p>
<p>查询缓存对应用程序是完全透明的。应用程序无需关心MySQL是通过查询缓存返回的结果还是实际执行返回的结果。事实上，这两种方式执行的结果是万全县通的。换句话说，查询缓存无需使用任何语法。无论是MySQL开启或者关闭查询缓存，对应用程序都是透明的。</p>
<p><strong>MySQL如何判断缓存命中</strong></p>
<p>MySQL判断缓存命中的方法很简单，缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了如下引入，即查询本身，当前要查询的数据库，客户端协议的版本等一些其他可能会影响返回结果的信息。</p>
<p>当判断查询缓存是否命中时，MySQL不会解析、正规化或者参数化查询语句，而是直接使用Sql语句和客户端发送过来的其他原始因袭。任何兹附上的不同，空格，注释，任何的不同都会导致缓存的不命中。所以在编写SQL语句的时候，需要特别注意这一点。通常使用同一个编码规则是一个好的习惯，在这这个好习惯会让你的系统运行的更快。</p>
<p>当查询语句中有一些不确定的数据时，则不会被缓存，例如包含函数NOW或者current_date的查询不会被虎啊黁从。类似的，一些语句会根据不同的用户返回不同的结果，所以也不会被缓存。事实上，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql中的系统表，或者包含列级别权限的表，都不会被缓存。</p>
<p>查询缓存是在完整的select语句基础上的。很多时候可以提升查询性能，但是使用的时候，有一些问题需要特别注意。首先，打开查询缓存对度和谐操作都会带来额外的消耗：</p>
<ul>
<li>读查询在开始之前必须先检查是否命中缓存。</li>
<li>如果这个读查询可以被缓存，那么当完成执行后，MySQL若发现查询缓存中没有个这个查询，会将其结果存储查询缓存，这会带来额外的系统消耗</li>
<li>这对写操作也会有影响，因为当向某个表写入数据的时候，MySQL必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就可能会带来很大的系统消耗</li>
</ul>
<p>innodb使用了多版本特性事务，会限制查询缓存的使用</p>
<p><strong>查询缓存如何使用内存</strong></p>
<p>查询缓存是完全存储在内存中的没所以在配置和使用它之前，我们需要先了解它是如何使用内存的。除了查询结果之外，需要缓存的还有很多别的维护相关的数据。这和文件系统有些类似，徐亚一些内存专门用来确定哪些内存目前是可用的，哪些是已经用掉的，哪些用来存储数据表和查询结果之前的映射。哪些用来存储查询字符串和查询结果。</p>
<p>这些基本的管理维护数据结构大概需要40KB的内存资源，除此之外，MySQL用于查询缓存的内存被分为一个个的数据块，数据块是变长的。每一个数据库奥众存储了自己的类型、大小和存储的数据本身，还外加直向前一个和后一个数据块的指针，数据块的类型有，内UN查询将诶过，存储查询和数据表的映射，存储查询文本，等等。不同的存储块，在内存使用上并没有什么不同，从用户角度看无需区分。</p>
<p>当服务器启动的时候，它先初始化查询缓存需要的内存。这个内存池初始是一个完整的空闲块。这个空闲块的大小就是你所配置的查询缓存大小再减去用于维护元数据的数据结构所消耗的空间。</p>
<p>当有查询结果需要缓存的时候，MySQL先从大的数据块中申请一个数据块用于存储结果。这个数据块需要大于参数query_cache_min_res_unit的配置，即使差U型你将诶过远远小于此，人需要至少申请query_cache_min_res_unit空间，因为需要在查询开始返回结果的时候就分配空间，而此时是无法阈值查询结果到底多大的，所以MySQL无法为每一个查询结果精确分配大小恰好匹配的缓存空间。</p>
<p>因为需要先锁住空间块，然后找到合适大小数据块，所以相对来说，分配内存快是一个非常慢的操作。MySQL尽量避免这个操作的次数。当需要缓存一个差U型那结果的号死后，它先选择一个尽可能小的内存块，然后将结果存入其中。如果数据块全部用完，但仍有剩余数据需要存储，那么MySQL会申请一块新数据块，仍然是既可能笑得数据块，继续存储结果数据。当查询完成，如果申请的内存空间还有剩余，MySQL会将其释放，并存入空闲内存</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2020/12/30/Book Nodes/高性能MySQL/9-MySQL的复制/" rel="next" title="MySQL的复制">
                  <i class="fa fa-chevron-left"></i> MySQL的复制
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/01/06/Book Nodes/高性能MySQL/10-MySQL的可扩展性/" rel="prev" title="MySQL的可扩展性">
                  MySQL的可扩展性 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="温海林"
    src="/uploads/images/fbb1.jpg">
  <p class="site-author-name" itemprop="name">温海林</p>
  <div class="site-description" itemprop="description">Fake it, make it!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wenslo" title="GitHub &rarr; https://github.com/wenslo" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/564544234@qq.com" title="E-Mail &rarr; 564544234@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温海林</span>
</div>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>













  

  

  

</body>
</html>

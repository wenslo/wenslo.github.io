---
title: 面试-MySQL篇

categories: 

- 面试

tags: 

- 面试
date: 2020-11-16 22:53:54

---

### 想提升，还是得连环炮方式的提问

1. 你们对线上的数据有没有做一些优化？怎么优化的？

   1. 如果回答的是索引

      1. 来说一说什么是索引？有哪几种索引？索引有什么优点？

         用于存储引擎快速找到记录的一种数据结构，存储引擎会先在索引中找到对应值，然后根据匹配的索引记录找到对应的记录行，索引可以包含一个或者多个列的值

         B-Tree索引，（准确的说是B+Tree，B-Tree和B+Tree有什么区别？）哈希索引，空间数据索引，全文索引，分行树索引

         优点：1.大大减少服务器需要扫描的数据量，2.可以帮助服务器避免排序和临时变，3.索引可以将随机IO变为顺序IO。

      2. 这些索引采取的是哪种数据结构？

         B-Tree索引用的B+Tree，哈希索引用的哈希表

      3. 为什么采取B+Tree？这种数据结构有什么好处么？

         B+Tree对索引列是按照顺序组织存储的，适用于**全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引的查询**。因为节点有序，还可用于查询中的order by操作。

         但是，如果**不是按照索引的最左列开始查找，则无法使用索引；不能跳过索引中的列；如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找**。

      4. 和哈希表相比，有什么优点或者有什么不同？

         Hash索引基于哈希表，会在哈希表中保存指向每个数据行的指针，**只有精确匹配索引所有列的查询才有效**。但是Hash并不是就一定会很快，因为hash值重复的话，会以链表的方式存放多个记录指针到一个条目中，所以说，极端情况下，会变成为链表。

         B+ Tree索引和Hash索引区别 哈希索引适合等值查询，但是无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。

      5. MySQL中B+Tree的叶子节点能存什么东西？

         首先，叶子节点会有索引列的数据，其次，B+Tree的叶子节点会保存数据行，MySQL中会保存数据库表的聚簇索引，主键（如果没有，首先会选择一个唯一的非空索引来代替，如果还没有，会隐式定义一个主键作为聚簇索引），然后会根据主键，进行回表，获取所需数据。

      6. 什么是聚簇索引和非聚簇索引？

         聚簇索引将**索引和数据放在同一行**，非聚簇索引将**索引和数据分开存放**。

         一个表仅有一个聚簇索引

         聚簇索引的插入速度依赖于插入顺序，如果使用UUID，可能导致插入页分裂降低速度。

         更新主键（聚簇索引）的时候，会导致被更新的行移动

         **采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。

      7. 查询的时候有什么区别？

         当取一定范围内的数据时，聚簇索引相比较非聚簇索引也会更快

         使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

         因为非聚簇索引查询时，会先扫描一遍B+Tree，获取到叶子节点的主键ID，然后根据ID进行回表，而聚簇索引，会包含整行数据，每次会把共同一个页的数据都加载到内存里，读取同一页的数据，避免了磁盘查找，速度会更快。同时，使用ID获取数据时，会更快。少了一次根据ID回表的过程。但是，比如有一个code，普通索引，查询这个code的时候，应为不需要获取其他数据，少了回表的过程，应该也算是聚簇索引。

         > 覆盖索引 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。

         

      8. 联合索引是怎么使用的？为什么使用联合索引？说一说最左前缀匹配

         给需要查询的列，或者是需要排序的列，添加联合索引，比如说(k1,k2,k3)这么一个联合索引，会相当于(k1),(k1,k2),(k1,k2,k3)三个索引，这就是最左前缀匹配。

      9. 各个MySQL版本中，对索引有哪些方面的优化？

         5.6版本的MySQL做了索引下推。

         people表中（zipcode，lastname，firstname）构成一个索引

         SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';

         如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

      10. 通过什么情况，能知道是否走了索引？

         使用explain语句进行分析

      11. 什么情况下会发生创建了索引，但是没有走索引的情况？

          查询发生隐式转换，比如数据库定义的是string，但是查询的时候使用的是int

          对索引列进行运算，导致索引失效

          使用<>，not in , not exist 等会导致索引失效

          如果变量为空，使用 = null ，会导致索引失效

          查询优化器 一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个，可能会优化器认为全表扫描的代价小于使用索引

      12. 不同类型的值，比如说varchar，int，等，使用索引会有什么变化？

          如果column定义的为是varchar，但是查询使用的是int，会走索引

          如果column定义的是int，查询用的是string，存在隐式转换，不会走索引

   2. 加缓存，memcache，redis等

      memcache，redis等问题放到其他章节

   3. 主从复制，或者主主复制，读写分离

   4. 分区表

   5. 垂直拆分

   6. 水平拆分


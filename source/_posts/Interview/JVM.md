---
title: 面试-JVM篇章

categories: 

- 面试

tags: 

- 面试
date: 2019-10-22 23:30:03
---

### JVM相关面试题

1. JVM运行时数据区分为哪几个部分？分别是什么作用？

   分为程序计数器，**Java虚拟机栈**，本地方法栈，**Java堆**，方法区

   程序计数器：

   程序计数器的工作就是通过改变计数器的值来选取吓一跳需要执行的字节码指令，分支、循环、跳转、异常处理、县城回复等基础功能都依赖程序计数器来完成。Java虚拟机的多线程是**通过线程轮流切换并分配处理器执行时间的方式来实现的**，在任何一个确定的时刻，**一个处理器（一个内核）都只会执行一条线程中的指令**。因此为了线程切换后能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，**互不影响，独立存储，线程私有**，而且是唯一一个没有**OutOfMemoryError**情况的区域。
   
   Java虚拟机栈：
   
   线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型：**每个方法在执行的同事都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程**。局部变量表**存放了编译期可知的各种基本数据类型（boolean,byte,char,short,int,float,long,double）、对象引用（reference类型，不是对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）**。如果线程请求的栈深度大于虚拟机允许的深度，那么会StackOverflowError，如果扩展时无法申请到足够的内存，则会OutOfMemoryError。
   
   本地方法栈：
   
   为虚拟机使用的Native方法服务。
   
   Java堆：
   
   是Java虚拟机所管理的内存中最大的一块。被所有线程共享，存放对象实例，**所有的对象实例以及数组都在堆上分配**。是是垃圾收集器管理的主要区域，细分可分为**新生代和老年代**，再细分可以有：**Eden空间、From Survivor空间、To Survivor空间。线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）**。可以用-Xmx和-Xms来控制大小。无法扩展的时候，会抛出OutOfMemotyError。
   
   方法区：
   
   各个线程共享，存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。也叫做永久代。
   
   运行时常量池：
   
   是方法取得一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内存在类加载后进入方法区的运行时常量池存放。
   
   直接内存：
   
   独立于Java堆和Native堆，收到本机总内存的影响。
   
   >可能延伸出的问题
   
   - 既然说程序计数器是唯一一个没有OutOfMemory的区域，那么说说有哪些区域会有OutOfMemory？
   
   答：Java虚拟机栈，Java堆，本地方法栈，方法区。虚拟机栈的内存是可以动态扩展的，但是如果动态扩展时，申请不到足够的内存的话，那么会抛出OutOfMemory；Java堆如果达到了最大使用内存，那么再次开辟内存的时候，同样也会抛出OutOfMemory；本地方法栈如果调用Native方法没有足够内存或者没有释放的时候，那么也会抛出OutOfMemory；方法区中由于有运行时常量池的存在，这部分是最占内存的，如果没有足够内存的时候，同样会OutOfMemory。
   
   - 来说一下线程的生命周期
   
     NEW（准备），RUNABLE（就绪），RUNNING（运行状态），休眠状态（Sleep）、DEAD(终止状态)。
   
     当使用new关键字new一个线程的时候，线程就处于准备状态，仅仅分配了内存，初始化了变量，但是没有开始运行。
   
   - 局部变量表里存放是有哪些？
   
   - 说一下一个栈帧在虚拟机栈中入栈出栈的过程
   
   - 什么情况下会StackOverflowError？栈深度怎么算？栈和堆所占内存比是多少？
   
   - Eden空间、From Survivor空间、To Survivor空间内存占比怎么算？
   
   - 虚拟机加载类的过程是什么样的？
   
   - 直接内存什么情况下会抛出**OutOfMemoryError**？
   
2. 当new一个对象的时候，对象的创建是怎么样一个过程？

   虚拟机遇到一条new执行时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。

   类加载检查通过后，虚拟机就会为对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。如果Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的放在一边，中间放着一个指针作为分界点的指示器，那分配内存就是仅仅把那个指针向空闲空间挪动一段与对象大小相等的距离，这种分配方式叫做指针碰撞（Bump the Pointer）。如果内存并不是规整的，已经使用内存和未使用的内存相互交错，这种情况下就没办法使用指针碰撞。那么Java虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式叫做空闲列表（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial，ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。

   > 延伸问题

   - 来说一下类加载的过程是什么样。
   - 如何确定一个对象所需内存大小？

   - 内存是如何进行分配的？
   - 如何确定内存分配方式？
   - 哪种垃圾收集器带有压缩整理功能？
   - 有哪几种垃圾收集器？分别有哪些特点？采用的垃圾回收算法有哪几种？分别是什么？


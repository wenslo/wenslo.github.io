---
title: HashMap源码问题解读

categories: 

- 源码阅读

tags: 

- JDK源码
mathjax: true

---

> HashMap相关问题放这里，带着问题看，自己的思路解答也会放这里

问题记录：

1. DEFAULT_INITIAL_CAPACITY为啥默认是16，为什么必须是2的倍数？

   解答：

   16可能是一个折中的选项，来避免说设置太小，稍微放一点数据，就进行扩容了，产生不必要的空间浪费。至于说2的倍数，因为底层计算的时候，都是通过cpu移位来进行计算，而2的倍数的话，只需要进行左移一位即可，不然的话，如果是什么加减乘除取模，全部都是cpu进行的加法运算，浪费效率。

2. 最大容量能否进行更改？达到最大容量的时候会浪费多少的容量？

   解答：

   不能通过构造方法更改，如果手动将其更改为比1<<30（1<<31的话，会超出整型的最大值，也就是Integer.MAX_VALUE）更大的数字的话，tableSizeFor()这个方法会重新将值设置为16。如果经过resize()方法扩容了很多次，那么，它的最大容量，实际上汇编成为Integer.MAX_VALUE。如果达到了最大容量，由于说hashmap的阈值范围是threshold * loadFactor，所以首先说，会有1/4的容量，是完全被浪费掉了的。

3. 默认加载因子是0.75，如果是其他的值会有什么影响？为什么是0.75？

   解答：

   threshold = capacity * 0.75，初始默认情况下，这个值为12，也就是说，刚开始map的capacity是16，threshold为12，而当容量达到12的时候就会进行扩容。如果loadFactor为0.5的话，那么容量到了8的时候就会扩容，如果等于1的话，那map里的用完之后才会进行扩容。

   由API注释可知，桶的分布满足于泊松分布，参数在在默认阈值0.75的条件下，平均数为0.5，会产生比较良好的分布。再问泊松分布的话，就不会了。。。。MLGJ

4. 树化的阈值为什么是8？树退化为链表的阈值为什么是6？达到阈值6和8的时候分别会产生什么效果？

   解答：

   因为hashmap是数组+链表，达到阈值后，会变成数组+红黑树。链表的复杂度为O(n)，红黑树的复杂度为O(logn)。假设长度为8的话，那么，红黑树的复杂度就是O(log8) = 3，链表的复杂度是O(8)，红黑树>链表。假设长度为6的话，那么，红黑树的复杂度就是O(log6) = 2.585，链表的复杂度是O(6)，但是红黑树对应的需要有平衡的操作，相对来说，这些操作没有链表来的复杂性小点，没有必要使用红黑树。所以说，树化阈值为8的时候，是最合适的一个值。

5. 最小树化容量不是64么，为什么源码注释里写的是4*8=32？如果是32会怎么样？

   解答：

   不知道

6. hashcode的集合仅仅在当前掩码变化的时候将会一直碰撞冲突？如果不异或呢。会怎么个冲突法？这个需要自己实现来验证。

7. (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)，为什么要这么做？hashcode为何要与code无符号右移16位后的数字做异或？

   解答：

   先不关注hashCode的实现方式，这个东西，后面再说吧。先看看为什么要这么做，好处在哪。

   hashcode右移16位，然后进行和原值进行异或。然后，由于是整型(int)，int的取值范围为0x00000000-0xFFFFFFFF，也就是说，是32位的二进制数据，如果这时候hashcode进行右移16位，那就是说，hashCode的高16位和低16位进行异或。至于为什么这么做，hashCode的值，用到高16位的情况，太少了，可能是为了减少hash碰撞吧，因为如果hashcode值比较小的话，那么产生相同的hashcode的可能性相对来说是比较高的一个情况，所以用高位和低位来异或，加快速度，减少hash碰撞。

8. tableSizeFor方法的作用是什么，为什么要这么写？

   解答：

   Returns a power of two size for the given target capacity。

   意思为：返回给定目标容量的2次方幂的数字。实际上，是返回一个比指定整数大，且是接近2次方幂的一个整数。

   因为移位的速度是最快的，能够以很高的效率来获取。看到是看明白了，这个是怎么推出来的？百思不得其解啊。

   ```java
   static final int tableSizeFor(int cap) {
     	//capacity默认值为16，以默认情况来看
       int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);
       return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
   }
   public static int numberOfLeadingZeros(int i) {
     //默认情况，i==2^4-1;
     // HD, Count leading 0's    HD是啥意思？应该是计算前导数的0有多少了吧
     //由此可见，i的最小值为0。
     if (i <= 0)
       return i == 0 ? 32 : 0;
     int n = 31;
     //i >= 2^16
     if (i >= 1 << 16) { n -= 16; i >>>= 16; }
     //i >= 2^8
     if (i >= 1 <<  8) { n -=  8; i >>>=  8; }
     //i >= 2^4
     if (i >= 1 <<  4) { n -=  4; i >>>=  4; }
     //i >= 2^2
     if (i >= 1 <<  2) { n -=  2; i >>>=  2; }
     return n - (i >>> 1);
   }
   ```

   * 默认情况（initial_capacity = 16）会进入下面的判断(i == 2^4 - 1)，此时，n=29，而i无符号右移两位之后，会从15(1111)->3(0011)，在return语句中，i再次进行无符号右移，变为(0001)，这时，n-i的值就为28。然后再看tableSizeFor，使用-1无符号右移28位。而-1的二进制表示为11111111111111111111111111111111(因为负数的二进制表示为：1的二进制表示，取反码，然后补码)，移位之后结果就变成了00000000000000000000000000001111，如果没有大于MAXIMUM_CAPACITY，则+1，变为了16，2^4
   * 换种情况，68983，当它进入numberOfLeadingZeros的时候，便成为68982。首先会进入i >= 1<<16，此时n-=16=15。i>>>16之后，会变为(0001)，下面三个判断都进不去，这时候return语句再次右移，就成0了，然后，n=15-0=15，最后，-1无符号右移15位，过程不进行叙述，最后结果为2^17，而68983是大于2^16的。

9. 初始容量和负载因子如果在构造方法中改变的话，会有什么影响？

   * 和上面的tableSizeFor方法相关，上面已经说了一部分了，如果修改了initial_capacity的话，会将这个值赋值给threshold，因为hashmap的扩容方法是触发threshold才会进行，也就是达到了capacity*loadFactor。如果赋值的是20，根据tableSizeFor方法，容量会变成为2^5(32)，当容量到了32之后，才会进行扩容，而不是说32\*0.75之后才扩容。
   * 如果loadFactor修改为1，那么，首先来说，当所有容量用完了，才会进行扩容；如果修改的太小了，那么数据刚扩容相对来说就会非常快（假设为0.1，到了十分之一就扩容和到了四分之三扩容，这个不言而喻）；还有个问题，hashmap是基于hash分布，如果说loadFactor设置太高的话，那么所有bucket都会被利用，不利于良好的hash分布，hash冲突就会增大，hashmap查询性能就会降低，如果太小，bucket空间又浪费太多。0.75是比较合适的一个值。结合上面的一起。

10. Float.isNaN = return v != v ，为什么这么写？

   isNaN接收的参数是一个float，而该方法判断这个值是否是一个数字，NaN(Not a Number)，而查看float的源码，里面有个常量，float NaN = 0.0f/0.0f。而hashmap源码里，会先进行判断，loadFactor<=0，如果这里满足的话，因该是不会进行后面的操作的，可能是因为hashmap不是线程安全的，虽然刚开始loadFactor是正确的值，然后被其他线程修改之后，就变成了0.0f/0.0f，就会变成一个not a number的数。

11. tab[(n - 1) & hash]，这个操作是什么意思？

   是用来定位数组位置的，上面说了这个hash值是自身的hashcode的高16位与低16位进行异或产生的结果，而n-1是当前hashmap的长度，通过(length-1) & hash的话，就能够得到所需要查找的下标，然后就可以通过index来获取到需要get或者说需要put的数据。

   hash算法最主要的就是说让元素均匀分布，而很多hash算法都是使用的取模运算，但是hashmap用的是(n-1) & hash，首先，&的运算速度是大于%的，然后length是2的倍数，x%length == (length-1) & x，求x。

   * 假设length=8,x=5，(8-1) & 5 == 0111 & 0101 ==5，结果正确
   * 假设length=4,x=21，(4-1) & 21 == 0011 & 10101 == 1，结果正确
   * 假设length=3,x=20，(3-1) & 20 == 1000 & 10100 == 0，结果错误

   由此可知，x%length == (length-1) & x这个公式是正确的，然后看下这个公式怎么推出来。

   一个十进制数用二进制方法表示：$X_nX_{n-1}X_{n-2}…X_1X_0$ == $X_n*2^n + X_{n-1}*2^{n-1} + X_{n-2}*2^{n-2} … +X_1*2^1 + X_0*2^0 $

   由于分配率的规定，由上面的公式可知，length为2的倍数，$X/2^k$的余数就为取模的值，那就看怎么取这个余数：$X/2^k ==  X_n*2^n/2^k + X_{n-1}*2^{n-1}/2^k + X_{n-2}/2^k*2^{n-2}/2^k … +X_1*2^1/2^k + X_0*2^0/2^k  $

   * 如果k>n的话，余数就是整个十进制数
   * 如果0<=k<=n，因为比k大的，都能被k整除，所以说，余数就为$X_k*2^k + X_{k-1} * 2^{k-1} + … X_k * 2^1 + X_k * 2^0 $
   * 特么的，这个公式《数据结构与算法》这本书上有

   一个十进制数对$2^n$的数进行取余，就是说，十进制数转换为二进制数后，向右进行移位，移掉的这n位数，就为余数，比如说，10 % 8  ==  2。1000 向右移位2位的话是 0010 == 2，结果正确。然后是怎么获取这个n位数：$2^0...2^n$ 用二进制表示为0001,0010,0100,1000…如果我们将$2^n-1$的话，就会变成为0000，0001，0011，0111，1111…然后用十进制数和该数字进行&操作，得到的数字，就是需要移位的数字。

   嗯。就是这些。

12. resize()这个方法初次执行的时候大小是多少？后续执行的时候，大小会如何变化？

   resize初次执行的时候大小为默认值1 << 4，后续执行的时候，大小会翻倍。

13. hashmap扩容的话，会怎么进行变化？

   分红黑树和链表两个方向来解释，

14. oldCapacity和oldThreshold是有可能不同时为0的对吧，为什么，什么时候发生的事？

15. 这个e.hash & oldCap是什么操作。。。
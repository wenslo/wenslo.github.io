---
title: HashMap源码问题解读

categories: 

- 源码阅读

tags: 

- JDK源码


---

> HashMap相关问题放这里，带着问题看，自己的思路解答也会放这里

问题记录：

1. DEFAULT_INITIAL_CAPACITY为啥默认是16，为什么必须是2的倍数？

   解答：

   16可能是一个折中的选项，来避免说设置太小，稍微放一点数据，就进行扩容了，产生不必要的空间浪费。至于说2的倍数，因为底层计算的时候，都是通过cpu移位来进行计算，而2的倍数的话，只需要进行左移一位即可，不然的话，如果是什么加减乘除取模，全部都是cpu进行的加法运算，浪费效率。

2. 最大容量能否进行更改？达到最大容量的时候会浪费多少的容量？

   解答：

   不能通过构造方法更改，如果手动将其更改为比1<<30（1<<31的话，会超出整型的最大值，也就是Integer.MAX_VALUE）更大的数字的话，tableSizeFor()这个方法会重新将值设置为16。如果经过resize()方法扩容了很多次，那么，它的最大容量，实际上汇编成为Integer.MAX_VALUE。如果达到了最大容量，由于说hashmap的阈值范围是threshold * loadFactor，所以首先说，会有1/4的容量，是完全被浪费掉了的。

3. 默认加载因子是0.75，如果是其他的值会有什么影响？为什么是0.75？

   解答：

   threshold = capacity * 0.75，初始默认情况下，这个值为12，也就是说，刚开始map的capacity是16，threshold为12，而当容量达到12的时候就会进行扩容。如果loadFactor为0.5的话，那么容量到了8的时候就会扩容，如果等于1的话，那map里的用完之后才会进行扩容。

   由API注释可知，桶的分布满足于泊松分布，参数在在默认阈值0.75的条件下，平均数为0.5，会产生比较良好的分布。再问泊松分布的话，就不会了。。。。MLGJ

4. 树化的阈值为什么是8？树退化为链表的阈值为什么是6？达到阈值6和8的时候分别会产生什么效果？

   解答：

   因为hashmap是数组+链表，达到阈值后，会变成数组+红黑树。链表的复杂度为O(n)，红黑树的复杂度为O(logn)。假设长度为8的话，那么，红黑树的复杂度就是O(log8) = 3，链表的复杂度是O(8)，红黑树>链表。假设长度为6的话，那么，红黑树的复杂度就是O(log6) = 2.585，链表的复杂度是O(6)，但是红黑树对应的需要有平衡的操作，相对来说，这些操作没有链表来的复杂性小点，没有必要使用红黑树。所以说，树化阈值为8的时候，是最合适的一个值。

5. 最小树化容量不是64么，为什么源码注释里写的是4*8=32？如果是32会怎么样？

   解答：

   不知道

6. hashcode的集合仅仅在当前掩码变化的时候将会一直碰撞冲突？如果不异或呢。会怎么个冲突法？这个需要自己实现来验证。

7. (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)，为什么要这么做？hashcode为何要与code无符号右移16位后的数字做异或？

   解答：

   先不关注hashCode的实现方式，这个东西，后面再说吧。先看看为什么要这么做，好处在哪。

   hashcode右移16位，然后进行和原值进行异或。大部分情况下，都会是原值。然后，由于是整型(int)，int的取值范围为0x00000000-0xFFFFFFFF，也就是说，是32位的二进制数据，如果这时候hashcode进行右移16位，那就是说，hashCode的高16位和低16位进行异或。至于为什么这么做，hashCode的值，用到高16位的情况，太少了，可能是为了减少hash碰撞吧，因为如果hashcode值比较小的话，那么产生相同的hashcode的可能性相对来说是比较高的一个情况，所以用高位和低位来异或，加快速度，减少hash碰撞。

8. tableSizeFor方法的作用是什么，为什么要这么写？

   解答：

   Returns a power of two size for the given target capacity。

   意思为：返回给定目标容量的2次方幂的数字。实际上，是返回一个比指定整数大，且是接近2次方幂的一个整数。可能是翻译不正确吧

   ```java
   static final int tableSizeFor(int cap) {
     	//capacity默认值为16，以默认情况来看
       int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);
       return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
   }
   public static int numberOfLeadingZeros(int i) {
     //默认情况，i==2^4-1;
     // HD, Count leading 0's    HD是啥意思？应该是计算前导数的0有多少了吧
     //由此可见，i的最小值为0。
     if (i <= 0)
       return i == 0 ? 32 : 0;
     int n = 31;
     //i >= 2^16
     if (i >= 1 << 16) { n -= 16; i >>>= 16; }
     //i >= 2^8
     if (i >= 1 <<  8) { n -=  8; i >>>=  8; }
     //i >= 2^4
     if (i >= 1 <<  4) { n -=  4; i >>>=  4; }
     //i >= 2^2
     if (i >= 1 <<  2) { n -=  2; i >>>=  2; }
     return n - (i >>> 1);
   }
   ```

   * 默认情况（initial_capacity = 16）会进入下面的判断(i == 2^4 - 1)，此时，n=29，而i无符号右移两位之后，会从15(1111)->3(0011)，在return语句中，i再次进行无符号右移，变为(0001)，这时，n-i的值就为28。然后再看tableSizeFor，使用-1无符号右移28位。而-1的二进制表示为11111111111111111111111111111111(因为负数的二进制表示为：1的二进制表示，取反码，然后补码)，移位之后结果就变成了00000000000000000000000000001111，如果没有大于MAXIMUM_CAPACITY，则+1，变为了16，2^4
   * 换种情况，68983，当它进入numberOfLeadingZeros的时候，便成为68982。首先会进入i >= 1<<16，此时n-=16=15。i>>>16之后，会变为(0001)，下面三个判断都进不去，这时候return语句再次右移，就成0了，然后，n=15-0=15，最后，-1无符号右移15位，过程不进行叙述，最后结果为2^17，而68983是大于2^16的。

9. 初始容量和负载因子如果在构造方法中改变的话，会有什么影响？

10. Float.isNaN = return v != v ，为什么这么写？

11. tab[(n - 1) & hash，这个操作是什么意思？

12. resize()这个方法初次执行的时候大小是多少？后续执行的时候，大小会如何变化？

13. hashmap扩容的话，会怎么进行变化？

14. oldCapacity和oldThreshold是有可能不同时为0的对吧，为什么，什么时候发生的事？

15. 这个e.hash & oldCap是什么操作。。。
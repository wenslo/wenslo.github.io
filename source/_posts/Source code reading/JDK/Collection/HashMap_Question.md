---
title: HashMap源码问题解读

categories: 

- 源码阅读

tags: 

- JDK源码


---

> HashMap相关问题放这里，带着问题看，自己的思路解答也会放这里

问题记录：

1. DEFAULT_INITIAL_CAPACITY为啥默认是16，为什么必须是2的倍数？

   解答：

   16可能是一个折中的选项，来避免说设置太小，稍微放一点数据，就进行扩容了，产生不必要的空间浪费。至于说2的倍数，因为底层计算的时候，都是通过cpu移位来进行计算，而2的倍数的话，只需要进行左移一位即可，不然的话，如果是什么加减乘除取模，全部都是cpu进行的加法运算，浪费效率。

2. 最大容量能否进行更改？达到最大容量的时候会浪费多少的容量？

   解答：

   不能通过构造方法更改，如果手动将其更改为比1<<30（1<<31的话，会超出整型的最大值，也就是Integer.MAX_VALUE）更大的数字的话，tableSizeFor()这个方法会重新将值设置为16。如果经过resize()方法扩容了很多次，那么，它的最大容量，实际上汇编成为Integer.MAX_VALUE。如果达到了最大容量，由于说hashmap的阈值范围是threshold * loadFactor，所以首先说，会有1/4的容量，是完全被浪费掉了的。

3. 默认加载因子是0.75，如果是其他的值会有什么影响？为什么是0.75？

4. 树化的阈值为什么是8？树退化为链表的阈值为什么是6？达到阈值6和8的时候分别会产生什么效果？

5. 最小树化容量不是64么，为什么源码注释里写的是4*8=32？如果是32会怎么样？

6. hashcode的集合仅仅在当前掩码变化的时候将会一直碰撞冲突？如果不异或呢。会怎么个冲突法？这个需要自己实现来验证。

7. (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)，为什么要这么做？hashcode为何要与code无符号右移16位后的数字做异或？

8. tableSizeFor方法的作用是什么，为什么要这么写？

9. 初始容量和负载因子如果在构造方法中改变的话，会有什么影响？

10. Float.isNaN = return v != v ，为什么这么写？

11. tab[(n - 1) & hash，这个操作是什么意思？

12. resize()这个方法初次执行的时候大小是多少？后续执行的时候，大小会如何变化？

13. hashmap扩容的话，会怎么进行变化？

14. oldCapacity和oldThreshold是有可能不同时为0的对吧，为什么，什么时候发生的事？

15. 这个e.hash & oldCap是什么操作。。。
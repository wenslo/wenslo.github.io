---
title: 动态规划，leetcode q322 coin change

categories: 

- 动态规划

tags: 

- leetcode

mathjax: true
date: 2021-01-12 13:48:51
description: 动态规划
---

#### 面值为2，5，7的三种硬币，凑出27元最少需要多少枚硬币？
______

##### 先确定最后一步

最后的值为27，那么结果就是为：$27=a_1+a_2+a_3+...+a_k$，那么最后一步即为：$a_k$

##### 拆分子问题

由于最后一枚硬币一定是$a_k$，因此，可以知道倒数第二个硬币为：$ a_{k-1}=  27 - a_k$，由此往前推可知，$a_0=0$。

我们将其转化为子问题，也就变为了：$f(27) = min\{f(27-2)+1,f(27-5)+1,f(27-7)+1\}$

#### 转移方程

$$f[x] = min\{f(27-2)+1,f(27-5)+1,f(27-7)+1\}$$

#### 按照实际逻辑设置边界情况和初始条件

$f[x] = min\{f(27-2)+1,f(27-5)+1,f(27-7)+1\}$ 的边界情况是[x-2] || [x-5] || [x-7]不能小于0（硬币面值为正），也不能高于27。

#### 确定计算顺序

根据上面的转移方程已经可以通过递归写出来了，但是递归会有个问题，重复计算太多

如果从$f[27]$，$f[26]$倒序开始计算的时候，比如，$f[27]$的时候，发现$f[26]$还没有计算，这样重复计算会很多。从$f[1]$,$f[2]$开始的话，就会发现，当计算$f[6]$的时候，$f[5]$已经计算过了，避免了很多重复计算。

也就是说，初始条件为：f[0] = 0

然后计算f[1],f[2],...f[27]

当计算到f[x]时，f[x-2],f[x-5],f[x-7]，都已经有值了

#### 代码如下

```java
public int f() {
        int amount = 27;
        int[] coins = new int[]{2, 5, 7};
        int[] f = new int[27 + 1];

        f[0] = 0;
        for (int i = 1; i <= amount; i++) {
            f[i] = Integer.MAX_VALUE;
            for (int j = 0; j < coins.length; j++) {
                if (i >= coins[j] && f[i - coins[j]] != Integer.MAX_VALUE) {
                    f[i] = Math.min(f[i - coins[j]] + 1, f[i]);
                }
            }
        }
        if (f[amount] == Integer.MAX_VALUE) {
            return -1;
        }
        return f[amount];
    }
```
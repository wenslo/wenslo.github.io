---
title: RabbitMQ 进阶概念

categories: 

- RabbitMQ

tags: 

- 消息队列
date: 2021-03-10 22:29:31

description: RabbitMQ 进阶概念
---

### 消息何去何从

mandatory和immediate是channel.basicPublish方法中的两个参数，都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。RabbitMQ提供的备份交换器可以将未能被交换器路由的消息（没有绑定队列或者没有匹配的绑定）存储起来，而不用返回给客户端。

#### mandatory 参数

当mandatory为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用BasicReturn命令将消息返回给生产者。当mandatory参数设置为false时，出现上述情形，则消息直接被丢弃。

生产者可以通过调用channel.addReturnListener来添加ReturnListener监听器实现。如果没有将消息成功路由到队列，监听器的方法会执行。

#### immediate参数

当immediate参数为true的时候，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过Basic.Return返回至生产者。

概括来说，mandatory参数告诉服务器至少将消息路由到一个队列中，否则将消息返回给生产者。immediate参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递，如果所有匹配的队列上都没有消费者，则直接将消息返还给生产者，不用讲消息存储队列而等待消费者了。

3.0后取消了immediate，建议采用TTL和DLX。

#### 备份交换器

Alternate Exchange，备胎交换器。生产者在发送消息的时候如果不设置mandatory参数，那么消息在未被路由的情况下将会丢失；如果设置了mandatory参数，那么需要添加ReturnListener的编程逻辑，生产者的代码将变的复杂。如果既不想复杂化生产者的编程逻辑，又不想消息丢失，那么可以使用备份交换器，这样可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。

可以在通过声明交换器（调用chnnel.exchangeDeclare方法）的时候添加alternate-exchange参数来实现，也可以通过策略的方式实现。如果两者同时使用，前者的优先级会更高，会覆盖掉Policy的设置。

备份交换器建议设置为fanout类型，需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。

备份交换器，有下面几种特殊情况

- 如果设置的备份交换器不存在，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失

- 如果备份服务器没有绑定任何队列，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失

- 如果备份交换器没有任何匹配的队列，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失

- 如果备份交换器和mandatory参数一起使用，那么mandatory参数无效

### 过期时间 TTL

Time to Live的简称

#### 设置消息的TTL

有两种方法可以设置消息的TTL。第一种是通过队列属性设置，队列中所有消息都有相同的过期时间。第二种是对消息本身进行单独设置，每条消息的TTL可以不同.如果两种方法一起使用，则消息的TTL以两者之间较小的那个数值为准.消息在队列中的生存时间一旦超过设置的TTL值时，就会变成死信，消费者将无法在收到该消息。

TTL设置为0，则表示除非此时可以直接将消息投递给消费者，否则该消息会被立刻丢弃。

对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。

为什么这两种方法处理的方式不一样？因为第一种方法里，队列中已过期的消息肯定在队列头部，RabbitMQ只需要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。


### 死信队列

Dead-Letter-Exchange，当消息在一个队列中变成死信后，它能被重新发送到另一个交换器中，这个交换器就是DLX，绑定于DLX的队列就称之为死信队列。

消息变成死信一般是由于以下几种情况：

- 消息被拒绝，并且设置requeue参数为false
- 消息过期
- 队列达到最大长度

DLX可以处理异常情况下，消息不能够被消费者正确消费而被置入死信队列中的情况，后续分析程序可以通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以改善和优化系统，DLX配合TTL还可以实现延迟队列的功能

### 延迟队列

场景很多，比如：

- 订单系统，有30分钟的时间进行支付

- 智能家居，指定的时间进行工作

DLX死信队列，同样可以看成为延迟队列。假设一个应用中需要将每条消息都设置为10秒的延迟，生产者通过exchange.normal这个交换器将发送的消息存储在queue.normal这个队列中。消费者订阅的并非是queue.normal这个队列，而是queue.dlx这个队列。当消息从queue.normal这个队列中过期之后被存到queue.dlx这个队列中，消费者就恰巧消费到了延迟10秒的这条信息。

### 优先级队列

优先级高的队列具备优先被消费的特权。这个也有前提，如果消费者的生产速度大于生产者的生产速度，并且Broker中没有消息堆积的情况下，对发送的消息设置优先级，也就没有什么实际意义。因为生产者刚生产完一条消息就被消费者消费了，那么久相当于Broker中至多只有一条消息，对于单条消息来说，优先不优先没啥意义。
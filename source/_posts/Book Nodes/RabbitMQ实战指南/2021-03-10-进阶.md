---
title: RabbitMQ 进阶概念

categories: 

- RabbitMQ

tags: 

- 消息队列
date: 2021-03-10 22:29:31

description: RabbitMQ 进阶概念
---

### 消息何去何从

mandatory和immediate是channel.basicPublish方法中的两个参数，都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。RabbitMQ提供的备份交换器可以将未能被交换器路由的消息（没有绑定队列或者没有匹配的绑定）存储起来，而不用返回给客户端。

#### mandatory 参数

当mandatory为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用BasicReturn命令将消息返回给生产者。当mandatory参数设置为false时，出现上述情形，则消息直接被丢弃。

生产者可以通过调用channel.addReturnListener来添加ReturnListener监听器实现。如果没有将消息成功路由到队列，监听器的方法会执行。

#### immediate参数

当immediate参数为true的时候，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过Basic.Return返回至生产者。

概括来说，mandatory参数告诉服务器至少将消息路由到一个队列中，否则将消息返回给生产者。immediate参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递，如果所有匹配的队列上都没有消费者，则直接将消息返还给生产者，不用讲消息存储队列而等待消费者了。

3.0后取消了immediate，建议采用TTL和DLX。

#### 备份交换器

Alternate Exchange，备胎交换器。生产者在发送消息的时候如果不设置mandatory参数，那么消息在未被路由的情况下将会丢失；如果设置了mandatory参数，那么需要添加ReturnListener的编程逻辑，生产者的代码将变的复杂。如果既不想复杂化生产者的编程逻辑，又不想消息丢失，那么可以使用备份交换器，这样可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。

可以在通过声明交换器（调用chnnel.exchangeDeclare方法）的时候添加alternate-exchange参数来实现，也可以通过策略的方式实现。如果两者同时使用，前者的优先级会更高，会覆盖掉Policy的设置。

备份交换器建议设置为fanout类型，需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。

备份交换器，有下面几种特殊情况

- 如果设置的备份交换器不存在，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失

- 如果备份服务器没有绑定任何队列，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失

- 如果备份交换器没有任何匹配的队列，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失

- 如果备份交换器和mandatory参数一起使用，那么mandatory参数无效

### 过期时间 TTL

Time to Live的简称

#### 设置消息的TTL

有两种方法可以设置消息的TTL。第一种是通过队列属性设置，队列中所有消息都有相同的过期时间。第二种是对消息本身进行单独设置，每条消息的TTL可以不同.如果两种方法一起使用，则消息的TTL以两者之间较小的那个数值为准.消息在队列中的生存时间一旦超过设置的TTL值时，就会变成死信，消费者将无法在收到该消息。

TTL设置为0，则表示除非此时可以直接将消息投递给消费者，否则该消息会被立刻丢弃。

对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。

为什么这两种方法处理的方式不一样？因为第一种方法里，队列中已过期的消息肯定在队列头部，RabbitMQ只需要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。


### 死信队列

Dead-Letter-Exchange，当消息在一个队列中变成死信后，它能被重新发送到另一个交换器中，这个交换器就是DLX，绑定于DLX的队列就称之为死信队列。

消息变成死信一般是由于以下几种情况：

- 消息被拒绝，并且设置requeue参数为false
- 消息过期
- 队列达到最大长度

DLX可以处理异常情况下，消息不能够被消费者正确消费而被置入死信队列中的情况，后续分析程序可以通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以改善和优化系统，DLX配合TTL还可以实现延迟队列的功能

### 延迟队列

场景很多，比如：

- 订单系统，有30分钟的时间进行支付

- 智能家居，指定的时间进行工作

DLX死信队列，同样可以看成为延迟队列。假设一个应用中需要将每条消息都设置为10秒的延迟，生产者通过exchange.normal这个交换器将发送的消息存储在queue.normal这个队列中。消费者订阅的并非是queue.normal这个队列，而是queue.dlx这个队列。当消息从queue.normal这个队列中过期之后被存到queue.dlx这个队列中，消费者就恰巧消费到了延迟10秒的这条信息。

### 优先级队列

优先级高的队列具备优先被消费的特权。这个也有前提，如果消费者的生产速度大于生产者的生产速度，并且Broker中没有消息堆积的情况下，对发送的消息设置优先级，也就没有什么实际意义。因为生产者刚生产完一条消息就被消费者消费了，那么久相当于Broker中至多只有一条消息，对于单条消息来说，优先不优先没啥意义。

### 生产者确认

如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何消息给生产者的，也就是默认情况下生产者是是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前已经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化？

针对这个问题，提供了两种解决方式：

- 通过事务机制实现

- 通过发送方确认机制实现。（publisher confirm）

#### 事务机制

RabbitMQ中和事务机制相关的方法有三个：channel.txSelect，channel.txCommit和channel.txRollback。txSelect用于将当前的信道设置为事务模式，txCommit用于提交事务，txRollback用于事务回滚。在通过txSelect方法开启事务之后，就可以发送消息给RabbitMQ了，如果事务提交成功，则消息一定到达了RabbitMQ中，如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行txRollback方法来实现事务回滚。

事务非常耗费性能，从AMQP协议层面来看没有什么更好的办法

#### 发送方确认机制

由于采用事务会严重降低RabbitMQ的吞吐量，因此引入一种轻量级的方式，发送方确认机制。

生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认给生产者（包含消息的唯一ID），这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。RabbitMQ回传给生产者的确认消息中的deliveryTag包含了确认消息的序号，此外RabbitMQ也可以设置channel.basicAck方法中的multiple参数，表示到这个需要之前的所有消息已经得到了处理

事务机制在一条消息发送之后会使得发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息。相比之下，发送方确认机制最大的好处在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack命令，生产者应用程序同样可以在回调方法中处理该nack命令

生产者通过调用channel.confirmSelect方法将信道设置为confirm模式，之后RabbitMQ会返回select-ok命令表示同意生产者将当前信道设置为confirm模式。所有被发送的后续消息都被ack或者nack一次，不会出现一条消息既被ack又被nack的情况，并且RabbitMQ也没有对消息被confirm的快慢做任何保证

### 消费端要点

- 消息分发

- 消息顺序性

- 启用QueueingConsumer

#### 消息分发

当RabbitMQ队列拥有多个消费者的时候，队列收到的消息将以轮训的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方法非常适合扩展，专门为并发程序设计的

但是轮训分发也不是那么优雅，如果分布不均匀，会造成整体应用吞吐量的下降

解决这个问题，需要使用channel.basicQos(int prefetchCount)，允许限制信道上的消费者所能保持的最大未确认消息的数量。对于拉模式的消费方式无效。如果为0，则表示没有上限。

可类比于TCP/IP中的滑动窗口

#### 消息顺序性

只有一个生产者和一个消费者的情况下，可以保证消费的顺序性。多个的话，无法保证。

有这么几种情形

如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用publisher confirm时，在发生超时，中断，又或者是收到RabbitMQ的Basic.Nack命令时，那么同样需要不常发送，结果与事务机制一样会错序。我们可以固执的认为消息的顺序性保证是从存入队列之后开始的，而不是在发送的时候开始的。

如果生产和发送的消息设置了不同的超时时间，并且也设置了死信队列，整体上来说相当于一个延迟对垒，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。

如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。

如果需要保证消息的顺序性，需要业务方使用RabbitMQ之后做进一步的处理，比如在消息体内添加全局有序标识

### 消息传输保障

一般消息中间件的消息传输保障分为三个层级。

- At most once，最多一次，消息可能会丢失，但绝不会重复传输
- At least once，最少一次，消息绝不会丢失，但可能会重复传输
- Exactly once，恰好一次。每条消息肯定会被传输一次且仅传输一次

RabbitMQ支持其中的最多一次和最少一次。其中最少一次投递实现需要考虑下面几点内容

1. 消息生产者需要开启事务机制或者publisher confirm机制，以确保消息可以可靠的传输到RabbitMQ中
2. 消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃
3. 消息和队列都需要进行持久化处理，以确保RabbitMQ服务器在遇到异常情况时不会造成消息丢失
4. 消费者在消费信息的同事需要将autoAck设置为false，然后通过手动确认的方式去确认已经正确消费的消息，以避免在消费端引起不必要的消费丢失

最多一次就无需考虑上面的内容，生产者随意发送，消费者随意消费，不过很难保证消息不会丢失

恰好一次无法保证。
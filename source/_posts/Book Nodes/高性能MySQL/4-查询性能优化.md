---
title: MySQL查询性能的优化

categories: 

- MySQL

tags: 

- MySQL
date: 2020-12-18 23:08:25
---

| 1.简介


查询的生命周期大致可以按照顺序来看：**客户端，服务器，在服务器上进行解析，生成执行计划，执行，返回结果给客户端，执行可以认为是整个生性周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组**。在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的IO操作上消耗时间，根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。

| 2.慢查询基础：优化数据访问

查询性能低下最根本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。两个步骤：**1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的航，但有时候也可能是访问了太多的列。2.确认MySQL服务器层是否在分析大量超过需要的数据行。**

| 2.1 是否想数据库请求了不需要的数据

1. 查询不需要的记录

    比如说，JDBC的结果集是缓存的查询语句的所有结果，获取前几行，关闭之后，剩余的数据就会被抛弃，这种情况应当加上limit

2. 多表关联时返回全部列

    只选择需要的列

3. 总是取出全部列

    也就是说，避免`select *`，这种查询，优化器无法完成覆盖扫描这类优化，还会带来额外的IO，内存和CPU的消耗。如果表设计不完善，比如所有字段都在一张表（包括大字段），那么`select*`就是灾难

4. 重复查询相同的数据

    缓存热点数据，避免重复查询

| 2.2 MySQL是否在扫描额外的记录

最简单的三个指标：***响应时间，扫描的行数，返回的行数***。这三个指标会记录到MySQL的慢日志中。

**响应时间**

响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间--可能是等待IO，也可能是行锁，很难做到逐个测量，一般常见的是IO和锁等地啊.

**扫描的行数和返回的行数**

较短的行访问速度更快，内存中的行也比磁盘中的行的访问速度要快。理想情况下，扫描多少行返回多少行，但是实际上不可能发生，比如关联查询，需要扫描多行才能生成结果集中的一行，比率一般在1：1和10：1之间，也有可能非常大。

在explain语句中的type列反应了访问类型。访问类型有很多种，从**全表扫描到索引扫描、范围扫描、唯一索引扫描、常数引用等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大（感觉书里写错了）。**

```sql
explain select * from film_actor where film_id = 1;
# +--+-----------+----------+----------+----+--------------+--------------+-------+-----+----+--------+-----+
# |id|select_type|table     |partitions|type|possible_keys |key           |key_len|ref  |rows|filtered|Extra|
# +--+-----------+----------+----------+----+--------------+--------------+-------+-----+----+--------+-----+
# |1 |SIMPLE     |film_actor|NULL      |ref |idx_fk_film_id|idx_fk_film_id|2      |const|10  |100     |NULL |
# +--+-----------+----------+----------+----+--------------+--------------+-------+-----+----+--------+-----+

# 这里能看到，在索引idx_fk_film_id上使用了ref访问类型来执行查询。explain的结果也显示MySQL预估需要访问10行数据。换句话说，查询优化器认为这种访问类型可以高效地完成查询。
# 但是如果没有索引话，MySQL就不得不使用一种更糟糕的访问类型。

alter table film_actor drop foreign key fk_film_actor_film;
alter table film_actor drop key idx_fk_film_id;

explain select * from film_actor where film_id = 1;
# +--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----------+
# |id|select_type|table     |partitions|type|possible_keys|key |key_len|ref |rows|filtered|Extra      |
# +--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----------+
# |1 |SIMPLE     |film_actor|NULL      |ALL |NULL         |NULL|NULL   |NULL|5462|10      |Using where|
# +--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----------+

# 这时候再看，访问类型变成了一个全表扫描，这里的using where 标识MySQL将通过where条件来筛选存储引擎返回的记录。

```

一般MySQL能使用下面三种方式应用where条件，从好到坏依次为：

1. 在索引中使用where条件来过滤不匹配的记录。这是在存储引擎完成的。

2. 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。

3. 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。

不过，MySQL不会告诉我们生成结果实际上需要扫描多少行数据，而只会告诉我们生成结果时一共扫描了多少行数据。扫描的行数中的大部分都很可能是被where条件过滤掉的，对最终的结果集没有贡献。上面的例子中，删除索引后，看到MySQL需要扫描所有记录然后根据where条件过滤，最终只返回10行结果。可以尝试以下技巧进行优化

1. 使用索引覆盖扫描，把所有需要用到的列都放到索引中，这样存储引擎无需回表获取对应行就可以返回结果

2. 改变库表结构，比如使用单独的汇总表

3. 重写复杂查询，让MySQL优化器能够以更有花的方式执行这个查询。


| 3.1 一个复杂查询还是多个简单查询

首先，个人观点，尽量避免复杂查询，外包公司可能是从oracle遗传下来的习惯，很喜欢各种复杂sql处理，因为以前的网络通信，查询解析和优化代价很高，但是这样，会导致数据库层成为瓶颈，而且，都2020年了，不思进取的老人也该被淘汰了。

MySQL从设计上让连接和断开都很轻量级，在返回一个小的查询结果方面很高效。MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MySQL相应数据给客户端就慢很多。相同条件下，使用尽可能少的查询当然是好的。但是，很多时候，将一个大查询分解为多个小查询是很有必要的。

| 3.2 切分查询

分治，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。**删除旧的数据就是一个很好的例子：如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但是很重要的查询。将一个大的delete语句分割成多个较小的查询可以尽可能小的影响MySQL性能，还可以减少MySQL复制的延迟。**例子如下：

```sql
delete from messages where created < date_sub(now(),interval 3 month )

```

可以改用下面的方法完成

```php
rows_affected = 0;
do{
  rows_affected = do_query("delete from messages where created < date_sub(now(),interval 3 month ) limit 
10000")
}while rows_affected>0
```

一次删除一万行数据一般来说是一个比较高效而且对服务器影响也最小的做法（如果是事务性引擎，很多时候小事务能够更高效）。同时需要注意的是，如果每次删除数据后，都暂停一会再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。

| 3.3 分解关联查询

很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表都进行一次单表查询，然后将结果在应用程序中进行关联，比如说：

```sql
select *
from tag
         join tag_post on tag_post.tab_id = tag.id
         join post on tag_post.post_id = post.id
where tag.tag = 'mysql';
# 可以分解为下面的查询：
select * from tag where tag='mysql';
select * from tag_post where tag_id=1234;
select * from post where post.id in (123,46,456,9992,9998);
```

看起来可能会说，这有什么好处，结果不一样么，但是，用这种方式，有下面这些优势：

- 让
---
title: MySQL创建高性能索引

categories: 

- MySQL

tags: 

- MySQL
date: 2020-12-17 10:32:32
---

| 1.1 索引的类型

索引是在存储引擎层实现，非服务器层实现，所以，不同的存储引擎之间，索引的工作方式不一样，也不是所有的存储引擎都实现了某一个索引，即使实现了，工作方式也很有可能不一样。

一般常说的索引指的是**B-Tree索引**，但是实际上一般是B+tree，因为B+tree每一个叶子节点都指向下一个叶子节点，有助于范围区间的查询遍历。

示例图如下

B-tree能提高数据访问速度，不再需要全表扫描，而是通过索引，从root节点开始搜索，树的深度和表的大小直接相关，因为b-tree是顺序存储，因此很适合范围查找数据，比如，整数的顺序，字母的顺序，非常高效。

B-tree适合于**全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引**等查询。而且，索引树种的节点是有序的，因此，能用于查询，也就能用于order by 排序。

B-tree索引的限制（最左匹配原则）：

1. 如果不是按照索引的最左列开始查找，则无法使用索引
2. 不能跳过索引中的列
3. 如果查询中有某个列的范围查询，那么右边的所有列都无法使用索引优化查找

**Hash索引**的话，必须是精确匹配所有的查询列才会生效，只有Memery引擎显示支持hash索引。hash找数据非常快，但是也有其自身的一些限制

1. hash索引只包含hash值和指针，无法避免回表
2. hash索引并不是按照索引值顺序排列的，也就无法用于排序
3. 不支持部分匹配查找
4. 只支持等值匹配查找
5. hash碰撞（冲突）很多的话，极端情况，会变化为链表

同时，InnoDB有一个功能叫”自适应hash索引“，当某些索引值使用的非常频繁的时候，会在内存中，基于B-Tree索引之上再创建一个hash索引，用户无法控制，但是这个功能可以关闭。

同时，如果想在InnoDB中使用hash索引的话，可以手动实现一个，其实就是插入前使用hash函数，但是需要注意，使用CRC32()函数比较合适，推荐使用整数，并不推荐使用SHA1和MD5，这种函数是为了最大化避免hash冲突，实际过程中，并不是那么的有必要。同时，由于生日悖论，hash冲突的出现会比想象中快很多，最好手动维护一个64位的hash函数使用。

**R-Tree 空间索引**

用作地理数据存储，但是必须使用GIS相关函数来维护数据

**全文索引**

MySQL不常用，更适合用搜索引擎来做

| 1.2 索引的优点

1. 大大减少了服务器需要扫描的数据量
2. 可以帮助服务器避免排序和临时表
3. 可以将随机I/O变为顺序IO

| 1.3 高性能索引策略

1. 独立的列

    如果查询的列不是独立的，那么无法使用索引，也就是说，索引列不能是表达式的一部分，也不能是函数的参数，比如：

    ```sql
    select * from actor where actor_id = 4+1;
    # 或者
    select * from xxx where to_day(current_date) - to_day(current_date) > 10;
    ```
    But，与MySQL8 测试，这个查询正常走了索引，估计是优化器进行了优化吧

2. 前缀所以和索引的选择性

    先说很重要的一点：**MySQL无法使用前缀索引进行order by和group by，也无法使用前缀索引做覆盖扫描**。

    有时候需要索引很长的字符列，这样的话，索引会变的又大又慢，一个策略是使用伪hash索引，但是通常情况下，可以索引开始的部分字符，这样可以大大节省索引空间，提升索引效率。但是同时也会降低索引的选择性。索引的选择性是指：**不重复的索引值和数据表的记录总数的比值，范围从1/T - 1 之间**，索引的选择性越高，则查询效率越高，因为选择性越高的索引在查询时能过滤掉更多的行，唯一索引的选择性为1，是性能最好的索引选择性。

    对于很长的text，varchar，blob，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

    诀窍在于选择足够长的前缀以保证较高的选择性，同时不能太长（节约空间），前缀应该足够长，使得选择性接近与索引整个列。  

    ```sql
    # 计算完成列的选择性
    select count(distinct city)/count(*) from city_demo;
    # 如何在一个查询中计算不同前缀长度的选择性
    select count(distinct left(city, 3)) / count(*) as sel3,
       count(distinct left(city, 4)) / count(*) as sel4,
       count(distinct left(city, 5)) / count(*) as sel5,
       count(distinct left(city, 6)) / count(*) as sel6,
       count(distinct left(city, 7)) / count(*) as sel7
    from city_demo
    ```

    这样的话，有助于帮助找到最合适的前缀索引长度。然后开始创建前缀索引。

    ```sql
    alter table city_demo add key(city(7));
    ```

3. 多列索引

    一个常见错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

    MySQL引入了一种叫**索引合并（index merge）**的策略，一定程度上可以利用表上的多个单列索引来定位指定的行。比如下面代码所示
    ```sql
    explain select film_id,actor_id from film_actor where actor_id = 1 or film_id =1;
    ```
    在某些语句的extra列中，还能看到嵌套操作。索引合并是一种优化的结果，但是也说明，索引实际上建的非常糟糕。
    - 当服务器对多个索引做相交操作时（多个AND条件），通常意味着需要一个包含相关列的多列索引，而不是多个独立的单列索引。
    - 当服务器需要对多个索引做联合操作时（多个OR条件），通常需要消耗大量的CPU和内存资源在算法的缓存，排序和合并操作上，特别是其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
    - 更重要的是，优化器不会把这些计算算到”查询成本（cost）“中，优化器只关心随机页面读取。这样会使得查询的成本被低估，导致该执行计划还不如全表扫描。这样不仅可能会消耗更多的CPU和内存资源，还可能会影响查询的并发性。还不如改写成union。

4. 选择合适的索引列顺序

    说明：***只适用于b-tree索引***

    在一个多列b-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的order by, group by 和 distinct等子句的查询需求。

    有的建议是：将选择性最高的列放到索引最前列。但是这个建议，**通常不如避免随机IO和排序那么重要**。

    当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好地。这时候索引的作用只适用于优化where条件的查找。这种情况下，这样索引能最快地过滤出所需要的行，对于在where子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。示例如下

    ```sql
    select * from payment where staff_id = 2 and customer_id = 584;
    # 应该创建一个(staff_id,customer_id)还是应该颠倒以下顺序？可以跑一些查询来确定在这个表中的分布情况，并确定哪个列的选择性更高。
    select sum(staff_id=2),sum(customer_id=584) from payment;
    # sum(staff_id=2)：7992
    # sum(customer_id=584)：30

    select sum(staff_id=2) from payment where customer_id = 584;
    # sum(staff_id=2)：17

    # 需要注意的是，查询的结果非常依赖与选定的具体值，如果这样来，服务器的整体性能可能会更糟，或者不如预期
    # 最好还是按照经验法则来，考虑全局技术和选择性，而不是某个具体查询
    select count(distinct staff_id)/count(*) as staff_id_selectivity,
        count(distinct customer_id)/count(*) as customer_id_selectivity,
        count(*) from payment;
    # 由结果可知，customer_id的选择性更高，所以它是索引列的第一列
    alter table payment add key (customer_id,staff_id)
    ```

5. 聚簇索引

    InnoDB的聚簇索引实际上在同一个结构中保存了B-tree索引和数据行。当表有局促索引时，它的数据行实际上存放在索引的叶子页中。因为无法同时把数据航存放在两个不同的地方，所以一个表只能有一个聚簇索引（覆盖索引可以模拟多个局促索引的情况）。

    图例在这

    如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。

    聚簇索引的一些优点：
    
    - 可以把相关数据保存在一起。避免每一次都是磁盘IO
    - 数据访问更快。聚簇索引将索引和数据保存在同一个B-tree中，从聚簇索引中获取数据通常比在非聚簇索引中查找要快
    - 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

    聚簇索引的一些缺点：

    - 最大限度的提高了I/O密集型应用的性能，但是数据如果全部都放在内存中，则反问的顺序就没有那么重要，聚簇索引也就没有什么优势
    - 插入速度严重依赖与插入顺序，按照主键的顺序插入是加载数据到InnoDB表中速度最快的，但是如果不是按照主键顺序加载，那么加载完成后，需要使用optimize table重新组织一下表。
    - 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
    - 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临”页分裂（page split）“的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将改页分裂成两个页面来运行，页分裂会导致表占用更多的磁盘空间
    - 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂，导致的数据存储不连续的时候
    - 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
    - 二级索引访问需要两次索引查找，而不是一次

    因为二级索引中保存的不是指向行的物理位置的指针，而是行的主键值。意味着通过二级索引查找行，存储引擎需要到二级索引的叶子节点获得对应的主键，然后根据这个值，去聚簇索引中查找到对应的行。自适应hash索引能减少这样的重复操作。
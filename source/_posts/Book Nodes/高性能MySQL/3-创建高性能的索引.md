---
title: MySQL创建高性能索引

categories: 

- MySQL

tags: 

- MySQL
date: 2020-12-17 10:32:32
---

| 1.1 索引的类型

索引是在存储引擎层实现，非服务器层实现，所以，不同的存储引擎之间，索引的工作方式不一样，也不是所有的存储引擎都实现了某一个索引，即使实现了，工作方式也很有可能不一样。

一般常说的索引指的是**B-Tree索引**，但是实际上一般是B+tree，因为B+tree每一个叶子节点都指向下一个叶子节点，有助于范围区间的查询遍历。

示例图如下

B-tree能提高数据访问速度，不再需要全表扫描，而是通过索引，从root节点开始搜索，树的深度和表的大小直接相关，因为b-tree是顺序存储，因此很适合范围查找数据，比如，整数的顺序，字母的顺序，非常高效。

B-tree适合于**全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引**等查询。而且，索引树种的节点是有序的，因此，能用于查询，也就能用于order by 排序。

B-tree索引的限制（最左匹配原则）：

1. 如果不是按照索引的最左列开始查找，则无法使用索引
2. 不能跳过索引中的列
3. 如果查询中有某个列的范围查询，那么右边的所有列都无法使用索引优化查找

**Hash索引**的话，必须是精确匹配所有的查询列才会生效，只有Memery引擎显示支持hash索引。hash找数据非常快，但是也有其自身的一些限制

1. hash索引只包含hash值和指针，无法避免回表
2. hash索引并不是按照索引值顺序排列的，也就无法用于排序
3. 不支持部分匹配查找
4. 只支持等值匹配查找
5. hash碰撞（冲突）很多的话，极端情况，会变化为链表

同时，InnoDB有一个功能叫”自适应hash索引“，当某些索引值使用的非常频繁的时候，会在内存中，基于B-Tree索引之上再创建一个hash索引，用户无法控制，但是这个功能可以关闭。

同时，如果想在InnoDB中使用hash索引的话，可以手动实现一个，其实就是插入前使用hash函数，但是需要注意，使用CRC32()函数比较合适，推荐使用整数，并不推荐使用SHA1和MD5，这种函数是为了最大化避免hash冲突，实际过程中，并不是那么的有必要。同时，由于生日悖论，hash冲突的出现会比想象中快很多，最好手动维护一个64位的hash函数使用。

**R-Tree 空间索引**

用作地理数据存储，但是必须使用GIS相关函数来维护数据

**全文索引**

MySQL不常用，更适合用搜索引擎来做

| 1.2 索引的优点

1. 大大减少了服务器需要扫描的数据量
2. 可以帮助服务器避免排序和临时表
3. 可以将随机I/O变为顺序IO

| 1.3 高性能索引策略

1. 独立的列

    如果查询的列不是独立的，那么无法使用索引，也就是说，索引列不能是表达式的一部分，也不能是函数的参数，比如：

    ```sql
    select * from actor where actor_id = 4+1;
    # 或者
    select * from xxx where to_day(current_date) - to_day(current_date) > 10;
    ```
    But，与MySQL8 测试，这个查询正常走了索引，估计是优化器进行了优化吧

2. 前缀所以和索引的选择性

    先说很重要的一点：**MySQL无法使用前缀索引进行order by和group by，也无法使用前缀索引做覆盖扫描**。

    有时候需要索引很长的字符列，这样的话，索引会变的又大又慢，一个策略是使用伪hash索引，但是通常情况下，可以索引开始的部分字符，这样可以大大节省索引空间，提升索引效率。但是同时也会降低索引的选择性。索引的选择性是指：**不重复的索引值和数据表的记录总数的比值，范围从1/T - 1 之间**，索引的选择性越高，则查询效率越高，因为选择性越高的索引在查询时能过滤掉更多的行，唯一索引的选择性为1，是性能最好的索引选择性。

    对于很长的text，varchar，blob，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

    诀窍在于选择足够长的前缀以保证较高的选择性，同时不能太长（节约空间），前缀应该足够长，使得选择性接近与索引整个列。  

    ```sql
    # 计算完成列的选择性
    select count(distinct city)/count(*) from city_demo;
    # 如何在一个查询中计算不同前缀长度的选择性
    select count(distinct left(city, 3)) / count(*) as sel3,
       count(distinct left(city, 4)) / count(*) as sel4,
       count(distinct left(city, 5)) / count(*) as sel5,
       count(distinct left(city, 6)) / count(*) as sel6,
       count(distinct left(city, 7)) / count(*) as sel7
    from city_demo
    ```

    这样的话，有助于帮助找到最合适的前缀索引长度。然后开始创建前缀索引。

    ```sql
    alter table city_demo add key(city(7));
    ```

3. 多列索引

    一个常见错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

    MySQL引入了一种叫**索引合并（index merge）**的策略，一定程度上可以利用表上的多个单列索引来定位指定的行。比如下面代码所示
    ```sql
    explain select film_id,actor_id from film_actor where actor_id = 1 or film_id =1;
    ```
    在某些语句的extra列中，还能看到嵌套操作。索引合并是一种优化的结果，但是也说明，索引实际上建的非常糟糕。
    - 当服务器对多个索引做相交操作时（多个AND条件），通常意味着需要一个包含相关列的多列索引，而不是多个独立的单列索引。
    - 当服务器需要对多个索引做联合操作时（多个OR条件），通常需要消耗大量的CPU和内存资源在算法的缓存，排序和合并操作上，特别是其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
    - 更重要的是，优化器不会把这些计算算到”查询成本（cost）“中，优化器只关心随机页面读取。这样会使得查询的成本被低估，导致该执行计划还不如全表扫描。这样不仅可能会消耗更多的CPU和内存资源，还可能会影响查询的并发性。还不如改写成union。

4. 选择合适的索引列顺序

    说明：***只适用于b-tree索引***

    在一个多列b-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的order by, group by 和 distinct等子句的查询需求。

    有的建议是：将选择性最高的列放到索引最前列。但是这个建议，**通常不如避免随机IO和排序那么重要**。
    
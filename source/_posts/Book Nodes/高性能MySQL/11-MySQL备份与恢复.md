---
title: MySQL的备份与恢复

categories: 

- MySQL

tags: 

- MySQL
date: 2021-01-10 16:03:36
description: MySQL的备份与恢复
---

### 1. 为什么要备份？
____

- 灾难恢复
- 领导改变想法
- 审计
- 测试

### 2. 定义备份需求
____

只有备份是不够的，还需要有一个恢复系统，但是，让备份系统平滑工作比构造良好的恢复过程和工具更容易。原因如下：

- 备份在先。只有已经做了备份才可能恢复，因此在构建系统时，注意力自然会集中到备份上
- 备份由脚本和任务自动完成。会花一些事件调优备份过程，但是天天同样重视恢复不可能。
- 备份是日常任务，恢复常常发生在危急情况下
- 因为安全的需要，如果正在做异地备份，可能需要对备份数据进行加密，或采取其他错误来进行保护。安全性往往只关注数据被盗用的结果，但是如果没有人能怼用来恢复数据的加密卷解锁，或者需要从一个整块的加密文件中抽取单个文件时，损害有多大？
- 只有一个人来规划、设计和实施备份。当灾难袭来时，那个人可能不在，因此需要培养几个人并有计划的互为备份，这样就不会要求一个不合格的人来恢复数据。

规划备份和恢复策略时，有两个重要的需求可以帮助思考：恢复点目标（PRO）和恢复时间目标（RTO）。它们定义了可以容忍丢失多少数据，以及需要等待多久将数据恢复。在定义PRO和RTO时，先尝试回答下面的问题：

- 不导致严重后果的情况下，可以容忍丢失多少数据？需要故障恢复，还是可以接受自从上次日常备份后所有的工作全部丢失？是否有法律法规的要求？
- 恢复需要在多长时间内完成？哪种类型的宕机是可接受的？哪种影响是应用和用户可以接受的？当哪些场景发生时，又该如何持续服务？
- 需要恢复什么？常见的是恢复整个服务器，单个数据库，单个表，或者仅仅是特定的事务或者语句

### 3 设计MySQL备份方案
_____

建议：

- 物理备份是必须的，逻辑备份太慢而且受到资源限制
- 保留多个备份集
- 定期从逻辑备份中抽取数据进行恢复测试
- 保存二进制日志以用于基于故障时间点的恢复，这样就可以在保持主库运行且不运行任何二进制日志的情况下创建一个备库。备库二进制日志与过期设置无关，二进制日志备份需要保存足够长的时间，以便能从最近的逻辑备份进行恢复
- 完全不借助备份工具来监控备份和备份的过程。另外需要验证备份是否正常
- 通过演练整个恢复过程来测试备份和恢复。测算需要的资源
- 对安全性仔细考虑

逻辑备份的优点：

- 逻辑备份可以用编辑器或者grep查看，当需要查看但不进行恢复的时候，很有帮助
- 恢复很简单
- 可以通过网络来恢复
- 很灵活，可以通过where 子句限制执行
- 与存储引擎无关
- 有助于避免数据损坏

缺点：

- 必须由数据库服务器完成逻辑备份的工作，因此需要更多的CPU时钟周期
- 逻辑本分某些场景下比数据库文件更大
- 无法保证导出后在还原一定是同样的数据
- 从逻辑悲愤中还原需要MySQL加载和解释语句，转换为存储格式，重建索引，很慢。

mysqldump 很有帮助。

物理备份的优点：

- 文件复制到其他地方即可完成备份
- 复制过去即可完成恢复，innodb需要停止服务
- 物理备份容易跨平台，操作系统，MySQL版本
- 恢复会更快

缺点：

- 原始文件比逻辑备份大很多，表空间有很多未使用的空间，缓冲，存储，回滚段等
- 物理备份不是总可以跨平台。


对于需要长期保留的备份，不要完全依赖于物理备份，每隔一段时间做一次逻辑备份。

建议混合使用，

#### 3.3 备份什么
_____

- 非显著数据，例如二进制日志，事务日志
- 代码，触发器，存储过程代码
- 配置复制，例如，二进制日志，中继日志，日志索引文件
- 服务器配置
- 操作系统文件

#### 3.4 存储引擎和一致性
____

数据一致性，应该考虑数据在指定时间点一致

文件一致性，例如，一条大的update语句执行时备份反映不出文件的状态。

### 4 管理和备份二进制日志
____

对于基于时间点的恢复是必须的，跟容易进行频繁的备份。经常备份二进制日志是个好主意。

需要决定日志的过期策略以防止磁盘被二进制日志写满。日志增长多大取决于负载和日志格式（基于行的日志会导致更大的日志）。通常使用**expre_log_days**来告诉MySQL定期清理日志。

### 5 备份数据
____

#### 生成逻辑备份

对于逻辑备份，有两种方式，SQL导出和符号分隔文件

```shell
mysqldump test t1
```

导出文件包含表结构和数据，以有效SQL命令写出。但是mysqldump默认选项对生成一个巨大的备份不太适合。

mysqldump不是生成SQL逻辑备份的唯一工具。SQL逻辑备份本来就有一些缺点：

- schema 和 数据存储在一起

    如果想从单个文件恢复会很方便，但是如果只想回复一个表或指向恢复数据就很困难了，可以通过导出两次的方式减缓这个问题，一次只导出数据，一次只导出schema

- 巨大的SQL语句

    服务器分析和执行SQL语句的工作量非常大，所以加载数据时会非常慢

- 单个巨大的文件

    大部分文本编辑器不能编辑巨大的或者包含非常长的行的文件。linux 和 unix可以，但是保持文件小型化是必要的

- 逻辑备份的成本很靠

这些意味着在表变大的时候会变得不可用。不过还有一个选择，**导出数据到符号分隔的文件中**。

```sql
select * into outfile '/tmp/t1.txt'
fields terminated by ',' optinally enclosed by '"'
lines terminated by '\n' from test.t1;
```

可以使用SQL命令 SELECT INTO OUTFILE 以符号分隔文件格式创建数据的逻辑备份（mysqldump --tab）。符号分隔文件以ASCII展示的原始数据，没有SQL，注释和列名。比起SQL导出,符号分隔文件更紧凑，更易于用命令行工具操作，最大的有点事备份和还原速度更快。可以和导出时使用一样的选项，用load data infile方法加载数据到表中

```sql
select * into infile '/tmp/t1.txt'
into table test.t1
fields terminated by ',' optionally enclosed by '"'
lines terminated by '\n';
```

符号分隔的恢复速度，比sql导出，快了接近一倍，但是导出的时候，时间差异不大。

但是select into outfile方法也有一些限制

- 只能被分到运行MySQL服务器机器上的文件中
- 运行MySQL的系统用户必须有文件目录的写权限，因为是由MySQL服务器来执行文件的写入，而不是运行SQL命令的用户
- 出于安全原因，不能覆盖已经存在的文件，不管文件权限如何。
- 不能直接导出到压缩文件中
- 某些情况下很难进行正确的导出或导入，例如非标准的字符集。


#### 文件快照系统

LVM使用写时复制的技术来创建快照。例如，对整个卷的某个瞬间的逻辑副本。这与数据库中的MVCC有点像，不同的是它只保留一个老的数据版本。

注意，说的不是物理副本。逻辑副本看起来好像包含了创建快照时卷中所有的数据，但实际上一开始快照是不包含数据的。相比复制数据到快照中，LVM知识简单地标记创建快照的时间点，然后对该快照请求读数据，实际上是从原试卷中读取的。因此，初始的复制基本上是一个瞬间就能完成的操作，不管创建快照的卷多大。

当原始卷中某些数据有变化时，LVM在任何变更写入之前，会复制受影响的块到快照预留的区域中。LVM不保留数据的多个老版本，因此对原始卷中变更块的额外写入并不需要对快照做其他更多的工作。换句话手，每个块只有第一次写入才会导致写时复制。

现在，在快照中请求这些块时，LVM会从复制块中而不是从原始卷中读取。所以，可以继续看到快照中相同时间点的数据而不需要阻塞任何原始卷。

快照会在/dev目录下创建一个新的逻辑卷，可以像挂载其他设备一样挂载它。

理论上讲，这种技术可以对一个非常大的卷做快照，而只需要非常少的物理存储空间。但是，必须设置足够的空间，保证在快照打开时，能够保存所有期望在原始卷上更新的数据。如果不预留足够的写时复制空间，当快照用完所有的空间后，设备就会变得不可用。这个影响就像拔出一个外部设备，任何从设备上读的备份工作都会因为IO错误而失败。


### 从备份中恢复
____

#### 恢复物理备份

简单复制文件到正确位置，是否需要关闭MySQL取决于存储引擎，innodb必须关闭。

如果使用innodb的file-per-table特性，innodb会将每个表的数据和索引存储于一个.ibd文件中。可以在服务器运行时通过复制这些文件来备份和还原单个表。

还原的时候，需要确保拥有权限，而且需要观察MySQL日志，同时，也需要使用show table status来监测日志。

#### 还原逻辑备份

加载导出文件前，需要考虑一下，文件有多大，需要多久加载完，以及在启动前还需要做什么事情，例如，禁掉二进制日志是个好主意，除非需要将还原操作复制到备库。服务器加载一个巨大的导出文件的代价很高，并且写二进制日志会增加更多的开销，对一些存储引擎也有影响。因为巨大的回滚段会导致文件，应该可控，并且逐个提交事务。

有两种类型的逻辑备份，所以，就应该有两种类型的还原操作。

##### 加载SQL文件

```shell
mysql < sakila-backup.sql
```

也可以使用source命令加载文件。如果是mysql管理用户，就可以关闭二进制记录，然后加载文件而不需要重启服务器

```mysql
set SQL_LOG_BIN = 0;
SOURCE sakila-backup.sql;
SET SQL_LOG_BIN = 1;
```

如果备份做过压缩，不要分别解压缩和加载。应该在单个操作中完成解压缩和加载。会快很多

```shell
gunzip -c sakila-backup.sql.gz | mysql
```

如果指向恢复单个表，如果数据没有分行但是有schema信息，那么还原数据并不难

```shell
grep 'INSERT INTO ``actor' sakila-backup.sql | mysql sakila
```

如果文件时压缩过的，那么命令如下

```shell
gunzip -c sakila-backup.sql.gz | grep 'INSERT INTO `actor`' | mysql sakila
```

##### 加载符号分隔文件

如果是通过select into outfile导出的符号分隔文件，可以使用load data infile通过相同的参数来加载。也可以使用mysqlimport，这是load data infile的一个包装。

使用load data infiel有一个好的优化技巧，load data file必须从文本文件中读取，因此，如果是压缩文件很多人会在加载前先解压缩，这是非常慢的磁盘密集型的操作。可以使用官道。

#### 基于时间点的恢复

对于MySQL做基于时间点的恢复常见的方法是还原最近一次全备份，然后从那个时间点开始重放二进制日志，就可以恢复到任何希望的时间点。甚至可以不太费力的恢复单个数据库。

最主要的缺点是二进制日志重放可能会是一个很慢的过程。它大体上等同于复制。


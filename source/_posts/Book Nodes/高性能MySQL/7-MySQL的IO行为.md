---
title: MySQL的IO行为

categories: 

- MySQL

tags: 

- MySQL
date: 2020-12-26 17:45:58
---


## MySQL的IO行为
____

innodb不仅允许控制怎么恢复，还允许控制怎么打开和刷新数据，这会对恢复和整体性能产生巨大的影响。尽管可以影响它的行为，innodb的恢复流程实际上是自动的，并且经常在innodb启动时运行。撇开恢复并假设innodb没有崩溃或者出错，innodb依然有很多需要配置的地方。它有一系列复杂的缓存和文件设计可以提升性能，以及保证ACID特性，并且每一部分都是可配置的。

#### innodb 事务日志

innodb使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机IO。innodb假设是用的是常规磁盘，随机IO比循序IO要昂贵得多,因为一个IO请求需要时间把磁头移动到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。

innodb用日志吧随机IO变成顺序IO，一旦日志安全写到磁盘，事务就持久化了，即使变更还没写到数据文件。如果一些糟糕的事情发生，比如断电，innodb可以重放日志并且回复已经提交的事务。

当然，innodb最后还是必须把变更写到数据文件，因为日志有固定的大小。innodb的日志是环形方式写的：当写道日志的尾部，会重新跳转到开头继续写，但不会覆盖还没有应用到数据文件的日志记录，因为这样做会清除掉已提交事务的唯一持久化记录。

innodb使用一个后台线程智能地书信这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。实际上，事务日志把数据文件的随机IO转换为几乎顺序的日志文件和数据文件IO，把刷新操作转移到后台使查询可以更快完成，并且缓和查询高峰时IO系统的压力。

整体的日志文件大小受控于innodo_log_file_size和innodb_log_files_in_group两个参数，这对写性能非常重要。日志文件的总大小是每个文件的大小之和。默认情况下，只有两个5MB的文件,总共10MB，这对于高性能工作来说太小了。至少需要几百M，甚至上G的日志文件.

innodb使用多个文件作为一组循环日志.通常不需要修改默认的日志数量,只修改每个日志文件的大小即可.要修改日志文件大小,需要完全关闭MySQL,将旧的日志文件转移到其他地方保存,重新配置参数,然后重启.一定要确保MySQL干净地关闭了,或者还有日志文件可以保证需要应用到数据文件的事务记录,否则数据库就无法恢复了.当重启副武器的时候,查看MySQL的错误日志.再重启成功后,才能删除就的日志文件.

日志文件大小和日志缓存。要确定立项的日志文件大小，必须权衡正常数据变更的开销和崩溃恢复需要的时间。如果日志太小，innodb将必须做更多的检查点，导致更多的日志写。在极个别情况下，写语句可能被拖累，在日志没有空间继续写入前，必须等待变更被应用到数据文件。另一方面，如果日志太大了，在崩溃恢复时innodb可能不得不做大量的工作。这可能极大地增加恢复时间，尽管这个处理在新的MySQL版本中已经改善跟多。

数据大小和访问模式也将影响恢复时间。假设有一个1TB的数据和16GB的缓冲池，并且全部日志大小是128MB。如果缓冲池里有很多葬爷，并且它们均匀分布在1TB数据中，崩溃后恢复将需要相当长一段时间。innodb必须从头到尾扫描日志，仔细检查数据文件，如果需要还要应用变更到数据文件。这是很庞大的读写操作！另一方面，如果变更是局部的，就是说，如果只有几百MB数据被频繁地变更，恢复可能就很快，即使数据和日志文件很大。恢复时间也依赖于普通修改操作的大小，这根数据行的平均长度有关系。较短的行使得更多的修改可以放在同样的日志中，所以innodb可能必须在恢复时重放更多修改操作。

当innodb变更任何数据时，会写一条变更记录到内存日志缓冲区。再缓冲满的时候，事务提交的时候，或者每一秒钟，innodb就会刷写缓冲区的内容到磁盘日志文件，无论上述三个条件哪个先到达。如果有大事务，增加日志缓冲区大小可以帮助减少IO。innodb_log_buffer_size可以控制日志缓冲区的大小。

通常不需要吧日志缓冲区设置的非常大。推荐的范围是1-8m，一般来说足够了，除非要写很多大的blob记录。相对于innodb的普通数据，日志条目是非常紧凑的。它们不是基于页的，所以不会浪费空间来一次存储整个页。innodb也使得日志条目尽可能地短。有时甚至会保存为函数号和C函数的参数。

较大的日志缓冲区在某些情况下也是有好处的：可以减少缓冲区中空间分配的争用。当配置一台有大内存的服务器时，有时简单地分配32-128m的日志缓冲，因为花费这么点相对而言比较小的内存并没有什么不好，还可以帮助避免压力平津。

可以通过检查**show innodb status**的输出中log部分来监控innodb的日志和日志缓冲区的IO性能，通过观察innodb_os_log_written状态变量来查看innodb对日志文件写出了多少数据。一个好用的经验法则是：**查看10-100秒间隔的数字，然后记录峰值。可以用这个来判断日志缓冲是否设置的正好。例如，若看到峰值是美妙写100k数据到日志，那么1M的日志缓冲可能足够了。也可以使用这个衡量标准来决定日志文件设置多大会比较好。如果峰值是100k/s，那么256m的日志文件足够存储至少2560秒的日志记录。这看起来足够了。作为一个经验法则，日志文件的全部大小，应该足够容纳服务器一个小时的活动内容。**

innodb怎样刷新日志缓冲。当innodb把日志缓冲刷新到磁盘日志文件时，会先使用一个mutex锁住缓冲区，刷新到所需要的位置，然后移动剩下的条目到缓冲区的前面，当mutex释放时，可能有炒股go一个事务已经准备好刷新七日织记录。innodb有一个group commit功能，可以在一个IO操作内提交多个事务,但是在MySQL5 中打开二进制日志时,这个功能就不能用了.

日志缓冲必须被刷新到持久化存储，以确保提交的事务完全被持久化了。如果和持久相比更在乎性能，可以修改innodb_flush_log_at_trx_commit变量来控制日志缓冲刷新的频繁程度。可能设置如下

- 0，把日志缓冲写到日志文件，并且每秒钟刷新一次，但是事务提交时不做任何事。
- 1，将日志缓冲写到日志文件，并且每次事务提交刷新到持久化存储。这是默认的设置，该设置能保证不会丢失任何已经提交的事务，除非磁盘或者操作系统是未刷新。
- 2，每次提交时把日志缓冲写到日志文件，但是并不刷新。innodb每秒钟做一次刷新。0和2的最重要的不同是，如果MySQL进程挂了，2不会丢失任事务。如果整个服务器挂了或者断电了，则还是可能会丢失一些事务。

了解“把日志缓冲写到日志文件”和“把日志刷新到持久化存储”之间的不同是很重要的。在大部分操作系统中，把缓冲写到日志知识简单的把数据从innodb的内存缓冲转移到了操作系统的缓冲，也是在内存里，并没有真的把数据写到了持久化存储。

因此，如果MySQL崩溃了或者电源断电了，设置0和2通常会导致最多一秒的数据丢失，因为数据只可能存在操作系统的缓存。我们说通常，因为不论如何innodb会每秒尝试刷新日志文件到磁盘，但是在一些场景下也可鞥丢失超过一秒的食物，例如当刷新没延迟了。

与此相反，把日志刷新到持久化存储意味着innodb请求操作系统把数据刷出缓存，并且确认写到磁盘了。这是一个阻塞IO的调用，知道数据被完全写回才会完成。因为写数据到磁盘比较慢，当innodb_flush_log_at_trx_commit被设置为1时，可能明显地降低innodb每秒可以提交的事务数，今天的告诉驱动器可能每秒只能执行一两百个磁盘事务，受限于磁盘旋转速度和寻址时间。

有时磁盘控制器或者操作系统假装做了刷新，其实知识吧数据放到了另一个缓存，例如磁盘自己的缓存。这更快但是很危险，因为如果驱动器断电，数据依然可能丢失。这甚至比设置innodb_flush_log_at_trx_commit为不为1的值更糟糕，因为只可能导致数据损坏，不仅仅是丢失事务。

设置innodb_flush_log_at_trx_commit为不为1的值坑会导致丢失事务。然而，如果不在意持久性，那么设置为其他的值也是有用的。也许你知识想拥有innodb的其他一些功能，例如聚簇索引，防治数据损坏，以及行锁。但仅仅因为性能原因用innodb替换myisam 的情况也并不少见。

**高性能事务处理需要的最佳配置是吧innodb_flush_log_at_trx_commit设置为1且把日志文件放到一个有电池保护的写缓存的RAID卷中。这兼顾了速度和安全**。事实上，我们敢说任何希望能扛过高负荷工作负载的产品数据库服务器，都需要有这种类型的硬件。

##### innodb怎样打开和刷新日志以及数据文件

使用innodb_flush_method选项可以配置innodb如果跟文件系统相互作用。从名字来看，会以为只能影响innodb怎么写数据，实际上影响了innodb怎么读数据。windows和非windwos的操作系统对这个选项的值是互斥的：async_unbuffered、unbuffered和normal之鞥呢在windows下使用，而且windows下不能使用其他的值。在windows下默认值是unbuffered，其他操作系统都是fdatasync。

**这是一个有点那一理解的选项，因为它既影响日志文件，业形象数据文件，而且有时候对不同类型的文件的处理也不一样。如果有一个选项来配置日志，另一个选项来配置数据文件，这样最好了，但实际上它们混合在同一个配置中。**

下面是一些可能的值

- fdatasync

    这在非windows系统上是默认值：innodb使用fsync()来刷新数据和日志文件。innobd通常用fsync代替fdatasync，即使这个值似乎表达的是相反的意思。fdatasync和fsync相似，但是只刷新文件的数据，而不包括元数据。因此，fsync会导致更多的IO，然而innodb的开发者都很保守，他们发现某些场景下fdatasync会导致数据损坏。innodb决定了哪些方法可以更安全地使用，有一些是编译时设置的，也有一些事运行时设置的。它使用尽可能最快的安全方法。

    使用fsync的缺点是操作系统至少会在自己的缓存中缓冲一些数据。理论上，这种双重缓冲室浪费的，因为innodb管理自己的缓冲比操作系统能做的更加智能。然而，最后的影响跟操作系统和文件系统非常相关。如果能让文件系统做更智能的IO调度和批量操作,双重缓冲可能并不是坏事.有的文件系统和操作系统可以积累写操作合并执行,通过对IO重新排序来提升效率，或者并发写如多个设备。它们也可能做预读优化，例如，若连续请求了几个顺序的块，它会通知硬盘预读下一个块。

    有时这些优化有帮助，有时么有。如果好奇fsync会做哪些具体的事，可以阅读系统的帮助手册。

    innodb_per_file_table选项会导致每个文件独立地做fsync，这意味着写多个表不能合并到一个IO操作。这可能导致innodb执行更多的fsync操作。

- 0_DIRECT

    innodb对数据文件使用0_DIRECT标记或者directio函数，这依赖于操作系统。这个设置并不影响日志文件并且不是在所有的类unix系统上都有效。但是linux是支持的。不像0_DSYNC标记，，它会同时影响读和写。

    这个设置依然使用fsync来刷新文件到磁盘，但是会通知操作系统不要缓存数据，也不要预读。这个选项**完全关闭了操作系统缓存，并且使得所有的读和写都直接通过存储设备，避免了双重缓冲。

    在大部分系统上，这个实现用fcntl调用来设置文件描述符的0_DIRECT标记，所以可以阅读fcntl的手册了解细节。

    如果RAID卡支持预读，这个设置不会关闭RAID卡的预读。这个设置只能关闭操作系统和文件系统的预读。

    如果使用0_DIRECT选项，通常需要带有写缓存的RAID卡，并且设置为write-back策略，因为这是典型的唯一能保持好性能的方法。当innodb和实际存储设备之间没有缓冲时使用0_DIRECT，例如当RAID卡没有写缓存时，可能导致严重的性能下降。现在有个多个写线程，问题小一点，但通常还有问题。MySQL5.5提供了更原生异步IO。

    这个选项可能导致服务器预热时间变长，特别是操作系统的缓存很大的时候。也可能导致小容量的缓冲池比缓冲IO方法操作要慢得多。这是因为操作系统不会通过保持更多数据在自己的缓存中来帮助提升性能。如果需要的数据不再缓冲池，innodb将不得不从磁盘读取。这个选项不会对innodb_per_file_table产生任何额外的损失。相反，如果不用innodb_per_file_table，当使用0_DIRECT时，可能由于一些顺序IO而遭受性能损失。这种情况的发生是因为一些文件系统的每个inode都有一个mutex。当在这些文件系统上使用0_DIRECT时，确实需要打开innodb_file_per_table

- ALL_0_DIRECT

    这个选项在percona server 和 mariadb中可用。它使得服务器再打开日志文件时，也能使用标准MySQL中打开数据文件的方式（0_DIRECT）

- 0_DSYNC
    
    这个选项使日志文件调用open函数时设置0_SYNC标记。它使得所有的写 同步。也就是说，只有数据写到磁盘后，写操作才返回。这个选项不影响数据文件。0_SYNC标记和0_DIRECT标记的不同之处在于，0_SYNC没有禁用操作系统层的缓存。因此，它没有避免双重缓冲，而且它没有使写操作直接操作到磁盘。使用了0_SYNC标记，在缓存中写数据，然后发送到磁盘。

    使用0_SYNC标记做同步写操作，听起来可能跟fsync做的事情非常相似，但是它们两个的实现无论在操作系统层是硬件层都非常不同。使用了0_SYNC标记后，操作系统可能把使用同步IO标记下传给硬件层，告诉设备不要使用缓存，另一方面，fsync告诉操作系统把修改过的缓冲数据刷写到设备上，如果设备支持，紧接着回传第一个指令给设备刷星他自己的缓存，所以，毫无疑问，数据肯定记录在了物理媒介上。另一个不同是，使用了0_SYNC的话，每个write或pwrite操作都会在函数完成之前把数据同步到磁盘，完成前函数调用是阻塞的。相对来看，不用0_SYNC标记的写入调用fsync允许写操作积累在缓存，然后一次性刷新所有的数据。

    这个选项设置0_SYNC标记，不是0_DSYNC标记，因为innodb开发者发现了0_DSYNC的bug。0_SYNC和0_DSYNC类似于fsync和fdatasync：0_SYNC同时同步数据和元数据，但是0_DSYNC只同步数据。

- async_unbuffered

    这是windows下的默认值。这个选项让innodb对大部分写使用没有缓冲的IO，里外是当innodb_flush_log_at_trx_commit设置为2的时候，对日志文件使用缓冲IO.

    这个选项使得innodb在windows 2000 ,xp 以及更新版本中对数据读写都使用操作系统的原生异步IO。

- unbuffered

    只对windows有效。这个选项与async_unbuffered类似，但是不使用原生异步IO。

- normal

    只对windows有效。这个选项让innodb不要使用原生异步IO或者无缓冲IO。

- nosync和littlesync

    只为开发使用

如果使用类unix操作系统并且RAID控制器带有电池保护的写缓存，建议使用0_DIRECT。如果不是这样，默认值或者0_DIRECT都可能是最好的选择。

#### InnoDB表空间
____

innodb把数据保存在表空间内，本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。innodb用表空间实现很多功能，并不只是存储表和索引。它还保存了回滚日志、插入缓冲、双写换成，以及其他内部数据结构。

配置表空间。通过innodo_data_file_path配置可以定制表空间文件。这些文件都放在innodb_data_home_dir指定的目录下，如：

```mysql
innodb_data_home_dir = /var/lib/mysql
innodb_data_file_path = ibdata1:1G,ibdata2:1G,ibdata3:1G
```

---
title: MySQL高级特性

categories: 

- MySQL

tags: 

- MySQL
date: 2020年12月20日18:29:59
---

1. 分区表

    对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。所以分区对于SQL层爱说是一个完全封装底层实现的黑盒，对应用是透明的，但是从底层的文件系统来看就很容易发现，每一个分区表都有一个使用#分割命名的表空间。

    MySQL在创建表时使用PARTITION BY 子句定义每个分区存放的数据。在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区——只需要查找包含需要数据的分区就可以了。

    分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中。这样做科技将相关的数据存放在一起，另外，如果想一次批量删除整个分区的数据也会变得方面。下面的场景中，分区可以起到非常大的作用。

    - 表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。
    - 分区表的数据更容易维护。例如，想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作
    - 分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备
    - 可以使用分区表来避免某些特殊的瓶颈，例如innodb的单个索引的互斥访问、ext3文件系统的inode锁竞争等。
    - 如果需要，还可以备份和恢复独立的分区，这在非常大的数据集下的场景下效果非常好

    分区的一些限制：

    - 一个表最多只能有1024个分区
    - MySQL5.1中，分区表达式必须是证书买或者是返回整数的表达式。在MySQL5.5中，某些场景汇总可以直接使用列来进行分区。
    - 如果分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
    - 分区表中无法使用外键约束


1.1 分区表的原理

分区表由多个相关的底层表实现，这些底层表由句柄对（Handler object）表示，所以我们也可以直接访问各分区。存储引擎管理分区的各个底层表和管理普通表一样（有的底层表都必须使用相同的存储引擎），分区表的索引知在各个底层表上各自加上一个完全相同的索引。
分区表操作的逻辑如下：

**select查询**
当查询一个分区表的时候，分区层先打开并锁住所有的底表，优化器先判断是否可以过滤部分分区，然后在调用对应存储引擎接口访问各个分区的数据。

**insert操作**
当写入一条记录时，分区层先打开并锁住所有的底层表，然确定那个分区接收这条记录，再将记录写入对应底层表。

**delete操作**
当写入一条记录时，分区层先打开并锁住所有的底层表，然确定数据对应的分区，最后对底层表进行删除操

**update操作**
当写入一条记录时，分区层先打开并锁住所有的底层表MySQL先确定需要更新的记录在哪个分区，然后取出数据并新，再判断更新后的数据应该放在哪个分区，最后对底层表行写入操作，并对原数据所在的底层表进行删除操作。

有些操作是支持过滤的。例如，当删除一条记录时，MySQL要先找到这条记录，如果where条件恰好和分区表达式匹配就可以将所有不包含这条记录的分区都过滤掉。针对udpat语句同样有效。如果是insert操作，则本身就是知名中一分区，其他分区都会被过滤掉。MySQL先确定这条记录属于个分区，然后再将记录写入对应的底层分区表，无需对任何他分区进行操作。

如果存储引擎能够自己实现行级锁，则会在分区层释放对应表锁。

1.2 分区表的类型

支持多种分区表，最多的是根据范围进行分区，每个分区存储落在某个范围的记录，分区表达式可以是列，也可以使包含列的表达式，例如：

```sql
create table sales(
    id int primary key not null auto_increment,
    order_date datetime not null
) engine=InnoDB partition by RANGE (year(order_date))(
    partition p_2010 values less than (2010),
    partition p_2011 values less than (2011),
    partition p_2012 values less than (2012),
    partition P_catchall values less than MAXVALUE 
    );
```

partition分区子句中可以使用各种函数。但是有一个要求，表达式返回的值要是一个确定的正数，而不能是一个常数。根据时间间隔进行分区，是一种很常见的分区方式。

MySQL还支持键值、哈希和列表分区，这其中还有些支持子分区，不生产环境中很少见到。

1.3 如何使用分区表

假设我们希望从一个非常大的表中查询出一段时间的记录，而这个表中包含了很多年的历史数据，数据是按照时间排序的，例如，希望查询最近几个月的数据，这大约有10亿条记录，而原表中有10TB的数据，这个数据量远大于内存，并确实用的是传统硬盘。

首先很肯定：**因为数据量巨大，肯定不嗯给你在每次查询的时候都扫描全表**。考虑到索引在空间和维护上的消耗，也不希望使用索引。即使真的使用索引，会发现数据并不是按照想要的方式聚集的，而且会有大量的碎片产生，最终会导致一个查询产生成千上万的随机IO，应用程序也随之僵死。情况好一点的时候，也许可以通过一两个索引结局一些问题。不过多数情况下，索引不会有任何作用。这时候只有两条路可选：**让所有的查询都只在数据表上做顺序扫描，或者将数据表和索引全部缓存在内存里。

**在数据量超大的时候，b-tree索引就无法起作用了**。除非是索引覆盖查询，否则数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，如果数据量巨大，者将产生大量随机IO，随之，数据库的响应时间将大刀不可接受的程度。另外，索引维护（磁盘空间，IO操作）的代价也非常高。

分区可以当做索引的最初形态，以代价非常小的方式定位到需要的数据在哪一片区域，在这片区域中，可以做顺序扫描，可以做索引，还可以将数据全都缓存到内存，等等。因为分区无需额外的数据结构记录每个分区有哪些数据，分区不需要正确定位每套数据的位置，也就无需额外的数据结构，所以代价非常低，只需要一个简单的表达式就可以表达每个分区存放的是什么数据。

为了保证大数据量的可扩展性，一般有下面两个策略：

- 全量扫描数据，不要任何索引

    可以使用简单的分区方式存放表，不要任何索引，根据分区的规则大致定位需要的数据位置。只要能使用where条件，将需要的数据限制在少数分区中，则效率是很高的。当然，也需要做一些简单的运算保证查询的响应时间能够满足需求。使用该策略假设不用将数据完全放入到内存中，同时还假设需要的数据全都在硬盘上，因为内存相对很小，数据很快会被挤出内存，索引缓存起不了任何作用。这个策略适用于已正常的方式访问大量数据的时候。警告：必须将查询需要扫描的分区个数限制在一个很小的数量。

- 索引数据，并分离热点

    如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效地使用缓存。

1.4 什么情况下会出问题

- null值会使分区过滤无效

    分区表达式不能为null，如果为null或者是一个非法值的时候，记录都会被存放到第一个分区，然后MySQL会同时检查两个分区。5.5以后可以直接基于列进行分区。

- 分区列和索引不匹配

    如果定义的索引和分区列不匹配，会导致查询无法进行分区锅炉工。假设在列a上定义了索引，而在列b上进行分区。因为每个分区都有其独立的索引，所以扫描列上的索引就需要扫描每一个分区对应的宿营。如果每个分区内对应缩影的飞叶子节点都会在内存中，那么扫描的速度还可以接收，如果能跳过某些分区索引当然会更好。要避免这个问题，应该避免简历和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。

    听起来避免这个问题很简单，不过有时候也会遇到一些意想不到的问题。例如，在一个关联查询中，分区表在管理按顺序中是第二个表，并且关联使用的索引和分区条件不匹配。那么关联时对第一个IE表符合条件的每一行，都需要访问并搜索第二个表的所有分区。

- 选择分区的成本可能很高

    不同类型分区的实现方式不同，性能也不同。尤其是范围分区，对于回答这一行属于哪个分区、这些符合查询条件的分区的行在哪些分区这样的问题的成本可能会非常高，因为服务器需要扫描所有的分区定义的列表来找到正确的答案。类似这样的线性搜索的效率不高，所以随着分区数的增长，成本会越来越高。

    示例：按行写入大量数据的时候，每写入一行数据到范围分区的表时，都需要扫描分区定义列表来找到合适的目标分区。可以通过限制分区的数量来缓解此问题，大多数系统来说，100个左右的分区毫无问题。

- 打开并锁住所有底层表的成本可能很高

    当查询访问分区表的时候，MySQL需要打开并锁柱所有的底层表，这是分区表的另一个开销。这个开销也在分区过滤之前发生，所以无法通过分区过滤降低此开销，并且该开销也和分区类型无关，会影响所有的查询。这一点对一些本身操作非常快的查询，比如根据主键查找单行，会带来明显的额外开销。可以用批量操作的方式来降低单个操作的此类开销，比如使用批量插入或者load data infile，一次删除多行数据等等，淡然爱过同时还是要限制分区的个数

- 维护分区的成本可能很高

    某些分区维护操作的速度会非常快，例如新增或删除分区。而有些操作，例如重组分区或者类似alter语句的操作：这类操作需要复制数据。重组分区的原理与alter类似，县创建一个临时的分区，然后将数据复制到其中，随后在删除原分区。

分区不是”银弹”，下面是目前分区实现中的一些其他限制：

- 所有分区都必须使用相同的存储引擎
- 分区函数中可以使用的函数和表达式也有一些限制
- 某些存储引擎不支持分区
- 对于myisam的分区表，不能使用load index info cache操作
- 对于myisam的表，使用分区表时需要打开更多的文件描述符。虽然看起来是一个表，但是背后有很多独立的分区，每一个分区对于存储引擎来说都是一个独立的表。这样即使分区表只占用一个表缓存条目，文件描述符还是需要多个。因此，即使已经配置了合适的表缓存，以确保不会超过操作系统的单个进程可以打开的文件描述符的个数，但对于分区表而言，还是会出现文件描述符限制的问题。

1.5 查询优化

对于分区表来说，很重要的一点就是要在where条件中带入分区列。这样可以让优化器能够过滤掉无需访问的分区。如果没有这些条件，MySQL就需要让对应存储引擎访问这个表的所有分区，如果表非常大的话，就肯能会非常慢

1.6 合并表

不写了， 未来会被删除


2. 视图

```sql
create view Oceania as select * from country where Continent = 'Oceania' with check option ;
```

实现视图最简单的方法就是将select语句的结果存放到临时表中。当需要访问视图的时候，直接访问这个临时表就可以了，看下面的查询

```sql
select * from Oceania where Name = 'Australia';
```

下面是使用临时表来模拟视图的方法，这里临时表的名字是为演示用的：

```sql
create temporary table TMP_Oceania_123 as select * from country where Continent = 'Oceania';

select code,name from TMP_Oceania_123 where Name = 'Australia';
```

这样做会有明显的性能问题，优化器也很难优化在这个临时表上的查询。实现视图更好的方法是，重写含有视图的查询，将视图的定义SQL直接包含进查询的SQL中：

```sql
select code,name from country where Continent = 'Oceania' and Name = 'Australia';
```

MySQL可以使用这两种办法的任何一种来处理视图。这两种算法分别被称为**合并算法（Merge）和临时表算法（Temptable）**，如果可能，会尽可能的使用合并算法。MySQL甚至可以嵌套地定义视图，也就是在一个视图上再定义另一个视图。可以再explain extended 之后使用 show warnings来查看使用视图的查询重写后的结果。

如果视图中包含group by 、 distinct、任何聚合函数、union、子查询等，只要无法在原表记录和视图记录中建立一一映射的场景中，MySQL都将使用临时表算法来实现视图。如果想确定MySQL到底是使用合并算法还是临时表算法，可以explain一条针对视图的简单查询：

```sql
explain select * from TMP_Oceania_123;
```

如果这里的select_type为DERIVED，说明该视图是采用临时表算法实现的。视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。例如：

```sql
create algorithm = temptable view v1 as select * from actor;
explain select * from v1;
+--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+
|id|select_type|table     |partitions|type|possible_keys|key |key_len|ref |rows|filtered|Extra|
+--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+
|1 |PRIMARY    |<derived2>|NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |
|2 |DERIVED    |actor     |NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |
+--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+
```

实现该视图的SQL本身并不需要临时表，但基于盖世兔无论执行什么样的查询，视图都会生成一个临时表。

2.1 可更新视图

可更新视图（updatable view）是指可以通过更新这个视图来更新视图涉及的相关表。只要制定了合适的条件，就可以更新、删除甚至向视图中写入数据。例如：

```sql
update oceanic set population = population *1.1 where name ='Australia'
```

如果视图定义中包含了group by , union , 聚合函数，以及其他一些特殊情况，就不能被更新了。更新视图的查询也可以是一个关联语句，但是有一个限制，被更新的列必须来自同一个表中。另外，所有使用临时表算法实现的视图都无法被更新。

2.2 视图对性能的影响，总的来说是不推荐使用

2.3 视图的限制

MySQL不支持物化视图，也不支持在视图中创建索引。也无法通过 show create view 查看视图创建的原始SQL语句

3. 外键约束

innodb是MySQL中唯一支持外间的内置存储引擎。

使用外键是有成本的。比如外键通常都要求每次在修改数据时都要在另外一张表中多执行一次查找操作。虽然innodb强制外键使用索引，但还是无法消除这种约束检查的开销。如果外键列的选择性很低，泽会导致一个非常大且选择性很低的索引。例如，在一个非常大的表上有status列，并希望限制这个状态列的取值，如果该列只能取三个值，虽然这个列本身很小，但是如果主键很大，那么这个索引就会很大，而且这个所引出了做这个外键限制，也没有其他任何的作用。

不过，在某些场景下，外键会提升一些性能。如果想确保两个相关表始终有一致的数据，那么使用外键比在应用程序中检查一致性的性能要高得多，此外，外键在相关数据的删除和更欣赏，也比在应用中维护要更高效，不过，外键维护操作时逐行进行的，所以这样的更新会比批量删除和更新要慢一些。

外键约束使得查询需要额外访问一些别的表，这也意味着需要额外的锁。如果向子表中写入一条记录，外键约束会让innodb检查对应的父表的记录，也就需要对父表对应记录进行枷锁操作，来确保这条记录不会在这个事务完成之时就被删除了。这会导致额外的锁等待，甚至会导致一些死锁。因为没有直接访问这些表，所以这类死锁问题往往难以排查。

如果只是用外键做约束，那么通常在应用程序里实现约束会更好。外键会带来很大的额外消耗，这里没有相关的基准测试的数据，不过有很多案例，发现外键约束就是瓶颈所在，删除外键后性能立即大幅提升。

4. 在MySQL内部存储代码

优点有：
- 它在服务器内部执行，离数据最近，另外在服务器上执行还可以节省贷款和网络延迟。
- 这是一种代码重用。可以方便地统一业务规则，保证某些行为总是一致，所以也可以为应用提供一定的安全性
- 它可以简化代码的维护和版本更新
- 他可以帮助提升安全，比如提供更细粒度的权限控制。一个常见的例子是银行用于转移资金的存储过程：这个存储过程可以在一个事务中完成资金转移和记录用于审计的日志。应用程序也可以通过存储过程的接口访问那些没有权限的表。
- 服务器端可以缓存存储过程的执行计划，这对于需要反复调用的过程，会大大降低消耗。
- 因为是在服务器端部署的，所以备份，维护都可以在服务器端完成。索引存储程序的维护工作会很简单。它没有什么外部依赖，例如，不依赖任何Perl包和其他不想在服务器上部署的外部软件
- 他可以在应用开发和数据库开发人员之间更好的分工。不过最好是由数据库专家来开发存储过程，因为不是每个应用开发人员都能写出高效的SQL查询。

缺点有：
- MySQL本身没有提供好用的开发和调试工具，所以写起来要难一些
- 存储代码效率要稍微差一些，使用的函数有限，所以也很难编写复杂的字符串维护功能，也很难实现太复杂的逻辑
- 存储代码可能会给应用程序代码的部署带来额外的复杂性。原本只需要部署应用代码和库表结构变更，现在还需要额外地部署MySQL内部的存储代码
- 因为存储程序都部署在服务器内，所以可能有安全隐患。如果将非标准的加密功能放在存储程序中，那么若是数据库被攻破，数据也就泄露了。但是若将加密函数放在应用程序代码中，那么攻击者必须同时攻破程序和数据库才能获得数据
- 存储过程会给数据库服务器增加额外的压力，而数据库服务器的扩展性相比应用服务器要差很多
- MySQL并没有什么选项可以控制存储程序的资源消耗，所以在存储过程中的一个小错误，可能直接把服务器拖死
- 存储代码在MySQL中的实现也有很多限制，执行计划缓存是连接级别的，游标的物化和临时表相同，在MySQL5.5版本之前，异常处理也非常困难，等等。
- 调试MySQL的存储过程是一件很困那的事情。
- 它和基于语句的二进制日志复制合作的并不好。在基于语句的复制中，使用存储代码有很多的坑

4.1 存储过程和函数

存储过程在替代很多小查询的时候要快很多，因为查询很小，相对于查询执行的成本，解析和网络开销就变得非常明显。存储过程无需网络通信开销、解析开销和优化器开销等。

4.2 触发器

可以减少客户端和服务器之间的通信。需要注意一下几点

- 对每一个表的每一个事件，最多只能定义一个触发器（也就是说，不能再after insert 上定义两个触发器）
- MySQL只支持基于行的触发，也就是受，触发器始终是针对一条记录的，而不是针对整个SQL语句的。如果变更的数据集非常大的话，效率会很低。
- 触发器可以掩盖服务器背后的工作，一个简单的SQL语句背后，因为触发器，可能包含了很多看不见的工作。例如，触发器可能会更新另一个相关表，那么这个触发器会让这条SQL影响的记录数翻一倍
- 触发器的问题也很难排查，如果某个性能问题和触发器相关，会很难分析和定位。
- 触发器可能导致死锁和锁等待。如果触发器失败，那么原来的SQL语句也会失败。如果没有意识到这其中是触发器在搞鬼，那么很难理解服务器抛出的错误代码时什么意思

如果只考虑性能，那么MySQL触发器的实现中，对服务器限制最大的就是它的基于行的触发设置。因为性能的原因，很多时候无法使用触发器来维护汇总和缓存表。使用触发器而不是批量更新的一个原因就是，使用触发器可以保证数据总是一致的。

innodb的触发器是在同一个事务中完成的，所以它们的操作是原子的，原操作和触发器操作会同时失败或者成功。不过，如果再innodb表上建立触发器去检查数据的一致性，要特别小心MVCC，稍不小心，可能会获得错误的结果。假设，想实现外键约束，但是不打算使用innodb的外键约束，打算编写一个before insert触发器来检查写入的数据对应列在另一个表中是存在的，但是若你在触发器中没有使用select for update，那么并发的更新语句可能会立刻更新对应记录，导致数据不一致。

5. 游标

9. 字符集和校对

11. 分布式事务

12. 查询缓存
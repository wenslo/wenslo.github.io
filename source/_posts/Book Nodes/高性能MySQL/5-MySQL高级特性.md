---
title: MySQL高级特性

categories: 

- MySQL

tags: 

- MySQL
date: 2020年12月20日18:29:59
---

1. 分区表

    对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。所以分区对于SQL层爱说是一个完全封装底层实现的黑盒，对应用是透明的，但是从底层的文件系统来看就很容易发现，每一个分区表都有一个使用#分割命名的表空间。

    MySQL在创建表时使用PARTITION BY 子句定义每个分区存放的数据。在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区——只需要查找包含需要数据的分区就可以了。

    分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中。这样做科技将相关的数据存放在一起，另外，如果想一次批量删除整个分区的数据也会变得方面。下面的场景中，分区可以起到非常大的作用。

    - 表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。
    - 分区表的数据更容易维护。例如，想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作
    - 分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备
    - 可以使用分区表来避免某些特殊的瓶颈，例如innodb的单个索引的互斥访问、ext3文件系统的inode锁竞争等。
    - 如果需要，还可以备份和恢复独立的分区，这在非常大的数据集下的场景下效果非常好

    分区的一些限制：

    - 一个表最多只能有1024个分区
    - MySQL5.1中，分区表达式必须是证书买或者是返回整数的表达式。在MySQL5.5中，某些场景汇总可以直接使用列来进行分区。
    - 如果分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
    - 分区表中无法使用外键约束


1.1 分区表的原理

分区表由多个相关的底层表实现，这些底层表由句柄对（Handler object）表示，所以我们也可以直接访问各分区。存储引擎管理分区的各个底层表和管理普通表一样（有的底层表都必须使用相同的存储引擎），分区表的索引知在各个底层表上各自加上一个完全相同的索引。
分区表操作的逻辑如下：

**select查询**
当查询一个分区表的时候，分区层先打开并锁住所有的底表，优化器先判断是否可以过滤部分分区，然后在调用对应存储引擎接口访问各个分区的数据。

**insert操作**
当写入一条记录时，分区层先打开并锁住所有的底层表，然确定那个分区接收这条记录，再将记录写入对应底层表。

**delete操作**
当写入一条记录时，分区层先打开并锁住所有的底层表，然确定数据对应的分区，最后对底层表进行删除操

**update操作**
当写入一条记录时，分区层先打开并锁住所有的底层表MySQL先确定需要更新的记录在哪个分区，然后取出数据并新，再判断更新后的数据应该放在哪个分区，最后对底层表行写入操作，并对原数据所在的底层表进行删除操作。

有些操作是支持过滤的。例如，当删除一条记录时，MySQL要先找到这条记录，如果where条件恰好和分区表达式匹配就可以将所有不包含这条记录的分区都过滤掉。针对udpat语句同样有效。如果是insert操作，则本身就是知名中一分区，其他分区都会被过滤掉。MySQL先确定这条记录属于个分区，然后再将记录写入对应的底层分区表，无需对任何他分区进行操作。

如果存储引擎能够自己实现行级锁，则会在分区层释放对应表锁。

1.2 分区表的类型

支持多种分区表，最多的是根据范围进行分区，每个分区存储落在某个范围的记录，分区表达式可以是列，也可以使包含列的表达式，例如：

```sql
create table sales(
    id int primary key not null auto_increment,
    order_date datetime not null
) engine=InnoDB partition by RANGE (year(order_date))(
    partition p_2010 values less than (2010),
    partition p_2011 values less than (2011),
    partition p_2012 values less than (2012),
    partition P_catchall values less than MAXVALUE 
    );
```

partition分区子句中可以使用各种函数。但是有一个要求，表达式返回的值要是一个确定的正数，而不能是一个常数。根据时间间隔进行分区，是一种很常见的分区方式。

MySQL还支持键值、哈希和列表分区，这其中还有些支持子分区，不生产环境中很少见到。

1.3 如何使用分区表

假设我们希望从一个非常大的表中查询出一段时间的记录，而这个表中包含了很多年的历史数据，数据是按照时间排序的，例如，希望查询最近几个月的数据，这大约有10亿条记录，而原表中有10TB的数据，这个数据量远大于内存，并确实用的是传统硬盘。

首先很肯定：**因为数据量巨大，肯定不嗯给你在每次查询的时候都扫描全表**。考虑到索引在空间和维护上的消耗，也不希望使用索引。即使真的使用索引，会发现数据并不是按照想要的方式聚集的，而且会有大量的碎片产生，最终会导致一个查询产生成千上万的随机IO，应用程序也随之僵死。情况好一点的时候，也许可以通过一两个索引结局一些问题。不过多数情况下，索引不会有任何作用。这时候只有两条路可选：**让所有的查询都只在数据表上做顺序扫描，或者将数据表和索引全部缓存在内存里。

**在数据量超大的时候，b-tree索引就无法起作用了**。除非是索引覆盖查询，否则数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，如果数据量巨大，者将产生大量随机IO，随之，数据库的响应时间将大刀不可接受的程度。另外，索引维护（磁盘空间，IO操作）的代价也非常高。

分区可以当做索引的最初形态，以代价非常小的方式定位到需要的数据在哪一片区域，在这片区域中，可以做顺序扫描，可以做索引，还可以将数据全都缓存到内存，等等。因为分区无需额外的数据结构记录每个分区有哪些数据，分区不需要正确定位每套数据的位置，也就无需额外的数据结构，所以代价非常低，只需要一个简单的表达式就可以表达每个分区存放的是什么数据。

为了保证大数据量的可扩展性，一般有下面两个策略：

- 全量扫描数据，不要任何索引

    可以使用简单的分区方式存放表，不要任何索引，根据分区的规则大致定位需要的数据位置。只要能使用where条件，将需要的数据限制在少数分区中，则效率是很高的。当然，也需要做一些简单的运算保证查询的响应时间能够满足需求。使用该策略假设不用将数据完全放入到内存中，同时还假设需要的数据全都在硬盘上，因为内存相对很小，数据很快会被挤出内存，索引缓存起不了任何作用。这个策略适用于已正常的方式访问大量数据的时候。警告：必须将查询需要扫描的分区个数限制在一个很小的数量。

- 索引数据，并分离热点

    如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效地使用缓存。

1.4 什么情况下会出问题

- null值会使分区过滤无效

    分区表达式不能为null，如果为null或者是一个非法值的时候，记录都会被存放到第一个分区，然后MySQL会同时检查两个分区。5.5以后可以直接基于列进行分区。

- 分区列和索引不匹配

    如果定义的索引和分区列不匹配，会导致查询无法进行分区锅炉工。假设在列a上定义了索引，而在列b上进行分区。因为每个分区都有其独立的索引，所以扫描列上的索引就需要扫描每一个分区对应的宿营。如果每个分区内对应缩影的飞叶子节点都会在内存中，那么扫描的速度还可以接收，如果能跳过某些分区索引当然会更好。要避免这个问题，应该避免简历和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。

    听起来避免这个问题很简单，不过有时候也会遇到一些意想不到的问题。例如，在一个关联查询中，分区表在管理按顺序中是第二个表，并且关联使用的索引和分区条件不匹配。那么关联时对第一个IE表符合条件的每一行，都需要访问并搜索第二个表的所有分区。

- 选择分区的成本可能很高

    不同类型分区的实现方式不同，性能也不同。尤其是范围分区，对于回答这一行属于哪个分区、这些符合查询条件的分区的行在哪些分区这样的问题的成本可能会非常高，因为服务器需要扫描所有的分区定义的列表来找到正确的答案。类似这样的线性搜索的效率不高，所以随着分区数的增长，成本会越来越高。

    示例：按行写入大量数据的时候，每写入一行数据到范围分区的表时，都需要扫描分区定义列表来找到合适的目标分区。可以通过限制分区的数量来缓解此问题，大多数系统来说，100个左右的分区毫无问题。

- 打开并锁住所有底层表的成本可能很高

    当查询访问分区表的时候，MySQL需要打开并锁柱所有的底层表，这是分区表的另一个开销。这个开销也在分区过滤之前发生，所以无法通过分区过滤降低此开销，并且该开销也和分区类型无关，会影响所有的查询。这一点对一些本身操作非常快的查询，比如根据主键查找单行，会带来明显的额外开销。可以用批量操作的方式来降低单个操作的此类开销，比如使用批量插入或者load data infile，一次删除多行数据等等，淡然爱过同时还是要限制分区的个数

- 维护分区的成本可能很高

    某些分区维护操作的速度会非常快，例如新增或删除分区。而有些操作，例如重组分区或者类似alter语句的操作：这类操作需要复制数据。重组分区的原理与alter类似，县创建一个临时的分区，然后将数据复制到其中，随后在删除原分区。

分区不是”银弹”，下面是目前分区实现中的一些其他限制：

- 所有分区都必须使用相同的存储引擎
- 分区函数中可以使用的函数和表达式也有一些限制
- 某些存储引擎不支持分区
- 对于myisam的分区表，不能使用load index info cache操作
- 对于myisam的表，使用分区表时需要打开更多的文件描述符。虽然看起来是一个表，但是背后有很多独立的分区，每一个分区对于存储引擎来说都是一个独立的表。这样即使分区表只占用一个表缓存条目，文件描述符还是需要多个。因此，即使已经配置了合适的表缓存，以确保不会超过操作系统的单个进程可以打开的文件描述符的个数，但对于分区表而言，还是会出现文件描述符限制的问题。

1.5 查询优化

对于分区表来说，很重要的一点就是要在where条件中带入分区列。这样可以让优化器能够过滤掉无需访问的分区。如果没有这些条件，MySQL就需要让对应存储引擎访问这个表的所有分区，如果表非常大的话，就肯能会非常慢

1.6 合并表

不写了， 未来会被删除


2. 视图

```sql
create view Oceania as select * from country where Continent = 'Oceania' with check option ;
```

实现视图最简单的方法就是将select语句的结果存放到临时表中。当需要访问视图的时候，直接访问这个临时表就可以了，看下面的查询

```sql
select * from Oceania where Name = 'Australia';
```

下面是使用临时表来模拟视图的方法，这里临时表的名字是为演示用的：

```sql
create temporary table TMP_Oceania_123 as select * from country where Continent = 'Oceania';

select code,name from TMP_Oceania_123 where Name = 'Australia';
```

这样做会有明显的性能问题，优化器也很难优化在这个临时表上的查询。实现视图更好的方法是，重写含有视图的查询，将视图的定义SQL直接包含进查询的SQL中：

```sql
select code,name from country where Continent = 'Oceania' and Name = 'Australia';
```

MySQL可以使用这两种办法的任何一种来处理视图。这两种算法分别被称为**合并算法（Merge）和临时表算法（Temptable）**，如果可能，会尽可能的使用合并算法。MySQL甚至可以嵌套地定义视图，也就是在一个视图上再定义另一个视图。可以再explain extended 之后使用 show warnings来查看使用视图的查询重写后的结果。

如果视图中包含group by 、 distinct、任何聚合函数、union、子查询等，只要无法在原表记录和视图记录中建立一一映射的场景中，MySQL都将使用临时表算法来实现视图。如果想确定MySQL到底是使用合并算法还是临时表算法，可以explain一条针对视图的简单查询：

```sql
explain select * from TMP_Oceania_123;
```

如果这里的select_type为DERIVED，说明该视图是采用临时表算法实现的。视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。例如：

```sql
create algorithm = temptable view v1 as select * from actor;
explain select * from v1;
+--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+
|id|select_type|table     |partitions|type|possible_keys|key |key_len|ref |rows|filtered|Extra|
+--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+
|1 |PRIMARY    |<derived2>|NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |
|2 |DERIVED    |actor     |NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |
+--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+
```

实现该视图的SQL本身并不需要临时表，但基于盖世兔无论执行什么样的查询，视图都会生成一个临时表。

2.1 可更新视图

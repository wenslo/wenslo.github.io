---
title: MySQL的Schema和数据类型优化

categories: 

- MySQL

tags: 

- MySQL
date: 2020-12-16 17:30:57
description: MySQL的Schema和数据类型优化
---

| 1. 选择数据类型时候的基本原则

1. **更小的通常更好**，占用更少的磁盘，内存和CPU缓存，处理时需要的CPU时钟周期也少，但是不建议项目初期就弄，不然改起来也太费劲了，超级痛苦。
2. **简单的更好**，比如能使用整形就不适用字符，能用date就不用字符串，因为字符集和排序规则使得字符串相比整形复杂。
3. **避免为null**，滴滴的数据表，全都是not null的，因为有null的列更难优化，耗费的成本更高，索引，统计更麻烦，浪费更多的存储空间，

| 1.1 整数类型

分为两种，整数（real number）和实数（real number），整数有这么几种：**TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT**，分别使用8，16，24，32，64位存储空间，存储的值为 -2^n-1 到 2^(n-1)-1，同时有可选的**UNSIGNED**属性，不允许负值，可以将正数上限提高一倍。**INT(11)**不会限制值的合法范围，只是规定了一些交互工具显示字符的个数。

| 1.2 实数类型

DECIMAL可以存比BIGINT更大的整数，也可以存储精确的小数，**CPU原生支持浮点运算，但是DECIMAL需要MySQL实现，因此浮点比DECIMAL运算更快。decimal计算中，会转换为double，因此，虽然DECIAML支持65个数字，但是实际上并不支持**。同时，建议选择数据类型，不建议选择decimal的精度。可以使用BIGINT取代decimal，避免运算代价过高。


| 1.3 varchar和char类型

varchar比定长更节省空间，因为它只使用必要的空间，除非使用row_format=fixed，但是varchar需要1-2个字节记录字符串长度。虽然varchar对于性能有好处，但是，由于行是变长的，因此update操作可能使得行比原先变的更长，这时候，innodb就会进行分裂页，是数据能够放入页内。

下面这几种情况使用varchar更合适：**字符串列的最大长度比平均长度长很多；列的更新很少，碎片不是问题；使用了复杂字符集，比如utf-8，每个字符都是用不同的字节数进行存储**。

char会删除末尾空格，由于定长，也不容易产生碎片，而且在存储空间上也更有效率，没有存储长度的多余字节。

| 1.3.1 Blob和Text类型

分别属于两组：**TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT  和 TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB**。区别是，blob存储的是二进制数据，没有排序规则和字符集，而text有排序规则和字符集。如果数据过大的话，MySQL会在外部存储区域进行存储实际的值，每个值在行内用1-4个字节存储一个指针。

| 1.4 时间和日期类型

MySQL能存储的最小时间单位粒度为秒，datetime可以存储1001-9999的数据，**使用8个字节的存储空间**。而timestamp，**保存的是标准时间，只能从1970-2038，使用4个字节进行存储，依赖于时区，默认为NOT NULL，效率也比datetime更高**。

如果想存储微秒级别的时间戳，可以使用bigint，或者使用MariaDB。

| 1.5 位数据类型

bit列的最大长度是64个位，MySQL把bit当成字符串类型使用，同时和上下文环境有关系，比如直接查询，可能是显示的这个二进制对应的ASCII码表的内容，但是如果与数字一起运算，得到的就是数字结果，谨慎使用。

如果需要很多true/false值，可以使用set，在MySQL内部是以一系列打包的位的集合表示的，能够有效利用存储空间，但是该变列的话，需要alter table.

总的来说不太推荐这种方式，并不如redis的位图来的直观好用。

| 1.6 选择标识符（identifier）

要确保所有关联表中都使用同样的类型，要精确匹配。**最好使用整数，快，而且可以使用AUTO_INCREMENT，要避免使用uuid，会有6倍左右的性能下降，会导致insert和select语句很慢**。

***因为插入的时候，会随机写到索引的不同位置，使得insert语句很慢，会导致页分裂，磁盘随机访问，以及聚簇索引碎片；select语句也会很慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方；随机值导致缓存对所有类型的查询语句效果都很差，会使得缓存赖以工作的访问局部性原理失效，如果数据都是热数据，那么缓存哪一部分到内存都没好处，如果工作集比内存大，缓存将会有很多刷新和不命中***

如果使用UUID，应当移除“-”符号，更好的做法应该是使用unhex函数转换uuid为16字节的数字，并且存在binary(16)的列中。检索时，通过hex()函数来格式化为十六进制。UUID虽然分布也不均匀，但还是有一点顺序，但是还是不如递增的整数好用。

| 2. schema设计中的陷阱（应当避免）

1. 太多的列

    MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，单然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。

2. 太多的关联

    MySQL限制了每个关联操作最多只能有61张表，同时，最好在12个表以内做关联。

3. 全能的枚举
4. 变相的枚举
5. 用魔法数字代替null

| 3. 数据库范式和反范式

三范式如下：

1．第一范式(确保每列保持原子性)

2．第二范式(确保表中的每列都和主键相关)

3．第三范式(确保每列都和主键列直接相关,而不是间接相关)

范式化的优点很明显：

1. 范式化的更新操作通常比反范式化更快
2. 很少或者没有重复数据，只需要修改更少的数据
3. 表更小，能更好的放内存里，执行起来会更快
4. 更好的distinct和group by语句

缺点也很明显：

1. 干个啥都得关联查询
2. 稍微复杂一点的语句在schema上都可能至少需要一次关联

反范式化的优点

1. 避免关联，对查询来说是极大的优化
2. 能使用更有效的缓存策略

| 缓存表和汇总表

| 物化视图

| 计数器表

更新的时候核能会碰到并发问题，记录会有一个全局的互斥锁，使得一些事务只能穿行执行，可以将数据保存为多行，随机选择一行进行更新，获得更高的并发更新性能。

| 5. 加快 alter table 操作的速度

使用alter column改变列，防止表重建，会直接修改.frm文件
---
title: MySQL的复制
categories: 

    - MySQL
tags: 

    - MySQL

date: 2020-12-30 22:48:46
description: MySQL的复制
---

#### 1 概述
____

MySQL可以是一主一备，一主多备，双主，多主，等不同的组合方式。

支持两种复制方式：基于行的复制方式和基于语句的复制。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。这意味着，在同一时间点上，备库的数据可能与主库存在不一致，并且无法保证主备之间的延迟。一些大的语句可能导致备库产生几秒，几分钟甚至几小时的延迟。

MySQL复制大部分是向后兼容的，新版本的服务器可以作为老版本的备库。但相反不行。

复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。除此之外，每个备库也会对主库增加一些负载（网络IO等），尤其当备库请求从主库读取旧的二进制文件时，可能会造成更高的IO开销。另外锁竞争也可能阻碍事务的提交。最后，如果是从一个高吞吐量的主库上复制到多个备库，唤醒多个复制线程发送事件的开销将会累加。

通过复制可以将读操作指向备库来获得更好的读扩展，但对于写操作，除非设计的当，否则并不适合通过复制来扩展写操作。在一主库多备库的架构中，写操作会被执行多次，这时候整个系统的性能取决于写入最慢的地方。

当使用一主库多备库的架构时，可能会造成一些浪费，因为本质上它会复制大量不必要的重复数据，例如，对于1台主库和10台备库，会有11份的数据拷贝，并且这11台的缓存中存储了大部分相同的数据。这和在服务器上有11录RAID1类似。

##### 1.1 复制解决的问题
____

- 数据分布

    MySQL复制通常不会对带宽造成很大的压力，但是**基于行的复制会比基于语句的复制的带宽压力更大**。你可以随意地停止或开始复制，并在不同的地理位置来分布数据备份，例如不同的数据中心。即使在不稳定的网络环境下，远程复制也可以工作。但如果为了保持很低的延迟复制，最好有一个稳定的、低延迟链接。

- 负载均衡

    通过MySQL复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化，并且实现很方便，通过简单的代码修改就能实现基本的负载均衡。对于小规模的应用，可以简单地对机器名做硬编码或者使用dn轮训。也可使用更复杂的方法，例如网络负载均衡
    这一类的标准负载均衡解决方案，能够很好地将负载分配到不同的MySQL服务器上。linux虚拟服务器也能够很好地工作。

- 备份

    对于备份来说，复制是一项很有意义的技术补充，但是复制既不是备份也不能够取代备份。

- 高可用性和故障切换

    复制能够帮助应用程序避免MySQL单点失败，一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间

- MySQL升级测试

    使用更高版本的MySQL作为备库，保证在升级全部实例前，查询能够在备库按照预期执行。

##### 1.2 复制如何工作
_____

- 在主库上把数据更改记录到二进制日志（bin log）中
- 备库将主库上的日志复制到自己的中继日志中(retry log)
- 备库读取中继日志中的事件，将其冲放到备库数据之上。

第一步是在主库上记录二进制日志。在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主库会告诉存储引擎可以提交事务了。

下一步，备库将主库的二进制日志复制到其本地的中继日志中。首先，备库会启动一个工作线程，称为IO线程，IO线程跟主库建立一个普通的客户端连接，然后再朱哭丧启动一个特殊的二进制（binlog dump）线程，这个二进制转储线程会读取主库上二进制日志中的时间。它不会对事件进行轮训。如果该线程追赶上了主库，它将进入睡眠状态，直到主库发送信号通知其有新的事件产生时才会被环境，备库IO线程会将接收到的事件记录到中继日志中.

备库的SQL线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当SQL线程追赶上IO线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中，它对后面的场景非常有用。

这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。也就是说IO线程能够独立于SQL线程之外进行工作.但这种架构也限制了复制的过程，其中最重要的一点是在主库上并发运行的查询在备库只能串行化执行，因为只有一个SQL线程来重放中继日志中的事件。这是很多工作负载的性能瓶颈所在。虽然有一些解决方案，但大多数用户仍然受制于单线程。

#### 2 配置复制
_____

1. 在每台服务器上创建复制账号
2. 配置主库和备库
3. 通知备库连接到主库并从主库复制数据。

##### 2.1 创建复制账号
_____

MySQL会赋予一些特殊的权限给复制线程。在备库运行的IO线程会建立一个到主库的TCP/IP链接，这意味着必须在主库创建一个用户，并赋予其合适的权限。备库IO线程以该用户名连接到主库并读取其二进制文件。通过以下语句创建用户账号：

```sql
grant replication slave,replication client on *.* to repl@'127.0.0.1' identified by 'p4ssword';
# 这个在新版本中不适用，只适合5.5之前的版本，新版本对这两条语句做了拆分

#3解决办法:
#创建账户:create user ‘用户名’@’访问主机’ identified by ‘密码’;
#赋予权限:grant 权限列表 on 数据库 to ‘用户名’@’访问主机’ ;(修改权限时在后面加with grant option)

create user 'slave'@'%' identified by 'slave1234';
grant replication slave on *.* to 'slave'@'%';
flush privileges;
```

##### 2.2 配置主库和备库
_____

下一步需要在主库上开启一些设置，需要打开二进制文件并指定一个独一无二的服务器ID（server ID），在主库的my.conf文件中增加或修改如下内容：

```conf
log_bin = mysql-bin
server_id = 10
```

必须明确地指定一个唯一的服务器ID，默认服务器ID通常为1，因此一定要自定义一个，通常做法是选择服务器IP地址的后八位，但是要保证是唯一不变的。最好选择一些有意义的约定并遵守。

如果之前没有在MySQL的配置文件中指定log-bin选项，就需要重新启动MySQL。为了确认二进制日志文件是否已经在主库上创建，使用show master status命令。检查输出，如下

```sql
+-------------+--------+------------+----------------+-----------------+
|File         |Position|Binlog_Do_DB|Binlog_Ignore_DB|Executed_Gtid_Set|
+-------------+--------+------------+----------------+-----------------+
|binlog.000003|1364176 |            |                |                 |
+-------------+--------+------------+----------------+-----------------+
```

备库也需要在my.cnf中增加类似的配置，并且同样需要重启服务器。

```mysql
log_bin = mysql-bin
server_id = 2
relay=log = /var/lib/mysql/mysql-relay-bin
log_slave_updates=1
read_only = 1
```

这些选项并不总是必要的。只有server_id时必须的。log_bin默认情况下是根据机器名来命名的，但如果机器名变化了可能会导致问题，为了简便，主库和备库设置为相同的值。

另外还有两个选项：relay_log（指定中继日志的位置和命名）和log_slave_updates（允许备库将其重放的日志也记录到自身的二进制日志中），后一个选项会给备库增加额外的工作，但正如后面将会看到的，我们有理由为每个备库设置该选项。

有时候只开启了二进制日志，却没有开启log_slave_updates，可能会碰到一些奇怪的现象，例如，当配置错误时可能会导致备库数据被修改。如果可能的话，最好使用read_only配置选项，该选项会阻止任何没有特权权限的线程修改数据（所以最好不要给予用户超出需要的权限）。但read_only选项常常不是很实用，特别是对于那些需要在备库建表的应用。

##### 2.3 启动复制
_____

下一步是告诉备库如何连接到主库并重放其二进制日志。这一步不要通过修改my.cnf来配置，而是使用change master to语句，该语句完全替代了my.cnf中的设置，并且允许以后指向别的主库时无需重启备库。

```sql
change master to master_host = 'server1' ,master_user = 'repl',master_password ='p4ssword',master_log_file ='mysql-bin.0000001',master_log_pos =0
```

master_log_pos参数被设置为0，因为要从日志的开头读起。当执行完这条语句后，可以通过show slave status语句来检查复制是否正确执行。

```sql
show slave status;
# TODO 
```
slave_io_state，slave_io_running和slave_sql_running这三列显示当前备库复制尚未运行。MySQL知道第一个事件从文件的第四位开始读。

运行命令开始复制

```sql
start slave;
```

执行该命令没有显示错误，我们再用show slave status命令检查。

```sql
show slave status;
# TODO
```

从输出可以看到IO线程和SQL线程都已经开始运行,seconds_behind_master的值也不再为null。IO线程正在等待从主库传递过来的事件，这意味着IO线程已经读取了主库所有的事件.日志位置发生了变化,表明已经从主库获取和执行了一些事件.如果实在主库上做一些数据更新，就会看到备库的文件或者日志文职都可能会增加。备库中的数据同样会随之更新。

还可以从线程列表中看到复制线程。在主库上可以看到由备库IO线程向主库的连接。

```sql
show processlist;
```

同样，在备库也可以看到两个线程，一个是IO线程，一个是SQL线程。

```sql
show processlist;
```

这些线程总是运行在system user账号下，其他列的值则不相同。例如，当SQL线程回放事件时，info列可能显示正在执行的查询

##### 2.4 从另一个服务器开始复制
_____

大多数情况下有一个已经运行了一段时间的主库，然后用一台新安装的备库与之同步，此时这台备库还没有数据。

有几种办法来初始化备库或者从其他服务器克隆数据到备库。包括从主库复制数据，从另外一台备库克隆数据，以及使用最近的一次备份来启动备库，需要有三个条件来让主库和备库保持同步。

- 在某个时间点的主库的数据快照
- 主库当前的二进制日志文件，和获得数据快照时在该二进制文件中的偏移量，我们把这两个值称为日志文件坐标（log file coordinates）。通过这两个值可以确定二进制日志的位置。可以通过show master status命令来获取这些值。
- 从快找时间到现在的二进制日志

下面是一些从被的服务器克隆备库的方法

- 使用冷备份

    最基本的方法是关闭主库，把数据复制到备库。重启主库后，会使用一个新的二进制日志文件，我们在备库通过执行change master to 指向这个文件的起始处。这个方法的缺点很明显，在复制数据时需要关闭主库

- 使用热备份

    如果仅使用了myisam表，可以在主库运行时使用mysqlhotcopy或rsync来复制数据。

- 使用mysqldump

    如果只包含innodb表，那么可以使用以下命令来转储主库数据并将其加载到备库，然后设置响应的二进制日志坐标

    ```shell
    mysqldump --single-transcation --all-databases --master-data=1 --host=server1 | mysql --host=server2
    ```
    
    选项--single-transaction使得转储的数据为事务开始前的数据。如果使用的是非事务型表，可以使用--loack-all-tabels选项来获得所有表的一致性转储。

- 使用快照或备份

    只要知道对应的二进制日志坐标，就可以使用主库的快照或者备份来初始化备库（如果只使用备份，需要确保从备份的时间点开始的主库二进制文件都要存在）。只需要把备份或快照恢复到备库，然后使用change master to 指定二进制日志的坐标。

- 使用Percona Xtrabackup

- 使用另外的备库

    可以使用任何一种提及的克隆或拷贝技术从任意一台备库上将数据克隆岛另外一台服务器，但是如果使用的是mysqldump，--master-data选项就不会起作用。

    此外，不能使用show master status来获得主库的二进制日志坐标，而是在获取快照时使用show slave status来获取备库在主库上的执行位置。

    使用另外的备库进行数据克隆最大的缺点是，如果这台备库的数据已经和主库不同步，克隆到的就是脏数据库。

##### 2.5 推荐的复制配置

在主库上二进制日志最重要的选项就是sync_binlog： sync_binlog=1

如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证在服务器崩溃时不会丢失事件。如果禁止该选项，服务器会少做一些工作，但二进制日志文件可能在服务器崩溃时损坏或丢失信息。在一个不需要作为主库的备库上，该选项带来了不必要的开销。他只适合于二进制日志，而非中继日志。

如果无法容忍服务器崩溃导致表损坏，推荐使用innodb。在表损坏无关紧要时，myisam是可以接受的，但在一次备库服务器崩溃重启后，myisam可能已经处于不一致状态。一种可能是语句没有完全应用到一个或多个表上，那么即使修复了表，数据也可能是不一致的。

如果使用innodb，我们强烈推荐设置如下选项：

```mysql
innodb_flush_logs_at_trx_commit # Flush every log write
innodb_support_xa=1 # MySQL 5.0 and newer only
innodb_safe_binlog  #MySQL 4.1 only，roughly equivalent to innodb support_xa
```

这些事MySQL5.0及最新版本中的默认配置，我们推荐明确指定二进制日志的名字，以保证二进制日志名在所有服务器上是一致的，避免因为服务器名的变化导致的日志文件名变化。你可能认为以服务器名来命名二进制日志无关紧要，但经验表明，当在服务器间转移文件、克隆新的备库、转储备份或者其他一些你想不到的场景下，可能会导致很多问题。为了避免这些问题，需要给log_bin选项制定一个参数。可以随意地给一个绝对路径，但必须明确地指定基本的命名：

```mysql
log_bin=/var/lib/mysql/mysql-bin
```

在备库上，我们同样推荐开启如下配置选项，为中继日志指定绝对路径

```mysql
relay_log = /path/to/logs/relay-bin
skip_slave_start
read_only
```

通过设置relay_log可以避免中继日志文件基于文件名来命名，防止之前剃刀哥可能在主库发生的问题。指定绝对路径可以避免多个MySQL版本中存在的bug，这些bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止备库在崩溃后自动启动复制。这可以给你一些机会来修复可能发生的问题。如果备库在崩溃后自动启动并且处于不一致的状态，就可能会导致更多的损坏，最后将不得不把所有数据丢弃，并重新开始配置备库

read_only选项可以组织大部分用户更改非临时表，除了复制SQL线程和其他拥有超级权限的用户之外，这也是要尽量避免给正常账号授予超级权限的原因之一。

即使开启了所有我们建议的选型，备库仍然可能在崩溃后被终端，因为master.info和中继日志文件都不是崩溃安全的。默认情况下甚至不会刷新到磁盘，直到MySQL5.5版本才有选项来控制这种行为。如果正在使用MySQL5.5并且不介意额外的fsync()导致的性能开销，最好设置以下选项。

```msyql
sync_master_info = 1
sync_relay_log = 1
sync_relay_log_info = 1
```

如果备库和主库的延迟很大，备库的IO线程可能会写很多中继日志文件，SQL线程在重放完一个中继日志中的时间后会尽快将其删除（通过relay_log_purge选项来控制）。 但如果延迟非常严重，IO线程可能会把整个磁盘撑满.解决办法是配置realy_log_space_limit变量。如果所有中继日志的大小之和超过这个值，IO线程会停止,等待SQL线程释放磁盘空间

还有一个隐藏的问题。如果备库没有从主库获取所有的中继日志，这些日志可能在主库崩溃时丢失。早先这个选项存在一些bug，使用率也不高，所以用到这个选项遇到bug的风险会更高。除非磁盘空间真的非常紧张，否则最好让中继日志使用其需要的磁盘空间，这也是为什么我们没有将relay_log_space_limit列入推荐的配置选项的原因。

#### 3 复制的原理

##### 3.1 基于语句的复制
_____

在MySQL5.0之前的版本中只支持语句语句的复制（逻辑复制），这在数据库领域是很少见的。基于语句的复制模式下，主库会记录那么造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。这种方式既有好处，也有缺点。

最明显的好处是实现相当简单。理论上讲，简单地记录和执行这些语句，能够让主备保持同步。另一个好处是二进制日志里的事件更加紧凑，所以相对而言，基于语句的模式不会使用太多带宽。一条更新好几兆数据的语句在二进制日志里可能只占几十个字节。另外mysqlbinlog工具是基于语句的日志的最佳工具。

但事实上基于语句的方式可能并不如其看起来那么便利。因为主库上的数据更新除了执行的语句外，可能还依赖于其他元素。例如，同一条SQL在主库和备库上执行的时间可能不同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即使如此，还存在着一些无法被正确复制的SQL。例如，使用current_user()函数的语句。存储过程和触发器在使用基于语句的复制模式时也可能存在问题。

另一个问题是更新必须是串行的。这需要更多的锁，有时候要特别关注这一点。另外不是所有的存储引擎都支持这种复制模式。尽管这些存储引擎是包括在MySQL5.5及之前版本中发行的。

##### 3.2 基于行的复制
_____

5.1开始支持基于行的复制，最大的好处是可以正确地复制每一行。一些语句可以被更加有效的复制。

由于无需重放更新主库数据的查询，使用基于行的复制模式能够高效地复制数据。重放一些查询的代价可能会很高。例如，下面有一个查询将数据从一个大表汇总到小表：
```sql
insert into summary_table(col1,col2,col3) select col1,col2,sum(col3) from enormous_table group by col1,col2;
```

如果表enormous_table的列col1和col2有三种组合，这个查询可能在源表上扫描多次，但最终只在目标表上产生三行数据。但使用基于行的命令方式，在备库上开销会小很多。这种情况下，基于行的复制模式更加高效。

但在另一方面，下面这条语句使用基于语句的复制方式代价会小很多。

```sql
update enormous_table set col1 = 0;
```

由于这条语句做了全表更新，使用基于行的复制开销会很大，因为每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大。并且会给主库上记录日志和复制增加额外的负载，更慢的日志记录会降低并发度。

没有哪种模式是完美的，MySQL能够在这两种复制模式减动态切换。默认情况下使用的是基于语句的复制方式，但如果发现语句无法被正确地复制，就切换到基于行的复制模式。还可以根据需要来设置会话级别的变量 binlog_format，控制二进制日志格式。

对于基于行的复制模式，很难进行时间点恢复，但并非不可能

##### 3.3 基于行或基于语句：哪种更优
_____

理论上基于行的复制模式整体上更优，并且在实际应用中也适用于大多数场景。

- 基于语句的复制模式的有点

    当贮备的模式不同时，逻辑复制能够在多种情况下工作。例如，在主备上的表的定义不同但数据类型相兼容、列的顺序不同等情况。这样就很容易现在备库上修改scheam，然后将其提升为主库，减少停机时间。基于语句的复制方式一般允许更灵活的操作。

    基于语句的方式执行复制的郭恒基本上就是执行SQL语句.这意味着所有在服务器上发生的变更都以一种容易理解的方式运行.这样当出现问题时可以很好的去定位.

- 基于语句的复制模式的缺点

    很多情况下通过基于语句的模式无法复制正确，几乎每一个安装的备库都会至少碰到一次。事实上对于存储过程，触发器以及其他的一些语句的复制在5.0和5.1的一系列版本中存在大量的BUG。这些语句的复制的方式已经被修改了很多次，以使其更好地工作。简单的说，如果正在使用触发器或者存储过程，就不要使用基于语句的复制模式，除非能够清楚的确定不会碰到复制问题。

- 基于行的复制模式的优点

    几乎没有基于行的复制模式无法处理的场景。对于所有的SQL构造、触发器、存储过程等都能正确执行。只是当你试图做一些诸如在备库修改表的schema这样的事情时才可能导致复制失败。

    这种方式同样可能减少锁的使用，因为它并不要求这种强串行化是可重复的。

    基于行的复制模式会记录数据变更，因此在二进制日志中记录的都是实际上在主库上发生了变化的数据。你不需要查看一条语句去猜测它到底修改了哪些数据。在某种程度上，该模式能够更加清楚滴知道服务器上发生了哪些更改，并且有一个更好的数据变更记录。另外在一些情况下基于行的二进制日志还会记录发生改变之前的数据，因此这可能有利于某些数据恢复。

    在很多情况下，由于无须像基于语句的复制那样需要为查询建立执行计划并执行查询，因此基于行的复制占用更少的CPU。

    最后在某些情况下，基于行的复制能够帮助更快地找到并解决数据不一致的情况。举个栗子，如果是使用基于语句的复制模式，在备库更新一个不存在的记录时不会失败，但在基于行的复制模式下则会报错并停止复制。

- 基于行的复制模式的缺点

    由于语句并没有在日志里记录，因此无法判断执行了哪些SQL，除了需要知道行的变化外，正在很多情况下也很重要（未来会被修复）。使用一种完全不同的方式在备库进行数据变更，而不是执行SQL，事实上，执行基于行的变化的过程就像一个黑盒子，你无法知道服务器正在做什么。并且没有很好的文档和解释。因此当出现问题时，可能很难找到问题所在。例如，若备库使用一个效率低下的方式去寻找行记录并更新，你无法观察到这一点。

    如果有多层的复制服务器，并且所有的都被配置成基于行的复制模式，当会话级别的变量@@binlog_format被设置为statement时，所执行的语句在原服务器上被记录为基于语句的模式，但第一层的备库可能将其记录成行模式，并传递给其它层的备库。也就是说你期待的基于语句的日志在复制拓扑中将会被切换到基于行的模式。基于行的日志无法处理注入在被备库修改表的schema这样的情况，而基于语句的日志可以。

    在某些情况下，例如找不到要修改的行时，基于行的复制可能会导致复制停止，而基于语句的复制则不会。这也可以认为是基于行的复制的一个有点。该行为可以通过slave_exec_mode来进行配置。

##### 3.4 复制文件
_____

复制会使用到的一些文件，除了二进制日志文件和中继日志文件外，还有其他很多文件。

- mysql-bin.index

    当在服务器是哪个开启二进制日志时，同时会生成一个和二进制日志同名的但是以index为后缀的文件，该文件用于记录磁盘上的二进制日志文件。这里的index并不是指表的索引，而是说这个文件的每一行包含了二进制文件的文件名。

    你可能认为这个文件时多余的，可以被删除（毕竟MySQL可以在磁盘上找到它所需要的文件）。事实上并非如此，MySQL依赖于这个文件，除非在这个文件里有记录，否则MySQL识别不了二进制日志文件。

- mysql-relay-bin-index

    中继日志的索引文件，和mysql-bin.index作用类型

- master.info

    这个文件用于保存备库连接到主库所需要的信息，格式为纯文本。此文件不能删除，否则备库在重启后无法连接到主库。这个文件以文本的方式记录了复制用户的密码，所以要注意权限控制。

- relay-log.info

    这个文件包含了当前备库复制的二进制日志和中继日志坐标（例如，备库复制在主库上的位置），同样也不要删除这个文件，否则在备库重启后将无法获知从哪个位置开始复制，可能会导致重放已经执行过的语句。

以.index作为后缀的文件也与expire_logs_days存在交互，该参数定义了MySQL清理过期日志的方式，如果文件mysql-bin.index在磁盘上不存在，某些版本中自动清理就不会起作用。

最好能显式的执行一些日志清理策略，比如设置expire_logs_days参数或者其他方式，否则MySQL的二进制日志可能会将磁盘撑满。当做这些事情时，还需要考虑到备份策略。

##### 3.5 发送复制事件到其他备库
_____

log_slave_updates 选项可以让备库变成其他服务器的主库。在设置该选项后，MySQL会将其执行过的时间记录到它自己的二进制日志中。这样它的备库就可以从其日志中检索并执行事件。

在这种场景下，主库将数据更新事件写入二进制日志，第一个备库提取并执行这个时间。这时候一个事件的生命周期应该已经结束了，但由于设置了log_slave_updates，备库会将这个事件写到她自己的二进制日志中。这样第二个备库就可以将时间提取到它的中继日志中并执行。这意味着作为源服务器的主库可以将数据变化传递给没有与其直接相连的备库上。默认情况下这个选项是被打开的，这样在连接到备库时就不需要重启服务器。

当第一个备库从主库获得的事件写入到其二进制日中中时，这个日志在备库二进制日中中的位置与其在主库二进制日志中的位置几乎肯定是不相同的，可能在不同的日志文件或文件内不同的位置。这意味着你不能嘉定所有拥有同一逻辑复制点的服务器拥有相同的日志坐标。

除非你已经注意到要给每个服务器分配一个唯一的服务器ID,否则按照这种方式配置备库会导致一些奇怪的错误,甚至还会导致复制停止.一个常见的问题是:为什么要制定服务器ID,难道MySQL在不知道复制命令来源的情况下不能执行么?为什么MySQL要在意服务器ID是全局唯一的。问题的答案自安于MySQL在复制过程中如何防止无限循环。当复制SQL线程读中继日志时，会丢弃事件中记录的服务器ID和该服务器本身ID相同的事件，从而打破了复制过程中的无限循环。在某些复制拓扑结构下打破无限循环非常重要，例如 主-主复制结构。

##### 3.6 复制过滤器
_____

复制过滤选项允许你金复制服务器上一部分数据，不过这可能没有想象中那么好用。有两种过滤方式：**在主库上过滤日志到二进制日志中的时间；以及在备库上过滤记录到中继日志的时间**。

使用选项**binlog_do_db和binlog_ignore_db来控制过滤，不需要开启他们，否则还得解释，数据为啥不一致啊。

#### 4. 复制拓扑
____

可以在任意个主库和备库之间建立复制，只有一个限制：**每一个备库只能有一个主库**。基本原则如下：

- 一个MySQL备库实例只能有一个主库
- 每个备库必须有一个唯一的服务器ID
- 一个主库可以有多个备库
- 如果打开了log_slave_updates选项，一个备库可以把其主库上的数据变化传播到其他备库。

##### 4.1 一主库多备库

备库之间根本没有交互，仅仅是连接到同一个主库上。

在有少量写和大量读的时候，这种配置是非常有用的。可以把读分摊到多个备库上，知道备库给主库造成了太大的负担，或者主备之间的带宽成为瓶颈为止。

下面是它的一些用途：

- 为不同的角色使用不同的备库
- 把一台备库当做待用的主库，除了复制没有其他数据传输。
- 将一台备库放到远程数据中心，用作灾难恢复。
- 延迟一个或多个备库，以备灾难恢复
- 使用其中一个备库，作为备份，培训，开发或者测试使用服务器

这种结构流行的原因是它避免了很多其他拓扑结构的复杂性：例如：**可以方便地比较不同备库重放的事件在主库二进制日志中的位置。换句话说，如果在同一个逻辑点停止所有备库的复制，他们读取的是主库上同一个日志文件的相同物理位置。这是个很好的特性，可以减轻管理员许多工作，例如把备库提升为主库**。

这种特性只存在于兄弟备库之间。在没有直接的主备或者兄弟关系的服务器上去比较日志文件的位置要复杂得多。

##### 4.2 主动 - 主动模式下的 主 - 主复制
______

主-主复制（双主复制）包含两套服务器，互为主备。是一对主库。

这种配置最大的问题是如何解决冲突，两个可写的互主服务器导致的问题非常多。通常发生在两台服务器同时修改一行记录，或者同时在两台服务器上向一个包含auto_increment列的表里插入数据。

MySQL不支持多主库复制

允许向两个服务器上写入所带来的麻烦远大于其带来的好处。但是 主动 - 被动模式则会非常有用

##### 4.3 主动 - 被动模式下的 主  主 复制
_____

主要区别在于，其中的一台服务器是只读的被动服务器。

这种方式使得反复切换主动和被动服务器非常方便，因为服务器的配置是对称的。这使得故障转译和故障恢复很容易。它也可以让你在不关闭服务器的情况下执行维护、优化表、升级操作系统等其他任务。

例如，**执行alter table操作可能会锁住整个表**，阻塞对表的读和写，这可能会花费很长时间并导致服务中断。然后在主-主配置下，可以先停止主动服务器上的备库复制线程，然后在被动服务器上执行alter操作，交换角色，最后再闲钱的主动服务器上启动复制线程。这个服务器将会读取中继日志并执行相同的alter语句。这可能花费很长时间，但不要紧，因为该服务器没有为任何活跃查询提供服务。

对称的设置：

1. 确保两台服务器上有相同的数据
2. 启用二进制日志，选择唯一的服务器ID，并创建复制账号
3. 启用备库更新的日志记录，后面将会看到，这是故障转移和故障恢复的关键。
4. 把被动服务器配置成只读，防治可能与主动服务器上的更新产生冲突，这一点是可选的
5. 启动每个服务器的MySQL实例
6. 将么个主库设置为对方的备库，使用新创建的二进制日志开始通过

主动服务器上更新时会发生什么事情：更新没记录到二进制日志中，通过复制传递给被动服务器的中继日志中。被动服务器执行查询并将其记录到自己的二进制日志中（因为开启了log_slave_updates选项）。由于事件的服务器ID与主动服务器的相同,因此主动服务器将忽略这些时间.

设置主动-被动的主-主拓扑结构在某种意义上类似于创建一个热备份,但是可以使用这个备份来提高性能,例如,用它来执行读操作、备份、离线维护以及升级等。真正的热备份做不了这些事情，但是，并不会获得比单台服务器更好的写性能。

##### 4.4 拥有备库的主-主结构
______

优点是增加了荣誉，对于不同地理位置的复制拓扑，能够消除站点单点失效的问题。

##### 4.5 环形复制
_____

环形结构没有双主结构的一些优点，例如对称的配置和简单的故障转移，并且完全依赖与环上的每一个可用节点，大大增加了系统失效的几率，如果移除一个节点，这个节点发起的事件就会陷入无限循环。环形结构非常脆弱，尽量避免。

##### 4.6 主库、分发主库以及备库
_____

当备库足够多时，会对主库造成很大的负载。每个备库会在主库上创建一个线程，并执行binlog dump命令。该命令会读取二进制文件中的数据，并将其发送给备库。每个备库都会重复这样的工作，它们不会共享binlog dump的资源。

如果有很多备库，并且有大的事件时，例如一次很大的load data file操作，主库上的负载会显著上升，甚至可能由于备库同时请求同样的事件而耗尽内存并崩溃。另一方面，如果备库请求的数据不再文件系统的缓存中，可能会导致大量的磁盘年间所，这同样会影响主库的性能并增加锁的竞争。

因此，如果需要多个备库，一个好的办法是从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的就是提取和提供主库的二进制日志。多个备库连接到分发主库，这使得原来的主库摆脱了负担。为了避免在分发主库上做十几的查询，可以将它的表格修改为blackhole存储引擎。如图

很难说备库数据达到多少时需要一个分发主库。按照通用规则，如果主库接近满负载，不应该为其建立10个以上的备库。如果有少量的写操作，或者只复制其中一部分表，主库皆可以提供更多的复制。另外，也不一定只使用一个分发主库。如需要的话，可以使用多个分发主库向大量的备库进行复制，或者使用金字塔的分发主库，在某些情况下，可以通过设置sleve_compressed_protocol来节约一些主库带宽。这对跨数据中心复制很有好处。

还可以通过分发主库实现其他目的，例如，对二进制日志进行过滤和重写规则。这比在每个备库上重复进行日志记录，重写和查询高效的多。

使用分发主库的另一个缺点是无法使用一个备库来代替主库，因为由于分发主库的存在，导致各个备库与原始主库的二进制日志坐标已经不相同。

##### 4.7 树或金字塔形
_____

这种设计的好处是减轻了主库的负担。缺点是中间层出现的任何错误都会影响到多个服务器。如果每个备库和主库直接相连就不会存在这样的问题。同样，中间层次越多，处理故障会更困难、更复杂。

##### 4.8 定制的复制方案
_____

- 选择性复制

为了利用访问局部性原理（locality of reference），并将需要读的工作驻留在内存中，可以复制少量数据到备库中。如果每个备库只拥有主库的一部分数据，并且将读分配给备库，就可以更好地利用备库的内存。并且每个备库也只有主库一部分的写入负载，这样主库的能力更强并能保证备库延迟。

这个类似于水平数据划分，但它的优势在于主库包含了所有的数据集，这意味着无需为了一条写入查询去访问多个服务器。如果读操作无法在备库上找到数据，还可以通过主库来查询。即使不能从备库上读取所有数据，也可以移除大量的主库读负担。

最简单的方法是在主库上将数据划分道不同的数据库里。然后将每个数据库复制到不同的备库上。例如，若需要将公司的每一个部分的数据复制到不同的备库，可以创建名为sales、marketing、procurement等的数据库，每个备库通过选项replicate_wild_do_table选项来限制给定数据库的数据。下面是sales数据库的配置：

```sql
replicate_wild_do_tabe = sales.%
```

也可以通过一台分发主库进行分发。举个栗子，如果想通过一个很慢或者非常昂贵的网络，从一台负载很高的数据库上复制一部分数据，就可以使用一个包含blackhole表和过滤规则的本地分发主库，分发主库可以通过复制过滤移除不需要的日志。这可以避免在主库上进行不安全的日志选项设定，并且无需传输所有的数据到远程备库。

- 分离功能
许多应用都混合了在线事务处理（OLTP）和在线数据分析（OLAP）的查询。OLTP查询比较短，并且是事务型的，OLAP查询通常很大，也很慢，并且不要求绝对最新的数据。这两种查询给服务器带来的负担完全不同，因此它们需要不同的配置，甚至可能使用不同的存储引擎或者硬件。

一个常见的办法是将OLTP服务器的数据复制到专门为OLAP工作负载准备的备库上。这些备库可以有不同的硬件、配置、索引或者不同的存储引擎。如果决定在备库上执行OLAP查询，就可能要忍受更大的复制延迟或降低备库的服务质量。这意味着在一个非专用的备库上执行一些任务时，可能会导致不可接受的性能。例如执行一条长时间运行的查询。

- 数据归档

可以在备库上实现数据归档，也就是说可以再备库上保留主库上删除过的数据，在主库上通过delete语句删除数据是确保delete语句不传递到备库就可以实现的。有两种通常的办法：一种是在主库上选择性地禁止二进制日志，另一种是在备库上使用replicate_ignore_db规则（都很危险）

第一种方法需要先将SQL_LOG_BIN设置为0,然后再进行数据清理。这种方法的好处是不需要再备库进行任何配置，由于SQL语句根本没有记录到二进制日志中，效率会稍微有所提升。最大缺点也正因为没有将主库的修改记录下载，因此无法使用二进制日志来进行审计或者做按时间点的数据恢复。另外还需要super权限。

第二种方法是在清理数据之前对主库上特定的数据库使用use语句。例如，可以创建一个名为purge的数据库，然后再备库的my.cnf文件里设置replicate_ignore_db=purge并重启服务器。备库将会忽略使用了USE语句指定的数据库。这种方法没有第一种方法的缺点，但有一个另外的缺点：备库需要去读取它不需要的时间。另外，也可能有人在purge数据库上执行非清理查询，从而导致备库无法重放改时间。

- 将备库用作全文检索

许多应用要求合并事务和全文检索。一个普遍的做法是配置一台备库，将某些表设置为myisam存储引擎，然后创建全文索引并执行全文检索查询。这避免了在主库上同时使用事务型和非事务型存储引擎所带来的复制问题，减轻了主库维护全文索引的负担。

- 只读备库

许多机构将备库设置为只读，以防止在备库进行的无意识修改导致复制通断。可以通过设置read_only选项实现。它会禁止大部分写操作，除了复制线程和拥有超级权限的用户以及临时表操作。只要不给也不应该给普通用户超级权限，这英爱是很完美的方法。

- 模拟多主库复制

当前MySQL不支持多主库复制（一个备库拥有多个主库）。但是可以通过把一台备库轮流指向多台主库的方式来模拟这种结构。

需要做一些额外的工作来为每个主库跟踪二进制日志坐标。可能还需要保证备库的IO线程在每一次循环读取超过需要的数据，否则可能因为每次循环反复地提取和抛弃大量数据导致主库的网络请求和开销明显增大。

- 创建日志服务器

创建没有数据的日志服务器。它唯一的作用就是更加容易重放并且/或者过滤二进制日志事件。对崩溃后重启复制很有帮助，同时对基于时间点的恢复也很有帮助。

假设有一组二进制日志或者中继日志，可能从备份或者一台崩溃的服务器上获取，希望能够重放这些日志中的事件，可以停通过mysqlbinlog工具从其中提取出事件，但更加方便和高效的方法是配置一个没有任何数据的MySQL实例并使其认为这些二进制日志是它拥有的。如果只是临时需要。因为无需执行二进制日志，日志服务器也就不需要任何数据。它的目的仅仅是将数据提供给别的服务器。

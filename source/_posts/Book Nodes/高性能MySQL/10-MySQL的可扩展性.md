---
title: MySQL的可扩展性

categories: 

- MySQL

tags: 

- MySQL
date: 2021-01-06 10:22:07
description: MySQL的可扩展性
---

扩展方式有两种

#### 向上扩展
____

加内存，选更强的CPU，加IO性能更强的设备。但是最好是MySQL的最新版本，不然的话，无法获得最好的性能。单服务器首先会达到读限制，特别是执行复杂的读查询时。类似这样的查询在MySQL内部是单线程的，因此只能使用一个CPU，这种情况下，加核心也无法提升多少性能，除非使用更快的CPU。当数据变得庞大以至于无法有效缓存时，内存也会成为瓶颈，通常表现为很高的磁盘使用率。

当主库升级到高端硬件后，一般是不太可能配制出一台能够跟上主库的强大备库的。一个高负载的主库通常可以承担比拥有同样的配置的备库更多的工作，因为备库的复制线程无法高效的利用多核CPU和磁盘资源。

#### 向外扩展
____

复制、拆分、数据分片

最简单的就是通过复制将数据分发到多个服务器上，然后将备库用于读查询。这种技术对于以读为主的应用很有效。但是也有一些缺点，例如重复缓存。

另一个常见的方法是将工作负载分布到多个节点。许多大型的MySQL应用不能自动分布负载，就算有也没有做到完全的自动化。在MySQL架构中，一个节点(node)就是一个功能部件。如果没有规划冗余和高可用性，那么一个节点就可能是一台服务器。如果设计的是能够故障转移的冗余系统，那么一个节点通常可能是下面的某一种：

- 一个主-主复制双机结构，拥有一个主动服务器和被动服务器
- 一个主库和多个备库
- 一个主动服务器，并使用分布式复制块设备（DRBD）作为备用服务器
- 一个基于存储区域网络（SAN）的集群

大多数情况下，一个节点内的所有服务器应该拥有相同的数据。我们倾向于把主-主复制架构作为两台服务器的主动-被动节点。

##### 1. 按功能拆分
____

按功能拆分，或者说按职责拆分，意味着不同的节点执行不同的任务。将独立的服务器或节点分配给不同的应用，这样每个节点只包含它的特定应用所需要的数据。如果应用很庞大，每个功能区域还可以拥有其专用的web服务器，但没有专用的数据库服务器这么常见。

另一个可能的按功能划分方法是对单个服务器的数据进行划分，并确保划分的表的集合之间不会执行关联操作。当必须执行关联操作时，如果对性能要求不高，可以在应用中做关联。虽然有一些变通的办法，但它们有一个共同点，就是每种类型的数据只能在单个节点上找到。这并不是一种通用的分布数据的方法，因为很难做到高效，并且相比其他方案没有任何优势。

归根结底，还是不能通过功能划分来无限的进行扩展，因为如果一个功能区域被捆绑到单个MySQL节点，就只能进行垂直扩展。其中的一个应用或者功能区域最终增长到非常庞大时，都会迫使你去寻求一个不同的策略。如果进行了太多的功能划分，以后就很难采用根据扩展性的设计了

##### 2. 数据分片
____

目前用于扩展大型MySQL应用的方案中，数据分片是最通用而且最成功的方法。它把数据分割成一小片，或者说一块，然后存储到不同的节点中。

数据分片在和某些类型的按功能划分联合使用时非常有用。大多数分片系统也有一些全局的数据不会被分片（城市列表，登录数据）。全局数据一般存储在单个节点上，并且通常保存在类似memcached这样的缓存里。

事实上，大多数应用只会对需要的数据做分片，通常是那些将会增长的非常庞大的数据。假设正在构建的博客服务，预计会有1000W用户，这时候就无须对注册用户进行分片，因为完全可将所有的用户放到内存中。假如用户达到5亿，那么就可能需要对用户数据分片。用户所产生的的内容。例如发表的文章和评论，几乎肯定需要进行数据分片，因为这些数据非常庞大，而且还会越来越多。

大型应用可能有多个逻辑数据集，并且处理方式也可以各不相同。可以将它们存储到不同的服务器组上，但这并不是必须的。还可以以多种方式对数据进行分片，这取决于如何使用他们。

分片技术和大多数应用的最初设计有着显著的差异，并且很难将应用从单一数据存储转换为分片架构。如果在应用设计出去就已经预计到分片，那实现起来就容易的多。

许多一开始没有建立分片架构的应用都会碰到规模扩大的情形。例如，可以使用复制来扩展博客服务的读查询，直到它不再奏效。然后可以把服务器划分为三个部分：用户信息，文章，以及评论。可以将这些数据放到不同的服务器上（按功能划分），也许可以使用面向服务的架构，并在应用层执行联合查询。

最后，可以通过用户ID来对文章和评论进行分片，而将用户信息保留在单个节点上。如果为全局节点配置一个主-备结构并为分片节点使用主-主结构，最终的数据可能如下图所示、

如果事先知道应用会扩大到很大的规模，并且清除按功能划分的局限性，就可以跳过中间步骤，直接从单个节点升级为分片数据存储。事实上，这种前瞻性可以帮你避免由于粗糙的分片方案带来的挑战。

采用分片的应用常会有一个数据库访问抽象层，用以降低应用和分片数据存储之间通信的复杂度，但无法完全隐藏分片。因为相比数据存储，应用通常更了解查询相关的一些信息。太多的抽象会导致低效率，例如查询所有的节点，可实际上需要的数据只在单一节点上。

分片数据存储看起来像是优雅的解决方案，但很难实现。那为啥要选择这个架构？因为：想扩展写容量，就必须切分数据。如果只有单台主库，那么不管有多少备库，写容量都是无法扩展的。对于上述缺点，数据分片是首选方案。

**如非必要，尽量不分片，首先看是否能通过性能调优或者更好的应用和数据库设计来推迟分片。如果能足够长时间的推迟分片，也许可以直接购买更大的服务器，升级MySQL到性能更优的版本，然后继续使用单台服务器，也可以增加或减少复制。**

**简单地说，对单台服务器而言，数据大小或写负载变得太大时，分片将会是不可避免的。如果不分片，而是尽可能的优化应用，系统能扩展到什么程度呢？答案可能会让你感到惊讶。有些非常受欢迎的应用，可能会以为一开始就分片了，但实际上知道已经值数十亿美元并且流量机器巨大也没有采用分片的设计。分片不是城里唯一的游戏，在没有必要的情况下，采用分片的架构来构建应用会步履维艰。**

##### 3. 选择分区键（partitioning key）
_____

数据分片最大的挑战是查找和获取数据：如何查找数据取决于如何进行分片。有很多种方法，其中有一些方法会比另外一些好。

我们的目标是对那些最重要并且频繁查询的数据减少分片（记住，可扩展性法则的其中一条就是要避免不同节点之间的交互）。这其中最重要的是如何为数据选择一个或多个分区键。分区键决定了每一行分配到哪一个分片中。如果知道一个对象的分区键，就可以回答如下两个问题：

- 应该在哪里存储数据？
- 应该从哪里取到希望得到的数据？

先看一个例子。假设像MySQL NDB Cluster那样来操作，并对每个表的主键使用哈希里将数据分割到各个分片中。这是一种非常简单的实现，但可扩展性不好，因为可能需要频繁检查所有分片来获得需要的数据。例如，如果想查看user3的博客文章，可以从哪里找到呢？由于使用主键值而非用户名进行分割，博客文章可能均匀分散在所有的数据分片中。使用主键值hash简化了判断数据存储在何处的操作，但却可能增加获取数据的难度，具体取决于需要什么数据以及是否知道主键。

跨多个分片的查询比单个分片上的查询性能要差，但只要不涉及太多的分片，也不会太糟糕。最糟糕的情况是不知道需要的数据存储在哪里，这时候就需要扫描所有的分片。

一个好的分区键常常是数据库中一个非常重要的实体的主键。这些键值决定了分片单元。例如，如果使用用户ID或客户端ID来分割数据，分片单元就是用户或者客户端。

确定分区键一个比较好的办法是用实体-关系图，或一个等效的能显示所有实体及其关系的工具来展示数据模型。尽管把相关联的实体靠的更近。这样可以很直观的找出候选分区键。当然不要仅仅看图，同样也要考虑应用的查询。即使两个实体在某些方面是相关联的，但如果很少或几乎不对其做关联操作，也可以打断这种联系来实现分片。

某些数据模型比其他的更容易进行分片，具体取决于实体-关系图中的关联性程度。图中，左边展示了一个易于分片的数据模型，右边的那个则很难分片。

左边的数据模型比较容易分片，因为与之相连的子图中大多数节点只有一个连接，很容易切断子图之间的联系。右边的数据则很难分片，因为它没有类似的子图。辛亏大多数数据模型更像左边的图。

选择分区键的时候，尽可能选择那些能够避免跨分片查询的，但同时也要让分片足够小，以免过大的数据片导致问题。如果可能，应该期望分片尽可能同样小，这样在为不同数量的分片进行分组时能够很容易平衡。例如，如果应用只在美国使用，并且希望将数据集分割为20个分片，则可能不应该按照州来划分，因为加利福尼亚的人口非常多。但是可以按照县或者电话区号来划分，因为尽管不是均匀分布的，但是足以选择20个集合以粗略的表示等同的密集程度，并且基本上避免跨分片查询。

##### 4. 多个分区键
____

复杂的数据模型会使数据分片更加困难。许多应用拥有多个分区键，特别是存在两个或者多个维度的时候。换句话话说，应用需要从不同的角度看到有效且连贯的数据视图，这意味着某些数据在系统内至少需要存储两份。

例如，需要将博客应用的数据按照用户ID和文章ID进行分片，因为这两者都是应用查询数据时比较普遍的方式。试想一下这种情形：频繁的读取某个用户的所有文章，以及某个文章的所有评论。如果按用户分片就无法找到谋篇文章的所有评论，而按照文章分片则无法找到某个用户的所有文章。如果希望这两个查询都落到同一个分片上，就需要从两个维度进行分片。

需要多个分区键并不意味着需要去设计两个完全冗余的数据存储。我们来看看另一个例子：一个社交网站下的读书俱乐部站点，该站点的所有用户都可以对书进行评论。该网站可以显示所有书籍的所有评论，也能显示某个用户已经读过或评论过的所有书籍。

假设为用户数据和书籍数据都设计了分片数据存储。而评论同时拥有用户ID和评论ID，这样就跨越了两个分片的便捷。实际上却无须荣誉存储两份评论数据，替代方案是，将评论和用户数据一起存储，然后把每个评论的标题和ID与书籍数据存储在一起.这样在渲染大多数关于某本书的评论的视图时无需同时访问用户和书籍数据存储,如果需要显示完整的评论内容,可以从用户数据存储中获得。

##### 5. 跨分片查询
____

大多数分片应用多少都有一些查询需要对多个分片的数据进行聚合或关联操作。例如，一个读书俱乐部网站要显示最受欢迎或最活跃的用户，就必须访问每一个分片。如何让这类查询很好地执行，是实现数据分片的架构中最困难的部分。虽然从应用的角度来看，这是一条查询，但实际上需要拆分成多条并行执行的查询，每个分片上执行一条。一个设计良好的数据库抽象层能够减轻这个问题，但类似的查询仍然会比分片内查询要慢并且更加昂贵，所以通常会更加依赖缓存。

跨分片查询也可以借助汇总表来执行。可以遍历所有分片来生成汇总表并将结果在每个分片上冗余存储。如果在每个分片上存储重复数据太过浪费，也可以把汇总表放到另外一个数据存储中，这样就只需要存储一份了。

为分片的数据通常存储在全局节点中，可以使用缓存来分担存储。

如果数据的均衡分布非常重要，或者没有很好的分区键，一些应用会采用随机分片的方式。分布式检索应用就是个很好的例子。这种场景下，跨分片查询和聚合查询非常常见。

跨分片查询并不是数据分片面临的唯一难题。维护数据一致性同样困难。外键无法在分片间内工作，因此需要由应用来检查参照一致性，或者只在分片内使用外键，因为分片内的内部一致性可能是最重要的。还可以使用XA事务，但由于开销太大，现实中使用很少。

还可以设计一些定期执行的清理过程。例如，如果一个用户的读书俱乐部账号到期，并不需要立刻将其移除。可以写一个定期任务将用户评论从每个书籍分片中移除。也可以写一个检查脚本周期性运行以确保分片间的数据一致性。

##### 6. 分配数据、分片和节点
_____

分片和节点不一定是一对一的关系，应该尽可能的让分片的大小比节点容量小很多，这样就可以在单个节点上存储多个分片。

保持分片足够小更容易管理。这将使得数据的备份和恢复更加容易，如果表很小，那么像改变表结构这样的操作会更加容易。例如，假设有一个100GB的表,你可以直接存储,也可以将其划分为100个1GB的分片，并存储在单个节点上。现在假如要向表上增加一个索引，在单个100GB的表上的执行时间会比100个1GB分片执行的总时间更长，因为1GB的分片更容易全部加载到内存中。并且在执行alter table时还会倒是数据不可用，阻塞1GB的数据比阻塞100GB的数据要好得多。

小一点的分片也便于抓你有。这有助于重新分配容量，平衡各个节点的分片。转译分片的效率一般都不高。通常需要先将受影响的分片设置为只读模式，提取数据，然后转移到另外一个节点。这包括使用mysqldump获取数据然后使用mysql命令将其重新导入。

除了在节点间移动分片，你可能还需要考虑在分片间移动数据，并尽量不中断整个应用提供服务。如果分片太大，就很难通过移动整个分片来平衡容量，这时候可能需要将一部分数据转移到其他分片。分片间转移数据比转移分片要更复杂，应该尽量避免这么做。这也是我们建议设置分片大小机娘易于管理的原因之一。

分片的相对大小取决于应用的需求。简单的说，我们说的易于管理的大小是指保持表足够小，以便能在5或者10分钟内提供日常的维护工作，例如alter table, check table 或者 optimize table。

如果将分片设置的太小，会产生太多的表，这可能引发文件系统或者MySQL内部结构的问题。另外太小的分片还会导致跨分片查询增多。

##### 7. 在节点上部署分片
______


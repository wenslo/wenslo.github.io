<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划，lintcode 116 Jump Game</title>
    <url>/2021/01/13/Data%20Struct/lintcode/116%20Jump%20Game/</url>
    <content><![CDATA[<h4><span id="题目如下">题目如下</span></h4><p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　</p><p>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　</p><a id="more"></a>

<p>判断你是否能到达数组的最后一个位置。</p>
<h5><span id="先确定最后一步">先确定最后一步</span></h5><p>最后一步为n-1<br>那么前一步设为i，那么 i &lt; n- 1<br>那么最后一步不超过最大距离为：$ n - 1 -i &lt;= a_i $</p>
<h5><span id="拆分子问题">拆分子问题</span></h5><p>那么子问题就变为 f[j]表示能不能到达数组j</p>
<h5><span id="转移方程">转移方程</span></h5><script type="math/tex; mode=display">f[j] = OR_{ 0 <= i< j }(f[i] AND i + a[i] >= j)</script><h5><span id="确定初始条件和边界">确定初始条件和边界</span></h5><p>初始条件：f[0] = ture</p>
<h5><span id="确定计算顺序">确定计算顺序</span></h5><p>从左到右，从小到大</p>
<h5><span id="代码如下">代码如下</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">boolean</span> f[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        f[j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &amp;&amp; i + A[i] &gt;= j) &#123;</span><br><span class="line">                f[j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划，lintcode 114 Unique Paths</title>
    <url>/2021/01/13/Data%20Struct/lintcode/114%20Unique%20Paths/</url>
    <content><![CDATA[<h4><span id="题目如下">题目如下</span></h4><p>有一个机器人的位于一个 m × n 个网格左上角。</p><p>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><a id="more"></a>

<p>问有多少条不同的路径？</p>
<hr>
<p>图示例如下</p>
<h5><span id="先确定最后一步">先确定最后一步</span></h5><p>最后一步是右下角，也就是坐标的最长的那一部分，也就是 [m][n]</p>
<h5><span id="拆分子问题">拆分子问题</span></h5><p>往上推，上一步也就变为了[m][n-1]，或者 [m-1][n]，在往上一步，就是[m][n-2]，或者 [m-2][n]，这样一直往前推即可</p>
<h5><span id="转移方程">转移方程</span></h5><p>由上面的可知，转移方程为 $f(x) = [m-1][n] + [m][n-1]$</p>
<h5><span id="确定初始条件和边界">确定初始条件和边界</span></h5><p>由于机器人从坐标初始点开始走，那么，也就是说从[0][0]这个位置开始走，也就是说，f[0][0]=1，自由一种方式可达<br>同时由于加法组合可知，如果机器人有x种方式可以从左上角走到[m-1][n]，有y种方式可以从左上角走到[m][n-1]，那么，走到[m][n]的方式也就有x+y种</p>
<h5><span id="确定计算顺序">确定计算顺序</span></h5><p>计算顺序为从左到右，可以利用已经计算过的位置</p>
<h5><span id="代码如下">代码如下</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划，leetcode q322 coin change</title>
    <url>/2021/01/12/Data%20Struct/leetcode/322_Coin_Change/</url>
    <content><![CDATA[<h4><span id="面值为257的三种硬币凑出27元最少需要多少枚硬币">面值为2，5，7的三种硬币，凑出27元最少需要多少枚硬币？</span></h4><hr><h5><span id="先确定最后一步">先确定最后一步</span></h5><p>最后的值为27，那么结果就是为：$27=a_1+a_2+a_3+…+a_k$，那么最后一步即为：$a_k$</p><a id="more"></a>

<h5><span id="拆分子问题">拆分子问题</span></h5><p>由于最后一枚硬币一定是$a<em>k$，因此，可以知道倒数第二个硬币为：$ a</em>{k-1}=  27 - a_k$，由此往前推可知，$a_0=0$。</p>
<p>我们将其转化为子问题，也就变为了：$f(27) = min{f(27-2)+1,f(27-5)+1,f(27-7)+1}$</p>
<h4><span id="转移方程">转移方程</span></h4><script type="math/tex; mode=display">f[x] = min\{f(27-2)+1,f(27-5)+1,f(27-7)+1\}</script><h4><span id="按照实际逻辑设置边界情况和初始条件">按照实际逻辑设置边界情况和初始条件</span></h4><p>$f[x] = min{f(27-2)+1,f(27-5)+1,f(27-7)+1}$ 的边界情况是[x-2] || [x-5] || [x-7]不能小于0（硬币面值为正），也不能高于27。</p>
<h4><span id="确定计算顺序">确定计算顺序</span></h4><p>根据上面的转移方程已经可以通过递归写出来了，但是递归会有个问题，重复计算太多</p>
<p>如果从$f[27]$，$f[26]$倒序开始计算的时候，比如，$f[27]$的时候，发现$f[26]$还没有计算，这样重复计算会很多。从$f[1]$,$f[2]$开始的话，就会发现，当计算$f[6]$的时候，$f[5]$已经计算过了，避免了很多重复计算。</p>
<p>也就是说，初始条件为：f[0] = 0</p>
<p>然后计算f[1],f[2],…f[27]</p>
<p>当计算到f[x]时，f[x-2],f[x-5],f[x-7]，都已经有值了</p>
<h4><span id="代码如下">代码如下</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">27</span>;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">27</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            f[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coins[j] &amp;&amp; f[i - coins[j]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    f[i] = Math.min(f[i - coins[j]] + <span class="number">1</span>, f[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f[amount] == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的备份与恢复</title>
    <url>/2021/01/10/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/11-MySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h3><span id="1-为什么要备份">1. 为什么要备份？</span></h3><hr><ul>
<li>灾难恢复</li>
<li>领导改变想法</li>
<li>审计</li>
<li>测试</li>
</ul><h3><span id="2-定义备份需求">2. 定义备份需求</span></h3><hr><p>只有备份是不够的，还需要有一个恢复系统，但是，让备份系统平滑工作比构造良好的恢复过程和工具更容易。原因如下：</p><a id="more"></a>



<ul>
<li>备份在先。只有已经做了备份才可能恢复，因此在构建系统时，注意力自然会集中到备份上</li>
<li>备份由脚本和任务自动完成。会花一些事件调优备份过程，但是天天同样重视恢复不可能。</li>
<li>备份是日常任务，恢复常常发生在危急情况下</li>
<li>因为安全的需要，如果正在做异地备份，可能需要对备份数据进行加密，或采取其他错误来进行保护。安全性往往只关注数据被盗用的结果，但是如果没有人能怼用来恢复数据的加密卷解锁，或者需要从一个整块的加密文件中抽取单个文件时，损害有多大？</li>
<li>只有一个人来规划、设计和实施备份。当灾难袭来时，那个人可能不在，因此需要培养几个人并有计划的互为备份，这样就不会要求一个不合格的人来恢复数据。</li>
</ul>
<p>规划备份和恢复策略时，有两个重要的需求可以帮助思考：恢复点目标（PRO）和恢复时间目标（RTO）。它们定义了可以容忍丢失多少数据，以及需要等待多久将数据恢复。在定义PRO和RTO时，先尝试回答下面的问题：</p>
<ul>
<li>不导致严重后果的情况下，可以容忍丢失多少数据？需要故障恢复，还是可以接受自从上次日常备份后所有的工作全部丢失？是否有法律法规的要求？</li>
<li>恢复需要在多长时间内完成？哪种类型的宕机是可接受的？哪种影响是应用和用户可以接受的？当哪些场景发生时，又该如何持续服务？</li>
<li>需要恢复什么？常见的是恢复整个服务器，单个数据库，单个表，或者仅仅是特定的事务或者语句</li>
</ul>
<h3><span id="3-设计mysql备份方案">3 设计MySQL备份方案</span></h3><hr>
<p>建议：</p>
<ul>
<li>物理备份是必须的，逻辑备份太慢而且受到资源限制</li>
<li>保留多个备份集</li>
<li>定期从逻辑备份中抽取数据进行恢复测试</li>
<li>保存二进制日志以用于基于故障时间点的恢复，这样就可以在保持主库运行且不运行任何二进制日志的情况下创建一个备库。备库二进制日志与过期设置无关，二进制日志备份需要保存足够长的时间，以便能从最近的逻辑备份进行恢复</li>
<li>完全不借助备份工具来监控备份和备份的过程。另外需要验证备份是否正常</li>
<li>通过演练整个恢复过程来测试备份和恢复。测算需要的资源</li>
<li>对安全性仔细考虑</li>
</ul>
<p>逻辑备份的优点：</p>
<ul>
<li>逻辑备份可以用编辑器或者grep查看，当需要查看但不进行恢复的时候，很有帮助</li>
<li>恢复很简单</li>
<li>可以通过网络来恢复</li>
<li>很灵活，可以通过where 子句限制执行</li>
<li>与存储引擎无关</li>
<li>有助于避免数据损坏</li>
</ul>
<p>缺点：</p>
<ul>
<li>必须由数据库服务器完成逻辑备份的工作，因此需要更多的CPU时钟周期</li>
<li>逻辑本分某些场景下比数据库文件更大</li>
<li>无法保证导出后在还原一定是同样的数据</li>
<li>从逻辑悲愤中还原需要MySQL加载和解释语句，转换为存储格式，重建索引，很慢。</li>
</ul>
<p>mysqldump 很有帮助。</p>
<p>物理备份的优点：</p>
<ul>
<li>文件复制到其他地方即可完成备份</li>
<li>复制过去即可完成恢复，innodb需要停止服务</li>
<li>物理备份容易跨平台，操作系统，MySQL版本</li>
<li>恢复会更快</li>
</ul>
<p>缺点：</p>
<ul>
<li>原始文件比逻辑备份大很多，表空间有很多未使用的空间，缓冲，存储，回滚段等</li>
<li>物理备份不是总可以跨平台。</li>
</ul>
<p>对于需要长期保留的备份，不要完全依赖于物理备份，每隔一段时间做一次逻辑备份。</p>
<p>建议混合使用，</p>
<h4><span id="33-备份什么">3.3 备份什么</span></h4><hr>
<ul>
<li>非显著数据，例如二进制日志，事务日志</li>
<li>代码，触发器，存储过程代码</li>
<li>配置复制，例如，二进制日志，中继日志，日志索引文件</li>
<li>服务器配置</li>
<li>操作系统文件</li>
</ul>
<h4><span id="34-存储引擎和一致性">3.4 存储引擎和一致性</span></h4><hr>
<p>数据一致性，应该考虑数据在指定时间点一致</p>
<p>文件一致性，例如，一条大的update语句执行时备份反映不出文件的状态。</p>
<h3><span id="4-管理和备份二进制日志">4 管理和备份二进制日志</span></h3><hr>
<p>对于基于时间点的恢复是必须的，跟容易进行频繁的备份。经常备份二进制日志是个好主意。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的可扩展性</title>
    <url>/2021/01/06/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/10-MySQL%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/</url>
    <content><![CDATA[<p>扩展方式有两种</p><h4><span id="向上扩展">向上扩展</span></h4><hr><p>加内存，选更强的CPU，加IO性能更强的设备。但是最好是MySQL的最新版本，不然的话，无法获得最好的性能。单服务器首先会达到读限制，特别是执行复杂的读查询时。类似这样的查询在MySQL内部是单线程的，因此只能使用一个CPU，这种情况下，加核心也无法提升多少性能，除非使用更快的CPU。当数据变得庞大以至于无法有效缓存时，内存也会成为瓶颈，通常表现为很高的磁盘使用率。</p><a id="more"></a>


<p>当主库升级到高端硬件后，一般是不太可能配制出一台能够跟上主库的强大备库的。一个高负载的主库通常可以承担比拥有同样的配置的备库更多的工作，因为备库的复制线程无法高效的利用多核CPU和磁盘资源。</p>
<h4><span id="向外扩展">向外扩展</span></h4><hr>
<p>复制、拆分、数据分片</p>
<p>最简单的就是通过复制将数据分发到多个服务器上，然后将备库用于读查询。这种技术对于以读为主的应用很有效。但是也有一些缺点，例如重复缓存。</p>
<p>另一个常见的方法是将工作负载分布到多个节点。许多大型的MySQL应用不能自动分布负载，就算有也没有做到完全的自动化。在MySQL架构中，一个节点(node)就是一个功能部件。如果没有规划冗余和高可用性，那么一个节点就可能是一台服务器。如果设计的是能够故障转移的冗余系统，那么一个节点通常可能是下面的某一种：</p>
<ul>
<li>一个主-主复制双机结构，拥有一个主动服务器和被动服务器</li>
<li>一个主库和多个备库</li>
<li>一个主动服务器，并使用分布式复制块设备（DRBD）作为备用服务器</li>
<li>一个基于存储区域网络（SAN）的集群</li>
</ul>
<p>大多数情况下，一个节点内的所有服务器应该拥有相同的数据。我们倾向于把主-主复制架构作为两台服务器的主动-被动节点。</p>
<h5><span id="1-按功能拆分">1. 按功能拆分</span></h5><hr>
<p>按功能拆分，或者说按职责拆分，意味着不同的节点执行不同的任务。将独立的服务器或节点分配给不同的应用，这样每个节点只包含它的特定应用所需要的数据。如果应用很庞大，每个功能区域还可以拥有其专用的web服务器，但没有专用的数据库服务器这么常见。</p>
<p>另一个可能的按功能划分方法是对单个服务器的数据进行划分，并确保划分的表的集合之间不会执行关联操作。当必须执行关联操作时，如果对性能要求不高，可以在应用中做关联。虽然有一些变通的办法，但它们有一个共同点，就是每种类型的数据只能在单个节点上找到。这并不是一种通用的分布数据的方法，因为很难做到高效，并且相比其他方案没有任何优势。</p>
<p>归根结底，还是不能通过功能划分来无限的进行扩展，因为如果一个功能区域被捆绑到单个MySQL节点，就只能进行垂直扩展。其中的一个应用或者功能区域最终增长到非常庞大时，都会迫使你去寻求一个不同的策略。如果进行了太多的功能划分，以后就很难采用根据扩展性的设计了</p>
<h5><span id="2-数据分片">2. 数据分片</span></h5><hr>
<p>目前用于扩展大型MySQL应用的方案中，数据分片是最通用而且最成功的方法。它把数据分割成一小片，或者说一块，然后存储到不同的节点中。</p>
<p>数据分片在和某些类型的按功能划分联合使用时非常有用。大多数分片系统也有一些全局的数据不会被分片（城市列表，登录数据）。全局数据一般存储在单个节点上，并且通常保存在类似memcached这样的缓存里。</p>
<p>事实上，大多数应用只会对需要的数据做分片，通常是那些将会增长的非常庞大的数据。假设正在构建的博客服务，预计会有1000W用户，这时候就无须对注册用户进行分片，因为完全可将所有的用户放到内存中。假如用户达到5亿，那么就可能需要对用户数据分片。用户所产生的的内容。例如发表的文章和评论，几乎肯定需要进行数据分片，因为这些数据非常庞大，而且还会越来越多。</p>
<p>大型应用可能有多个逻辑数据集，并且处理方式也可以各不相同。可以将它们存储到不同的服务器组上，但这并不是必须的。还可以以多种方式对数据进行分片，这取决于如何使用他们。</p>
<p>分片技术和大多数应用的最初设计有着显著的差异，并且很难将应用从单一数据存储转换为分片架构。如果在应用设计出去就已经预计到分片，那实现起来就容易的多。</p>
<p>许多一开始没有建立分片架构的应用都会碰到规模扩大的情形。例如，可以使用复制来扩展博客服务的读查询，直到它不再奏效。然后可以把服务器划分为三个部分：用户信息，文章，以及评论。可以将这些数据放到不同的服务器上（按功能划分），也许可以使用面向服务的架构，并在应用层执行联合查询。</p>
<p>最后，可以通过用户ID来对文章和评论进行分片，而将用户信息保留在单个节点上。如果为全局节点配置一个主-备结构并为分片节点使用主-主结构，最终的数据可能如下图所示、</p>
<p>如果事先知道应用会扩大到很大的规模，并且清除按功能划分的局限性，就可以跳过中间步骤，直接从单个节点升级为分片数据存储。事实上，这种前瞻性可以帮你避免由于粗糙的分片方案带来的挑战。</p>
<p>采用分片的应用常会有一个数据库访问抽象层，用以降低应用和分片数据存储之间通信的复杂度，但无法完全隐藏分片。因为相比数据存储，应用通常更了解查询相关的一些信息。太多的抽象会导致低效率，例如查询所有的节点，可实际上需要的数据只在单一节点上。</p>
<p>分片数据存储看起来像是优雅的解决方案，但很难实现。那为啥要选择这个架构？因为：想扩展写容量，就必须切分数据。如果只有单台主库，那么不管有多少备库，写容量都是无法扩展的。对于上述缺点，数据分片是首选方案。</p>
<p><strong>如非必要，尽量不分片，首先看是否能通过性能调优或者更好的应用和数据库设计来推迟分片。如果能足够长时间的推迟分片，也许可以直接购买更大的服务器，升级MySQL到性能更优的版本，然后继续使用单台服务器，也可以增加或减少复制。</strong></p>
<p><strong>简单地说，对单台服务器而言，数据大小或写负载变得太大时，分片将会是不可避免的。如果不分片，而是尽可能的优化应用，系统能扩展到什么程度呢？答案可能会让你感到惊讶。有些非常受欢迎的应用，可能会以为一开始就分片了，但实际上知道已经值数十亿美元并且流量机器巨大也没有采用分片的设计。分片不是城里唯一的游戏，在没有必要的情况下，采用分片的架构来构建应用会步履维艰。</strong></p>
<h5><span id="3-选择分区键partitioning-key">3. 选择分区键（partitioning key）</span></h5><hr>
<p>数据分片最大的挑战是查找和获取数据：如何查找数据取决于如何进行分片。有很多种方法，其中有一些方法会比另外一些好。</p>
<p>我们的目标是对那些最重要并且频繁查询的数据减少分片（记住，可扩展性法则的其中一条就是要避免不同节点之间的交互）。这其中最重要的是如何为数据选择一个或多个分区键。分区键决定了每一行分配到哪一个分片中。如果知道一个对象的分区键，就可以回答如下两个问题：</p>
<ul>
<li>应该在哪里存储数据？</li>
<li>应该从哪里取到希望得到的数据？</li>
</ul>
<p>先看一个例子。假设像MySQL NDB Cluster那样来操作，并对每个表的主键使用哈希里将数据分割到各个分片中。这是一种非常简单的实现，但可扩展性不好，因为可能需要频繁检查所有分片来获得需要的数据。例如，如果想查看user3的博客文章，可以从哪里找到呢？由于使用主键值而非用户名进行分割，博客文章可能均匀分散在所有的数据分片中。使用主键值hash简化了判断数据存储在何处的操作，但却可能增加获取数据的难度，具体取决于需要什么数据以及是否知道主键。</p>
<p>跨多个分片的查询比单个分片上的查询性能要差，但只要不涉及太多的分片，也不会太糟糕。最糟糕的情况是不知道需要的数据存储在哪里，这时候就需要扫描所有的分片。</p>
<p>一个好的分区键常常是数据库中一个非常重要的实体的主键。这些键值决定了分片单元。例如，如果使用用户ID或客户端ID来分割数据，分片单元就是用户或者客户端。</p>
<p>确定分区键一个比较好的办法是用实体-关系图，或一个等效的能显示所有实体及其关系的工具来展示数据模型。尽管把相关联的实体靠的更近。这样可以很直观的找出候选分区键。当然不要仅仅看图，同样也要考虑应用的查询。即使两个实体在某些方面是相关联的，但如果很少或几乎不对其做关联操作，也可以打断这种联系来实现分片。</p>
<p>某些数据模型比其他的更容易进行分片，具体取决于实体-关系图中的关联性程度。图中，左边展示了一个易于分片的数据模型，右边的那个则很难分片。</p>
<p>左边的数据模型比较容易分片，因为与之相连的子图中大多数节点只有一个连接，很容易切断子图之间的联系。右边的数据则很难分片，因为它没有类似的子图。辛亏大多数数据模型更像左边的图。</p>
<p>选择分区键的时候，尽可能选择那些能够避免跨分片查询的，但同时也要让分片足够小，以免过大的数据片导致问题。如果可能，应该期望分片尽可能同样小，这样在为不同数量的分片进行分组时能够很容易平衡。例如，如果应用只在美国使用，并且希望将数据集分割为20个分片，则可能不应该按照州来划分，因为加利福尼亚的人口非常多。但是可以按照县或者电话区号来划分，因为尽管不是均匀分布的，但是足以选择20个集合以粗略的表示等同的密集程度，并且基本上避免跨分片查询。</p>
<h5><span id="4-多个分区键">4. 多个分区键</span></h5><hr>
<p>复杂的数据模型会使数据分片更加困难。许多应用拥有多个分区键，特别是存在两个或者多个维度的时候。换句话话说，应用需要从不同的角度看到有效且连贯的数据视图，这意味着某些数据在系统内至少需要存储两份。</p>
<p>例如，需要将博客应用的数据按照用户ID和文章ID进行分片，因为这两者都是应用查询数据时比较普遍的方式。试想一下这种情形：频繁的读取某个用户的所有文章，以及某个文章的所有评论。如果按用户分片就无法找到谋篇文章的所有评论，而按照文章分片则无法找到某个用户的所有文章。如果希望这两个查询都落到同一个分片上，就需要从两个维度进行分片。</p>
<p>需要多个分区键并不意味着需要去设计两个完全冗余的数据存储。我们来看看另一个例子：一个社交网站下的读书俱乐部站点，该站点的所有用户都可以对书进行评论。该网站可以显示所有书籍的所有评论，也能显示某个用户已经读过或评论过的所有书籍。</p>
<p>假设为用户数据和书籍数据都设计了分片数据存储。而评论同时拥有用户ID和评论ID，这样就跨越了两个分片的便捷。实际上却无须荣誉存储两份评论数据，替代方案是，将评论和用户数据一起存储，然后把每个评论的标题和ID与书籍数据存储在一起.这样在渲染大多数关于某本书的评论的视图时无需同时访问用户和书籍数据存储,如果需要显示完整的评论内容,可以从用户数据存储中获得。</p>
<h5><span id="5-跨分片查询">5. 跨分片查询</span></h5><hr>
<p>大多数分片应用多少都有一些查询需要对多个分片的数据进行聚合或关联操作。例如，一个读书俱乐部网站要显示最受欢迎或最活跃的用户，就必须访问每一个分片。如何让这类查询很好地执行，是实现数据分片的架构中最困难的部分。虽然从应用的角度来看，这是一条查询，但实际上需要拆分成多条并行执行的查询，每个分片上执行一条。一个设计良好的数据库抽象层能够减轻这个问题，但类似的查询仍然会比分片内查询要慢并且更加昂贵，所以通常会更加依赖缓存。</p>
<p>跨分片查询也可以借助汇总表来执行。可以遍历所有分片来生成汇总表并将结果在每个分片上冗余存储。如果在每个分片上存储重复数据太过浪费，也可以把汇总表放到另外一个数据存储中，这样就只需要存储一份了。</p>
<p>为分片的数据通常存储在全局节点中，可以使用缓存来分担存储。</p>
<p>如果数据的均衡分布非常重要，或者没有很好的分区键，一些应用会采用随机分片的方式。分布式检索应用就是个很好的例子。这种场景下，跨分片查询和聚合查询非常常见。</p>
<p>跨分片查询并不是数据分片面临的唯一难题。维护数据一致性同样困难。外键无法在分片间内工作，因此需要由应用来检查参照一致性，或者只在分片内使用外键，因为分片内的内部一致性可能是最重要的。还可以使用XA事务，但由于开销太大，现实中使用很少。</p>
<p>还可以设计一些定期执行的清理过程。例如，如果一个用户的读书俱乐部账号到期，并不需要立刻将其移除。可以写一个定期任务将用户评论从每个书籍分片中移除。也可以写一个检查脚本周期性运行以确保分片间的数据一致性。</p>
<h5><span id="6-分配数据-分片和节点">6. 分配数据、分片和节点</span></h5><hr>
<p>分片和节点不一定是一对一的关系，应该尽可能的让分片的大小比节点容量小很多，这样就可以在单个节点上存储多个分片。</p>
<p>保持分片足够小更容易管理。这将使得数据的备份和恢复更加容易，如果表很小，那么像改变表结构这样的操作会更加容易。例如，假设有一个100GB的表,你可以直接存储,也可以将其划分为100个1GB的分片，并存储在单个节点上。现在假如要向表上增加一个索引，在单个100GB的表上的执行时间会比100个1GB分片执行的总时间更长，因为1GB的分片更容易全部加载到内存中。并且在执行alter table时还会倒是数据不可用，阻塞1GB的数据比阻塞100GB的数据要好得多。</p>
<p>小一点的分片也便于抓你有。这有助于重新分配容量，平衡各个节点的分片。转译分片的效率一般都不高。通常需要先将受影响的分片设置为只读模式，提取数据，然后转移到另外一个节点。这包括使用mysqldump获取数据然后使用mysql命令将其重新导入。</p>
<p>除了在节点间移动分片，你可能还需要考虑在分片间移动数据，并尽量不中断整个应用提供服务。如果分片太大，就很难通过移动整个分片来平衡容量，这时候可能需要将一部分数据转移到其他分片。分片间转移数据比转移分片要更复杂，应该尽量避免这么做。这也是我们建议设置分片大小机娘易于管理的原因之一。</p>
<p>分片的相对大小取决于应用的需求。简单的说，我们说的易于管理的大小是指保持表足够小，以便能在5或者10分钟内提供日常的维护工作，例如alter table, check table 或者 optimize table。</p>
<p>如果将分片设置的太小，会产生太多的表，这可能引发文件系统或者MySQL内部结构的问题。另外太小的分片还会导致跨分片查询增多。</p>
<h5><span id="7-在节点上部署分片">7. 在节点上部署分片</span></h5><hr>
<p>需要确定如何在节点上部署数据分片，下面是一些常用的办法：</p>
<ul>
<li>每个分片使用单一数据库，并且要求数据库名要相同。典型的应用场景是需要每个分片都能镜像到原应用的结构。这在部署多个应用实例，并且每个实例对应一个分片时很有用。</li>
<li>将多个分片的表放到一个数据库中，在每个表名上包含分片号（例如bookclub.comments_23）。这种配置下，单个数据库可以支持多个数据分片。</li>
<li>为每个分片使用一个数据库，并在数据库中包含所有应用需要的表。在数据库名中包含分片号（例如bookclub_23.comments），但表名不包括分片号。当应用连接到单个数据库并且不在查询中指定数据库名时，这种做法很常见。优点是无需为每个分片专门编写查询，也便于对只使用单个数据库的应用进行分片。</li>
<li>每个分片能使用一个数据库，并在数据库名和表名中包含分片号（例如表名可以是bookclub_32.comment_23）</li>
<li>在每个节点上运行多个MySQL实例，每个实例上有一个或多个分片，可以使用上面提高的方式的任意组合来安排分片。</li>
</ul>
<p>如果在表名中包含了分片号，就需要在查询模版里插入分片号。这在新应用中很容易实现，但旧的很困难。构建新应用时，查询模板并不是问题，我们更倾向于使用每个分片一个数据库的方式，并把分片号写到数据库名和表名中。这回增加例如alter table的复杂度，但也有下面的一些优点：</p>
<ul>
<li>如果分片全部在一个数据库中，转移分片会比较容易。</li>
<li>因为数据库本身是文件系统的一个目录，所以可以很方便的管理一个分片的文件。</li>
<li>如果分片互不关联，则很容易查看分片的大小。</li>
<li>全局唯一表名可避免误操作。如果表名每个地方都相同，很容易因为连接到错误的节点而查询了错误的分片，或者是将一个分片的数据导入另外一个分片的表中。</li>
</ul>
<p>为一已有的应用增加分片支持的结果往往是一个节点对应一个分片。这种简化的设计可以减少对应用查询的修改。分片对应用而言通常是一种颠覆性的改变，所以应尽可能简化它。如果在分片后，每个节点看起来就像是整个应用数据的缩略图，就无须去改变大多数查询或者担心查询是否传递到期望的节点。</p>
<h5><span id="8-固定分配">8. 固定分配</span></h5><hr>
<p>将数据分配到分片中有两种主要的方法：固定分配和动态分配。两种方法都需要一个分区函数，使用行的分区键值作为输入，返回存储该行的分片。</p>
<p>固定分配使用的分区函数仅仅依赖与分区键的值。哈希函数和取模运算就是很好的例子。这些函数按照每个分区键的值将数据分散到一定数量的桶中。</p>
<p>假设有100个桶，你希望弄清楚用户111该放到哪个桶里。如果使用的是对数字求模的方式，答案很简单：111对100取模为11，所以应该将其放到第11个分片中。</p>
<p>而如果使用CRC32()函数来做哈希，答案是81.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">CRC32</span>(<span class="number">111</span>) % <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>固定分配的主要优点是简单，开小弟，甚至可以在应用中直接硬编码。</p>
<p>但是固定分配也有如下缺点：</p>
<ul>
<li>如果分片很大并且数量不都，就很难平衡不同分片之间的负载。</li>
<li>固定分片的方式无法自定义数据到哪个分片上，这一点对于那些在分片间负载不均衡的应用来说尤其重要。一些数据可能比其他的更加活跃，如果这些热点数据都分配到同一个分片中，固定分配的方式就无法通过热点数据转移的方式来平衡负载。（如果每个分片的数量切分的比较小，这个问题就没那么严重，根据大数定律，这样做会更容易将热点数据平均分配到不同分片。）</li>
<li>修改分片策略通常比较困难，因为需要重新分配已有的数据。例如，如果通过模10的哈希函数来进行分片，就会有10个分片。如果应用增长使得分片变大，如果要拆分成20个分片，就需要对所有数据进行重新哈希，这会导致更新大量数据，并在分片间转移数据。</li>
</ul>
<p>正是由于这些现实，我们倾向于为新应用选择动态分配的方式。但如果是为已有的应用做分片，使用固定分配策略可能会更容易些，因为它更简单。也就是说，大多数使用固定分配的应用最后迟早要使用动态分配策略。</p>
<h5><span id="9动态分配">9.动态分配</span></h5><hr>
<p>另外一个选择是使用动态分配，将每个数据单元映射到一个分片。假设一个有两列的表，包括用户ID和分片ID。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_to_shard(</span><br><span class="line">    user_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    shard_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (user_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这个表本身就是分区函数。给定分区键（用户ID）的值就可以获得分片号。如果该行不存在，就从目标分片中找到并将其加入到表中。也可以推迟更新，这就是动态分配的含义。</p>
<p>动态分配增加了分区函数的开销，因为需要额外调用一次外部资源，例如目录服务器（存储映射关系的数据存储节点）。出于效率方面的考虑，这种架构常常需要更多的分层。例如，可以使用一个分布式缓存系统将目录服务器的数据加载到内存中，因为这些数据平时改动很小。或者更普遍的，你可以直接向user表中增加一个shard_id用于存储分片号。</p>
<p>动态分配的最大好处是可以对数据存储位置做细粒度的控制。这使得均衡分配数据到分片更容易，并可提供适应未知改变的灵活性。</p>
<p>动态映射可以在简单的键一分片（key-to-shard）映射的基础上建立多层次的分片策略。例如，可以建立一个双重映射，将每个分片单元指定到一个分组中，然后尽可能将这些组保持在同一个分片中。这样可以利用分片亲和性，避免跨分片查询。</p>
<p>如果使用动态分配策略，可以生成不均衡的分片。如果服务器能力不相同，或者希望将其中一些分片用于特定目的（例如归档数据），这可能会有用。如果能够做到随时重新平衡分片，也可以为分片和节点间维持一一对应的映射关系，这不会浪费容量。也有些人喜欢简单的每个节点一个分片的方式。（但是请记住，保持分片尽可能小是有好处的）</p>
<p>动态分配以及灵活的利用分片亲和性有助于减轻规模扩大而带来的跨分片查询问题。假设一个跨分片查询涉及四个节点，当使用固定分配时，任何给定的查询可能需要访问所有分片，但动态分配策略则可能只需要在其中的三个节点上运行同样的查询。这看起来没什么大区别，但考虑一下当数据存储增加到400个分片时会发生什么？固定分配策略需要访问400个分片，而动态分配方式依然只需要访问3个。</p>
<p>动态分配可以让分片策略根据需要变得很复杂。固定分配则没有这么多选择。</p>
<h5><span id="10-混合动态分配和固定分配">10. 混合动态分配和固定分配</span></h5><hr>
<p>可以混合使用固定分配和动态分配。这种方法通常很有用，有时候甚至必须要混合使用。目录映射不太大时，动态分配可以很好胜任。但如果分片单元太多，效果就会变差。</p>
<p>以一个存储网站链接的系统为例。这样一个站点需要存储数百亿的行，所使用的分区键是源地址和目的地址URL的组合（这两个URL的任意一个都有可能有好几亿的链接，因此，单独一个URL并不适合做分区键）。但是在映射表中存储所有的源地址和和目的地址URL组合并不合理,因为数据量太大了，每个URL都需要很多存储空间。</p>
<p>一个解决方案是将URL项链并将其哈希到固定数目的桶中,然后把桶动态的映射到分片上.如果桶的数目足够大，例如100W个，你就能把大多数数据分配到每个分片上，获得动态分配的大部分好处，而无须使用庞大的映射表。</p>
<h5><span id="11-显式分配">11. 显式分配</span></h5><hr>
<p>第三种分配策略是在应用插入新的数据行时，显式的选择目标分片。这种策略在已有的数据上很难做到。所以在为应用增加分片时很少使用。但在某些情况下还是有用的。</p>
<p>这个方法是把数据分片号编码到ID中，这和之前提到的避免主-主复制主键冲突策略比较相似。例如，应用要创建一个用户3，将其分配到第11个分片中，并使用bigint列的高八位来保存分片号。这样最终的ID就是(11&lt;&lt;56)+3，即792633534417207299。应用可以很方便的从中抽取出用户ID和分片号，如下例所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="number">792633534417207299</span> &gt;&gt; <span class="number">56</span>) <span class="keyword">as</span> shard_id, <span class="number">792633534417207299</span> &amp; ~(<span class="number">11</span> &lt;&lt; <span class="number">56</span>) <span class="keyword">as</span> user_id;</span><br></pre></td></tr></table></figure>
<p>现在假设要为该用户创建一条评论，并存储在同一个分片中。应用可以为该用户分配一个评论ID 5,然后以同样的方式组合 5 和分片号 11。</p>
<p>这种方法的好处是每个对象的ID同时包含了分区键，而其他方法通常需要一次关联或者查找来确定分区键。如果要从数据库中检索某个特定的评论，无须知道哪个用户拥有它；对象ID会告诉你到哪里去找.如果对象是通过用户ID动态分片的,就得先找到该评论的用户,然后通过目录服务器找到对应的数据分片。</p>
<p>另一个解决方案是将分区键存储在一个单独的列里。例如，你可能不会单独引用评论5，但是评论5属于用户3。这种方法可能会让一些人不高兴，因为这不违背第一范式；然而额外的列会增加开销、编码，以及其他不便之处。（这也是我们将两值存在单独一列的优点之一）</p>
<p>显式分配的缺点是分片方式是固定的，很难做到分片间的负载均衡。但结合固定分配和动态分配，该方法就能很好地工作。不再像之前那样哈希到固定数目的桶里并将其映射到节点，而是将桶作为对象的一部分进行编码。这样应用就能够控制数据的存储位置，因此可以将相关联的数据一起放到同样的分片中。</p>
<p>正常情况下并不推荐这样用。尽可能使用动态分配，避免显示分配。</p>
<h5><span id="12-重新均衡分片数据">12. 重新均衡分片数据</span></h5><hr>
<p>如有必要，可以通过在分片间移动数据来达到负载均衡。在分片之间移动数据的好处很明显。例如，当需要升级硬件时，可以将用户数据从旧分片转移到新分片上，而无须暂停整个分片的服务或将其设置为只读。</p>
<p>然而，我们也应该尽量避免重新均衡分片数据，因为这可能会影响用户使用。在分片间转移数据也使得为应用增加新特性更加困难，因为新特性可能还需要包含针对重新均衡脚本的升级。如果分片足够小，就无须这么做；也可以经常移动整个分片来重新均衡负载，这比移动分片中的部分数据要容易得多（并且以每行数据开销来衡量的话，更有效率）</p>
<p>一个较好的策略是使用动态分片策略，并将新数据随机分配到分片中。当一个分片快满时，可以设置一个标志位，告诉应用不要再往这里放数据了。如果未来需要向分片中放入更多数据，可以直接把标记位清除。</p>
<p>假设安装了一个新的MySQL节点，上面有个100个分片。先将他们的标记设置为1，这样应用就知道它们正准备接受新数据。一旦它们的数据足够多时（例如，每个分片10000个用户），就把标记位设置为0.之后，如果节点因为大量废弃账号导致敷在不足，可以重新打开一些分片向其中增加新用户。</p>
<p>如果升级应用并且增加的新特性会导致每个分片的查询负载升高，或者只是算错了负载，可以把一些分片移到新节点来减轻负载。缺点是操作期间整个分片会变成只读或者处于离线状态。这需要根据实际情况来看是否能接受。</p>
<p>另外一种使用的较多的策略是为每个分片设置两台备库，每个备库都有该分片的完整数据。然后每个备库负责其中一半的数据，并完全停止在主库上查询。这样每个备库都会有一半它不会用到的数据。然后在后台移除不需要的数据即可。</p>
<h5><span id="13-生成全局唯一id">13. 生成全局唯一ID</span></h5><hr>
<p>当希望把一个现有系统转换为分片数据存储时，经常会需要在多台机器上生成全局唯一ID。单一数据存储时通常可以使用AUTO_INCREMENT列来获取唯一ID。但涉及多台服务器时就不奏效了。以下几种方法可以解决这个问题</p>
<ul>
<li><p>使用auto_increment_increment 和  auto_increment_offset</p>
<p>  这两个服务器变量可以让MySQL以期望的值和偏移量来增加auto_increment列的值。列一个最简单的场景，只有两台服务器，可以配置这两台服务器自增幅度为2，其中一台的偏移量设置为1，另外一台为2。这样一台服务器总会包含偶数，另外一台总是包含奇数。这种这是可以配置到服务器的每一个表里。</p>
<p>  这种方法简单，并且不依赖于某个节点，因此是生成唯一ID的比较普遍的方法.但是这需要非常仔细的配置服务器。很容易因为配置错误生成重复数字，特别是当增加服务器需要改变其角色，或进行灾难恢复时。</p>
</li>
<li><p>全局节点中创建表</p>
<p>  在一个全局数据库节点中创建一个包含auto_increment的表，应用可以通过这个表来生成唯一数字</p>
</li>
<li><p>使用memcached</p>
<p>  在memcached中有个Incr()函数，可以自动增长一个数字并返回结果。或者redis</p>
</li>
<li><p>批量分配数字</p>
<p>  应用可以从一个全局节点中请求一批数字，用完后再申请。</p>
</li>
<li><p>使用复合值</p>
<p>  可以使用一个复合值来做唯一ID，例如分片号和自增数的组合</p>
</li>
<li><p>使用GUID值</p>
<p>  可以使用UUID()来生成全局唯一值.注意，尽管这个函数在基于语句的复制时不能正确复制，但可以先获得这个值，在存放到应用的内存中，然后作为数字在查询中使用。GUID的值很大并且不连续，因此不适合作为innodb表的主键。有一个函数UUID_SHORT()，能够生成连续的值，并使用64位代替了之前的128位。</p>
</li>
</ul>
<p>如果使用全局分配器来产生唯一ID，要注意避免单点争用成为应用的性能瓶颈。</p>
<p>memcached没有持久性。推荐redis。</p>
<h5><span id="14-分片工具">14. 分片工具</span></h5><hr>
<p>在设计数据分片应用时，首先要做的事情是编写能够查询多个数据源的代码。</p>
<p>如果没有任何抽象层，直接让应用访问多个数据源，那绝对是一个很差的设计，因为这会增加大量的编码复杂性。最好的办法是将数据源隐藏在抽象层中，这个抽象层主要完成以下任务：</p>
<ul>
<li>连接到正确的分片并执行查询</li>
<li>分布式一致性校验</li>
<li>跨分片结果集聚合</li>
<li>跨分片关联操作</li>
<li>锁和事务管理</li>
<li>创建新的数据分片并重新平衡分片</li>
</ul>
<p>sharding-jdbc，  hibernate-shard</p>
<h4><span id="通过多实例扩展">通过多实例扩展</span></h4><p>——————————</p>
<p>不要在一台性能强悍的服务器上只运行一个服务器实例，可以让数据分片足够小，以使每台机器上都能放置多个分片，每台服务器上运行多个实例，然后划分服务器的硬件资源，将其分配给每个实例。</p>
<p>这样做尽管比较繁琐，但确实有效。这是一种向上扩展和向外扩展你的组合方案。也可以用其他方法实现，不一定需要分片，但分片对于大型服务器上的了联合扩展具有天然的适应性。</p>
<p>虚拟化技术实现合并扩展的话，IO损耗非常惊人。性能下降很快</p>
<p>另一种选择是运行多个MySQL实例，每个实例监听不同的网络端口，或绑定到不同的IP地址.</p>
<p>有时候网络可能会成为瓶颈。可以通过使用多块网卡并进行绑定来解决这个问题。但linux内核可能会不理想，因为老的内核对每个绑定社保的网络中断只能使用一个CPU。因此不要把太多的连线绑定到很少的虚拟设备商，否则会遇到内核层的网络瓶颈。新的没事。</p>
<p>另一个方法是将每个MySQL实例绑定到特定的CPU核心上。有两点好处：第一，由于MySQL内部的可扩展性，当核心数较少时，能够在每个核心上获得更好的心梗。第二，当实例在多个核心上运行线程时，由于需要在多核心上同步数据，因而会有一些额外的开销。这可以避免硬件本身的可扩展性限制。限制MySQL到少数几个核心能能够帮助减少CPU核心之间的交互。注意到问题没？将进程绑定到具有相同物理套接字的核心上可以获得最优的效果。</p>
<h4><span id="通过集群扩展">通过集群扩展</span></h4><h4><span id="向内扩展">向内扩展</span></h4><hr>
<p>处理不断增长的数据和负载最简单的办法是对不再需要的数据进行归档和清理。这种操作可能会带来显著的成效，具体取决于工作负载和数据特性。这种做法并不用来代替其他策略，但可以作为争取时间的短期策略，也可以作为处理大数据量的长期计划之一。</p>
<p>设计归档和清理策略时需要考虑到如下几点：</p>
<ul>
<li><p>对应用的影响</p>
<p>  关键是能高效的找到要删除的行，然后一小块一小块的移除。通常需要平衡一次归档的行数和事务的大小，以找到一个锁竞争和事务负载量的平衡。还需要设计归档任务在必要的时候让步于事务处理</p>
</li>
<li><p>要归档的行</p>
<p>  在知道某些数据不再使用后，就可以立即清理或归档它们。也可以设计应用去归档哪些几乎不怎么使用的数据。可以把归档的数据置于核心表附近，通过视图来访问，或完全转移到别的服务器上。</p>
</li>
<li><p>维护数据一致性</p>
<p>  当数据存在联系时，会导致归档和清理工作更加复杂。一个设计良好的归档任务能够保证数据的逻辑一致性，或至少在应用需要时能够保证一致，而无须在大量事务中包含多个表</p>
<p>  当数据间存在联系时，哪个表首先归档是个问题。在归档时需要考虑孤立行的影响。可以选择违背外键约束（est foreign_key_checks=0）或者暂时吧悬空指针记录放到一边。如果应用层认为这些相关联的表有层次关系，那么归档的顺序也应该和它一样。例如，如果应用总是先检查订单再检查发货单，就先归档订单。应用应该看不到孤立的发货单，因此接下来就可以将发货单归档。</p>
</li>
<li><p>避免数据丢失</p>
<p>  如果是在服务器间归档，归档期间可能就无法做分布式事务处理，也有可能将数据归档到myisam或其他非事务型的存储引擎中。因此，为了避免数据丢失，也在从源表中删除时，要保证已经在目标机器上保存。将归档数据单独写到一个文件里也是个好主意。可以将归档任务设计为能够随时关闭或重启，并且不会引起不一致或索引冲突之类的错误。</p>
</li>
<li><p>解除归档</p>
<p>  可以通过一些解除归档策略来减少归档的数据量。它可以帮助你归档那些不确定是否需要的数据，并在以后可以通过选项进行回退。如果可以设置一些检查点让系统来检查是否有需要归档的数据，那么这应该是一个很容易实现的策略。例如，要对不活跃的用户进行归档，检查点就可以设置在登录验证时。如果因为用户不存在导致登录失败，可以去检查归档数据中是否存在该用户，如果有，则从中取出来并完成登录。</p>
</li>
</ul>
<p>保持活跃数据独立，即使并不真的把老数据转移到别的服务器，许多应用也能受益于活跃数据和非活跃数据的隔离。这有助于高效利用缓存，并为活跃的和不活跃的数据使用不同的硬件或应用架构。下面列举了几种做法：</p>
<ul>
<li><p>将表划分为几个部分</p>
<p>  分表，常用数据，小字段，一张表，明显改善内存利用率。</p>
</li>
<li><p>MySQL分区</p>
</li>
<li><p>基于时间的数据分区</p>
<p>  一般新数据比旧数据更加活跃。在两个节点的分片上存储用户数据，新数据总是进入活跃节点，该节点使用更大的内存和磁盘，另外一个节点存储旧数据，使用非常大但很缓慢的磁盘。对于很多应用而言这是合理的假设，依靠10%的数据满足90%的要求。可以通过动态分片来轻松实现。</p>
</li>
</ul>
<h3><span id="负载均衡">负载均衡</span></h3><hr>
<p>负载均衡的基本思路很简单：在一个服务器集群汇总尽可能的平均负载量。通常的做法是在服务器前端设置一个负载均衡器。然后负载均衡器将请求的连接路由到最空闲的可用服务器。</p>
<p>负载均衡有五个常见目的。</p>
<ul>
<li><p>可扩展性</p>
<p>  负载均衡对某些扩展策略有帮助，例如读写分离时从备库读数据。</p>
</li>
<li><p>高效性</p>
<p>  负载均衡有助于更有效的利用资源，因为它能够控制请求被路由到何处。如果服务器处理能力各不相同，这就尤为重要：你可以把更多的工作分配给性能更好的机器</p>
</li>
<li><p>可用性</p>
<p>  一个灵活的负载均衡解决方案能够使用时刻保持可用的服务器。</p>
</li>
<li><p>透明性</p>
<p>  客户端无需知道是否存在负载均衡设置，也不需要关心在负载均衡器的背后有多少机器，它们的名字是什么。负载均衡器给客户端看到的只是一个虚拟的服务器</p>
</li>
<li><p>一致性</p>
<p>  如果应用是有状态的（数据库事务，网站会话），那么负载均衡服务器就应将相关的查询指向同一个服务器，以防止状态丢失。应用无需去跟踪到底连接的是哪个服务器。</p>
</li>
</ul>
<p>MySQL里，负载均衡架构通常和数据分片和复制紧密相关。例如，可以再MySQL cluster集群的多个SQL节点上做负载均衡，也可以在多个数据中心间做负载均衡，其中每个数据中心又可以使用数据分片架构，每个节点实际上是拥有多个备库的主-主复制对结构，这里又可以做负载均衡。对于高可用性策略也同样如此：在一个架构里可以配置多层的故障转译机制。</p>
<p>负载均衡有许多微妙之处，举个栗子，其中一个挑战就是管理读/写策略。有些负载均衡技术本身能够实现这一点，但其他的需要应用自己知道哪些节点是刻度的或可写的。</p>
<h4><span id="直接连接">直接连接</span></h4><hr>
<p>有些人认为负载均衡就是配置在应用和MySQL服务器之间的东西。但这并不是唯一的负载均衡方法。你可以在保持应用和MySQL连接的情况下使用负载均衡。事实上，集中化的负载均衡系统只有存在一个对等值换的服务器池时才能很好工作。如果应用需要做一些决策，例如在备库上执行读操作是否安全，就需要直接连到服务器。</p>
<h5><span id="复制上的读写分离">复制上的读写分离</span></h5><hr>
<p>除了可能出现的一些特定逻辑，应用为负载均衡做决策是非常高效的。例如，如果有两个完全相同的备库，你可以选择在备库还是主库上执行查询。由于备库复制是异步的，因此主要的难点是如何处理备库上的脏数据。应该将备库用作只读的，而主库可以同时处理读和写查询。</p>
<p>通常需要修改应用以适应这种分离需求。然后应用就可以使用主库来进行写操作，并将读操作分配到主库和备库上；如果不太关心数据是否是脏的，可以使用备库，而对需要即时数据的请求使用主库。称之为读写分离。</p>
<p>如果使用的是主动-被动模式的主-主复制对，同样也需要考虑这个问题。使用这种配置时，只有主动服务器接受写操作。如果能够接受读到脏数据，可以将读分配给被动服务器</p>
<p>最大的问题是如何避免由于读了脏数据引起的奇怪问题。一个典型的例子是当一个用户做了某些修改，例如增加了一条博客文章的评论，然后重新加载页面，但并没有看到更新，因为应用从备库读取到了脏的数据。比较常见的读写分离方法如下：</p>
<ul>
<li><p>基于查询分离</p>
<p>  最简单分离方法是将所有不能容忍脏数据的读和写查询分配到主动或主库服务器上。该策略很容易实现，但是不实用，因为很少有查询能容忍脏数据</p>
</li>
<li><p>基于脏数据分离</p>
<p>  这是对基于查询分离方法的小改进。需要做一些额外的工作，让应用检查复制延迟，以确定备库数据是否太旧。许多报表类应用都使用这个策略，主需要晚上加载的数据复制到备库，它们并不关心是不是跟上了主库。</p>
</li>
<li><p>基于会话分离</p>
<p>  另一个决定能否从备库读数据的稍微复杂一点的方法是判断用户自己是否修改了数据。用户不需要看到其他用户的最新数据，但需要看到自己的更新。可以在会话层设计一个标记位，表名做了更新，就将该用户的查询在一段时间内总是指向主库。这是我们通常推荐的策略，因为他是在简单和有效性之间的一种很好的拖鞋。</p>
<p>  可以把基于会话的分离方法和复制延迟监控结合起来。如果用户在10秒前更新了数据，而所有备库延迟在5秒内，就可以安全地从备库中读取数据。但为整个会话选择同一个备库是一个很好的主意，否则用户可能会奇怪有些备库的更新速度比其他服务器要慢。</p>
</li>
<li><p>基于版本分离</p>
<p>  这和基于会话的分离方式相似：你可以跟踪对象的版本号或者时间戳，通过从备库读取对象的版本或时间戳来判断数据是否足够新。如果备库的数据太旧，可以从主库获取新的数据。即使对象本身没有变化，但如果是顶层对象，只要下面的任何对象有变化，也可以增加版本号，这简化了脏数据检查（只需要检查顶层对象一处就能判断是否有更新）。例如，在用户发表了一篇新文章后，可以更新用户的版本。这样就会从主库去读取数据</p>
</li>
<li><p>基于全局版本/会话分离</p>
<p>  这个办法是基于版本分离和基于会话分离的变种。当应用执行写操作时，在提交事务后，执行一次show master status操作。然后在缓存中存储主库日志坐标，作为被修改对象或者会话的版本号。当应用连接到备库时，执行show slave status并将备库上的坐标和缓存中的版本号相对比。如果备库相比记录点更新，就可以安全的读取备库数据。</p>
</li>
</ul>
<p>大多数读写分离都需要监控复制延迟来决策读查询的分配，不管是通过复制或负载均衡器，或者中间件。如果这么做，需要注意show slave status得到的seconds_behind_master列的值并不能准确的用于监控延迟。pt-heartbeat工具能够帮助监控延迟，并维护元数据，例如二进制日志位置，这可以减轻之前我们讨论的一些策略存在的问题。</p>
<p>如果不在不用昂贵的硬件来承载压力，就可以不使用复制来扩展读操作，这样当然更简单。这可以避免在主备上分离读的复杂性。有些人认为这很有意义；也有人认为会浪费硬件。这种分歧是由于不同的目的引起的：你是只需要可扩展性，还是要同时具有可扩展性和高利用率？如果需要高利用率，那么备库除了保存数据副本外还需要承担其他任务，就不得不处理这些额外的复杂度。</p>
<h5><span id="修改应用的配置">修改应用的配置</span></h5><hr>
<p>还有一个分发负载的方法是重新配置应用。例如，你可以配置多个机器来分担生成大报表操作的负载。每台机器可以配置成连接到不同的MySQL备库，并为第N个用户或网站生成报表。</p>
<p>这样的系统很容易实现，但如果需要修改一些代码，包括配置文件修改，就会变得非常脆弱且难以处理。硬编码有着固有的限制，需要在每台服务器上修改硬编码，或者在一个中心服务器上修改，然后通过文件副本或代码控制更新命令发布到其他服务器上。如果将配置存储在服务器或缓存中，就可以避免这些麻烦</p>
<h5><span id="修改dns名">修改DNS名</span></h5><hr>
<p>比较粗糙，最大的问题无法完全控制DNS</p>
<ul>
<li>修改DNS并不是立刻生效的，也不是原子的。将DNS的变化传递到整个网络或在网络间传播都需要比较长的时间</li>
<li>DNS数据会在各个地方缓存下来，它的过期时间是建议性质的而非强制的</li>
<li>可能需要应用或者服务器重启才能使修改后的DNS完全生效</li>
<li>多个IP地址共用一个DNS名并依赖于轮询行为来均衡请求，这并不是一个好主意。因为轮询行为并不总是可预知的</li>
<li>DBA可能没有权限直接访问DNS</li>
</ul>
<h5><span id="转移ip地址">转移IP地址</span></h5><hr>
<p>一个比较方便的技术是为每个物理服务器分配一个固定的IP地址。该IP地址固定在服务器上，不再改变。然后可以为每个逻辑上的服务使用一个虚拟IP地址。它们能够很方便的在服务器间转移，这使得转移服务和应用无需再重新配置应用。</p>
<h4><span id="引入中间件">引入中间件</span></h4><hr>
<p>最靠谱的方法</p>
<ul>
<li>负载均衡器</li>
<li>负载均衡算法</li>
<li>在服务池中增加/移除服务器</li>
</ul>
<h3><span id="一主多备间的负载均衡">一主多备间的负载均衡</span></h3><hr>
<p>最常见的就是一个主库加多个备库。</p>
<ul>
<li><p>功能分区</p>
<p>  对于特定的目的可以通过配置备库或一组备库来极大的扩展容量。一些比较常见的功能包括报表、分析、数据昂库，以及全文检索</p>
</li>
<li><p>过滤和数据分区</p>
<p>  可以使用复制过滤技术在相似的备库上对数据做分区。只要数据在主库上已经被隔离到不同的数据库或表中，这种方法就可以奏效。不幸的是，没有内建的办法在行级别上进行复制过滤。需要使用一些独创的技术来实现，例如触发器和一组不同的表。</p>
<p>  即使不把数据分区到各个备库上，也可以通过对读进行分区而不是随机分配来提高缓存效率。例如，可以把对以字母A-M开头的用户名的读操作分配给一个给定的备库，把以N-Z开头的分配给另外一个。者能够更好的利用每台机器的缓存，因为分离读更可能在缓存中找到相关的数据。最好的情况下，当没有写操作时，这样是用的缓存相当于两台服务器缓存的综合。相比之下，如果随机的在备库上分配读操作，每个机器的缓存本质上还是重复的数据，而总的有效缓存效率和一个备库缓存一样，不管有多少台备库</p>
</li>
<li><p>将部分写操作转移到备库</p>
<p>  主库并不总是需要处理写操作中的所有工作，它需要知道数据处于哪个时间点，哪怕需要等待一会才能到达这个点，可以使用函数master_pos_wait()阻塞知道备库赶上了设置的主库同步点。另一种替代方案是使用复制心跳来检查延迟情况。</p>
</li>
<li><p>同步写操作</p>
<p>  也可以使用master_post_wait()函数来确保写操作已经被同步到一个或多个备库上。如果应用需要模拟同步复制来保证数据安全性，就可以在多个备库上轮流执行master_pos_wait()函数。这就类似创建了一个同步屏障，当任意一个备库出现复制延迟时，都可能花费很长时间完成，所以最好在确实需要的时候才使用这种方法。（如果你的目的知识确保某些备库拥有时间，可以只等待一台备库接收到时间。MySQL增加了半同步复制，可以支持）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高级特性</title>
    <url>/2020/12/31/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/5-MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<ol>
<li><p>分区表</p>
<p> 对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。所以分区对于SQL层爱说是一个完全封装底层实现的黑盒，对应用是透明的，但是从底层的文件系统来看就很容易发现，每一个分区表都有一个使用#分割命名的表空间。</p>
<p> MySQL在创建表时使用PARTITION BY 子句定义每个分区存放的数据。在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区——只需要查找包含需要数据的分区就可以了。</p>
<p> 分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中。这样做科技将相关的数据存放在一起，另外，如果想一次批量删除整个分区的数据也会变得方面。下面的场景中，分区可以起到非常大的作用。</p>
<ul>
<li>表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。</li>
<li>分区表的数据更容易维护。例如，想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作</li>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li>
<li>可以使用分区表来避免某些特殊的瓶颈，例如innodb的单个索引的互斥访问、ext3文件系统的inode锁竞争等。</li>
<li><p>如果需要，还可以备份和恢复独立的分区，这在非常大的数据集下的场景下效果非常好</p>
<p>分区的一些限制：</p>
</li>
<li><p>一个表最多只能有1024个分区</p>
</li>
<li>MySQL5.1中，分区表达式必须是证书买或者是返回整数的表达式。在MySQL5.5中，某些场景汇总可以直接使用列来进行分区。</li>
<li>如果分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li>
<li>分区表中无法使用外键约束</li>
</ul>
</li>
</ol><a id="more"></a>
<p>1.1 分区表的原理</p>
<p>分区表由多个相关的底层表实现，这些底层表由句柄对（Handler object）表示，所以我们也可以直接访问各分区。存储引擎管理分区的各个底层表和管理普通表一样（有的底层表都必须使用相同的存储引擎），分区表的索引知在各个底层表上各自加上一个完全相同的索引。<br>分区表操作的逻辑如下：</p>
<p><strong>select查询</strong><br>当查询一个分区表的时候，分区层先打开并锁住所有的底表，优化器先判断是否可以过滤部分分区，然后在调用对应存储引擎接口访问各个分区的数据。</p>
<p><strong>insert操作</strong><br>当写入一条记录时，分区层先打开并锁住所有的底层表，然确定那个分区接收这条记录，再将记录写入对应底层表。</p>
<p><strong>delete操作</strong><br>当写入一条记录时，分区层先打开并锁住所有的底层表，然确定数据对应的分区，最后对底层表进行删除操</p>
<p><strong>update操作</strong><br>当写入一条记录时，分区层先打开并锁住所有的底层表MySQL先确定需要更新的记录在哪个分区，然后取出数据并新，再判断更新后的数据应该放在哪个分区，最后对底层表行写入操作，并对原数据所在的底层表进行删除操作。</p>
<p>有些操作是支持过滤的。例如，当删除一条记录时，MySQL要先找到这条记录，如果where条件恰好和分区表达式匹配就可以将所有不包含这条记录的分区都过滤掉。针对udpat语句同样有效。如果是insert操作，则本身就是知名中一分区，其他分区都会被过滤掉。MySQL先确定这条记录属于个分区，然后再将记录写入对应的底层分区表，无需对任何他分区进行操作。</p>
<p>如果存储引擎能够自己实现行级锁，则会在分区层释放对应表锁。</p>
<p>1.2 分区表的类型</p>
<p>支持多种分区表，最多的是根据范围进行分区，每个分区存储落在某个范围的记录，分区表达式可以是列，也可以使包含列的表达式，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sales(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    order_date datetime <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">RANGE</span> (<span class="keyword">year</span>(order_date))(</span><br><span class="line">    <span class="keyword">partition</span> p_2010 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2010</span>),</span><br><span class="line">    <span class="keyword">partition</span> p_2011 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2011</span>),</span><br><span class="line">    <span class="keyword">partition</span> p_2012 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2012</span>),</span><br><span class="line">    <span class="keyword">partition</span> P_catchall <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>partition分区子句中可以使用各种函数。但是有一个要求，表达式返回的值要是一个确定的正数，而不能是一个常数。根据时间间隔进行分区，是一种很常见的分区方式。</p>
<p>MySQL还支持键值、哈希和列表分区，这其中还有些支持子分区，不生产环境中很少见到。</p>
<p>1.3 如何使用分区表</p>
<p>假设我们希望从一个非常大的表中查询出一段时间的记录，而这个表中包含了很多年的历史数据，数据是按照时间排序的，例如，希望查询最近几个月的数据，这大约有10亿条记录，而原表中有10TB的数据，这个数据量远大于内存，并确实用的是传统硬盘。</p>
<p>首先很肯定：<strong>因为数据量巨大，肯定不嗯给你在每次查询的时候都扫描全表</strong>。考虑到索引在空间和维护上的消耗，也不希望使用索引。即使真的使用索引，会发现数据并不是按照想要的方式聚集的，而且会有大量的碎片产生，最终会导致一个查询产生成千上万的随机IO，应用程序也随之僵死。情况好一点的时候，也许可以通过一两个索引结局一些问题。不过多数情况下，索引不会有任何作用。这时候只有两条路可选：**让所有的查询都只在数据表上做顺序扫描，或者将数据表和索引全部缓存在内存里。</p>
<p><strong>在数据量超大的时候，b-tree索引就无法起作用了</strong>。除非是索引覆盖查询，否则数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，如果数据量巨大，者将产生大量随机IO，随之，数据库的响应时间将大刀不可接受的程度。另外，索引维护（磁盘空间，IO操作）的代价也非常高。</p>
<p>分区可以当做索引的最初形态，以代价非常小的方式定位到需要的数据在哪一片区域，在这片区域中，可以做顺序扫描，可以做索引，还可以将数据全都缓存到内存，等等。因为分区无需额外的数据结构记录每个分区有哪些数据，分区不需要正确定位每套数据的位置，也就无需额外的数据结构，所以代价非常低，只需要一个简单的表达式就可以表达每个分区存放的是什么数据。</p>
<p>为了保证大数据量的可扩展性，一般有下面两个策略：</p>
<ul>
<li><p>全量扫描数据，不要任何索引</p>
<p>  可以使用简单的分区方式存放表，不要任何索引，根据分区的规则大致定位需要的数据位置。只要能使用where条件，将需要的数据限制在少数分区中，则效率是很高的。当然，也需要做一些简单的运算保证查询的响应时间能够满足需求。使用该策略假设不用将数据完全放入到内存中，同时还假设需要的数据全都在硬盘上，因为内存相对很小，数据很快会被挤出内存，索引缓存起不了任何作用。这个策略适用于已正常的方式访问大量数据的时候。警告：必须将查询需要扫描的分区个数限制在一个很小的数量。</p>
</li>
<li><p>索引数据，并分离热点</p>
<p>  如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效地使用缓存。</p>
</li>
</ul>
<p>1.4 什么情况下会出问题</p>
<ul>
<li><p>null值会使分区过滤无效</p>
<p>  分区表达式不能为null，如果为null或者是一个非法值的时候，记录都会被存放到第一个分区，然后MySQL会同时检查两个分区。5.5以后可以直接基于列进行分区。</p>
</li>
<li><p>分区列和索引不匹配</p>
<p>  如果定义的索引和分区列不匹配，会导致查询无法进行分区锅炉工。假设在列a上定义了索引，而在列b上进行分区。因为每个分区都有其独立的索引，所以扫描列上的索引就需要扫描每一个分区对应的宿营。如果每个分区内对应缩影的飞叶子节点都会在内存中，那么扫描的速度还可以接收，如果能跳过某些分区索引当然会更好。要避免这个问题，应该避免简历和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。</p>
<p>  听起来避免这个问题很简单，不过有时候也会遇到一些意想不到的问题。例如，在一个关联查询中，分区表在管理按顺序中是第二个表，并且关联使用的索引和分区条件不匹配。那么关联时对第一个IE表符合条件的每一行，都需要访问并搜索第二个表的所有分区。</p>
</li>
<li><p>选择分区的成本可能很高</p>
<p>  不同类型分区的实现方式不同，性能也不同。尤其是范围分区，对于回答这一行属于哪个分区、这些符合查询条件的分区的行在哪些分区这样的问题的成本可能会非常高，因为服务器需要扫描所有的分区定义的列表来找到正确的答案。类似这样的线性搜索的效率不高，所以随着分区数的增长，成本会越来越高。</p>
<p>  示例：按行写入大量数据的时候，每写入一行数据到范围分区的表时，都需要扫描分区定义列表来找到合适的目标分区。可以通过限制分区的数量来缓解此问题，大多数系统来说，100个左右的分区毫无问题。</p>
</li>
<li><p>打开并锁住所有底层表的成本可能很高</p>
<p>  当查询访问分区表的时候，MySQL需要打开并锁柱所有的底层表，这是分区表的另一个开销。这个开销也在分区过滤之前发生，所以无法通过分区过滤降低此开销，并且该开销也和分区类型无关，会影响所有的查询。这一点对一些本身操作非常快的查询，比如根据主键查找单行，会带来明显的额外开销。可以用批量操作的方式来降低单个操作的此类开销，比如使用批量插入或者load data infile，一次删除多行数据等等，淡然爱过同时还是要限制分区的个数</p>
</li>
<li><p>维护分区的成本可能很高</p>
<p>  某些分区维护操作的速度会非常快，例如新增或删除分区。而有些操作，例如重组分区或者类似alter语句的操作：这类操作需要复制数据。重组分区的原理与alter类似，县创建一个临时的分区，然后将数据复制到其中，随后在删除原分区。</p>
</li>
</ul>
<p>分区不是”银弹”，下面是目前分区实现中的一些其他限制：</p>
<ul>
<li>所有分区都必须使用相同的存储引擎</li>
<li>分区函数中可以使用的函数和表达式也有一些限制</li>
<li>某些存储引擎不支持分区</li>
<li>对于myisam的分区表，不能使用load index info cache操作</li>
<li>对于myisam的表，使用分区表时需要打开更多的文件描述符。虽然看起来是一个表，但是背后有很多独立的分区，每一个分区对于存储引擎来说都是一个独立的表。这样即使分区表只占用一个表缓存条目，文件描述符还是需要多个。因此，即使已经配置了合适的表缓存，以确保不会超过操作系统的单个进程可以打开的文件描述符的个数，但对于分区表而言，还是会出现文件描述符限制的问题。</li>
</ul>
<p>1.5 查询优化</p>
<p>对于分区表来说，很重要的一点就是要在where条件中带入分区列。这样可以让优化器能够过滤掉无需访问的分区。如果没有这些条件，MySQL就需要让对应存储引擎访问这个表的所有分区，如果表非常大的话，就肯能会非常慢</p>
<p>1.6 合并表</p>
<p>不写了， 未来会被删除</p>
<ol>
<li>视图</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> Oceania <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> Continent = <span class="string">'Oceania'</span> <span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span> ;</span><br></pre></td></tr></table></figure>
<p>实现视图最简单的方法就是将select语句的结果存放到临时表中。当需要访问视图的时候，直接访问这个临时表就可以了，看下面的查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Oceania <span class="keyword">where</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure>
<p>下面是使用临时表来模拟视图的方法，这里临时表的名字是为演示用的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> TMP_Oceania_123 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> Continent = <span class="string">'Oceania'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> code,<span class="keyword">name</span> <span class="keyword">from</span> TMP_Oceania_123 <span class="keyword">where</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure>
<p>这样做会有明显的性能问题，优化器也很难优化在这个临时表上的查询。实现视图更好的方法是，重写含有视图的查询，将视图的定义SQL直接包含进查询的SQL中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> code,<span class="keyword">name</span> <span class="keyword">from</span> country <span class="keyword">where</span> Continent = <span class="string">'Oceania'</span> <span class="keyword">and</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure>
<p>MySQL可以使用这两种办法的任何一种来处理视图。这两种算法分别被称为<strong>合并算法（Merge）和临时表算法（Temptable）</strong>，如果可能，会尽可能的使用合并算法。MySQL甚至可以嵌套地定义视图，也就是在一个视图上再定义另一个视图。可以再explain extended 之后使用 show warnings来查看使用视图的查询重写后的结果。</p>
<p>如果视图中包含group by 、 distinct、任何聚合函数、union、子查询等，只要无法在原表记录和视图记录中建立一一映射的场景中，MySQL都将使用临时表算法来实现视图。如果想确定MySQL到底是使用合并算法还是临时表算法，可以explain一条针对视图的简单查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> TMP_Oceania_123;</span><br></pre></td></tr></table></figure>
<p>如果这里的select_type为DERIVED，说明该视图是采用临时表算法实现的。视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> algorithm = temptable <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> v1;</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+</span></span><br><span class="line">|id|select_type|table     |partitions|type|possible_keys|key |key_len|ref |rows|filtered|Extra|</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+</span></span><br><span class="line">|1 |PRIMARY    |&lt;derived2&gt;|NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |</span><br><span class="line">|2 |DERIVED    |actor     |NULL      |ALL |NULL         |NULL|NULL   |NULL|200 |100     |NULL |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>
<p>实现该视图的SQL本身并不需要临时表，但基于盖世兔无论执行什么样的查询，视图都会生成一个临时表。</p>
<p>2.1 可更新视图</p>
<p>可更新视图（updatable view）是指可以通过更新这个视图来更新视图涉及的相关表。只要制定了合适的条件，就可以更新、删除甚至向视图中写入数据。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> oceanic <span class="keyword">set</span> population = population *<span class="number">1.1</span> <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'Australia'</span></span><br></pre></td></tr></table></figure>
<p>如果视图定义中包含了group by , union , 聚合函数，以及其他一些特殊情况，就不能被更新了。更新视图的查询也可以是一个关联语句，但是有一个限制，被更新的列必须来自同一个表中。另外，所有使用临时表算法实现的视图都无法被更新。</p>
<p>2.2 视图对性能的影响，总的来说是不推荐使用</p>
<p>2.3 视图的限制</p>
<p>MySQL不支持物化视图，也不支持在视图中创建索引。也无法通过 show create view 查看视图创建的原始SQL语句</p>
<ol>
<li>外键约束</li>
</ol>
<p>innodb是MySQL中唯一支持外间的内置存储引擎。</p>
<p>使用外键是有成本的。比如外键通常都要求每次在修改数据时都要在另外一张表中多执行一次查找操作。虽然innodb强制外键使用索引，但还是无法消除这种约束检查的开销。如果外键列的选择性很低，泽会导致一个非常大且选择性很低的索引。例如，在一个非常大的表上有status列，并希望限制这个状态列的取值，如果该列只能取三个值，虽然这个列本身很小，但是如果主键很大，那么这个索引就会很大，而且这个所引出了做这个外键限制，也没有其他任何的作用。</p>
<p>不过，在某些场景下，外键会提升一些性能。如果想确保两个相关表始终有一致的数据，那么使用外键比在应用程序中检查一致性的性能要高得多，此外，外键在相关数据的删除和更欣赏，也比在应用中维护要更高效，不过，外键维护操作时逐行进行的，所以这样的更新会比批量删除和更新要慢一些。</p>
<p>外键约束使得查询需要额外访问一些别的表，这也意味着需要额外的锁。如果向子表中写入一条记录，外键约束会让innodb检查对应的父表的记录，也就需要对父表对应记录进行枷锁操作，来确保这条记录不会在这个事务完成之时就被删除了。这会导致额外的锁等待，甚至会导致一些死锁。因为没有直接访问这些表，所以这类死锁问题往往难以排查。</p>
<p>如果只是用外键做约束，那么通常在应用程序里实现约束会更好。外键会带来很大的额外消耗，这里没有相关的基准测试的数据，不过有很多案例，发现外键约束就是瓶颈所在，删除外键后性能立即大幅提升。</p>
<ol>
<li>在MySQL内部存储代码</li>
</ol>
<p>优点有：</p>
<ul>
<li>它在服务器内部执行，离数据最近，另外在服务器上执行还可以节省贷款和网络延迟。</li>
<li>这是一种代码重用。可以方便地统一业务规则，保证某些行为总是一致，所以也可以为应用提供一定的安全性</li>
<li>它可以简化代码的维护和版本更新</li>
<li>他可以帮助提升安全，比如提供更细粒度的权限控制。一个常见的例子是银行用于转移资金的存储过程：这个存储过程可以在一个事务中完成资金转移和记录用于审计的日志。应用程序也可以通过存储过程的接口访问那些没有权限的表。</li>
<li>服务器端可以缓存存储过程的执行计划，这对于需要反复调用的过程，会大大降低消耗。</li>
<li>因为是在服务器端部署的，所以备份，维护都可以在服务器端完成。索引存储程序的维护工作会很简单。它没有什么外部依赖，例如，不依赖任何Perl包和其他不想在服务器上部署的外部软件</li>
<li>他可以在应用开发和数据库开发人员之间更好的分工。不过最好是由数据库专家来开发存储过程，因为不是每个应用开发人员都能写出高效的SQL查询。</li>
</ul>
<p>缺点有：</p>
<ul>
<li>MySQL本身没有提供好用的开发和调试工具，所以写起来要难一些</li>
<li>存储代码效率要稍微差一些，使用的函数有限，所以也很难编写复杂的字符串维护功能，也很难实现太复杂的逻辑</li>
<li>存储代码可能会给应用程序代码的部署带来额外的复杂性。原本只需要部署应用代码和库表结构变更，现在还需要额外地部署MySQL内部的存储代码</li>
<li>因为存储程序都部署在服务器内，所以可能有安全隐患。如果将非标准的加密功能放在存储程序中，那么若是数据库被攻破，数据也就泄露了。但是若将加密函数放在应用程序代码中，那么攻击者必须同时攻破程序和数据库才能获得数据</li>
<li>存储过程会给数据库服务器增加额外的压力，而数据库服务器的扩展性相比应用服务器要差很多</li>
<li>MySQL并没有什么选项可以控制存储程序的资源消耗，所以在存储过程中的一个小错误，可能直接把服务器拖死</li>
<li>存储代码在MySQL中的实现也有很多限制，执行计划缓存是连接级别的，游标的物化和临时表相同，在MySQL5.5版本之前，异常处理也非常困难，等等。</li>
<li>调试MySQL的存储过程是一件很困那的事情。</li>
<li>它和基于语句的二进制日志复制合作的并不好。在基于语句的复制中，使用存储代码有很多的坑</li>
</ul>
<p>4.1 存储过程和函数</p>
<p>存储过程在替代很多小查询的时候要快很多，因为查询很小，相对于查询执行的成本，解析和网络开销就变得非常明显。存储过程无需网络通信开销、解析开销和优化器开销等。</p>
<p>4.2 触发器</p>
<p>可以减少客户端和服务器之间的通信。需要注意一下几点</p>
<ul>
<li>对每一个表的每一个事件，最多只能定义一个触发器（也就是说，不能再after insert 上定义两个触发器）</li>
<li>MySQL只支持基于行的触发，也就是受，触发器始终是针对一条记录的，而不是针对整个SQL语句的。如果变更的数据集非常大的话，效率会很低。</li>
<li>触发器可以掩盖服务器背后的工作，一个简单的SQL语句背后，因为触发器，可能包含了很多看不见的工作。例如，触发器可能会更新另一个相关表，那么这个触发器会让这条SQL影响的记录数翻一倍</li>
<li>触发器的问题也很难排查，如果某个性能问题和触发器相关，会很难分析和定位。</li>
<li>触发器可能导致死锁和锁等待。如果触发器失败，那么原来的SQL语句也会失败。如果没有意识到这其中是触发器在搞鬼，那么很难理解服务器抛出的错误代码时什么意思</li>
</ul>
<p>如果只考虑性能，那么MySQL触发器的实现中，对服务器限制最大的就是它的基于行的触发设置。因为性能的原因，很多时候无法使用触发器来维护汇总和缓存表。使用触发器而不是批量更新的一个原因就是，使用触发器可以保证数据总是一致的。</p>
<p>innodb的触发器是在同一个事务中完成的，所以它们的操作是原子的，原操作和触发器操作会同时失败或者成功。不过，如果再innodb表上建立触发器去检查数据的一致性，要特别小心MVCC，稍不小心，可能会获得错误的结果。假设，想实现外键约束，但是不打算使用innodb的外键约束，打算编写一个before insert触发器来检查写入的数据对应列在另一个表中是存在的，但是若你在触发器中没有使用select for update，那么并发的更新语句可能会立刻更新对应记录，导致数据不一致。</p>
<ol>
<li>游标</li>
</ol>
<p>MySQL在服务端能提供只读的、单向的游标，而且只能在存储过程或者更底层的客户端API中使用。因为MySQL游标中指向的对象都是存储在临时表中而不是实际查询到的数据，所以MySQL游标总是只读的。它可以逐行指向查询结果，然后让程序做进一步的处理。在一个存储过程中，可以有多个游标，也可以在循环中嵌套地使用游标。</p>
<p>因为游标是使用临时表实现的，所以在效率上给开发人员一个错觉。需要记住的一点是，当打开一个游标的时候，需要执行整个查询。看下面的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> bad_cursor()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> film_id <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> f <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> film_id <span class="keyword">from</span> film;</span><br><span class="line">    open f;</span><br><span class="line">    fetch f into film_id;</span><br><span class="line">    close f;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子可以看到，不用处理完所有的数据就可以立刻返回游标。在MySQL中，会带来很多的不必要的额外操作。使用show status诊断这个存储过程，可以看到它需要做1000个索引页的读取，做1000个写入。这是因为在表film中有1000条记录，而这些读和写都发生在第五行的打开游标动作。</p>
<p>如果在关闭游标的时候，只是扫描一个大结果集的一小部分，那么存储过程可能不仅没有减少开销，相反带来了大量的额外开销。这时，你需要考虑使用limit来限制返回的结果集。</p>
<p>游标也会让MySQL执行一些额外的IO操作，而这些操作的效率可能非常低。因为临时内存表不支持blob和text类型，如果游标返回的结果包含这样的列的话，MySQL就必须创建临时磁盘表来存放，这样性能可能会很糟。即使没有这样的列，当临时表大于tmp_table_size的时候，MySQL还是会在磁盘上创建临时表。</p>
<p>MySQL不支持客户端的游标，不过客户端API可以通过缓存全部查询结果的方式模拟客户端的游标.这和直接将结果放在一个内存数组中来维护并没有什么不同。</p>
<ol>
<li>字符集和校对</li>
</ol>
<p><strong>只有基于字符的值真正的有字腹肌的概念。</strong>对其他类型的值，字符集只是一个设置，指定用哪一种字符集来比较或者其他操作。基于字符的值能存在某列中、某查询的字段中、表达式的计算结果中或者某个用户变量中，等等。</p>
<p>MySQL的设置可以分为两类：创建对象时的默认值、在服务器和客户端通信时的设置。</p>
<p>MySQL服务器有默认的字符集和校对规则，每个数据库也有自己的默认值，每个表也有自己的默认值。这是一个逐层继承的默认设置，最终最靠底层的默认设置将影响你创建的对象，这些默认值，自上而下的告诉MySQL应该使用什么字符集来存储某个列。</p>
<ul>
<li>创建数据库的时候，将根据服务器上的character_set_server来指定该数据库的默认字符集</li>
<li>创建表的时候，将根据数据库的字符集设置指定这个表的字符集设置</li>
<li>创建列的时候，将根据标的设置指定列的字符集设置</li>
</ul>
<p>需要记住的是，真正存放数据的事列，所以更高阶梯的设置只是指定默认值。一个表的默认字符集设置无法影响存储在这个表中某个列的值。只有当创建列而美欧为列指定字符集的时候，如果没有指定字符集，表的默认字符集才有作用。</p>
<p>当服务器和客户端通信的时候，它们可能使用不同的字符集。这时，服务器端将进行必要的翻译转换工作：</p>
<ul>
<li>服务器端总是假设客户端是按照character_set_client设置的字符来传输数据和SQL语句的.</li>
<li>当服务器收到客户端的SQL语句时，它先将其转换成自负其character_set_connection。它还是用这个设置来决定如何将数据转换成字符串</li>
<li>当服务器端返回数据或者错误信息给客户端时，它会将其转换成character_set_result。</li>
</ul>
<p><strong>MySQL如何比较两个字符串的大小</strong></p>
<p>如果比较的两个字符串的字符集不同，MySQL会先将其转成同一个字符集再进行比较。如果两个字符集不兼容的话，则会抛出错误。这种情况下需要通过函数convert()显式地将其中一个字符串的字符集转成一个兼容的字符集。MySQL5.0经常会有这样的隐式转换。</p>
<p>还可以使用前缀和collate子句来制定字符串的字符集或校对字符集。例如，下面的实例中使用了前缀来指定字符集，还使用了collate子句制定了使用二进制校对规则：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> _utf8 <span class="string">'hello world'</span> <span class="keyword">collate</span> utf8_bin;</span><br></pre></td></tr></table></figure>
<p>一些特殊情况</p>
<ul>
<li><p>诡异的character_set_database设置</p>
<p>  当使用load data infile的时候，数据库总是将文件中的字符按照字符集aharacter_set_database来解析。在MySQL5.0之后，可以再load file infile 中使用子句character set来设定字符集，不过最好不要依赖这个设定。我们发现使用字符集最好的方式是先试用use 指定数据库，在执行 set names 来设定字符集，最后再夹在数据。MySQL在夹在数据的时候，总是以同样的字符集处理所有数据，而不管表中的列是否有不同的字符集设定</p>
</li>
<li><p>select into outfile</p>
<p>  MySQL会将select into outfile的结果不做任何转码写入文件。目前除了使用函数convert()将所有的列都做一次换吗外，还没有什么办法可以指定输出的字符集。</p>
</li>
<li><p>嵌入式转义序列</p>
<p>  MySQL会根据character_set_client的设置来解析转义序列，即使是字符串中包含前缀或者collate子句也一样。这是因为解析器在处理字符串中的转义字符时，完全不关心校对规则，对于解析器来说，前缀并不是一个指定，他只是一个关键字而已。</p>
</li>
</ul>
<p><strong>字符集和校对规则</strong></p>
<p>可以使用命令show characterset 和 show collation 来查看MySQL支持的字符集和校对规则。</p>
<p>对于校对规则通常需要考虑的一个问题是，是否已大小写敏感的方式比较字符串，或者是以字符串编码的二进制值来比较大小。它们对应的校对规则的前缀分别是_cs、_ci和_bin，根据需要很容易选择。大小写敏感和二进制校对规则的不同之处在于，二进制校对规则直接使用字符的字节进行比较，而大小写敏感的校对规则在多字节字符集时，比如德语，有更复杂的比较规则。</p>
<p><strong>字符集和校对规则如何影响查询</strong></p>
<p>不同的字符集和校对规则之间的转换可能会带来额外的系统开销。例如，film在列title上有索引，可以加速下面的order by 查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> title ,release_year <span class="keyword">from</span> sakila.film <span class="keyword">order</span> <span class="keyword">by</span> title;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> title <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">collate</span> utf8mb4_bin;</span><br></pre></td></tr></table></figure>
<p>只有排序要求的字符集和服务器数据的字符集相同的时候，才能使用索引进行排序。索引根据数据列的校对规则进行排序，这里使用的是utf8_general_ci。如果希望使用别的校对规则进行排序，那么MySQL就需要使用文件排序。MySQL8测试发现，依然使用了索引</p>
<p>为了能够适应各种字符集，包括客户端字符集、在查询中显式指定的字符集，MySQL会在需要的时候进行字符集转换。例如，当使用两个字符集不同的列来关联两个表的时候，MySQL会尝试转换其中一个列的字符集。这和在数据列外面风装一个函数一样，会让MySQL无法使用这个列上的索引。如果你不确定MySQL内部是否做了这种转换，可以再explain extended 后使用show warnings来查看MySQL是如何处理的。丛输出中可以看到查询中使用的字符集，也可以看到MySQL是否做了字符集转换操作。</p>
<p>UTF-8是一种多字节编码,它存储一个字符会使用变长的字节数，在MySQL内部，通常使用一个定长的空间来存储字符串，再进行相关操作，这样做的目的是希望总是保证缓存中有足够的空间来存储字符串。例如，一个编码是utf8的char(10)需要30个字节，即使最终存储的时候没有存储任何多字节字符串也是一样。变长的字段类型存储在磁盘上时不会有这个困扰，但是当它存储在临时表中或者用来处理排序时，也总是会分配最大可能的长度。</p>
<p>在多字节字符集众，一个字符不再是一个字节。所以，在MySQL中有两个函数length 和 char_length来计算字符串的长度，在多字节字符集众，这两个函数的返回结果会不同。如果是用的是多字节字符集，那么确保在统计字符集的时候使用char_length。</p>
<p>还有个地方是索引方面：<strong>如果要索引一个UTF8字符集的列，MySQL会假定每一个字符都是三个字节，所以最长索引前缀的限制一下缩短到原来的三分之一了</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> big_string(</span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">varchar</span>(<span class="number">500</span>),</span><br><span class="line">    <span class="keyword">key</span>(<span class="keyword">str</span>)</span><br><span class="line">)<span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span> ;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> big_string;</span><br></pre></td></tr></table></figure>
<p>得了，MySQL 8 中，没有复现，说明这些问题已经被修复</p>
<ol>
<li>分布式事务</li>
</ol>
<p>XA事务，需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）。如果协调器收到所有的参与者都准备好的消息，就会告诉所有的事务可以提交了，这是第二阶段。MySQL在这个XA事务中扮演的是一个参与者的角色，而不是协调者。</p>
<p>实际上，MySQL中有两种XA事务。一方面，MySQL可以参与到外部的分布式事务中；另一方面，还可以通过XA事务来协调存储引擎和二进制日志。</p>
<p>TODO，从其他地方找资料进行补充吧。</p>
<ol>
<li>查询缓存</li>
</ol>
<p>MySQL查询缓存保存查询返回的完整结果。当查询命中该缓存，MySQL会立即返回结果，跳过了解析。优化和执行阶段。</p>
<p>查询缓存系统会追踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的查询缓存都将失效。这种机制效率看起来比较低，因为数据表变化时很有可能对应的查询结果并没有变更，但是这种简单实现代价很小， 而这点对于一个非常繁忙的系统来说非常重要。</p>
<p>查询缓存对应用程序是完全透明的。应用程序无需关心MySQL是通过查询缓存返回的结果还是实际执行返回的结果。事实上，这两种方式执行的结果是万全县通的。换句话说，查询缓存无需使用任何语法。无论是MySQL开启或者关闭查询缓存，对应用程序都是透明的。</p>
<p><strong>MySQL如何判断缓存命中</strong></p>
<p>MySQL判断缓存命中的方法很简单，缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了如下引入，即查询本身，当前要查询的数据库，客户端协议的版本等一些其他可能会影响返回结果的信息。</p>
<p>当判断查询缓存是否命中时，MySQL不会解析、正规化或者参数化查询语句，而是直接使用Sql语句和客户端发送过来的其他原始因袭。任何兹附上的不同，空格，注释，任何的不同都会导致缓存的不命中。所以在编写SQL语句的时候，需要特别注意这一点。通常使用同一个编码规则是一个好的习惯，在这这个好习惯会让你的系统运行的更快。</p>
<p>当查询语句中有一些不确定的数据时，则不会被缓存，例如包含函数NOW或者current_date的查询不会被虎啊黁从。类似的，一些语句会根据不同的用户返回不同的结果，所以也不会被缓存。事实上，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql中的系统表，或者包含列级别权限的表，都不会被缓存。</p>
<p>查询缓存是在完整的select语句基础上的。很多时候可以提升查询性能，但是使用的时候，有一些问题需要特别注意。首先，打开查询缓存对度和谐操作都会带来额外的消耗：</p>
<ul>
<li>读查询在开始之前必须先检查是否命中缓存。</li>
<li>如果这个读查询可以被缓存，那么当完成执行后，MySQL若发现查询缓存中没有个这个查询，会将其结果存储查询缓存，这会带来额外的系统消耗</li>
<li>这对写操作也会有影响，因为当向某个表写入数据的时候，MySQL必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就可能会带来很大的系统消耗</li>
</ul>
<p>innodb使用了多版本特性事务，会限制查询缓存的使用</p>
<p><strong>查询缓存如何使用内存</strong></p>
<p>查询缓存是完全存储在内存中的没所以在配置和使用它之前，我们需要先了解它是如何使用内存的。除了查询结果之外，需要缓存的还有很多别的维护相关的数据。这和文件系统有些类似，徐亚一些内存专门用来确定哪些内存目前是可用的，哪些是已经用掉的，哪些用来存储数据表和查询结果之前的映射。哪些用来存储查询字符串和查询结果。</p>
<p>这些基本的管理维护数据结构大概需要40KB的内存资源，除此之外，MySQL用于查询缓存的内存被分为一个个的数据块，数据块是变长的。每一个数据库奥众存储了自己的类型、大小和存储的数据本身，还外加直向前一个和后一个数据块的指针，数据块的类型有，内UN查询将诶过，存储查询和数据表的映射，存储查询文本，等等。不同的存储块，在内存使用上并没有什么不同，从用户角度看无需区分。</p>
<p>当服务器启动的时候，它先初始化查询缓存需要的内存。这个内存池初始是一个完整的空闲块。这个空闲块的大小就是你所配置的查询缓存大小再减去用于维护元数据的数据结构所消耗的空间。</p>
<p>当有查询结果需要缓存的时候，MySQL先从大的数据块中申请一个数据块用于存储结果。这个数据块需要大于参数query_cache_min_res_unit的配置，即使差U型你将诶过远远小于此，人需要至少申请query_cache_min_res_unit空间，因为需要在查询开始返回结果的时候就分配空间，而此时是无法阈值查询结果到底多大的，所以MySQL无法为每一个查询结果精确分配大小恰好匹配的缓存空间。</p>
<p>因为需要先锁住空间块，然后找到合适大小数据块，所以相对来说，分配内存快是一个非常慢的操作。MySQL尽量避免这个操作的次数。当需要缓存一个差U型那结果的号死后，它先选择一个尽可能小的内存块，然后将结果存入其中。如果数据块全部用完，但仍有剩余数据需要存储，那么MySQL会申请一块新数据块，仍然是既可能笑得数据块，继续存储结果数据。当查询完成，如果申请的内存空间还有剩余，MySQL会将其释放，并存入空闲内存</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的复制</title>
    <url>/2020/12/30/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/9-MySQL%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h4><span id="1-概述">1 概述</span></h4><hr><p>MySQL可以是一主一备，一主多备，双主，多主，等不同的组合方式。</p><p>支持两种复制方式：基于行的复制方式和基于语句的复制。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。这意味着，在同一时间点上，备库的数据可能与主库存在不一致，并且无法保证主备之间的延迟。一些大的语句可能导致备库产生几秒，几分钟甚至几小时的延迟。</p><a id="more"></a>


<p>MySQL复制大部分是向后兼容的，新版本的服务器可以作为老版本的备库。但相反不行。</p>
<p>复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。除此之外，每个备库也会对主库增加一些负载（网络IO等），尤其当备库请求从主库读取旧的二进制文件时，可能会造成更高的IO开销。另外锁竞争也可能阻碍事务的提交。最后，如果是从一个高吞吐量的主库上复制到多个备库，唤醒多个复制线程发送事件的开销将会累加。</p>
<p>通过复制可以将读操作指向备库来获得更好的读扩展，但对于写操作，除非设计的当，否则并不适合通过复制来扩展写操作。在一主库多备库的架构中，写操作会被执行多次，这时候整个系统的性能取决于写入最慢的地方。</p>
<p>当使用一主库多备库的架构时，可能会造成一些浪费，因为本质上它会复制大量不必要的重复数据，例如，对于1台主库和10台备库，会有11份的数据拷贝，并且这11台的缓存中存储了大部分相同的数据。这和在服务器上有11录RAID1类似。</p>
<h5><span id="11-复制解决的问题">1.1 复制解决的问题</span></h5><hr>
<ul>
<li><p>数据分布</p>
<p>  MySQL复制通常不会对带宽造成很大的压力，但是<strong>基于行的复制会比基于语句的复制的带宽压力更大</strong>。你可以随意地停止或开始复制，并在不同的地理位置来分布数据备份，例如不同的数据中心。即使在不稳定的网络环境下，远程复制也可以工作。但如果为了保持很低的延迟复制，最好有一个稳定的、低延迟链接。</p>
</li>
<li><p>负载均衡</p>
<p>  通过MySQL复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化，并且实现很方便，通过简单的代码修改就能实现基本的负载均衡。对于小规模的应用，可以简单地对机器名做硬编码或者使用dn轮训。也可使用更复杂的方法，例如网络负载均衡<br>  这一类的标准负载均衡解决方案，能够很好地将负载分配到不同的MySQL服务器上。linux虚拟服务器也能够很好地工作。</p>
</li>
<li><p>备份</p>
<p>  对于备份来说，复制是一项很有意义的技术补充，但是复制既不是备份也不能够取代备份。</p>
</li>
<li><p>高可用性和故障切换</p>
<p>  复制能够帮助应用程序避免MySQL单点失败，一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间</p>
</li>
<li><p>MySQL升级测试</p>
<p>  使用更高版本的MySQL作为备库，保证在升级全部实例前，查询能够在备库按照预期执行。</p>
</li>
</ul>
<h5><span id="12-复制如何工作">1.2 复制如何工作</span></h5><hr>
<ul>
<li>在主库上把数据更改记录到二进制日志（bin log）中</li>
<li>备库将主库上的日志复制到自己的中继日志中(retry log)</li>
<li>备库读取中继日志中的事件，将其冲放到备库数据之上。</li>
</ul>
<p>第一步是在主库上记录二进制日志。在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p>
<p>下一步，备库将主库的二进制日志复制到其本地的中继日志中。首先，备库会启动一个工作线程，称为IO线程，IO线程跟主库建立一个普通的客户端连接，然后再朱哭丧启动一个特殊的二进制（binlog dump）线程，这个二进制转储线程会读取主库上二进制日志中的时间。它不会对事件进行轮训。如果该线程追赶上了主库，它将进入睡眠状态，直到主库发送信号通知其有新的事件产生时才会被环境，备库IO线程会将接收到的事件记录到中继日志中.</p>
<p>备库的SQL线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当SQL线程追赶上IO线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中，它对后面的场景非常有用。</p>
<p>这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。也就是说IO线程能够独立于SQL线程之外进行工作.但这种架构也限制了复制的过程，其中最重要的一点是在主库上并发运行的查询在备库只能串行化执行，因为只有一个SQL线程来重放中继日志中的事件。这是很多工作负载的性能瓶颈所在。虽然有一些解决方案，但大多数用户仍然受制于单线程。</p>
<h4><span id="2-配置复制">2 配置复制</span></h4><hr>
<ol>
<li>在每台服务器上创建复制账号</li>
<li>配置主库和备库</li>
<li>通知备库连接到主库并从主库复制数据。</li>
</ol>
<h5><span id="21-创建复制账号">2.1 创建复制账号</span></h5><hr>
<p>MySQL会赋予一些特殊的权限给复制线程。在备库运行的IO线程会建立一个到主库的TCP/IP链接，这意味着必须在主库创建一个用户，并赋予其合适的权限。备库IO线程以该用户名连接到主库并读取其二进制文件。通过以下语句创建用户账号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span>,<span class="keyword">replication</span> <span class="keyword">client</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> repl@<span class="string">'127.0.0.1'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'p4ssword'</span>;</span><br><span class="line"><span class="comment"># 这个在新版本中不适用，只适合5.5之前的版本，新版本对这两条语句做了拆分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3解决办法:</span></span><br><span class="line"><span class="comment">#创建账户:create user ‘用户名’@’访问主机’ identified by ‘密码’;</span></span><br><span class="line"><span class="comment">#赋予权限:grant 权限列表 on 数据库 to ‘用户名’@’访问主机’ ;(修改权限时在后面加with grant option)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'slave'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'slave1234'</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'slave'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
<h5><span id="22-配置主库和备库">2.2 配置主库和备库</span></h5><hr>
<p>下一步需要在主库上开启一些设置，需要打开二进制文件并指定一个独一无二的服务器ID（server ID），在主库的my.conf文件中增加或修改如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_bin = mysql-bin</span><br><span class="line">server_id = 10</span><br></pre></td></tr></table></figure>
<p>必须明确地指定一个唯一的服务器ID，默认服务器ID通常为1，因此一定要自定义一个，通常做法是选择服务器IP地址的后八位，但是要保证是唯一不变的。最好选择一些有意义的约定并遵守。</p>
<p>如果之前没有在MySQL的配置文件中指定log-bin选项，就需要重新启动MySQL。为了确认二进制日志文件是否已经在主库上创建，使用show master status命令。检查输出，如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+--------+------------+----------------+-----------------+</span></span><br><span class="line">|File         |Position|Binlog_Do_DB|Binlog_Ignore_DB|Executed_Gtid_Set|</span><br><span class="line">+<span class="comment">-------------+--------+------------+----------------+-----------------+</span></span><br><span class="line">|binlog.000003|1364176 |            |                |                 |</span><br><span class="line">+<span class="comment">-------------+--------+------------+----------------+-----------------+</span></span><br></pre></td></tr></table></figure>
<p>备库也需要在my.cnf中增加类似的配置，并且同样需要重启服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_bin = mysql-bin</span><br><span class="line">server_id = 2</span><br><span class="line">relay=log = /var/lib/mysql/mysql-relay-bin</span><br><span class="line">log_slave_updates=1</span><br><span class="line">read_only = 1</span><br></pre></td></tr></table></figure>
<p>这些选项并不总是必要的。只有server_id时必须的。log_bin默认情况下是根据机器名来命名的，但如果机器名变化了可能会导致问题，为了简便，主库和备库设置为相同的值。</p>
<p>另外还有两个选项：relay_log（指定中继日志的位置和命名）和log_slave_updates（允许备库将其重放的日志也记录到自身的二进制日志中），后一个选项会给备库增加额外的工作，但正如后面将会看到的，我们有理由为每个备库设置该选项。</p>
<p>有时候只开启了二进制日志，却没有开启log_slave_updates，可能会碰到一些奇怪的现象，例如，当配置错误时可能会导致备库数据被修改。如果可能的话，最好使用read_only配置选项，该选项会阻止任何没有特权权限的线程修改数据（所以最好不要给予用户超出需要的权限）。但read_only选项常常不是很实用，特别是对于那些需要在备库建表的应用。</p>
<h5><span id="23-启动复制">2.3 启动复制</span></h5><hr>
<p>下一步是告诉备库如何连接到主库并重放其二进制日志。这一步不要通过修改my.cnf来配置，而是使用change master to语句，该语句完全替代了my.cnf中的设置，并且允许以后指向别的主库时无需重启备库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host = <span class="string">'server1'</span> ,master_user = <span class="string">'repl'</span>,master_password =<span class="string">'p4ssword'</span>,master_log_file =<span class="string">'mysql-bin.0000001'</span>,master_log_pos =<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>master_log_pos参数被设置为0，因为要从日志的开头读起。当执行完这条语句后，可以通过show slave status语句来检查复制是否正确执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment"># TODO</span></span><br></pre></td></tr></table></figure>
<p>slave_io_state，slave_io_running和slave_sql_running这三列显示当前备库复制尚未运行。MySQL知道第一个事件从文件的第四位开始读。</p>
<p>运行命令开始复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>执行该命令没有显示错误，我们再用show slave status命令检查。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment"># TODO</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看到IO线程和SQL线程都已经开始运行,seconds_behind_master的值也不再为null。IO线程正在等待从主库传递过来的事件，这意味着IO线程已经读取了主库所有的事件.日志位置发生了变化,表明已经从主库获取和执行了一些事件.如果实在主库上做一些数据更新，就会看到备库的文件或者日志文职都可能会增加。备库中的数据同样会随之更新。</p>
<p>还可以从线程列表中看到复制线程。在主库上可以看到由备库IO线程向主库的连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure>
<p>同样，在备库也可以看到两个线程，一个是IO线程，一个是SQL线程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure>
<p>这些线程总是运行在system user账号下，其他列的值则不相同。例如，当SQL线程回放事件时，info列可能显示正在执行的查询</p>
<h5><span id="24-从另一个服务器开始复制">2.4 从另一个服务器开始复制</span></h5><hr>
<p>大多数情况下有一个已经运行了一段时间的主库，然后用一台新安装的备库与之同步，此时这台备库还没有数据。</p>
<p>有几种办法来初始化备库或者从其他服务器克隆数据到备库。包括从主库复制数据，从另外一台备库克隆数据，以及使用最近的一次备份来启动备库，需要有三个条件来让主库和备库保持同步。</p>
<ul>
<li>在某个时间点的主库的数据快照</li>
<li>主库当前的二进制日志文件，和获得数据快照时在该二进制文件中的偏移量，我们把这两个值称为日志文件坐标（log file coordinates）。通过这两个值可以确定二进制日志的位置。可以通过show master status命令来获取这些值。</li>
<li>从快找时间到现在的二进制日志</li>
</ul>
<p>下面是一些从被的服务器克隆备库的方法</p>
<ul>
<li><p>使用冷备份</p>
<p>  最基本的方法是关闭主库，把数据复制到备库。重启主库后，会使用一个新的二进制日志文件，我们在备库通过执行change master to 指向这个文件的起始处。这个方法的缺点很明显，在复制数据时需要关闭主库</p>
</li>
<li><p>使用热备份</p>
<p>  如果仅使用了myisam表，可以在主库运行时使用mysqlhotcopy或rsync来复制数据。</p>
</li>
<li><p>使用mysqldump</p>
<p>  如果只包含innodb表，那么可以使用以下命令来转储主库数据并将其加载到备库，然后设置响应的二进制日志坐标</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transcation --all-databases --master-data=1 --host=server1 | mysql --host=server2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>选项--single-transaction使得转储的数据为事务开始前的数据。如果使用的是非事务型表，可以使用--loack-all-tabels选项来获得所有表的一致性转储。
</code></pre><ul>
<li><p>使用快照或备份</p>
<p>  只要知道对应的二进制日志坐标，就可以使用主库的快照或者备份来初始化备库（如果只使用备份，需要确保从备份的时间点开始的主库二进制文件都要存在）。只需要把备份或快照恢复到备库，然后使用change master to 指定二进制日志的坐标。</p>
</li>
<li><p>使用Percona Xtrabackup</p>
</li>
<li><p>使用另外的备库</p>
<p>  可以使用任何一种提及的克隆或拷贝技术从任意一台备库上将数据克隆岛另外一台服务器，但是如果使用的是mysqldump，—master-data选项就不会起作用。</p>
<p>  此外，不能使用show master status来获得主库的二进制日志坐标，而是在获取快照时使用show slave status来获取备库在主库上的执行位置。</p>
<p>  使用另外的备库进行数据克隆最大的缺点是，如果这台备库的数据已经和主库不同步，克隆到的就是脏数据库。</p>
</li>
</ul>
<h5><span id="25-推荐的复制配置">2.5 推荐的复制配置</span></h5><p>在主库上二进制日志最重要的选项就是sync_binlog： sync_binlog=1</p>
<p>如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证在服务器崩溃时不会丢失事件。如果禁止该选项，服务器会少做一些工作，但二进制日志文件可能在服务器崩溃时损坏或丢失信息。在一个不需要作为主库的备库上，该选项带来了不必要的开销。他只适合于二进制日志，而非中继日志。</p>
<p>如果无法容忍服务器崩溃导致表损坏，推荐使用innodb。在表损坏无关紧要时，myisam是可以接受的，但在一次备库服务器崩溃重启后，myisam可能已经处于不一致状态。一种可能是语句没有完全应用到一个或多个表上，那么即使修复了表，数据也可能是不一致的。</p>
<p>如果使用innodb，我们强烈推荐设置如下选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_flush_logs_at_trx_commit # Flush every log write</span><br><span class="line">innodb_support_xa=1 # MySQL 5.0 and newer only</span><br><span class="line">innodb_safe_binlog  #MySQL 4.1 only，roughly equivalent to innodb support_xa</span><br></pre></td></tr></table></figure>
<p>这些事MySQL5.0及最新版本中的默认配置，我们推荐明确指定二进制日志的名字，以保证二进制日志名在所有服务器上是一致的，避免因为服务器名的变化导致的日志文件名变化。你可能认为以服务器名来命名二进制日志无关紧要，但经验表明，当在服务器间转移文件、克隆新的备库、转储备份或者其他一些你想不到的场景下，可能会导致很多问题。为了避免这些问题，需要给log_bin选项制定一个参数。可以随意地给一个绝对路径，但必须明确地指定基本的命名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_bin=/var/lib/mysql/mysql-bin</span><br></pre></td></tr></table></figure>
<p>在备库上，我们同样推荐开启如下配置选项，为中继日志指定绝对路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">relay_log = /path/to/logs/relay-bin</span><br><span class="line">skip_slave_start</span><br><span class="line">read_only</span><br></pre></td></tr></table></figure>
<p>通过设置relay_log可以避免中继日志文件基于文件名来命名，防止之前剃刀哥可能在主库发生的问题。指定绝对路径可以避免多个MySQL版本中存在的bug，这些bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止备库在崩溃后自动启动复制。这可以给你一些机会来修复可能发生的问题。如果备库在崩溃后自动启动并且处于不一致的状态，就可能会导致更多的损坏，最后将不得不把所有数据丢弃，并重新开始配置备库</p>
<p>read_only选项可以组织大部分用户更改非临时表，除了复制SQL线程和其他拥有超级权限的用户之外，这也是要尽量避免给正常账号授予超级权限的原因之一。</p>
<p>即使开启了所有我们建议的选型，备库仍然可能在崩溃后被终端，因为master.info和中继日志文件都不是崩溃安全的。默认情况下甚至不会刷新到磁盘，直到MySQL5.5版本才有选项来控制这种行为。如果正在使用MySQL5.5并且不介意额外的fsync()导致的性能开销，最好设置以下选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync_master_info = 1</span><br><span class="line">sync_relay_log = 1</span><br><span class="line">sync_relay_log_info = 1</span><br></pre></td></tr></table></figure>
<p>如果备库和主库的延迟很大，备库的IO线程可能会写很多中继日志文件，SQL线程在重放完一个中继日志中的时间后会尽快将其删除（通过relay_log_purge选项来控制）。 但如果延迟非常严重，IO线程可能会把整个磁盘撑满.解决办法是配置realy_log_space_limit变量。如果所有中继日志的大小之和超过这个值，IO线程会停止,等待SQL线程释放磁盘空间</p>
<p>还有一个隐藏的问题。如果备库没有从主库获取所有的中继日志，这些日志可能在主库崩溃时丢失。早先这个选项存在一些bug，使用率也不高，所以用到这个选项遇到bug的风险会更高。除非磁盘空间真的非常紧张，否则最好让中继日志使用其需要的磁盘空间，这也是为什么我们没有将relay_log_space_limit列入推荐的配置选项的原因。</p>
<h4><span id="3-复制的原理">3 复制的原理</span></h4><h5><span id="31-基于语句的复制">3.1 基于语句的复制</span></h5><hr>
<p>在MySQL5.0之前的版本中只支持语句语句的复制（逻辑复制），这在数据库领域是很少见的。基于语句的复制模式下，主库会记录那么造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。这种方式既有好处，也有缺点。</p>
<p>最明显的好处是实现相当简单。理论上讲，简单地记录和执行这些语句，能够让主备保持同步。另一个好处是二进制日志里的事件更加紧凑，所以相对而言，基于语句的模式不会使用太多带宽。一条更新好几兆数据的语句在二进制日志里可能只占几十个字节。另外mysqlbinlog工具是基于语句的日志的最佳工具。</p>
<p>但事实上基于语句的方式可能并不如其看起来那么便利。因为主库上的数据更新除了执行的语句外，可能还依赖于其他元素。例如，同一条SQL在主库和备库上执行的时间可能不同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即使如此，还存在着一些无法被正确复制的SQL。例如，使用current_user()函数的语句。存储过程和触发器在使用基于语句的复制模式时也可能存在问题。</p>
<p>另一个问题是更新必须是串行的。这需要更多的锁，有时候要特别关注这一点。另外不是所有的存储引擎都支持这种复制模式。尽管这些存储引擎是包括在MySQL5.5及之前版本中发行的。</p>
<h5><span id="32-基于行的复制">3.2 基于行的复制</span></h5><hr>
<p>5.1开始支持基于行的复制，最大的好处是可以正确地复制每一行。一些语句可以被更加有效的复制。</p>
<p>由于无需重放更新主库数据的查询，使用基于行的复制模式能够高效地复制数据。重放一些查询的代价可能会很高。例如，下面有一个查询将数据从一个大表汇总到小表：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> summary_table(col1,col2,col3) <span class="keyword">select</span> col1,col2,<span class="keyword">sum</span>(col3) <span class="keyword">from</span> enormous_table <span class="keyword">group</span> <span class="keyword">by</span> col1,col2;</span><br></pre></td></tr></table></figure></p>
<p>如果表enormous_table的列col1和col2有三种组合，这个查询可能在源表上扫描多次，但最终只在目标表上产生三行数据。但使用基于行的命令方式，在备库上开销会小很多。这种情况下，基于行的复制模式更加高效。</p>
<p>但在另一方面，下面这条语句使用基于语句的复制方式代价会小很多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> enormous_table <span class="keyword">set</span> col1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>由于这条语句做了全表更新，使用基于行的复制开销会很大，因为每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大。并且会给主库上记录日志和复制增加额外的负载，更慢的日志记录会降低并发度。</p>
<p>没有哪种模式是完美的，MySQL能够在这两种复制模式减动态切换。默认情况下使用的是基于语句的复制方式，但如果发现语句无法被正确地复制，就切换到基于行的复制模式。还可以根据需要来设置会话级别的变量 binlog_format，控制二进制日志格式。</p>
<p>对于基于行的复制模式，很难进行时间点恢复，但并非不可能</p>
<h5><span id="33-基于行或基于语句哪种更优">3.3 基于行或基于语句：哪种更优</span></h5><hr>
<p>理论上基于行的复制模式整体上更优，并且在实际应用中也适用于大多数场景。</p>
<ul>
<li><p>基于语句的复制模式的有点</p>
<p>  当贮备的模式不同时，逻辑复制能够在多种情况下工作。例如，在主备上的表的定义不同但数据类型相兼容、列的顺序不同等情况。这样就很容易现在备库上修改scheam，然后将其提升为主库，减少停机时间。基于语句的复制方式一般允许更灵活的操作。</p>
<p>  基于语句的方式执行复制的郭恒基本上就是执行SQL语句.这意味着所有在服务器上发生的变更都以一种容易理解的方式运行.这样当出现问题时可以很好的去定位.</p>
</li>
<li><p>基于语句的复制模式的缺点</p>
<p>  很多情况下通过基于语句的模式无法复制正确，几乎每一个安装的备库都会至少碰到一次。事实上对于存储过程，触发器以及其他的一些语句的复制在5.0和5.1的一系列版本中存在大量的BUG。这些语句的复制的方式已经被修改了很多次，以使其更好地工作。简单的说，如果正在使用触发器或者存储过程，就不要使用基于语句的复制模式，除非能够清楚的确定不会碰到复制问题。</p>
</li>
<li><p>基于行的复制模式的优点</p>
<p>  几乎没有基于行的复制模式无法处理的场景。对于所有的SQL构造、触发器、存储过程等都能正确执行。只是当你试图做一些诸如在备库修改表的schema这样的事情时才可能导致复制失败。</p>
<p>  这种方式同样可能减少锁的使用，因为它并不要求这种强串行化是可重复的。</p>
<p>  基于行的复制模式会记录数据变更，因此在二进制日志中记录的都是实际上在主库上发生了变化的数据。你不需要查看一条语句去猜测它到底修改了哪些数据。在某种程度上，该模式能够更加清楚滴知道服务器上发生了哪些更改，并且有一个更好的数据变更记录。另外在一些情况下基于行的二进制日志还会记录发生改变之前的数据，因此这可能有利于某些数据恢复。</p>
<p>  在很多情况下，由于无须像基于语句的复制那样需要为查询建立执行计划并执行查询，因此基于行的复制占用更少的CPU。</p>
<p>  最后在某些情况下，基于行的复制能够帮助更快地找到并解决数据不一致的情况。举个栗子，如果是使用基于语句的复制模式，在备库更新一个不存在的记录时不会失败，但在基于行的复制模式下则会报错并停止复制。</p>
</li>
<li><p>基于行的复制模式的缺点</p>
<p>  由于语句并没有在日志里记录，因此无法判断执行了哪些SQL，除了需要知道行的变化外，正在很多情况下也很重要（未来会被修复）。使用一种完全不同的方式在备库进行数据变更，而不是执行SQL，事实上，执行基于行的变化的过程就像一个黑盒子，你无法知道服务器正在做什么。并且没有很好的文档和解释。因此当出现问题时，可能很难找到问题所在。例如，若备库使用一个效率低下的方式去寻找行记录并更新，你无法观察到这一点。</p>
<p>  如果有多层的复制服务器，并且所有的都被配置成基于行的复制模式，当会话级别的变量@@binlog_format被设置为statement时，所执行的语句在原服务器上被记录为基于语句的模式，但第一层的备库可能将其记录成行模式，并传递给其它层的备库。也就是说你期待的基于语句的日志在复制拓扑中将会被切换到基于行的模式。基于行的日志无法处理注入在被备库修改表的schema这样的情况，而基于语句的日志可以。</p>
<p>  在某些情况下，例如找不到要修改的行时，基于行的复制可能会导致复制停止，而基于语句的复制则不会。这也可以认为是基于行的复制的一个有点。该行为可以通过slave_exec_mode来进行配置。</p>
</li>
</ul>
<h5><span id="34-复制文件">3.4 复制文件</span></h5><hr>
<p>复制会使用到的一些文件，除了二进制日志文件和中继日志文件外，还有其他很多文件。</p>
<ul>
<li><p>mysql-bin.index</p>
<p>  当在服务器是哪个开启二进制日志时，同时会生成一个和二进制日志同名的但是以index为后缀的文件，该文件用于记录磁盘上的二进制日志文件。这里的index并不是指表的索引，而是说这个文件的每一行包含了二进制文件的文件名。</p>
<p>  你可能认为这个文件时多余的，可以被删除（毕竟MySQL可以在磁盘上找到它所需要的文件）。事实上并非如此，MySQL依赖于这个文件，除非在这个文件里有记录，否则MySQL识别不了二进制日志文件。</p>
</li>
<li><p>mysql-relay-bin-index</p>
<p>  中继日志的索引文件，和mysql-bin.index作用类型</p>
</li>
<li><p>master.info</p>
<p>  这个文件用于保存备库连接到主库所需要的信息，格式为纯文本。此文件不能删除，否则备库在重启后无法连接到主库。这个文件以文本的方式记录了复制用户的密码，所以要注意权限控制。</p>
</li>
<li><p>relay-log.info</p>
<p>  这个文件包含了当前备库复制的二进制日志和中继日志坐标（例如，备库复制在主库上的位置），同样也不要删除这个文件，否则在备库重启后将无法获知从哪个位置开始复制，可能会导致重放已经执行过的语句。</p>
</li>
</ul>
<p>以.index作为后缀的文件也与expire_logs_days存在交互，该参数定义了MySQL清理过期日志的方式，如果文件mysql-bin.index在磁盘上不存在，某些版本中自动清理就不会起作用。</p>
<p>最好能显式的执行一些日志清理策略，比如设置expire_logs_days参数或者其他方式，否则MySQL的二进制日志可能会将磁盘撑满。当做这些事情时，还需要考虑到备份策略。</p>
<h5><span id="35-发送复制事件到其他备库">3.5 发送复制事件到其他备库</span></h5><hr>
<p>log_slave_updates 选项可以让备库变成其他服务器的主库。在设置该选项后，MySQL会将其执行过的时间记录到它自己的二进制日志中。这样它的备库就可以从其日志中检索并执行事件。</p>
<p>在这种场景下，主库将数据更新事件写入二进制日志，第一个备库提取并执行这个时间。这时候一个事件的生命周期应该已经结束了，但由于设置了log_slave_updates，备库会将这个事件写到她自己的二进制日志中。这样第二个备库就可以将时间提取到它的中继日志中并执行。这意味着作为源服务器的主库可以将数据变化传递给没有与其直接相连的备库上。默认情况下这个选项是被打开的，这样在连接到备库时就不需要重启服务器。</p>
<p>当第一个备库从主库获得的事件写入到其二进制日中中时，这个日志在备库二进制日中中的位置与其在主库二进制日志中的位置几乎肯定是不相同的，可能在不同的日志文件或文件内不同的位置。这意味着你不能嘉定所有拥有同一逻辑复制点的服务器拥有相同的日志坐标。</p>
<p>除非你已经注意到要给每个服务器分配一个唯一的服务器ID,否则按照这种方式配置备库会导致一些奇怪的错误,甚至还会导致复制停止.一个常见的问题是:为什么要制定服务器ID,难道MySQL在不知道复制命令来源的情况下不能执行么?为什么MySQL要在意服务器ID是全局唯一的。问题的答案自安于MySQL在复制过程中如何防止无限循环。当复制SQL线程读中继日志时，会丢弃事件中记录的服务器ID和该服务器本身ID相同的事件，从而打破了复制过程中的无限循环。在某些复制拓扑结构下打破无限循环非常重要，例如 主-主复制结构。</p>
<h5><span id="36-复制过滤器">3.6 复制过滤器</span></h5><hr>
<p>复制过滤选项允许你金复制服务器上一部分数据，不过这可能没有想象中那么好用。有两种过滤方式：<strong>在主库上过滤日志到二进制日志中的时间；以及在备库上过滤记录到中继日志的时间</strong>。</p>
<p>使用选项**binlog_do_db和binlog_ignore_db来控制过滤，不需要开启他们，否则还得解释，数据为啥不一致啊。</p>
<h4><span id="4-复制拓扑">4. 复制拓扑</span></h4><hr>
<p>可以在任意个主库和备库之间建立复制，只有一个限制：<strong>每一个备库只能有一个主库</strong>。基本原则如下：</p>
<ul>
<li>一个MySQL备库实例只能有一个主库</li>
<li>每个备库必须有一个唯一的服务器ID</li>
<li>一个主库可以有多个备库</li>
<li>如果打开了log_slave_updates选项，一个备库可以把其主库上的数据变化传播到其他备库。</li>
</ul>
<h5><span id="41-一主库多备库">4.1 一主库多备库</span></h5><p>备库之间根本没有交互，仅仅是连接到同一个主库上。</p>
<p>在有少量写和大量读的时候，这种配置是非常有用的。可以把读分摊到多个备库上，知道备库给主库造成了太大的负担，或者主备之间的带宽成为瓶颈为止。</p>
<p>下面是它的一些用途：</p>
<ul>
<li>为不同的角色使用不同的备库</li>
<li>把一台备库当做待用的主库，除了复制没有其他数据传输。</li>
<li>将一台备库放到远程数据中心，用作灾难恢复。</li>
<li>延迟一个或多个备库，以备灾难恢复</li>
<li>使用其中一个备库，作为备份，培训，开发或者测试使用服务器</li>
</ul>
<p>这种结构流行的原因是它避免了很多其他拓扑结构的复杂性：例如：<strong>可以方便地比较不同备库重放的事件在主库二进制日志中的位置。换句话说，如果在同一个逻辑点停止所有备库的复制，他们读取的是主库上同一个日志文件的相同物理位置。这是个很好的特性，可以减轻管理员许多工作，例如把备库提升为主库</strong>。</p>
<p>这种特性只存在于兄弟备库之间。在没有直接的主备或者兄弟关系的服务器上去比较日志文件的位置要复杂得多。</p>
<h5><span id="42-主动-主动模式下的-主-主复制">4.2 主动 - 主动模式下的 主 - 主复制</span></h5><hr>
<p>主-主复制（双主复制）包含两套服务器，互为主备。是一对主库。</p>
<p>这种配置最大的问题是如何解决冲突，两个可写的互主服务器导致的问题非常多。通常发生在两台服务器同时修改一行记录，或者同时在两台服务器上向一个包含auto_increment列的表里插入数据。</p>
<p>MySQL不支持多主库复制</p>
<p>允许向两个服务器上写入所带来的麻烦远大于其带来的好处。但是 主动 - 被动模式则会非常有用</p>
<h5><span id="43-主动-被动模式下的-主-主-复制">4.3 主动 - 被动模式下的 主  主 复制</span></h5><hr>
<p>主要区别在于，其中的一台服务器是只读的被动服务器。</p>
<p>这种方式使得反复切换主动和被动服务器非常方便，因为服务器的配置是对称的。这使得故障转译和故障恢复很容易。它也可以让你在不关闭服务器的情况下执行维护、优化表、升级操作系统等其他任务。</p>
<p>例如，<strong>执行alter table操作可能会锁住整个表</strong>，阻塞对表的读和写，这可能会花费很长时间并导致服务中断。然后在主-主配置下，可以先停止主动服务器上的备库复制线程，然后在被动服务器上执行alter操作，交换角色，最后再闲钱的主动服务器上启动复制线程。这个服务器将会读取中继日志并执行相同的alter语句。这可能花费很长时间，但不要紧，因为该服务器没有为任何活跃查询提供服务。</p>
<p>对称的设置：</p>
<ol>
<li>确保两台服务器上有相同的数据</li>
<li>启用二进制日志，选择唯一的服务器ID，并创建复制账号</li>
<li>启用备库更新的日志记录，后面将会看到，这是故障转移和故障恢复的关键。</li>
<li>把被动服务器配置成只读，防治可能与主动服务器上的更新产生冲突，这一点是可选的</li>
<li>启动每个服务器的MySQL实例</li>
<li>将么个主库设置为对方的备库，使用新创建的二进制日志开始通过</li>
</ol>
<p>主动服务器上更新时会发生什么事情：更新没记录到二进制日志中，通过复制传递给被动服务器的中继日志中。被动服务器执行查询并将其记录到自己的二进制日志中（因为开启了log_slave_updates选项）。由于事件的服务器ID与主动服务器的相同,因此主动服务器将忽略这些时间.</p>
<p>设置主动-被动的主-主拓扑结构在某种意义上类似于创建一个热备份,但是可以使用这个备份来提高性能,例如,用它来执行读操作、备份、离线维护以及升级等。真正的热备份做不了这些事情，但是，并不会获得比单台服务器更好的写性能。</p>
<h5><span id="44-拥有备库的主-主结构">4.4 拥有备库的主-主结构</span></h5><hr>
<p>优点是增加了荣誉，对于不同地理位置的复制拓扑，能够消除站点单点失效的问题。</p>
<h5><span id="45-环形复制">4.5 环形复制</span></h5><hr>
<p>环形结构没有双主结构的一些优点，例如对称的配置和简单的故障转移，并且完全依赖与环上的每一个可用节点，大大增加了系统失效的几率，如果移除一个节点，这个节点发起的事件就会陷入无限循环。环形结构非常脆弱，尽量避免。</p>
<h5><span id="46-主库-分发主库以及备库">4.6 主库、分发主库以及备库</span></h5><hr>
<p>当备库足够多时，会对主库造成很大的负载。每个备库会在主库上创建一个线程，并执行binlog dump命令。该命令会读取二进制文件中的数据，并将其发送给备库。每个备库都会重复这样的工作，它们不会共享binlog dump的资源。</p>
<p>如果有很多备库，并且有大的事件时，例如一次很大的load data file操作，主库上的负载会显著上升，甚至可能由于备库同时请求同样的事件而耗尽内存并崩溃。另一方面，如果备库请求的数据不再文件系统的缓存中，可能会导致大量的磁盘年间所，这同样会影响主库的性能并增加锁的竞争。</p>
<p>因此，如果需要多个备库，一个好的办法是从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的就是提取和提供主库的二进制日志。多个备库连接到分发主库，这使得原来的主库摆脱了负担。为了避免在分发主库上做十几的查询，可以将它的表格修改为blackhole存储引擎。如图</p>
<p>很难说备库数据达到多少时需要一个分发主库。按照通用规则，如果主库接近满负载，不应该为其建立10个以上的备库。如果有少量的写操作，或者只复制其中一部分表，主库皆可以提供更多的复制。另外，也不一定只使用一个分发主库。如需要的话，可以使用多个分发主库向大量的备库进行复制，或者使用金字塔的分发主库，在某些情况下，可以通过设置sleve_compressed_protocol来节约一些主库带宽。这对跨数据中心复制很有好处。</p>
<p>还可以通过分发主库实现其他目的，例如，对二进制日志进行过滤和重写规则。这比在每个备库上重复进行日志记录，重写和查询高效的多。</p>
<p>使用分发主库的另一个缺点是无法使用一个备库来代替主库，因为由于分发主库的存在，导致各个备库与原始主库的二进制日志坐标已经不相同。</p>
<h5><span id="47-树或金字塔形">4.7 树或金字塔形</span></h5><hr>
<p>这种设计的好处是减轻了主库的负担。缺点是中间层出现的任何错误都会影响到多个服务器。如果每个备库和主库直接相连就不会存在这样的问题。同样，中间层次越多，处理故障会更困难、更复杂。</p>
<h5><span id="48-定制的复制方案">4.8 定制的复制方案</span></h5><hr>
<ul>
<li>选择性复制</li>
</ul>
<p>为了利用访问局部性原理（locality of reference），并将需要读的工作驻留在内存中，可以复制少量数据到备库中。如果每个备库只拥有主库的一部分数据，并且将读分配给备库，就可以更好地利用备库的内存。并且每个备库也只有主库一部分的写入负载，这样主库的能力更强并能保证备库延迟。</p>
<p>这个类似于水平数据划分，但它的优势在于主库包含了所有的数据集，这意味着无需为了一条写入查询去访问多个服务器。如果读操作无法在备库上找到数据，还可以通过主库来查询。即使不能从备库上读取所有数据，也可以移除大量的主库读负担。</p>
<p>最简单的方法是在主库上将数据划分道不同的数据库里。然后将每个数据库复制到不同的备库上。例如，若需要将公司的每一个部分的数据复制到不同的备库，可以创建名为sales、marketing、procurement等的数据库，每个备库通过选项replicate_wild_do_table选项来限制给定数据库的数据。下面是sales数据库的配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">replicate_wild_do_tabe = sales.%</span><br></pre></td></tr></table></figure>
<p>也可以通过一台分发主库进行分发。举个栗子，如果想通过一个很慢或者非常昂贵的网络，从一台负载很高的数据库上复制一部分数据，就可以使用一个包含blackhole表和过滤规则的本地分发主库，分发主库可以通过复制过滤移除不需要的日志。这可以避免在主库上进行不安全的日志选项设定，并且无需传输所有的数据到远程备库。</p>
<ul>
<li>分离功能<br>许多应用都混合了在线事务处理（OLTP）和在线数据分析（OLAP）的查询。OLTP查询比较短，并且是事务型的，OLAP查询通常很大，也很慢，并且不要求绝对最新的数据。这两种查询给服务器带来的负担完全不同，因此它们需要不同的配置，甚至可能使用不同的存储引擎或者硬件。</li>
</ul>
<p>一个常见的办法是将OLTP服务器的数据复制到专门为OLAP工作负载准备的备库上。这些备库可以有不同的硬件、配置、索引或者不同的存储引擎。如果决定在备库上执行OLAP查询，就可能要忍受更大的复制延迟或降低备库的服务质量。这意味着在一个非专用的备库上执行一些任务时，可能会导致不可接受的性能。例如执行一条长时间运行的查询。</p>
<ul>
<li>数据归档</li>
</ul>
<p>可以在备库上实现数据归档，也就是说可以再备库上保留主库上删除过的数据，在主库上通过delete语句删除数据是确保delete语句不传递到备库就可以实现的。有两种通常的办法：一种是在主库上选择性地禁止二进制日志，另一种是在备库上使用replicate_ignore_db规则（都很危险）</p>
<p>第一种方法需要先将SQL_LOG_BIN设置为0,然后再进行数据清理。这种方法的好处是不需要再备库进行任何配置，由于SQL语句根本没有记录到二进制日志中，效率会稍微有所提升。最大缺点也正因为没有将主库的修改记录下载，因此无法使用二进制日志来进行审计或者做按时间点的数据恢复。另外还需要super权限。</p>
<p>第二种方法是在清理数据之前对主库上特定的数据库使用use语句。例如，可以创建一个名为purge的数据库，然后再备库的my.cnf文件里设置replicate_ignore_db=purge并重启服务器。备库将会忽略使用了USE语句指定的数据库。这种方法没有第一种方法的缺点，但有一个另外的缺点：备库需要去读取它不需要的时间。另外，也可能有人在purge数据库上执行非清理查询，从而导致备库无法重放改时间。</p>
<ul>
<li>将备库用作全文检索</li>
</ul>
<p>许多应用要求合并事务和全文检索。一个普遍的做法是配置一台备库，将某些表设置为myisam存储引擎，然后创建全文索引并执行全文检索查询。这避免了在主库上同时使用事务型和非事务型存储引擎所带来的复制问题，减轻了主库维护全文索引的负担。</p>
<ul>
<li>只读备库</li>
</ul>
<p>许多机构将备库设置为只读，以防止在备库进行的无意识修改导致复制通断。可以通过设置read_only选项实现。它会禁止大部分写操作，除了复制线程和拥有超级权限的用户以及临时表操作。只要不给也不应该给普通用户超级权限，这英爱是很完美的方法。</p>
<ul>
<li>模拟多主库复制</li>
</ul>
<p>当前MySQL不支持多主库复制（一个备库拥有多个主库）。但是可以通过把一台备库轮流指向多台主库的方式来模拟这种结构。</p>
<p>需要做一些额外的工作来为每个主库跟踪二进制日志坐标。可能还需要保证备库的IO线程在每一次循环读取超过需要的数据，否则可能因为每次循环反复地提取和抛弃大量数据导致主库的网络请求和开销明显增大。</p>
<ul>
<li>创建日志服务器</li>
</ul>
<p>创建没有数据的日志服务器。它唯一的作用就是更加容易重放并且/或者过滤二进制日志事件。对崩溃后重启复制很有帮助，同时对基于时间点的恢复也很有帮助。</p>
<p>假设有一组二进制日志或者中继日志，可能从备份或者一台崩溃的服务器上获取，希望能够重放这些日志中的事件，可以停通过mysqlbinlog工具从其中提取出事件，但更加方便和高效的方法是配置一个没有任何数据的MySQL实例并使其认为这些二进制日志是它拥有的。如果只是临时需要。因为无需执行二进制日志，日志服务器也就不需要任何数据。它的目的仅仅是将数据提供给别的服务器。</p>
<p>假设日志被命名为somelog-bin.000001,somelog-bin000002等，将这些日志放到日志服务器的日志文件夹中，假设为/var/log/mysql。然后在启动服务器前编辑my.cnf文件，如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_bin = /var/log/mysql/somelog-bin</span><br><span class="line">log_bin_index = /var/log/mysql/somelog-bin.index</span><br></pre></td></tr></table></figure>
<p>服务器不会自动发现日志，因此还需要更新日志的索引文件。下面这个命令可以在类unix系统上完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /var/log/mysql/somelog-bin.[0-9]* &gt; /var/log/mysql/somelog-bin.index</span><br></pre></td></tr></table></figure>
<p>确保运行MySQL的账户能够读写日志索引文件。现在可以启动日志服务器并通过show master logs命令来确保其找到日志文件。</p>
<p>为什么使用日志服务器比用mysqlbinlog来实现恢复更好呢？有以下几个原因：</p>
<ul>
<li>复制作为应用二进制日志的方法已经被大量的用户所测试，能够证明是可行的。mysqlbinlog并不能确保像复制那样工作，并且可能无法正确生成二进制日志中的数据更新。</li>
<li>复制的速度很快，因为无需将语句从日志导出来并传递给MySQL</li>
<li>可以很容易观察到复制过程</li>
<li>能够更方便处理错误。例如，可以跳过执行失败的语句。</li>
<li>更方便过滤复制事件</li>
<li>有时候mysqlbinlog会因为日志记录格式更改而无法读取二进制日志。</li>
</ul>
<h4><span id="5-复制和容量规划">5. 复制和容量规划</span></h4><hr>
<p>写操作通常是复制的瓶颈，并且很难使用复制来扩展写操作。例如，假设工作负载为20%的写以及80%的读。为了简单计算，假设有以下前提：</p>
<ul>
<li>读和写包含同样的工作量</li>
<li>所有的服务器是等同的，每秒能进行1000次查询。</li>
<li>备库和主库有同样的性能特征。</li>
<li>可以把所有的读操作转移到备库。</li>
</ul>
<p>如果当前有一个服务器能支持每秒1000次查询，那么应该增加多少备库才能处理当前两倍的负载，并将所有的读查询分配给备库？</p>
<p>看上去应该增加两个备库并将1600次读操作平分给它们。但是不要忘记，写入负载同样增加到了400次每秒，并且无法在主备服务器之间进行分摊。每个备库每秒必须处理400次写入，这意味着每个备库写入占了40%，只能每秒为600次查询提供服务。因此，需要三台而不是两台备库来处理双倍负载。</p>
<p>如果负载再增加一倍呢？将有每秒800次写入，这时候主库还能处理，但备库的写入同样提升到80%，这样就需要16台备库来处理每秒3200次读查询。并且如果再增加一点负载，主库也会无法承担。</p>
<p>这远远不是线性扩展，查询数量增加4倍，却需要17倍的服务器。这说明当为单台主库增加备库时，将很快达到投入远高于回报的地址。这仅仅是基于上面的假设，还忽略了一些事情，例如，单线程的基于语句的复制常常导致备库容量小于主库。</p>
<h5><span id="51-为什么复制无法扩展写操作">5.1 为什么复制无法扩展写操作</span></h5><hr>
<p>糟糕的服务容量比例的根本原因是不能像分发读操作那样把写操作等同地分发到更多服务器上。换句话说，复制只能扩展读操作，无法扩展写操作。</p>
<p>有没有办法使用复制来增加写入能力？答案是否定的，根本不行。对数据进行分区是唯一可以扩展写入的方法。</p>
<p>可能会想到使用主-主拓扑结构，并为两个服务器执行写操作。这种配置比主备结构能支持稍微多一点的写入，因为可以在两台服务器之间共享串行化带来的开销。如果每台服务器上执行50%的写入，那复制的执行量也只有50%需要串行化。理论上讲，这比在一台机器上对100%的写入并发执行，而在另外一台机器上对100%的写入做串行化要更优。</p>
<p>但是这种策略不能扩展写入的原因。它只能在两台服务器之间共享串行化写入的缺点。所以，链中最弱的一环并不是那么弱，它只提供了比主动-被动复制稍微好点的性能，但是增加了很大的风险，通常不能带来任何好处。</p>
<h5><span id="52-备库什么时候开始延迟">5.2 备库什么时候开始延迟</span></h5><hr>
<p>首先应该观察复制延迟的尖刺。如果有复制延迟的曲线图，需要注意到图上的一些短暂的延迟骤升，这时候可能负载加大，备库短时间内无法跟上主库。当负载接近耗尽备库的容量时，会发现曲线上的突起会更高更宽。前面曲线的上升角度不变，但随后当备库在产生延迟后开始追赶主库时，将会产生一个平缓的斜坡。这些突起的出现和增长是一个警告信息，意味着已经接近容量限制。</p>
<p>为了预测在某个是简单会发生什么，可以认为制造延迟，然后看多久，备库能够赶上主库。目的是为了明确说明曲线上的斜坡的陡度。如果将备库停止一个小时，然后开启并在一个小时内追赶上，说明正常情况下只消耗了一半的容量。也就是说，如果中午12.00停止备库复制，在1.00开启，并且在2.00追赶上，备库在一小时内完成了两个小时内的所偶变更，说明复制可以再双倍速度下运行。</p>
<h5><span id="53-规划冗余容量">5.3 规划冗余容量</span></h5><hr>
<p>在构建一个大型应用时，有意让服务器不被充分使用，这是一种聪明而且划算的方式，尤其是在使用复制的时候。有多余容量的服务器可以更好的处理负载尖锋，也有更多的能力处理慢速查询和维护工作（如optimize table），并且能够更好的跟上复制。</p>
<p>试图同时向主-主拓扑结构的两个节点来写入或减少复制问题通常是不划算的。分配给每台机器的读负载应该低于50%，否则，如果某台服务器失效，就没有足够的容量了。如果两台服务器都能够独立处理负载，就用不着担心复制的问题了。</p>
<p>构建冗余容量也是实现高可用性的最佳方式之一，当然还有别的方式，例如，当错误发生时让应用在降级模式下运行。</p>
<h4><span id="6-复制管理和维护">6 复制管理和维护</span></h4><hr>
<p>复制增加了MySQL监控的复杂性。尽管复制发生在主库和备库上，但大多数工作是在备库上完成的，这也正是最常出问题的地方。是否所有的备库都在工作？最慢的备库延迟是多大？MySQL本身提供了大量可以回答上述问题的信息，但要实现自动化监控过程以及使复制更健壮，还是需要用户做更多的的工作。</p>
<p>在主库上，可以使用show master status命令来查看当前主库的二进制日志位置和配置，还可以查看主库当前有哪些二进制日志是在磁盘上的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">logs</span>;</span><br><span class="line">+<span class="comment">-------------+---------+---------+</span></span><br><span class="line">|Log_name     |File_size|Encrypted|</span><br><span class="line">+<span class="comment">-------------+---------+---------+</span></span><br><span class="line">|binlog.000001|668      |No       |</span><br><span class="line">|binlog.000002|179      |No       |</span><br><span class="line">|binlog.000003|1364199  |No       |</span><br><span class="line">|binlog.000004|156      |No       |</span><br><span class="line">+<span class="comment">-------------+---------+---------+</span></span><br></pre></td></tr></table></figure>
<p>该命令用于给purge master logs命令决定使用哪个参数，另外还可以通过show binlog events来查看复制时间。例如，在运行前一个命令后，我们在另一个不曾使用过的服务器上创建一个表，因为知道这是唯一改变数据的语句，并且也知道语句在二进制日志中的偏移量是156，所以可以看大如下内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'binlog.000003'</span> <span class="keyword">from</span> <span class="number">156</span></span><br><span class="line"></span><br><span class="line">+<span class="comment">-------------+---+--------------+---------+-----------+------------------------------------+</span></span><br><span class="line">|Log_name     |Pos|Event_type    |Server_id|End_log_pos|Info                                |</span><br><span class="line">+<span class="comment">-------------+---+--------------+---------+-----------+------------------------------------+</span></span><br><span class="line">|<span class="keyword">binlog</span><span class="number">.000003</span>|<span class="number">156</span>|Anonymous_Gtid|<span class="number">1</span>        |<span class="number">233</span>        |<span class="keyword">SET</span> @@SESSION.GTID_NEXT= <span class="string">'ANONYMOUS'</span>|</span><br><span class="line">|<span class="keyword">binlog</span><span class="number">.000003</span>|<span class="number">233</span>|<span class="keyword">Query</span>         |<span class="number">1</span>        |<span class="number">342</span>        |<span class="keyword">DROP</span> <span class="keyword">SCHEMA</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> sakila        |</span><br><span class="line">|<span class="keyword">binlog</span><span class="number">.000003</span>|<span class="number">342</span>|Anonymous_Gtid|<span class="number">1</span>        |<span class="number">419</span>        |<span class="keyword">SET</span> @@SESSION.GTID_NEXT= <span class="string">'ANONYMOUS'</span>|</span><br><span class="line">|<span class="keyword">binlog</span><span class="number">.000003</span>|<span class="number">419</span>|<span class="keyword">Query</span>         |<span class="number">1</span>        |<span class="number">531</span>        |<span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> sakila <span class="comment">/* xid=94 */</span>   |</span><br><span class="line">+<span class="comment">-------------+---+--------------+---------+-----------+------------------------------------+</span></span><br></pre></td></tr></table></figure>
<h5><span id="62-测量备库延迟">6.2 测量备库延迟</span></h5><hr>
<p>一个比较普遍的问题是如何监控备库落后主库的延迟有多大。虽然show slave status输出的seconds_behind_master列理论上显示了备库的延时，但由于各种各样的原因，并不总是准确的。</p>
<ul>
<li>备库seconds_bebind_master值是通过将服务器当前的时间戳与二进制日志中的时间戳相对比得到的，所以只有在执行事件时才能报告延迟。</li>
<li>如果备库复制线程没有运行，就会报延迟为null</li>
<li>一些错误（例如主备的max_allowed_packet不匹配，或者网络不稳定）可能中断复制并且/或者停止复制线程，但second_behind_master将显示为0而不是显示错误。</li>
<li>即使备库线程正在运行，备库有时候可能无法计算延时。如果发生这种情况，备库会报0或者null。</li>
<li>一个大事务可能会导致延迟拨动，例如，有一个事务更新数据长达一个小时，最后提交，这条更新将比他实际发生时间晚一个小时才记录到二进制日志中。当备库执行这条语句时，会临时地报告备库延迟为一个小时，然后又很快标称0。</li>
<li>如果分发主库落后了，并且其本身也有已经追赶上它的备库，备库的延迟将显示为0，而事实上和源主库之间是有延迟的。</li>
</ul>
<p>解决这些问题的办法是，忽略seconds_behind_master的值，并使用一些可以直接观察和衡量的方式来监控备库延迟。最好的解决办法是使用heartbeat record，这是一个在主库上会每秒更新一次的时间戳。为了计算延时，可以直接用备库当前的时间戳减去心跳记录的值。这个方法能够解决刚刚我们提到的所有问题，另外一个额外的好处是我们还可以通过时间戳知道备库当前的复制情况。</p>
<p>心跳还有其他好处，记录在二进制日志中的心跳记录拥有许多用途，例如在一些很难解决的场景下可以用于灾难恢复。</p>
<h5><span id="63-确定主备是否一致">6.3 确定主备是否一致</span></h5><hr>
<p>理想情况下，备库和主库的数据应该是完全一样的。但事实上备库可能发生错误并导致数据不一致。即使没有明显的错误，备库同样可能因为MySQL自身的特性导致数据不一致，例如MySQL的BUG，网络中断、服务器崩溃，非正常关闭或者其他一些错误。</p>
<p>按照经验来看，主备一致应该是一种规范，而不是例外，也就是说，检查你的主备一致性应该是一个日常工作，特别是当使用备库来做备份时尤为重要，因为你肯定不希望从一个已经损坏的备库里获得备份数据。</p>
<p>MySQL并没有内建的方法来比较一台服务器与别的服务器的数据是否相同。它提供了一些组件来为表和数据生成校验值，例如checknum table。但当复制正在进行时，这种方法是不可行的。</p>
<p>pt-table-checksum是唯一能够有效比较主备一致性的工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-table-checknum --replicate=test.checksum &lt;master_host&gt;</span><br></pre></td></tr></table></figure>
<h5><span id="64-从主库重新同步备库">6.4 从主库重新同步备库</span></h5><hr>
<p>传统的修复不一致的办法是关闭备库，然后从主库复制一份数据。当备库数据不一致的问题可能导致严重后果时，一旦发现就应该将备库停止并从生产环境移除，然后在从一个备份中克隆或者恢复备库。</p>
<p>这种方法的缺点是不太方便，特别是数据量很大时。如果能够找出并修复不一致的数据，要比从其他服务器上重新克隆数据有效的多。如果发现的不一致并不严重，就可以保持备库在线，并重新同步受影响的数据。</p>
<p>最简单的办法是使用mysqldump转储受影响的数据并重新导入。在整个过程中，如果数据没有发生变化，这种方法会很好。你可以在主库上简单地锁住表然后进行转储，再等待备库赶上主库，然后将数据导入到备库中。（需要等待备库赶上主库，这样就不至于为其他表引入新的不一致，例如那么可能通过和失去同步的表做join后进行数据更新的表）</p>
<p>虽然这种方法在许多场景下是可行的，但在一个繁忙的服务器上有可能行不通。另外一个缺点是在备库上通过非复制的方式改变数据。通过复制改变备库数据（通过在主库上执行更新）通常是一种安全的技术，因为它避免了竞争条件和其他意料外的事情。如果表很大或者网络带宽受限，转储和重载数据的代价依然很高。当在一个有一百万行的表上只有一千行不同的数据呢？转储和重载表是非常浪费的。</p>
<p>pt-table-sync可以解决该问题。</p>
<h5><span id="65-改变主库">6.5 改变主库</span></h5><hr>
<p>主需要在备库简单的使用change master to 命令，并制定合适的值。大多数值都是可选的。只需要制定需要的改变的项即可。备库将抛弃之前的配置和中继日志并从新的主库开始复制。同样新的参数会被更新到master.info文件中，这样就算重启，备库配置信息也不会丢失。</p>
<p>整个过程中最难得是获取新主库上合适的二进制日志位置，这样备库才可以从老主库相同的逻辑位置开始复制。</p>
<p>把备库提升为主库要更苦难一点。有两种场景需要将备库替换为主库，一种是计划内的提升，一种是计划外的提升。</p>
<ul>
<li><p>计划内的提升</p>
<ul>
<li>停止向老的主库写入</li>
<li>让备库追赶上主库</li>
<li>将一台备库配置为新的主库</li>
<li>将备库和写操作指向新的主库，然后开启主库的写入</li>
</ul>
</li>
</ul>
<p>更深入一点，下面是大多数配置需要的步骤</p>
<ol>
<li>停止当前主库上的所有写操作。如果可以，最好能将所有的客户端程序关闭（除了复制链接）。为客户端程序建立一个do not run这样的类似标记可能会有所帮助。如果正在使用虚拟IP地址,也可以简单的关闭虚拟IP,然后断开所有的客户端链接以关闭其打开的事务.</li>
<li>通过flush tables with read lock在主库上停止所有活跃的写入，这一步是可选的。也可以在主库上设置read_only选项。从这一刻开始，应该禁止向即将被替换的主库做任何写入。因为一旦它不是主库，写入就意味着数据丢失。注意，即使设置read_only也不会阻止当前已存在的食物继续提交，为了更好的保证这一点，可以先kill掉所有打开的事务，这样将会真正的结束所有写入。</li>
<li>选择一个备库作为新的主库，并确保它已经完全跟上主库（例如，让它执行完所有从主库获得的中继日志）</li>
<li>确保新主库和旧主库的数据是一致的。</li>
<li>在新主库上执行stop slave。</li>
<li>在新主库上执行 change master to master_host = ‘’，然后在执行reset slave ，使其断开与老主库的链接，并丢弃master.info里记录的信息（这就是不建议把复制连接信息写到配置文件里的原因之一）</li>
<li>执行show master status记录新主库的二进制日志坐标</li>
<li>确保其他主库已经追赶上。</li>
<li>关闭旧主库</li>
<li>激活新主库上事件</li>
<li>将客户端连接到新主库</li>
<li>在每台备库上执行change master to语句，使用之前通过show master status获得的二进制日志坐标，来指向新的主库。</li>
</ol>
<ul>
<li>计划外的提升</li>
</ul>
<p>当主库崩溃时，需要提升一台备库来替代它，这个过程可能就不太容易。如果只有一台备库，可以直接使用这台备库。但如果有超过一台的备库，就需要做一些额外的工作。</p>
<p>另外，还有潜在的丢失复制事件的问题。可能有主库上已经发生的修改还没有更新到它的任何一台备库上的情况。甚至还可能一条语句在主库上执行了回滚，但在备库上没有回滚，这样备库可能超过主库的逻辑复制位置。如果能在某一点恢复主库的数据，也许就可以取得丢失的语句并手动执行它们。</p>
<p>以下是对主备拓扑结构中的备库进行提升的过程：</p>
<ol>
<li>确定哪台备库的数据最新。检查每台备库上show slave status命令的输出，选择其中master_log_file / read_master_log_pos的值最新的那个</li>
<li>让所有备库执行完所有其从崩溃前的旧主库那获得的中继日志。如果在未完成前修改备库的主库，它会抛弃剩下的日志事件，从而无法获知该备库在什么地方停止。</li>
<li>执行前一小节的5-7步</li>
<li>比较每台备库和新主库上的master_log_file / read_master_log_pos的值。</li>
<li>执行前一小节的10 - 12步。</li>
</ol>
<p>如果有备库和新主库的位置不相同，则需要找到该备库最后一条执行的时间在新主库的二进制日志中响应的位置，然后在执行change master to ，可以通过mysqlbinlog工具来找到备库执行的最后一条查询，然后在主库上找到同样的查询，进行简单的计算就可以得到。</p>
<p>为了便于描述，假设每个日志事件有一个自增的数字ID，最新的备库，也就是新主库，在旧主库崩溃时获得了编号为100的事件，假设有另外两台备库：replica2和replica3。replica2已经获取了99号事件，replica3获取了98号事件。如果把两台备库都指向新主库的同一个二进制日志位置，它们将从101号事件开始复制，从而导致数据不同步。但只要新主库的二进制日志已经通过log_slage_updates打开，就可以在新主库的二进制日志中找到99号和100号日志，从而将备库恢复到一直的状态。</p>
<p>由于服务器重启，不同的配置，日志轮转或者flush logs命令，同一个事件在不同的服务器上可能有不同的偏移量。找到这些时间可能会耗时很长并且枯燥，但是通常没有难度。通过mysqlbinlog从二进制日志或中介日志中解析出每台备库上执行的最后一个事件，并同样使用该命令解析新主库上的二进制日志，找到相同的词典哈讯，mysqlbinlog会打印出该事件的偏移量，在change master to 命令中使用这个值。</p>
<p>更快的方法是把新主库的停止的备库上的字节偏移量想减，它显示了字节为止的差异。然后把这个值和新主库当前二进制日志的位置相减，就可以得到期望的查询的位置。只需要验证一下就可以据此启动备库。</p>
<p>看个例子。假设server1是server2和server3的主库，其中服务器server1已经崩溃，根据show slave status获得master_log_file/read_master_file_post的值，server2已经执行完了server1上的所有二进制日志，但server3还不是最新数据。如图：</p>
<p>如图所示，我们可以确定，server2已经执行忘了主库上的所有二进制日志，因为master_log_file和read_master_log_pos的值和server1上最后的日志位置是相吻合的，因此我们可以将server2提升为新主库，并将server3设置为server2的备库。</p>
<p>应该在server3上为需要执行的change master to语句赋予什么样的参数呢？这里需要做一点点计算和调查。server3在偏移量1493停止，比server2执行的最后一条语句的偏移量1582要小89字节。server2正在想偏移量为8167的二进制日志写入，8167-89=8087，因此理论上我们应该将server3指向server2的日志的偏移量设置为8087的位置。最好去确认下这个位置附近的日志时间，以确定在该位置上是否是正确的日志时间，因为可能有别的例外，例如有些更新你只发生在server2上</p>
<p>假设我们观察到的事件是一样的，下面这条命令会将server3切换为server2的备库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host = <span class="string">'server2'</span>,master_log_file=<span class="string">'mysql-bin.000009'</span>, master_log_post=<span class="number">8078</span></span><br></pre></td></tr></table></figure>
<p>如果服务器在崩溃时已经完成并记录了超过一个时间，会怎么样呢？因为server2仅仅读取并执行到了偏移位置1582，你可能永远的失去了一个时间。但是如果老主库的磁盘没有损坏，仍然可以通过mysqlbinlog或者从二进制服务器日志中找到丢失的事件。</p>
<p>如果需要从老主库上恢复丢失的时间，建议在提升新主库之后且在允许客户端连接之前做这件事情。这样就无需再没台备库上都执行丢失的事件，只需使用复制来完成。但如果崩溃的老主库完全不可用，就不得不等待，稍后再做这一项工作。</p>
<p>上述流程中一个可调整的地方是使用可靠的方式来存储二进制日志，比如SAN或者分布式复制数据库设备（DRBD）。即使主库完全失效，依然能够获得它的二进制日志。也可以设置一个日志服务器，把备库指向它，然后让所有备库赶上主库失效的点。这使得提升一个备库为新的主库没那么重要，本质上这个计划中的提升是相同的。</p>
<h5><span id="66-在一个主-主配置中交换角色">6.6 在一个主 - 主配置中交换角色</span></h5><hr>
<p>主主复制拓扑结构的一个好处就是可以很容易的切换主动和被动的角色，因为其配置是对称的。</p>
<p>当在主-主配置下切换角色时，必须确保任何时候只有一个服务器可以写入。如果两台服务器交叉写入，可能会导致写入冲突。换句话说，在切换角色后，原被动服务器不应该接收到主动服务器的任何二进制日志。可以通过确保原被动服务器的复制SQL线程在该服务器可写之前已经赶上主动服务器来避免。</p>
<p>通过以下步骤切换服务器角色，可以避免更新重复的危险；</p>
<ol>
<li>停止主动服务器上的所有写入。</li>
<li>在主动服务器上执行set global read_only = 1，同时在配置文件里也设置一下read_only，防止重启后失效。但记住这不会阻止拥有超级权限的用户更改数据。如果想阻止所有人更改数据，可以执行flush tables with read lock。如果没有这么做，你必须kill所有的客户端连接以保证没有长时间运行的语句或者未提交的事务。</li>
<li>在主动服务器上执行show master status并记录二进制日志坐标。</li>
<li>使用主动服务器上的二进制日志坐标在被动服务器上执行select master_pos_wait()。该语句将会阻塞，知道复制跟上主动服务器中。</li>
<li>在被动服务器上执行set global read_only =0，这样就变换成主动服务器。</li>
<li>修改应用的配置，使其写入到新的主动服务器中。</li>
</ol>
<h4><span id="7-复制的问题和解决方案">7 复制的问题和解决方案</span></h4><h5><span id="71-数据损坏或丢失的错误">7.1 数据损坏或丢失的错误</span></h5><hr>
<p>MySQL的复制并不能很好地从服务器崩溃、掉电，磁盘损坏、内存或网络错误中恢复。回到这些问题时几乎可以肯定都需要从某个点开始重启复制。</p>
<p>大部分由于非正常关机后导致的肤质问题都是由于没有把数据及时地刷到磁盘。下面是意外关闭服务器时可能会碰到的情况。</p>
<ul>
<li><p>主库意外关闭</p>
<p>  如果没有设置主库的sync_binlog选项，就可能在崩溃前没有降最后的几个二进制日志时间刷新到磁盘中。备库IO线程因此也可能一直处于读不到尚未写入磁盘的事件的状态中。当主库重新启动时，备库将重连到主库并在此尝试去读该事件，但主库会告诉备库没有这个二进制日志偏移量。二进制日志转储线程通常很快，因此这种情况并不经常发生。</p>
<p>  结局色这个问题的办法是指定备库从下一个二进制文件的开头度日志。但是有一些日志事件将会永久的丢失，建议使用pt-table-checknum来检查主备一致性，以便于修复。可以通过在主库开启sync_binlog来避免事件丢失。</p>
<p>  即使开启了sync_binlog，myisam表的数据仍然可能在崩溃的时候损坏，对于innodb事务，如果innodb_flush_log_at_trx_commit没有设为1，也可能丢失数据（但数据不会损坏）</p>
</li>
<li><p>备库意外关闭</p>
<p>  当备库再一次非计划中的关闭后重启时，回去读master.info文件以找到上次停止复制的位置。不幸的是，该文件没有同步写到磁盘，文件中存储的信息可能是错误的。备库可能会尝试重新执行一些二进制日志事件，这可能会导致唯一索引错误。除非能确定备库在哪里停止，否则唯一的办法就是忽略那些错误。pt-slave-restart工具可以完成</p>
<p>  如果使用的都是innodb表，可以再重启后观察MySQL错误日志。innodb在恢复过程中会打印出它的恢复点的二进制日志坐标。可以使用这个值来决定备库指向主库的偏移量。</p>
</li>
</ul>
<p>除了MySQL非正常关闭导致的数据丢失外，磁盘上二进制文件或中继日志文件损坏并不罕见。下面是一些更普遍的场景：</p>
<ul>
<li><p>主库上的二进制文件损坏</p>
<p>  如果主库上的二进制日志损坏，除了忽略损坏的位置外你别无选择。可以再主库上执行flush logs命令，这样主库会开始一个新的日志文件，然后将备库指向该文件的开始位置。也可以试着去发现损坏区域的结束位置。某些情况下可以通过set global sql_slave_skip_counter = 1来忽略一个损坏的事件，如果有多个损坏的事件，就需要重复该步骤，知道跳过所有损坏的时间。但是如果有太多的损坏事件，这么做可能就没有意义了。损坏的事件头会阻止服务器找到下一个事件。这种情况下，可能不得不手动地找到下一个完好的事件。</p>
</li>
<li><p>备库上的中继日志损坏</p>
<p>  如果主库上的日志是完好的，就可以通过change master to 命令丢弃并获取损坏的事件。只需要将备库指向它当前正在复制的位置。这会导致备库丢弃所有在磁盘上的中继日志。就这一点而言，MySQL5.5做了一些改进，它能够在崩溃后自动重新获取中继日志。</p>
</li>
<li><p>二进制日志于innodb事务日志不同步</p>
<p>  当主库崩溃时，innodb可能将一个事务标记为已提交，此时该事务可能还没有记录到二进制日志中。除非是某个备库的中继日志已经保存，否则没有任何办法恢复丢弃的事务。MySQL5之后可以设置sync_binlog选项来防止该问题。</p>
</li>
</ul>
<p>当一个二进制日志损坏时，能恢复多少数据取决于损坏的类型。</p>
<ul>
<li><p>数据改变，但事件仍是有效的SQL</p>
<p>  不幸的是,MySQL无法察觉这种损坏。因此最好还是经常检查备库的数据是否正确。在MySQL未来的版本中可能会被修复。</p>
</li>
<li><p>数据改变并且事件时无效的SQL</p>
<p>  这种情况可以通过mysqlbinlog提取出事件并看到一些错乱的数据，例如：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tab1 <span class="keyword">col</span>???????</span><br></pre></td></tr></table></figure>
<p>  可以通过增加偏移量的方式找到下一个事件，这样就可以之忽略这个损坏的事件。</p>
</li>
<li><p>数据遗漏并且/或者事件的长度是错误的</p>
<p>  这种情况下，mysqlbinlog可能会发生错误退出或者直接崩溃，因为它无法读取时间，并且找不到下一个事件的开始位置。</p>
</li>
<li><p>某些事件已经损坏或被覆盖，或者偏移量已经改变并且下一个事件的起始偏移量也是错误的</p>
<p>  同样，mysqlbinlog没作用。</p>
</li>
</ul>
<p>当损坏非常严重，通过mysqlbinlog已经无法获取日志事件时，就不得不进行一些十六进制的编辑或者通过一些繁琐的技术找到日志事件的边界。通常不困难，因为有一些可辨识的标记会分割事件。</p>
<p>如下面的例子，先用mysqlbinlog找到样例日志的日志事件偏移量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysql-bin.000113 | egrep '^# at '</span><br><span class="line"></span><br><span class="line">at 4</span><br><span class="line">at 98 </span><br><span class="line">15 447</span><br></pre></td></tr></table></figure>
<p>一个找到日志便宜量的比较简单的方法是比较一下string命令输出的偏移量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings -n 2 -t d mysql-bin.000113</span><br><span class="line">std</span><br><span class="line">test</span><br><span class="line">C'C</span><br><span class="line">std</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<p>注意以’G结尾的字符串在日志事件开头的一个字节后的位置。他们是固定长度的事件头的一部分。</p>
<p>简单分析后应该能从二进制日志中找到这些模式并找到下一个完成的日志事件偏移量。然后通过mysqlbinlog的—start-position选项来跳过损坏的事件，或者使用change master to 命令的 master_log_pos参数。</p>
<h5><span id="72-使用非事务型表">7.2 使用非事务型表</span></h5><hr>
<p>如果一切正常，基于语句的复制通常能够很好的处理非事务型表。但是当对非事务型表的更新发生错误时，例如在查询完成前被kill，就可能导致主库和备库的数据不一致。</p>
<p>例如，假设更新一个myisam表的100还能够数据，若查询更新到了其中50条时有人kill该查询，会发生什么呢？一般的数据改变了，而另一半则没有，结果是复制必然不同步，因为该查询会在备库重放并更新完100行数据（MySQL嘶吼会在主库上发现查询引起的错误，而备库上则没有报错，伺候复制将会发生错误并中断）</p>
<p>如果使用的是myisam表，在关闭MySQL之前需要确保已经运行了stop slave，否则服务器在关闭时会kill所有正在运行的查询（包括没有完成的更新）。事务型存储引擎则没有这个问题。如果使用的是事务型表，失败的更新会在主库上回滚并不会记录到二进制日志中。</p>
<h5><span id="73-混合事务型和非事务型表">7.3 混合事务型和非事务型表</span></h5><hr>
<p>如果使用的是事务型存储引擎，只有在事务提交后才会将查询记录到二进制日志中。因此如果事务回滚，MySQL就不会记录这条查询，也就不会在备库上重放。</p>
<p>但是如果混合使用事务型和非事务型表，并且发横了一次回滚，MySQL能够回滚事务表的更新，但非事务型表则被永久地更新了。只要不发生类似查询中被kill这样的错误，就不是问题：MySQL此时会记录该查询并记录一条rollback语句到日志中。如果是同样的语句也在备库执行，所有的都很正常。这样效率会低一点，因为备库需要做一些工作最后再把它们丢弃掉。但理论上能够保证主备的数据一致。</p>
<p>但是如果备库发生死锁而主库也没有也可能会导致问题。事务型表的更新会被回滚，而非事务型表则无法回滚，此时备库和主库的数据是不一致的。</p>
<p>防止该问题的唯一办法是避免混合使用事务型和非事务型表。如果遇到这个问题，唯一的解决办法是忽略错误，并重新同步相关的表。</p>
<p>基于行的复制不会受到这个问题的影响。因为它记录的是数据的修改，而不是SQL语句.如果一条语句改变了一个myisam表和一个innodb表的某些航,然后主库上发生了一次死锁,innodb表的更新会被回滚,而myisam标的更新仍会被记录到日志中并在备库重放</p>
<h5><span id="74-不确定语句">7.4 不确定语句</span></h5><hr>
<p>当使用基于语句的复制模式时，如果通过不确定的方式更改数据可能会导致主备不一致。例如，一条带有limit的update语句更改的数据取决于查找航的顺序，除非能保证主库和备库上的顺序相同。例如，若行根据主键排序，一条查询可能在主库和备库上更新不同的行，这些问题非常微妙并且很难注意到。所以一些人禁止对哪些会更新数据的语句使用limit。另一种不确定的行为是在一个拥有多个唯一索引的表上使用replace或者insert ignore语句，MySQL在主库和备库上可能会选择不同的索引。</p>
<p>另外还要注意那些涉及information_schema表的语句。他们很容易在主库和备库上产生不一致，其结果也会不相同。</p>
<h5><span id="75-主库和备库使用不同的存储引擎">7.5 主库和备库使用不同的存储引擎</span></h5><hr>
<p>基于语句的复制方式，如果备库使用了不同的存储引擎，则可能造成一条查询在主库和备库上的执行结果不同。</p>
<h5><span id="76-备库发生数据改变">7.6 备库发生数据改变</span></h5><hr>
<p>基于语句的复制方式前提是确保备库上有和主库相同的数据，因此不应该允许对备库数据的任何修改（read_only）。假设有如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">select</span> * <span class="keyword">from</span> table2;</span><br></pre></td></tr></table></figure>
<p>如果备库上table2的数据和主库上不同，该语句会导致table1的数据也会不一致。换句话说，数据不一致可能会在表之间传播。不仅仅是insert … select查询，所有类型的查询都有可能发生。有两种可能的结果：备库上发生重复索引键冲突错误或者根本不提示任何错误。如果能报告错误还好，起码能够提示你主备数据已经不一致。无法察觉的不一致可能会悄无声息的导致各种问题</p>
<p>唯一的解决办法就是重新从主库同步数据。</p>
<h5><span id="77-不唯一的服务器id">7.7 不唯一的服务器ID</span></h5><hr>
<p>如果不小心为两台备库设置了相同的服务器ID，看起来似乎没有什么问题，但如果查看错误日志，或者使用innotop查看主库，可能会看到一些固态的信息。</p>
<p>在主库上，会发现两台备库中只有一台连接到主库（通常情况下所有的备库都会建立连接以等待随时进行复制）。在备库的错误日志中，则会发现反复的重连和连接断开信息，但不会提及被错误配置的服务器ID。</p>
<p>MySQL可能会缓慢的进行正确的复制，也可能无法进行正确复制，这取决于MySQL的版本，给定的备库可能会丢失二进制日志时间，或者重复执行事件，导致重复建错误（或者不可见的数据损坏）。也可能因为备库的互相竞争造成主库的负载升高。如果备库竞争非常激烈，会导致错误日志在很短时间内急剧增大。</p>
<p>唯一的解决办法是小心设置备库的服务器ID。建立映射表。</p>
<h5><span id="78-未定义的服务器id">7.8 未定义的服务器ID</span></h5><hr>
<p>如果没有在my.cnf里定义服务器ID，可以通过chnge master to 来设置备库，但无法启动复制。</p>
<h5><span id="79-对未复制数据的依赖性">7.9 对未复制数据的依赖性</span></h5><hr>
<p>如果在主库上有备库不存在的数据库或表，复制会很容易意外中断，反之亦然。假设主库上有一个备库不存在的数据库，命名为search。如果在主库上发生对该数据库中表的更新，备库会在尝试重放这些更新时中断。同样的，如果在主库上创建一个备库上已存在的表，复制也可能会中断。</p>
<p>没有办法，只能避免</p>
<h5><span id="710-丢失的临时表">7.10 丢失的临时表</span></h5><hr>
<p>临时表在某些时候比较有用，但不幸的是，它与基于语句的复制方式是不相容的。如果备库崩溃或者正常关闭，任何复制线程拥有的临时表都会丢失。重启备库后，所有依赖于该临时表的语句都会失败。</p>
<p>当基于语句进行复制时，在主库上没有安全使用临时表的方法。很多人确实很喜欢临时表。但是不管它们的存在多么短暂，都会使得备库的启动和停止以及崩溃恢复变得困难，即使是在一个事务内使用也是一样。</p>
<p>如果备库重启后复制因找不到临时表而停止，可能需要做下面一些事：可以直接跳过错误，或者手动创建一个名字和结构相同的表来代替消失的临时表。不管用什么办法，如果写入查询依赖于临时表，都可能造成数据不一致。</p>
<p>避免使用临时表没有看起来那么难，临时表主要有两个比较有用的特性：</p>
<ul>
<li>只对创建临时表的线程课件。所以不会和其他拥有相同名字临时表的连接起冲突。</li>
<li>随着连接关闭而消失，所以无需显式的移除它们。</li>
</ul>
<p>可以保留一个专用的数据库，在其中创建持久表，把他们作为临时表，模拟这些特性，只需要为它们选择一个唯一的名字。当应用不在使用临时表后，可以将其删除或者使用一个清理线程来进行移除。使用实体表而非临时表还有别的好处。例如，能够帮助你更容易的调试应用程序，因为可以通过别的链接来查看应用正在维护的数据。如果使用的是临时表，可能就没这么容易做到。</p>
<p>但是实体表会多一些开销，例如创建更慢，因为为这些表分配.frm文件需要刷新到磁盘。可以通过禁止sync_frm选项来加速，但是这坑你导致钱财的风险。</p>
<p>如果确实需要使用临时表，也应该在关闭备库前确保slaev_open_temp_tables状态变量值为0。如果不是0，在重启备库后就可能会出现问题。合适的流程是执行stop slave，检查变量，然后再关闭备库。如果在停止复制前检查变量，可能会发生竞争条件的风险。</p>
<h5><span id="711-不复制所有的更新">7.11 不复制所有的更新</span></h5><hr>
<p>如果错误的使用set sql_log_bin=0或者没有理解过滤规则，备库可能会丢失主库上已经发生的更新。有时候希望利用此特性来做归档，但常常会导致意外并出现不好的结果。</p>
<p>例如，假设设置了replicate_do_db规则，把sakila数据库的数据复制到某一台备库上。如果在主库执行如下语句，会导致主备数据不一致；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line">upate sakila.actor ...</span><br></pre></td></tr></table></figure>
<h5><span id="712-innodb枷锁读引起的锁争用">7.12 InnoDB枷锁读引起的锁争用</span></h5><hr>
<p>正常情况下，InnoDB的读操作是非阻塞的，但在某些情况下需要枷锁。特别是在使用基于语句的复制方式时，执行insert … select操作会锁定源表上的所有行。MySQL需要枷锁以确保该语句的执行结果和在主库和备库上是一致的。实际上，枷锁导致主库上的语句串行化，以确保和备库上执行的方式相同。</p>
<p>这种设计可能导致锁竞争、则色，以及锁等待超时等情况。一种缓解的办法就是避免让事务开启太久以减少阻塞。可以再主库上尽快的提交事务以释放所。</p>
<p>把大命令拆成小命令，使其尽可能简短。这也是一种减少锁竞争的有效方法。即使有时很难做到，但也是值得的</p>
<p>另一种方法是替换掉insert … select语句，在主库上先执行select into outfile，在执行load data in file。这种方法更快，并且不需要加锁。这种方法很特殊，但有时候很有用。最大的问题是为输出文件选择一个唯一的名字，并在完成后清理掉文件。可以通过之前讨论过的connection_id()来保证文件名的唯一性。并且可以使用定时任务在链接不在使用你这些文件后进行自动清理工。</p>
<p>也可以尝试关闭上面的锁机制，而不是使用上面的变通方法。有一种方法可以做到，但在大多数场景下并不是好办法，备库可能会在不知不觉间就失去和主库的数据同步。这也会导致在做恢复时二进制日志变得毫无用处。但如果确实觉得这么做利大于弊，可以使用下面的方式来关闭这种锁机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This is not safe!</span><br><span class="line">innodb_locks_unsafe_for_binlog=1</span><br></pre></td></tr></table></figure>
<p>这使得查询的结果所依赖的数据不再枷锁。如果第二条查询修改了数据并在第一条查询之前先提交。在主库和备库上执行这两条语句的结果可能不相同。对于复制和基于时间点的恢复都是如此。</p>
<p>为了了解读取锁定是如何防止混乱的，假设有两张表，一个没有数据，另一个只有一行数据，值为00.有两个事务更新数据，事务1将第二张表的数据插入到第一张表，事务2更新第二张表。如图：两个事务更新数据，使用共享锁串行化读取</p>
<p>第二步非常重要，事务2尝试去更新源表，这需要在更新的行上加排他锁（写锁）。排他锁与其他锁是不相容的，包括事务1在行记录上加的共享锁。因此事务2需要等待直到事务1完成。事务按照其提交的顺序在二进制日志中记录，所以在备库重放这些事务时产生相同的效果。</p>
<p>但从另一个方面来说，如果事务1没有在读取的行上加共享锁，就无法保证了。如果没有枷锁，记录在日志中的事务顺序在主备上可能会产生不同的结果。MySQL会先记录事务2，这回影响到事务1在备库上的结果，而主库上则不会发生，从而导致了主备的数据不一致。</p>
<p>强烈建议将innodb_locks_unsafe_for_binlog的值设置为0。基于行的复制由于记录了数据的变化而非语句，因此不会存在这个问题。</p>
<h5><span id="713-在主-主复制结构中写入两台主库">7.13 在主-主复制结构中写入两台主库</span></h5><hr>
<p>太多不写，基本没有机会可以用到</p>
<h5><span id="714-过大的延迟复制">7.14 过大的延迟复制</span></h5><hr>
<p>复制延迟是一个很普遍的问题。不管怎么样，最好在设计应用程序时能够让其容忍备库出现延迟。如果系统在备库出现延迟时就无法很好的工作，那么应用程序也许就不应该用到复制。但是也有一些办法可以让备库跟上主库。</p>
<p>MySQL单线程复制的设计导致备库的效率相当低下。即使备库有很多磁盘、CPU或者内存，也会很容易落后于主库。因为备库的单线程通常只会有效的使用一个CPU和磁盘.而事实上,备库通常都会和主库使用相同配置的机器.</p>
<p>备库上的锁同样也是问题。其他在备库运行的查询可能会阻塞住复制线程。因为复制是单线程的，复制线程在等待时将无法做别的事情。</p>
<p>复制一般有两种产生延迟的方式：突然产生延迟然后再跟上，或者稳定的延迟增大。前一种通常姑娘是由于一条运行很长时间的查询导致的，而后者即使在没有长时间的查询时也会出现。</p>
<p>不幸的是，目前我们没那么容易确定备库是否接近其容量上限。正如之前所提到的。如果负载总是保持均匀的，备库在负载达到99%时和其负载在10%的时候表现的性能相同，但一旦达到100%时就会突然开始产生延迟。但实际上负载不太可能很稳定，所以当备库接近写容量时，就可能在尖峰负载时看到复制延迟的增加。</p>
<p>当备库无法跟上时，可以记录备库上的查询并使用一个日志分析工具找出哪里慢了。不要依赖与自己的直觉，也不要基于查询在主库上的查询性能进行判断，因为主库和备库性能特征很不相同。最好的分析办法是暂时在备库上打开慢查询日志记录，然后使用pt-query-digest工具来分析。如果打开了log_slow_slave_statementse选项，在标准的MySQL慢查询日志能够记录复制线程执行的语句，这样就可以找到在复制时哪些语句满了。</p>
<p>除了购买更快的磁盘和CPU,备库没有太多的调优空间。大部分选项都是禁止某些额外的工作来减少备库的负载。一个简单的办法是配置innodb，使其不要那么频繁的刷新磁盘，这样事务会提交的更快一些。可以通过设置innodb_flush_log_at_trx_commit的值为2来实现。还可以在备库上禁止二进制日志记录，把innodb_locks_unsafe_for_binlog设置为1，并把myisam的delay_key_write设置为all。但是这些设置以牺牲安全换取速度。如果需要将备库提升为主库，记得把这些选项这只会安全的值。</p>
<p><strong>不要重复写操作中代价比较高的部分</strong></p>
<p>重构应用或者优化查询通常是最好的保持备库同步的办法。尝试去最小化系统中重复的工作。任何主库上昂贵的写操作都会在每一个备库上重放。如果可以把工作转移到备库，那么就只有一台备库需要执行，然后我们可以把写的结果回传到主库，例如，通过执行load data infile。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> main_db.summary_table(col1,col2,...)</span><br><span class="line"><span class="keyword">select</span> col1,<span class="keyword">sum</span>(col2,...)</span><br><span class="line"><span class="keyword">from</span> main_db.enormous_table <span class="keyword">group</span> <span class="keyword">by</span> col1;</span><br></pre></td></tr></table></figure>
<p>如果在主库上执行查询，每个备库将同样需要执行庞大的group by 查询。当进行太多这样的操作时,备库将无法跟上。把这些工作转移到一台备库上也许会有帮助。在备库上创建一个特别保留的数据库，用于避免和从主库上复制的数据产生冲突。可以执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> smmary_db.summary_table(col1,col2,...)</span><br><span class="line"><span class="keyword">select</span> col1,<span class="keyword">sum</span>(col2,...)</span><br><span class="line"><span class="keyword">from</span> main_db.enormous_table <span class="keyword">group</span> <span class="keyword">by</span> col1;</span><br></pre></td></tr></table></figure>
<p>现在可以执行select info outfile，然后再执行load data infile，将结果集加载到主库中。现在重复工作被简化为load data infile操作。如果有N个备库,就节约了N-1次庞大的group by 操作。</p>
<p>该策略的问题是需要处理陈旧数据。有时候从备库读取的数据和写入主库的数据很难保持一致。如果难以在备份上读取数据，依然能够简化并节省库备工作。如果分离查询的replace和select部分，就可以把结果返回给应用程序，然后将其插入到主库中。首先，在主库执行如下查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col1, <span class="keyword">sum</span>(col2,...) <span class="keyword">from</span> main_db.enormous_table <span class="keyword">group</span> <span class="keyword">by</span> col1;</span><br></pre></td></tr></table></figure>
<p>然后为结果集的每一行重复执行如下语句，将结果插入到汇总表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">replae into main_db.summary_table (col1,col2,...) <span class="keyword">values</span> (?,?,...)</span><br></pre></td></tr></table></figure>
<p>这种方法再次避免了在备库上执行查询中的group by 部分。将select 和 repalce分离后意味着查询的select操作不会在每一台备库上重放。</p>
<p>这种通用的策略，节约了备库上昂贵的写入操作部分，在很多情况下很有帮助：计算查询的结果代价很昂贵，但一旦计算出来后，处理就很容易。</p>
<p><strong>在复制之外并行写入</strong></p>
<p>另一种避免备库严重延迟的办法是绕过复制。任何在主库的写入操作必须在备库串行化。因此有理由认为串行化写入并不能充分利用资源。所有写操作都应该从主库传递到备库么？如果把备库有限的串行写入容量留给那些真正需要通过复制进行的写入？</p>
<p>这种考虑有助于对写入进行区分。特别是，如果能确定一些写入可以轻易的在复制之外执行，就可以并行化这些操作以利用备库的写入容量。</p>
<p>一个很哈的例子是之前讨论过的数据归档。OLTP归档需求通常是简单的单行操作。如果只是把不需要的记录从一个表转移到另一个表，就没有必要将这些写入复制到备库。可以禁止归档查询记录到二进制日志中，然后分别在主库和备库上单独执行这些归档查询。</p>
<p>自己复制数据到另外一台服务器，而不是通过复制，听起来很扯，但对一些应用很有意义，特别是如果应用是某些标的唯一更新源。复制的瓶颈通常集中在小部分表上。如果能在复制之外单独处理这些表，就能够显著的加快复制。</p>
<p><strong>为复制线程预取缓存</strong></p>
<p>如果有正确的工作负载，就能通过预先将数据读入内存中，以受益于在备库上的并行IO所带来的好处。这种方式大部分人并不会使用，因为除非有争取的工作负载特性和硬件配置，否则可能没有任何用户。我们刚刚讨论过的其他几种变通方式是更好的选择，并且有更多的方法来应用他们。</p>
<p>有两种可行的实现方法。一种是通过程序实现，略微比备库SQL提前读取中继日志并将其转换为SELECT语句执行。这会使得服务器将数据从磁盘加载到内存中农，这样当SQL线程执行到对应的语句时，就无须从磁盘读取数据。事实上，select语句可以并行的执行，所以可以加速SQL线程的串行IO。当一条语句正在执行时，洗啊一条语句需要的数据也正在从磁盘加载到内存中。</p>
<p>如果满足下面这些条件，预取可能弧有效：</p>
<ul>
<li>复制SQL线程是IO密集型的，但备库服务器并不是IO密集型的.一个完全的IO密集型服务器不会受益于预取，因为他没有多余的磁盘性能来提供预取。</li>
<li>备库有多个硬盘驱动器，也许8个或者更多。</li>
<li>是用的是innodb引擎，并且工作集远不能完全加载到内存中。</li>
</ul>
<p>一个受益于预读取的例子是随机单行update语句，这些语句通常在主库山高并发执行。delete语句也可能受益于这种方法，但insert语句则不太可能会，尤其是当顺序插入时，因为前一次插入已经使得索引预热了。</p>
<p>如果表上有很多索引，同样无法预取所有将要被修改的数据。update语句可能需要更新所有索引，但select语句通常只会读取主键和一个二级索引。update语句依然需要去读取其他索引的数据已进行更新。在多索引表上这种方法效率会降低。</p>
<p>只有在清除硬件和操作系统的状况时才能尝试这种方法。正确设置参数非常重要，但是并没有绝对正确的参数组合。</p>
<p>另一种方法是innobd内部实现的。它可以允许设置事务为特殊的模式，以语序innodb执行假更新。因此可以使用一个程序来执行这些假更新，这样复制线程就可以更快的执行真正的更新。</p>
<h5><span id="715-例子主库的过大的包">7.15 例子主库的过大的包</span></h5><hr>
<p>主库的max_allow_packet值和备库的不匹配。这种情况下，主库可能会记录一个备库认为过大的包。当备库获取到该二进制日志事件时，可能会碰到各种各样的问题，包括无线报错和重试，或者中继日志损坏。</p>
<h5><span id="716-受限制的复制贷款">7.16 受限制的复制贷款</span></h5><hr>
<p>如果带宽受限，可以开启备库上的slave_compressed_protocol选项。当备库连接主库时，会请求一个被压缩的连接，和MySQL客户端使用的压缩连接一样。使用的压缩引擎是zip，它能将文本类型的数据压缩到大约其原始大小的三分之一。代价是额外的CPU时间，包括在主库和备库上解压数据。</p>
<h5><span id="717-磁盘空间不足">7.17 磁盘空间不足</span></h5><hr>
<p>可能因为二进制日志、中继日志或临时文件将磁盘撑满。特别是在主库上执行了load data infile查询并在备库开启了log_slave_updates选项。延迟越严重，接收到但尚未执行的中继日志会占用越多的磁盘空间。可以通过监控磁盘并设置relay_log_space选项来避免这个问题。</p>
<h5><span id="718-复制的局限性">7.18 复制的局限性</span></h5><hr>
<p>M大量的SQL函数和编程实践不能被可靠的复制.</p>
<p>服务器BUG，大多数MySQL的朱版本都存在历史遗留的复制BUG。</p>
<h4><span id="8-复制有多快">8. 复制有多快</span></h4><hr>
<p>简单说，它和MySQL从主库复制事件并在备库重放的速度一样快。如果网络很慢并且二进制日志很大，记录二进制日志和在备库上执行的延迟可能会非常明显。如果查询需要执行很长时间而网络很快，通常可以认为查询时间占据了更多的复制时间开销。</p>
<p>理论上只受限于网络丝度。MySQL二进制日志转储线程并没有通过轮训的方式从主库请求时间，而是由主库来通知备库新的时间，因为前者低效且缓慢。从主库读取一个二进制日志是一个阻塞型网络调用，当主库记录事件后，马上就开始发送。因此可以说，只要复制线程被唤醒并且能够通过网络传输数据，时间就会很快到达备库。</p>
<h4><span id="9-mysql复制的高级特性">9. MySQL复制的高级特性</span></h4><hr>
<p>MySQL5.5以后包含下面改动</p>
<p>增加了多线程（并行）复制以减少单线程复制的瓶颈。</p>
<p>半同步复制。可以帮助你确保备库拥有主库数据的拷贝，减少了潜在的数据丢失危险。</p>
<p>半同步复制在提交过程中增加了一个延迟：当提交事务时，在客户端接收到查询结束反馈前必须保证二进制日志已经传输到至少一台备库上主库将食物提交到磁盘上之后会增加一些延迟。同样的，这也增加了客户端的延迟，因此其执行大量事务的速度不会比将这些事务传递给备库的速度更快。</p>
<p>关于半同步，有一些无解，下面是它不会去做的：</p>
<ul>
<li>在备库提示其已经收到事件前，会阻塞主库上的事务提交。事实上在主库上已经完成事务提交，只有通知客户端被延迟了。</li>
<li>知道备库执行完事务后，才不会堵塞客户端。备库在接收到事务后发送反馈而完成事务后发送。</li>
<li>半同步不总是能够工作。如果备库一直没有回应已收到时间，会超时并转化为正常的异步复制模式。</li>
</ul>
<p>尽管如此，这仍然是一个很好用的工具，有助于确保备库提供更好的冗余度和持久性。</p>
<p>在性能方面，从客户端的角度来看，增加了事务提交的延时，延时的多少取决于网络传输，数据写入和刷新到备库磁盘的时间（如果开启了配置）以及备库反馈的网络时间。听起来似乎这是累加的，但测试证明这些几乎是不重要的，也许延迟是由其他原因引起的，每次提交大约延时200微秒。对小事务开销可能会比较明显，这也是预期中的。</p>
<p>事实上半同步复制在某些场景下确实能够提供足够的灵活以改善性能，在主库关闭sync_binlog的情况下保证更加安全。写入远程的内存（一台备库反馈）比写入本地的磁盘（写入并刷新）要更快。使用半同步复制相比在主库上进行强持久化的性能有两倍的改善。在任何系统上都没有绝对的持久化，只有更高效的持久化层层次，并且看起来半同步复制应该是一种比其他替代方案开销更小的系统数据持久化方法。</p>
<p>除了半同步复制，还提供了复制心跳，保证备库一直与主库相联系，避免悄无声息的断开连接。如果出现断开的网络连接，备库会注意到丢失的心跳数据。当使用基于行的复制时，还提供了一种改进的能力来处理主库和备库上不同的数据类型。有几个选项可以用于配置复制元数据文件时如何刷新到磁盘以及在一次崩溃后如何处理中继日志，减少了备库崩溃恢复后出现问题的概率。</p>
<p>5.6的改进：</p>
<ul>
<li>事务复制状态，即使崩溃也不会导致元数据失去同步</li>
<li>二进制日志的checksum值，用于检测中继日志中损坏的事件</li>
<li>备库延迟复制，用于提到pt-slave-delay工具</li>
<li>允许基于行的二进制日志事件也包含在主库执行的SQL</li>
<li>实现多线程复制</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL操作系统和硬件优化</title>
    <url>/2020/12/29/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/8-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3><span id="1什么限制了mysql的性能">1.什么限制了MySQL的性能</span></h3><hr><p>最常见的两个瓶颈是CPU和IO资源。当数据可以放在内存中或者可以从磁盘中以足够块的速度读取时，CPU可能出现瓶颈。把大量的数据完全放到大容量的内存中，以现在的硬件条件是完全可行的。</p><a id="more"></a>

<p>另一方面，IO瓶颈，一般发生在工作所需的数据远远超过有效内存容量的时候。如果应用程序是分布在网络上的，如果有大量的查询和低延迟的要求，瓶颈可能转移到网络上，而不再是磁盘IO。</p>
<h4><span id="2-如何为mysql选择cpu">2 如何为MySQL选择CPU</span></h4><hr>
<p>档升级或者购买硬件的时候，应当考虑下工作负载是不是CPU密集型。可以通过CPU利用率来判断是否是CPU密集型的工作负载，但是仅看CPU整体的负载是不合理的，还需要看看CPU使用率和大多数重要的查询的IO的平衡，并注意CPU负载是否均匀分配。</p>
<h5><span id="21-哪个更好更快的cpu还是更多的cpu">2.1 哪个更好，更快的CPU还是更多的CPU</span></h5><hr>
<p>当遇到CPU密集型的工作时,MySQL通常可以从更快的CPU中获益。但这不是绝对的，因为还依赖于负载情况和CPU数量。古老的MySQL在多CPU上有扩展性问题，即使新版本也不能对单个查询并发利用多个CPU。因此，CPU速度限制了每个CPU密集型查询的响应时间。</p>
<p>调优服务器的目标：</p>
<ul>
<li><p>低延时（快速响应）</p>
<p>  要做到这一点，需要高速CPU，因为每个查询只能使用一个CPU。</p>
</li>
<li><p>高吞吐</p>
<p>  如果能同时运行很多查询语句，则可以从多个CPU处理查询中受益。然后，实践中，取决于具体情况。因为MySQL还不能再多个CPU中完美扩展，能用多少CPU是有极限的。不过新版本可以。</p>
</li>
</ul>
<p>MySQL复制也能在高速CPU下工作的很好，而多CPU对复制的帮助不大。如果工作负载是CPU密集型，主库上的并发任务传递到备库以后会被简化为串行任务，这样即使备库硬件比主库好，也可能无法保持跟主库之间的同步。也就是说，备库的瓶颈通常是IO子系统，而不是CPU。</p>
<p>如果有一个CPU密集型的工作负载，考虑是需要更快的CPU还是更多CPU的另外一个因素是查询语句实际在做什么。在硬件层面，一个查询可以在执行或等待。处于等待状态常见的原因是在运行队列中等待（进程已经是可运行状态，但所有的CPU都忙）、等待闩锁（Latch）或锁（Lock）、等待磁盘或网络。那么你期望查询是等待什么呢？如果等待闩锁或锁，通常需要更快的CPU；如果在运行队列中等待，那么更多或者更快的CPU都有可能有帮助。（也有可能例外，例如，查询等待InnoDB日志缓冲区的mutex，直到IO完成前都不会释放，这可能表型需要更多的IO容量）。</p>
<p>这就是说，MySQL在某些工作负载下可以有效地利用很多CPU。例如，假设有很多连接查询的是不同表（假设这些查询不会造成表锁的竞争，实际上对myisam和memory表可能会有问题），并且副武器的总吞吐量比任何单个查询的响应时间都更重要。吞吐量在这种情况下可以非常高，因为线程可以同时运行而互不争用。</p>
<p>再次说明，在理论上这可能更好的工作：不管查询是读取不同的表还是相同的表，InnoDB都会有一些全局共享的数据结构，而myisam在每个缓冲区都有全局所。而且不仅仅是存储引擎，服务器层也会有全局所。以前InnoDB承担了所有的骂名，但最近做了一些改进后，暴露了服务器层中的其他瓶颈。例如臭名昭著的lock_open互斥量（Mutex），在MySQL5.1和更早版本中可能就是个大问题，另外还有其他一些服务器级别的互斥量（例如查询缓存）</p>
<h5><span id="23-扩展到多个cpu和核心">2.3 扩展到多个CPU和核心</span></h5><hr>
<p>多CPU在联机事务处理（OLTP）系统的场景中非常有用。这些系统通常执行许多小的操作，并且是从多个连接发起请求，因此可以在多个CPU上运行。在这样的环境中，并发可能成为瓶颈。大多数web应用程序都属于这一类。</p>
<p>OLTP服务器一般使用InnoDB，尽管它在多CPU的环境中还存在一些未解决的并发问题。然而，不只是InnoDB可能成为瓶颈：任何共享资源都是潜在的竞争点。InnoDB之所以获得大量关注是因为它是高并发环境下最常见的存储引擎。但myisam在大压力时的表现也不好，即使不修改任何数据只是读取数据也是如此。许多并发瓶颈，如InnoDB的行锁和myisam的表锁，没有办法优化，除了尽可能快地处理人物之外。没有别的办法解决，这样，锁就可以尽快分配给等待的任务。如果有一个锁是造成它们都在等待的原因，那么不管有多少CPU都一样。因此，即使是一些高并发工作负载，也可以从更快的CPU中收益。</p>
<p>实际上有两种类型的数据库并发问题，需要不同的方法来解决</p>
<ul>
<li><p>逻辑并发问题</p>
<p>  应用程序可以看到自愿的竞争，如表或者行锁争用。这些问题通常需要好的策略来解决，如改变应用程序、使用不同的存储引擎、改变服务器的配置，或使用不同的锁定提示或事务隔离级别。</p>
</li>
<li><p>内部并发问题</p>
<p>  比如信号量、访问innodb缓冲池页面的资源争用，等等。可以尝试通过改变服务器的设置、改变操作系统，或使用不同的硬件解决这些问题，但通常只能缓解而无法彻底消灭。在某些情况下，使用不同的存储引擎或给存储引擎打补丁，可以帮助缓解这些问题。</p>
</li>
</ul>
<p>MySQL是吧的扩展模式是指它可以有效利用的CPU数量，以及在压力不断增长的情况下如何扩展，这同时取决于工作负载和系统架构。通过系统架构的手段是指通过调整操作系统和硬件，而不是通过优化使用MySQL的应用程序。CPU架构（RISC、CISC、流水线深度等）、CPU型号和操作系统都影响MySQL的扩展模式。这也是为什么说基础测试是非常重要的：一些系统可以在不断增加的并发下依然运行的很好，而另一些的表现则糟糕的多。</p>
<p>有些系统在更多的处理器下，甚至可能降低整体性能。这是普遍的情况，我们了解到许多人试图升级到有多个CPU的系统。最后只能被迫恢复到旧系统。因为这种升级反而降低了性能。如果规划一个大的升级必须要同时考虑硬件，服务器版本和工作负载。</p>
<p>现在CPU的两个复杂之处也值得提一下，首先是频率调整，这是一种电源管理技术。可以根据CPU的压力而动态的改变CPU的时钟速度。问题是他有时不能很好的处理间歇性突发的短查询的情况。因为操作系统可能需要一段时间来决定CPU的时钟是否应该变好。结果查询可能会有一段时间的速度。比较慢。并且响应时间增加了，频率调整可以能使得间歇性的工作负载性能低下，但可能更重要的是他会导致性能波动。</p>
<p>第二个复杂之处是boost技术。周技术改变了我们的CPU模式的看法，我们曾经以为四核2GhzCPU有四个同样强大的核心，不管其中有些闲置或非闲置。由此，一个完美的可扩展系统，当它使用所有四个内核的时候，预计可以得到四倍的提升。但是现在已经不是这样了，因为它系统只使用一个核心时。处理器和运行在更高的时钟速度上。例如3GHz。这给很多的规划容量和可扩展性建模的工具处了一个难题。因为系统性能表现不再是线性的变化了。这也意味着，空闲CPU并不代表相同规模的资源浪费。如果有一台服务器上只运行了备库的复制，复制执行是单线程的。所以有三个CPU是空闲的。因此可以认为利用这些CPU执行其他任务而不影响复制，那就错了。</p>
<h4><span id="3-平衡内存和磁盘内置">3 平衡内存和磁盘内置</span></h4><hr>
<p>配置大量内存最大的原因不是因为可以在内存中保存大量数据，最终目的是避免磁盘IO。磁盘io比在内存中访问数据要慢的多。关键是要平衡内存和磁盘的大小，速度，成本和其他因素。以便为工作负载提供高性能的表现。</p>
<p>最近被使用的数据可能很快再次被使用，以及相邻的数据可能很快需要使用。这些算法非常有效，因为他们算好的空间和时间的局部性原理。</p>
<p>从程序员的视角看，CPU寄存器和高速缓存是透明的，并且与硬件架构相关。管理他们是编译器和CPU的工作。然而程序员会有意识的注意到内存和硬盘的不同。并且在程序中通常区分使用他们。</p>
<p>在数据库服务器上尤其明显。其行为往往非常符合我们刚刚提到的预测算法所做的预测。设计良好的数据会缓存，其效率通常超过操作系统的缓存。因为搜索系统缓存是为通用任务设计的，数据库库缓存，更了解数据库存取数据的需求。它包含特殊用途的逻辑，以帮助满足这些需求。此外，系统调用不需要访问数据库中的缓存数据。内存和存储是唯一可以改变的东西。</p>
<h5><span id="31-随机io和顺序io">3.1 随机IO和顺序IO</span></h5><hr>
<p>数据库服务器同时使用顺序和随机IO。随机IO从缓存中收益最多。想象有一个典型的混合工作负载。青黄的包含单行查找和多行范围扫描。可以说服自己相信这个说法。典型的情况是热点数据随机分布。因此，缓存这些数据将有助于避免昂贵的磁盘寻道。相反，顺序读取一般只需要扫描一次数据。所以缓存对他是没用的。除非能完全放在内存中缓存起来。</p>
<p>顺序读取不能从缓存中受益的给另一个原因是他们比随机读快。这有以下两个原因：</p>
<ul>
<li><p>顺序IO比随机IO块。</p>
<p>  顺序操作的执行速度比随机操作快，无论是在内存还是磁盘上。假设磁盘每秒可以做100个随机IO操作。并且合约完成每秒50M的顺序读取。如果每行100字节，随机读，可以每秒读100行。相比之下，顺序都可以每秒都50万行，是随机读的5000倍。或几个数量级的差异。因此，在这种情况下，随机IO可以从缓存中获得很多好处。</p>
<p>  顺序访问内存行的速度也快于随机访问。现在的内存芯片通常可以随机访问约25万次100字节的行。或者每秒500万次的顺序访问。请注意，内存随机访问速度比磁盘随机访问快了2500倍，而内存中顺序访问只有磁盘10倍的速度。</p>
</li>
<li><p>存储引擎执行顺序读比随机读块</p>
<p>  一个随机读一般意味着存储引擎必须执行索引操作。通常需要通过B树的数据结构查找，并且和其他值比较。相反，连续读取一般需要遍历一个简单的数据结构，例如链表。这样就减少了很多工作。反复这样操作，连续读取的速度就比随机读要快了。</p>
</li>
</ul>
<p>最后，随机读取通常只要查找特定的行，但不仅仅只读取一行，而是要读取一整页的数据，其中大部分是不需要的。这浪费了很多工作。另一方面，顺序读取数据，通常发生在想要的页面上的所有行，所以更符合成本收益。</p>
<p>综上所述，通过缓存顺序读取可以节省一些工作，但缓存随机读取可以计生工作的工作。换句话说，如果能负担得起，增加内存是解决随机IO读取问题最好的办法。</p>
<h5><span id="32-缓存读和写">3.2 缓存，读和写</span></h5><hr>
<p>如果有足够的内存,就可以完全避免磁盘读取请求。如果所有的数据文件都可以放在内存中，一旦服务区缓存热起来了，所有的读操作都会在缓存命中。虽然还是会有逻辑读取，不过物理读取就没有了。但写入时不同的问题。写入可以像读一样在内存中完成，但迟早要被写入到磁盘，所以它是需要持久化的。换句话说，缓存可延缓写入，但不能想消极读取一样消除写入。</p>
<p>事实上，除了允许写入被延迟，缓存可以允许他们被集中操作，主要通过一下两个重要途径：</p>
<ul>
<li><p>多次写入，一次刷新</p>
<p>  一片数据可以在内存中改变很多次，而不需要把所有的新值写到磁盘。当数据最终被刷新到磁盘后，最后一次物理写之前发生的修改都被持久化了。例如，许多语句可以更新内存中的计数器。如果计数器递增100次，然后写到磁盘，100次修改就被合并为一次写。</p>
</li>
<li><p>IO合并</p>
<p>  许多不同部分的数据可以在内存中修改，并且这些修改可以合并在一起，通过一次磁盘操作完成物理写入。</p>
</li>
</ul>
<p>这就是为什么许多交易系统使用预写日志（WAL）策略。预写日志采用在内存中变更页面，而不马上刷新到磁盘上的策略，因为刷新磁盘通常需要随机IO,这非常慢。相反，如果把变化的记录写到一个连续的日志文件，这就很快了。后台线程可以稍后把修改的页面刷新到磁盘，并在刷新过程中优化写操作。</p>
<p>写入从缓存中大大受益，因为它把随机IO更多地转换到连续IO。异步写通常是由操作系统批量处理，使他们能以更优化的方式书信到磁盘。同步写必须在写入到磁盘之后才能完成。这就是为什么它们受益于RAID控制器中电池供电的回写高速缓存。</p>
<h5><span id="33-工作集是什么">3.3 工作集是什么</span></h5><hr>
<p>每个应用程序都有一个数据的工作集，就是做这个工作确实需要用到的数据。很多数据库都有大量不在工作集内的数据。</p>
<p>可以把数据库想象为有抽屉的办公桌。工作集就是放在桌面上的完成工作必须使用的文件。桌面是这个比喻中的主缓存，而抽屉就是硬盘。就像完成工作不需要办公桌里每一张纸一样，也不需要把每个数据库状态内存中来获得最佳性能，只需要工作集就可以。</p>
<p>工作集大小的不同取决于应用程序。对于某些应用程序工作及可能是总数据大小的1%。而对于其他应用。有可能接近百分之百。当工作集不能完全放在内存中时，数据库必须在磁盘和内存之间交换数据。已完成工作。这就是为什么内存不足，有可能看起来却像IO问题。有事没有办法把整个工作机的数据放在内存中。而并且有时也并不真的想这么做(例如，应用需要大量的顺序IO)。工作集能否完全放在内存中,对应用程序体系结构的设计会产生很大影响。</p>
<p>工作机可以定义为基于时间的百分比。例如，一小时的工作集可能是一个小时内数据库使用的95%的页面，除了5%的的最不常用的页面。百分比是考虑这个问题最有用的方式，因为每小时可能需要访问的数据只有1%，但超过24小时，需要访问的数据可能增加到整个数据库中20%的不同页面。根据需要被缓存起来的数据量的多少，来思考工作集会更加直观，缓存的数据越多，工作负载就越可能成为CPU密集型。如果不能缓存足够的数据，工作集就不能完全放在内存中。</p>
<p>应该依据最常用的页面集来考虑工作集，而不是最频繁读写的页面集。这意味着，确定工作集需要在应用程序内有测量的模块，而不能仅仅看外部资源的利用，例如IO访问,因为页面的IO操作跟逻辑访问页面不是同一回事。例如，MySQL可能把一个页面读入内存，然后访问它数百万次，但如果查看strace，只会看到一个IO操作。缺乏确定工作集所需的检测模块，最大的原因是没有对这个主题有比较多的研究。</p>
<p>工作集包括数据和索引，所以应该采用缓存单位来计数。一个缓存单位是存储引擎工作的数据最小单位。</p>
<p>不同存储引擎的缓存单位大小是不一样的，因此也使得工作集的大小不一样。例如，InnoDB在默认情况下是16KB的页。如果InnoDB做一个单行查找需要读取磁盘，就需要把该行的整个页面读入缓冲池进行缓存，这会引起一些缓存的浪费。假设要随机访问100字节的行。InnoDB将用掉缓冲池中很多额外的内存来缓存这些行，因为每一行都必须读取和缓存一个完整的16KB页面.因为工作集也包括索引,InnoDB也会读取并缓存查找行所需的索引树的一部分.InnoDB的索引页大小也是16KB，这意味着访问一个100字节的行可能一共要使用32KB的缓存空间（有可能更多，这取决于索引树有多深）。因此，缓存单位也是在InnoDB中精心挑选聚集索引非常重要的另一个原因。聚集索引不仅可以优化磁盘访问，还可以帮助在同一页面存储相关的数据，因此在缓存中可以尽量放下整个工作集。</p>
<h5><span id="34-找到有效的内存磁盘比例">3.4 找到有效的内存/磁盘比例</span></h5><hr>
<p>找到一个良好的内存/磁盘比例最好的方式是通过实验和基准测试。如果可以把所有东西放入内存，你就大功告成了，后面没有必要再为此考虑什么。但大多数的时候不可能这么做，所以要用数据的一个子集来做基准测试，看看将会发生什么。测试的目标是一个可接受的缓存命中率。缓存未命中是当有查询请求数据时，数据不能在内存中命中，服务器需要从磁盘获取数据。</p>
<p>缓存命中率实际上也会决定使用了多少CPU，所以评估缓存命中率的最好方法是查看CPU使用率。例如，若CPU使用了99%的时间工作，用了1%的时间等待IO，那缓存命中率还是不错的。</p>
<p>考虑下工作集是如何影响高速缓存命中率的。首先重要的一点，要认识到工作集不仅是一个单一的数字而是一个统计分布，并且缓存命中率是非线性分布的。例如，有10G内存，并且未缓存命中率为10%，可能会认为只需要增加11%以上的内存，就可以降低缓存的未命中率到0。但实际上，诸如缓存单位的大小之类的问题会导致缓存效率低下，可能意味着理论上需要50GB的内存,才能把未命中率降低到1%。即使与一个完美的缓存单位相匹配，理论预测也可能是错误的：例如数据访问模式的因素也可能让事情更复杂。解决1%的缓存未命中率甚至可能需要500GB的内存，这取决于具体的工作负载。</p>
<p>有时候很容易去优化一些可能不会带来多少好处的地方。例如，10%的未命中率可能导致80%的CPU使用率，这已经是相当不错的了。假设增加内存，并能够让缓存未命中率下降到5%，简单来说，将提供另外约6%的数据给CPU。再简化一下，也可以说，把CPU使用率增加到了84.8%。然而，考虑到为了得到这个结果需要购买的内存，这不一定是一个大胜利。在现实中，因为内存和磁盘访问速度之间的差异、CPU真正操作的数据，以及许多其他因素，降低缓存未命中率到5%可能都不会太多改变CPU使用率。</p>
<p>这就是为什么我们说，你应该争取一个可接受的缓存命中率，而不是将缓存未命中率降低到零。没有一个应该作为目标的数据，因为可以接受怎么定义，取决于应用程序和工作负载。有些应用程序有1%的缓存未命中都可以工作得非常好，而另一些应用实际上需要这个比例低到0.01才能良好运转。</p>
<p>最好的内存/硬盘的比例还取决于系统上的其他组件。假设有16GB的内存、20GB的数据，以及大量未使用的磁盘空间系统。该系统在80%的CPU利用水平下运行的很好。如果想在这个系统上放置两倍多的数据，并且保持相同的性能水平，你可能会认为只需要让CPU数量和内存量也增加到两倍。然而，即使系统中的每个组件都按照增加的负载扩展相同的量（一个不切实际的假设），这依然可能会使得系统无法正常工作。有20GB数据的系统可能使用了某些组件超过50%的容量。例如，它可能已经用掉了每秒IO最大操作数的80%。并且在系统内排队也是非线性的。服务器将无法处理两倍的负载。因此，最好的内存/磁盘比例取决于系统中最薄弱的组件。</p>
<h5><span id="35-选择硬盘">3.5 选择硬盘</span></h5><hr>
<p>如果无法满足让足够的数据在内存中的目标。例如，估计将需要500GB的内存才能完全让CPU负载起当前的IO系统，那么应该考虑一个更强大的IO子系统，有时甚至要牺牲内存为代价。同时，应用程序的设计应该能够处理IO等待。</p>
<p>这听起来似乎有悖常理。毕竟我们刚刚说过。更多的内存可以缓解IO子系统的压力，减少IO等待.为什么要加强IO子系统？如果只增加内存能解决问题吗？当然就在所涉及的因素之间的平衡。例如读写之间的平衡。每个艾欧操作的大小。以及每秒有多少这样的操作发生。例如，若需要快速写日志。就不能通过增加大量有效内存来避免磁盘写入。在这种情况下，投资一个高性能的IO系统。投资电池支持的写缓存或者固态存储。可能是个更好的主意。</p>
<p>从传统磁盘读取数据的过程分为三个步骤。</p>
<ul>
<li>移动读取磁头到磁盘表面上的正确位置。</li>
<li>等待磁盘旋转。所有所需的数据在读取磁头下。</li>
<li>等待磁待磁盘旋转过去，所有所需的数据都被读取磁头读出。</li>
</ul>
<p>磁盘执行这些操作有多快？可以浓缩为两个数字：访问时间（步骤一和步骤二合并）和传输速度。这两个数字也决定延迟和存储量。不管是需要快速访问时间还是快速的传输速度或者两者混合，依赖于与正在运行的查询语句的种类，从完成一次磁盘都读取所需要的总时间来说，小的随机查找以步骤一和步骤二为主。而大的顺序读主要是第三步。</p>
<p>其他一些因素也会影响磁盘的选择，哪个重要取决于应用。假设正在为一个在线应用选择磁盘。例如一个受欢迎的新闻网站。有大量小的磁盘随机读取。可能需要考虑下列因素。</p>
<ul>
<li><p>存储容量</p>
<p>  对在线应用来说，容量很少成为问题。现在的磁盘足够大了。如果不够，用RAID把小磁盘组合起来是标准做法</p>
</li>
<li><p>传输速度</p>
<p>  现在磁盘通常数据传输速度非常快。正如我们前面看到的，究竟多快，主要取决于主轴转速和数据存储在磁盘表面上的密度。再加上主机系统的接口的限制。无论如何，传输速度通常不是在线应用的限制因素。你们他们一般会做很多小的随机查找。</p>
</li>
<li><p>访问时间</p>
<p>  对随机查找的速度而言，这是个主要因素，所以应该寻找更快的访问时间的磁盘。</p>
</li>
<li><p>物理尺寸</p>
<p>  所有其他条件都相同的情况下，磁盘的物理尺寸也会带来差别。越小的磁盘，移动读取磁头需要的时间就越短。服务器级的2.5英寸磁盘性能。往往比他们的更大的盘更快，他们还可以节省电力，并且通常会融入机箱中。</p>
</li>
</ul>
<p>和CPU一样,MySQL如何扩展到多个磁盘上取决于存储引擎和工作负载，InnoDB能很好地扩展到多个磁盘驱动器。然而，myisam的表锁限制其写的可扩展性，因此写繁重的工作加在myisam上，可能无法从多个驱动器中收益。虽然操作系统的文件系统缓冲和后台并发写入会有点帮助，但myisam相对于innodb在写可扩展性上有更多的限制。</p>
<p>和CPU一样，更多的磁盘也不并总是更好。有些应用要求低延迟需要的是更快的驱动器，更不是更多的驱动器。例如，复制通常在更快的驱动器上表现更好，因为备库的更新是单线程的。</p>
<h4><span id="4-固态存储">4.  固态存储</span></h4><hr>
<p>高质量闪存设备具备：</p>
<ul>
<li>相比硬盘有更好的随机读写性能，闪存设备通常读明显比写要快。</li>
<li>相比硬盘有更好的顺序读写性能。但是相比较而言不如随机IO的改善那么大，因为硬盘随机IO比顺序IO慢得多。入门级固态硬盘的顺序读取实际上还可能比传统硬盘慢</li>
<li>相比硬盘能更好的支持并发。闪存设备可以支持更多的并发操作，事实上，只有大量的并发请求才能真正实现最大吞吐量。</li>
</ul>
<p>最重要的事情是提升随机IO和并发性。闪存记忆体可以再高并发下提供很好的随机IO性能，这正是范式化的数据库所需要的。设计非范式化的schema最常见的原因之一是为了避免随机IO，并且使得查询可能转化为顺序IO。</p>
<h5><span id="优化固态存储上的mysql">优化固态存储上的MySQL</span></h5><hr>
<ul>
<li><p>增加innodb的IO容量</p>
<p>  闪存比机械硬盘支持更高的并发量。所以可以增加读写线程数到10或15来获得更好的结果。也可以在两千到两万范围内调整innodb_io_capacity选项，这要看设备实际上能支撑多大的IOPS。尤其是对官方的innodb很有必要，内部很多算法依赖这个配置。</p>
</li>
<li><p>让innodb日志文件更大</p>
<p>  即使最近版本的innodb中改进了崩溃恢复算法，也不应该把磁盘上的日志文件调的太大，因为崩溃恢复需要随机IO访问，会导致恢复需要很长一段时间。闪存存储让这个过程快很多，所以可以设置更大的innodb日志文件，以帮助提升和稳定性能。对oracle官方的innodb，这个设置尤其重要，它维持一个持续的脏页刷新比例有点麻烦，除非有相当大的日志文件，4G或者更大，在写的时候对服务器来说是个不错的选择。</p>
</li>
<li><p>把一些文件从闪存移到RAID</p>
<p>  除了把innodb日志文件设置的更大，把日志文件从数据文件中拿出来，单独放在一个带有电池保护写缓存的RAID组上而不是固态设备上，也是个好主意。这么做有几个原因。一个原因是日志文件的IO类型，在闪存设备上不比在这样一个RAID组上要快。innodb写日志是以512字节为单位的顺序IO写下去,并且除了崩溃恢复会顺序读取，其他时候绝不会去读。这样的IO操作类型用闪存设备是很浪费。并且把小的写入操作从闪存转移到RAID卷也是个好主意，因为很小的写入会增加闪存设备的写放大因子，会影响一些设备的使用寿命。大小写操作混合到一起也会引起某些设备延时的增加。</p>
<p>  基于相同的原因，有时把二进制日志文件转移到RAID卷也会有好处。并且你可能会认为ibdata1文件也适合放在RAID卷上，因为ibdata1文件包含双写缓冲和插入缓冲。尤其是双写缓冲会进行很多重复写入。在percona server中，可以把双写缓冲从ibdata1文件中拿出来，单独存放到一个文件，然后把这个文件放在RAID卷上。</p>
<p>  还有另一个选择：可以利用percona server的特性，使用4KB的块写事务日志,而不是512字节.因为这会匹配大部分内存本身的块大小,所以可以获得更好的效果.</p>
</li>
<li><p>禁用预读</p>
<p>  预读通过通知和预测读取模式来优化设备的访问,一旦认为某些数据在未来需要被访问到,就会从设备上读取这些数据。实际上在innodb中有两种类型的预读，我们发现在多种情况下的性能问题，其实都输预读以及它的内部工作方式造成的。在许多情况下，开销比收益大，尤其是在闪存存储，但没有证据证明提升多少性能。</p>
</li>
<li><p>配置InnoDB刷新算法</p>
<p>  这决定innodb什么时候、刷新多少、刷新哪些页面，这是个非常复杂的主题。建议innodb_adaptive_checkpoint选项为keep_average，不要用默认值estimate。可以确保更持续的性能，避免服务器抖动<br>  另外建议为闪存设备设置innodb_flush_neighbor_page=0。这样可以避免innodb尝试查找相邻的脏页一起刷写。这个算法可能会导致更大快的写、更高的延迟以及内部竞争。在闪存存储设备商完全没必要，也没有什么收益，因为相邻的页面单独刷新不会冲击性能</p>
</li>
<li><p>禁用双写缓冲的可能</p>
<p>  相对于把双写缓存转移到闪存设备，可以考虑直接诶关闭它。并且这个收益在闪存设备上比在传统磁盘上要高得多，禁用双写缓冲在闪存存储上可以提高MySQL整体性能差不多50%。</p>
</li>
<li><p>限制插入缓冲大小</p>
<p>  插入缓冲（变更缓冲）设计用来减少当更新行不在内存中的非唯一索引引起的随机IO。在硬盘驱动器上，减少随机IO可以带来巨大的性能提升。对某些类型的工作服在，当工作集比内存大很多时，差异可能达到近两个数量级。插入缓冲在这类场景下就很有用。<br>  然而，对闪存就没必要了。闪存上随机IO非常快,所以即使完全禁用插入缓冲,也不会带来太大影响，尽管如此，可能你也不想完全禁用插入缓存。所以最好还是启用，因为IO只是修改不在内存中的索引页面的开销的一部分.对内存设备而言，最重要的配置是控制最大允许的插入缓冲大小，可以限制为一个相对比较小的值，而不是让它无限制地增长，这可以避免消耗设备上的大量空间，并避免ibdata1文件变得非常大的情况。</p>
</li>
</ul>
<p>修改页大小，修改innodb页面校验算法。服务器开启超线程，当使用闪存存储时，会有很大帮助，因为磁盘通常不再是瓶颈，任务会更多地从IO密集变为CPU密集。</p>
<h4><span id="5-为备库选择硬件">5 为备库选择硬件</span></h4><hr>
<p>固态硬盘，最好是相同的硬件和配置，能承受主库的所有写入。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的IO行为</title>
    <url>/2020/12/26/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/7-MySQL%E7%9A%84IO%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<h2><span id="mysql的io行为">MySQL的IO行为</span></h2><hr><p>innodb不仅允许控制怎么恢复，还允许控制怎么打开和刷新数据，这会对恢复和整体性能产生巨大的影响。尽管可以影响它的行为，innodb的恢复流程实际上是自动的，并且经常在innodb启动时运行。撇开恢复并假设innodb没有崩溃或者出错，innodb依然有很多需要配置的地方。它有一系列复杂的缓存和文件设计可以提升性能，以及保证ACID特性，并且每一部分都是可配置的。</p><a id="more"></a>

<h4><span id="innodb-事务日志">innodb 事务日志</span></h4><p>innodb使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机IO。innodb假设是用的是常规磁盘，随机IO比循序IO要昂贵得多,因为一个IO请求需要时间把磁头移动到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p>innodb用日志吧随机IO变成顺序IO，一旦日志安全写到磁盘，事务就持久化了，即使变更还没写到数据文件。如果一些糟糕的事情发生，比如断电，innodb可以重放日志并且回复已经提交的事务。</p>
<p>当然，innodb最后还是必须把变更写到数据文件，因为日志有固定的大小。innodb的日志是环形方式写的：当写道日志的尾部，会重新跳转到开头继续写，但不会覆盖还没有应用到数据文件的日志记录，因为这样做会清除掉已提交事务的唯一持久化记录。</p>
<p>innodb使用一个后台线程智能地书信这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。实际上，事务日志把数据文件的随机IO转换为几乎顺序的日志文件和数据文件IO，把刷新操作转移到后台使查询可以更快完成，并且缓和查询高峰时IO系统的压力。</p>
<p>整体的日志文件大小受控于innodo_log_file_size和innodb_log_files_in_group两个参数，这对写性能非常重要。日志文件的总大小是每个文件的大小之和。默认情况下，只有两个5MB的文件,总共10MB，这对于高性能工作来说太小了。至少需要几百M，甚至上G的日志文件.</p>
<p>innodb使用多个文件作为一组循环日志.通常不需要修改默认的日志数量,只修改每个日志文件的大小即可.要修改日志文件大小,需要完全关闭MySQL,将旧的日志文件转移到其他地方保存,重新配置参数,然后重启.一定要确保MySQL干净地关闭了,或者还有日志文件可以保证需要应用到数据文件的事务记录,否则数据库就无法恢复了.当重启副武器的时候,查看MySQL的错误日志.再重启成功后,才能删除就的日志文件.</p>
<p>日志文件大小和日志缓存。要确定立项的日志文件大小，必须权衡正常数据变更的开销和崩溃恢复需要的时间。如果日志太小，innodb将必须做更多的检查点，导致更多的日志写。在极个别情况下，写语句可能被拖累，在日志没有空间继续写入前，必须等待变更被应用到数据文件。另一方面，如果日志太大了，在崩溃恢复时innodb可能不得不做大量的工作。这可能极大地增加恢复时间，尽管这个处理在新的MySQL版本中已经改善跟多。</p>
<p>数据大小和访问模式也将影响恢复时间。假设有一个1TB的数据和16GB的缓冲池，并且全部日志大小是128MB。如果缓冲池里有很多葬爷，并且它们均匀分布在1TB数据中，崩溃后恢复将需要相当长一段时间。innodb必须从头到尾扫描日志，仔细检查数据文件，如果需要还要应用变更到数据文件。这是很庞大的读写操作！另一方面，如果变更是局部的，就是说，如果只有几百MB数据被频繁地变更，恢复可能就很快，即使数据和日志文件很大。恢复时间也依赖于普通修改操作的大小，这根数据行的平均长度有关系。较短的行使得更多的修改可以放在同样的日志中，所以innodb可能必须在恢复时重放更多修改操作。</p>
<p>当innodb变更任何数据时，会写一条变更记录到内存日志缓冲区。再缓冲满的时候，事务提交的时候，或者每一秒钟，innodb就会刷写缓冲区的内容到磁盘日志文件，无论上述三个条件哪个先到达。如果有大事务，增加日志缓冲区大小可以帮助减少IO。innodb_log_buffer_size可以控制日志缓冲区的大小。</p>
<p>通常不需要吧日志缓冲区设置的非常大。推荐的范围是1-8m，一般来说足够了，除非要写很多大的blob记录。相对于innodb的普通数据，日志条目是非常紧凑的。它们不是基于页的，所以不会浪费空间来一次存储整个页。innodb也使得日志条目尽可能地短。有时甚至会保存为函数号和C函数的参数。</p>
<p>较大的日志缓冲区在某些情况下也是有好处的：可以减少缓冲区中空间分配的争用。当配置一台有大内存的服务器时，有时简单地分配32-128m的日志缓冲，因为花费这么点相对而言比较小的内存并没有什么不好，还可以帮助避免压力平津。</p>
<p>可以通过检查<strong>show innodb status</strong>的输出中log部分来监控innodb的日志和日志缓冲区的IO性能，通过观察innodb_os_log_written状态变量来查看innodb对日志文件写出了多少数据。一个好用的经验法则是：<strong>查看10-100秒间隔的数字，然后记录峰值。可以用这个来判断日志缓冲是否设置的正好。例如，若看到峰值是美妙写100k数据到日志，那么1M的日志缓冲可能足够了。也可以使用这个衡量标准来决定日志文件设置多大会比较好。如果峰值是100k/s，那么256m的日志文件足够存储至少2560秒的日志记录。这看起来足够了。作为一个经验法则，日志文件的全部大小，应该足够容纳服务器一个小时的活动内容。</strong></p>
<p>innodb怎样刷新日志缓冲。当innodb把日志缓冲刷新到磁盘日志文件时，会先使用一个mutex锁住缓冲区，刷新到所需要的位置，然后移动剩下的条目到缓冲区的前面，当mutex释放时，可能有炒股go一个事务已经准备好刷新七日织记录。innodb有一个group commit功能，可以在一个IO操作内提交多个事务,但是在MySQL5 中打开二进制日志时,这个功能就不能用了.</p>
<p>日志缓冲必须被刷新到持久化存储，以确保提交的事务完全被持久化了。如果和持久相比更在乎性能，可以修改innodb_flush_log_at_trx_commit变量来控制日志缓冲刷新的频繁程度。可能设置如下</p>
<ul>
<li>0，把日志缓冲写到日志文件，并且每秒钟刷新一次，但是事务提交时不做任何事。</li>
<li>1，将日志缓冲写到日志文件，并且每次事务提交刷新到持久化存储。这是默认的设置，该设置能保证不会丢失任何已经提交的事务，除非磁盘或者操作系统是未刷新。</li>
<li>2，每次提交时把日志缓冲写到日志文件，但是并不刷新。innodb每秒钟做一次刷新。0和2的最重要的不同是，如果MySQL进程挂了，2不会丢失任事务。如果整个服务器挂了或者断电了，则还是可能会丢失一些事务。</li>
</ul>
<p>了解“把日志缓冲写到日志文件”和“把日志刷新到持久化存储”之间的不同是很重要的。在大部分操作系统中，把缓冲写到日志知识简单的把数据从innodb的内存缓冲转移到了操作系统的缓冲，也是在内存里，并没有真的把数据写到了持久化存储。</p>
<p>因此，如果MySQL崩溃了或者电源断电了，设置0和2通常会导致最多一秒的数据丢失，因为数据只可能存在操作系统的缓存。我们说通常，因为不论如何innodb会每秒尝试刷新日志文件到磁盘，但是在一些场景下也可鞥丢失超过一秒的食物，例如当刷新没延迟了。</p>
<p>与此相反，把日志刷新到持久化存储意味着innodb请求操作系统把数据刷出缓存，并且确认写到磁盘了。这是一个阻塞IO的调用，知道数据被完全写回才会完成。因为写数据到磁盘比较慢，当innodb_flush_log_at_trx_commit被设置为1时，可能明显地降低innodb每秒可以提交的事务数，今天的告诉驱动器可能每秒只能执行一两百个磁盘事务，受限于磁盘旋转速度和寻址时间。</p>
<p>有时磁盘控制器或者操作系统假装做了刷新，其实知识吧数据放到了另一个缓存，例如磁盘自己的缓存。这更快但是很危险，因为如果驱动器断电，数据依然可能丢失。这甚至比设置innodb_flush_log_at_trx_commit为不为1的值更糟糕，因为只可能导致数据损坏，不仅仅是丢失事务。</p>
<p>设置innodb_flush_log_at_trx_commit为不为1的值坑会导致丢失事务。然而，如果不在意持久性，那么设置为其他的值也是有用的。也许你知识想拥有innodb的其他一些功能，例如聚簇索引，防治数据损坏，以及行锁。但仅仅因为性能原因用innodb替换myisam 的情况也并不少见。</p>
<p><strong>高性能事务处理需要的最佳配置是吧innodb_flush_log_at_trx_commit设置为1且把日志文件放到一个有电池保护的写缓存的RAID卷中。这兼顾了速度和安全</strong>。事实上，我们敢说任何希望能扛过高负荷工作负载的产品数据库服务器，都需要有这种类型的硬件。</p>
<h5><span id="innodb怎样打开和刷新日志以及数据文件">innodb怎样打开和刷新日志以及数据文件</span></h5><p>使用innodb_flush_method选项可以配置innodb如果跟文件系统相互作用。从名字来看，会以为只能影响innodb怎么写数据，实际上影响了innodb怎么读数据。windows和非windwos的操作系统对这个选项的值是互斥的：async_unbuffered、unbuffered和normal之鞥呢在windows下使用，而且windows下不能使用其他的值。在windows下默认值是unbuffered，其他操作系统都是fdatasync。</p>
<p><strong>这是一个有点那一理解的选项，因为它既影响日志文件，业形象数据文件，而且有时候对不同类型的文件的处理也不一样。如果有一个选项来配置日志，另一个选项来配置数据文件，这样最好了，但实际上它们混合在同一个配置中。</strong></p>
<p>下面是一些可能的值</p>
<ul>
<li><p>fdatasync</p>
<p>  这在非windows系统上是默认值：innodb使用fsync()来刷新数据和日志文件。innobd通常用fsync代替fdatasync，即使这个值似乎表达的是相反的意思。fdatasync和fsync相似，但是只刷新文件的数据，而不包括元数据。因此，fsync会导致更多的IO，然而innodb的开发者都很保守，他们发现某些场景下fdatasync会导致数据损坏。innodb决定了哪些方法可以更安全地使用，有一些是编译时设置的，也有一些事运行时设置的。它使用尽可能最快的安全方法。</p>
<p>  使用fsync的缺点是操作系统至少会在自己的缓存中缓冲一些数据。理论上，这种双重缓冲室浪费的，因为innodb管理自己的缓冲比操作系统能做的更加智能。然而，最后的影响跟操作系统和文件系统非常相关。如果能让文件系统做更智能的IO调度和批量操作,双重缓冲可能并不是坏事.有的文件系统和操作系统可以积累写操作合并执行,通过对IO重新排序来提升效率，或者并发写如多个设备。它们也可能做预读优化，例如，若连续请求了几个顺序的块，它会通知硬盘预读下一个块。</p>
<p>  有时这些优化有帮助，有时么有。如果好奇fsync会做哪些具体的事，可以阅读系统的帮助手册。</p>
<p>  innodb_per_file_table选项会导致每个文件独立地做fsync，这意味着写多个表不能合并到一个IO操作。这可能导致innodb执行更多的fsync操作。</p>
</li>
<li><p>0_DIRECT</p>
<p>  innodb对数据文件使用0_DIRECT标记或者directio函数，这依赖于操作系统。这个设置并不影响日志文件并且不是在所有的类unix系统上都有效。但是linux是支持的。不像0_DSYNC标记，，它会同时影响读和写。</p>
<p>  这个设置依然使用fsync来刷新文件到磁盘，但是会通知操作系统不要缓存数据，也不要预读。这个选项**完全关闭了操作系统缓存，并且使得所有的读和写都直接通过存储设备，避免了双重缓冲。</p>
<p>  在大部分系统上，这个实现用fcntl调用来设置文件描述符的0_DIRECT标记，所以可以阅读fcntl的手册了解细节。</p>
<p>  如果RAID卡支持预读，这个设置不会关闭RAID卡的预读。这个设置只能关闭操作系统和文件系统的预读。</p>
<p>  如果使用0_DIRECT选项，通常需要带有写缓存的RAID卡，并且设置为write-back策略，因为这是典型的唯一能保持好性能的方法。当innodb和实际存储设备之间没有缓冲时使用0_DIRECT，例如当RAID卡没有写缓存时，可能导致严重的性能下降。现在有个多个写线程，问题小一点，但通常还有问题。MySQL5.5提供了更原生异步IO。</p>
<p>  这个选项可能导致服务器预热时间变长，特别是操作系统的缓存很大的时候。也可能导致小容量的缓冲池比缓冲IO方法操作要慢得多。这是因为操作系统不会通过保持更多数据在自己的缓存中来帮助提升性能。如果需要的数据不再缓冲池，innodb将不得不从磁盘读取。这个选项不会对innodb_per_file_table产生任何额外的损失。相反，如果不用innodb_per_file_table，当使用0_DIRECT时，可能由于一些顺序IO而遭受性能损失。这种情况的发生是因为一些文件系统的每个inode都有一个mutex。当在这些文件系统上使用0_DIRECT时，确实需要打开innodb_file_per_table</p>
</li>
<li><p>ALL_0_DIRECT</p>
<p>  这个选项在percona server 和 mariadb中可用。它使得服务器再打开日志文件时，也能使用标准MySQL中打开数据文件的方式（0_DIRECT）</p>
</li>
<li><p>0_DSYNC</p>
<p>  这个选项使日志文件调用open函数时设置0_SYNC标记。它使得所有的写 同步。也就是说，只有数据写到磁盘后，写操作才返回。这个选项不影响数据文件。0_SYNC标记和0_DIRECT标记的不同之处在于，0_SYNC没有禁用操作系统层的缓存。因此，它没有避免双重缓冲，而且它没有使写操作直接操作到磁盘。使用了0_SYNC标记，在缓存中写数据，然后发送到磁盘。</p>
<p>  使用0_SYNC标记做同步写操作，听起来可能跟fsync做的事情非常相似，但是它们两个的实现无论在操作系统层是硬件层都非常不同。使用了0_SYNC标记后，操作系统可能把使用同步IO标记下传给硬件层，告诉设备不要使用缓存，另一方面，fsync告诉操作系统把修改过的缓冲数据刷写到设备上，如果设备支持，紧接着回传第一个指令给设备刷星他自己的缓存，所以，毫无疑问，数据肯定记录在了物理媒介上。另一个不同是，使用了0_SYNC的话，每个write或pwrite操作都会在函数完成之前把数据同步到磁盘，完成前函数调用是阻塞的。相对来看，不用0_SYNC标记的写入调用fsync允许写操作积累在缓存，然后一次性刷新所有的数据。</p>
<p>  这个选项设置0_SYNC标记，不是0_DSYNC标记，因为innodb开发者发现了0_DSYNC的bug。0_SYNC和0_DSYNC类似于fsync和fdatasync：0_SYNC同时同步数据和元数据，但是0_DSYNC只同步数据。</p>
</li>
<li><p>async_unbuffered</p>
<p>  这是windows下的默认值。这个选项让innodb对大部分写使用没有缓冲的IO，里外是当innodb_flush_log_at_trx_commit设置为2的时候，对日志文件使用缓冲IO.</p>
<p>  这个选项使得innodb在windows 2000 ,xp 以及更新版本中对数据读写都使用操作系统的原生异步IO。</p>
</li>
<li><p>unbuffered</p>
<p>  只对windows有效。这个选项与async_unbuffered类似，但是不使用原生异步IO。</p>
</li>
<li><p>normal</p>
<p>  只对windows有效。这个选项让innodb不要使用原生异步IO或者无缓冲IO。</p>
</li>
<li><p>nosync和littlesync</p>
<p>  只为开发使用</p>
</li>
</ul>
<p>如果使用类unix操作系统并且RAID控制器带有电池保护的写缓存，建议使用0_DIRECT。如果不是这样，默认值或者0_DIRECT都可能是最好的选择。</p>
<h4><span id="innodb表空间">InnoDB表空间</span></h4><hr>
<p>innodb把数据保存在表空间内，本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。innodb用表空间实现很多功能，并不只是存储表和索引。它还保存了回滚日志、插入缓冲、双写换成，以及其他内部数据结构。</p>
<p>配置表空间。通过innodo_data_file_path配置可以定制表空间文件。这些文件都放在innodb_data_home_dir指定的目录下，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_data_home_dir = /var/lib/mysql</span><br><span class="line">innodb_data_file_path = ibdata1:1G,ibdata2:1G,ibdata3:1G</span><br></pre></td></tr></table></figure>
<p>这里在三个文件中创建了3G的表空间。有时人们并不清楚可以使用多个文件分散驱动器的负载，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_data_file_path = /disk1/ibdata1:1G;/disk2/ibdata2:1G;...</span><br></pre></td></tr></table></figure>
<p>在这个例子中，表空间文件确实放在代表不同驱动器的不同目录中，InnoDB把这些文件首尾相连组合起来。因此，通常这种方式并不能获得太多收益。InnoDB先填满第一个文件，当第一个文件满了再用第二个，如此循环；负载并没有真的按照希望的高新能方式分布。用RAID控制器分布负载是更聪明的方式。</p>
<p>为了允许表空间在超过了分配的空间时还能增长，可以像这样配置最后一个文件自动扩展：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ibdaa3:1G:autoextend</span><br></pre></td></tr></table></figure>
<p>磨人的行为是创建单个10MB的自动扩展文件。如果让文件可以自动扩展，那么最好给表空间大小设置一个上限，别让它扩展的太大，因为一旦扩展了，就不能收缩回来。例如，下面的例子现只能自动扩展文件最多道2GB：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ibdata3:1G:autoextend:max:2G</span><br></pre></td></tr></table></figure>
<p>管理一个单独的表空间可能有点麻烦，尤其是如果它是自动扩展的，并且希望回收空间时（因为这个原因，建议关闭自动扩展功能，至少设置一个合理的空间范围）。回收空间唯一的方式是导出数据，关闭MySQL，删除所有文件，修改配置，重启，让InnoDB创建新的数据文件，然后倒入数据。InnoDB的这种表空间管理方式很让人头疼，不能简单地删除文件或者改变大小。如果表空间损坏了，InnoDB会拒绝启动。对日志文件也一样的严格。如果想myisam一样随便移动文件，一定要谨慎。</p>
<p>innobd_file_per_table选项让InnoDB为每张表使用一个文件。它在数据字典存储为 表名.ibd的数据。这使得删除一张表时回收空间简单多了，并且可以容易地分散表到不同的磁盘上。然而，把数据放到多个文件，总体来说可能导致更多的空间浪费，因为单个InnoDB表空间的内部碎片浪费分不到了多个.ibd文件。<strong>对于非常小的表，这个问题更大，因为InnoDB的页大小是16KB。即使表只有1KB的数据，仍然需要至少16KB的磁盘空间。</strong></p>
<p>即使打开innodb_file_per_table选项，依然需要为回滚日志和其他系统数据创建共享表空间。没有把所有数据存在其中是明智的做法，但最好还是关闭它的自动增长，因为无法在不导入全部数据的情况下给共享表空间瘦身。</p>
<p>一些人喜欢使用innodb_file_per_table，只是因为特别容易管理，并且可以看到每个表的文件。例如，可以通过查看文件的大小来确认表的大小，这比使用show table status来看快多了，这个命令需要执行很多复杂的工作来判断一个表分配了多少页面。</p>
<p>设置innodb_per_file也有不好的一面：更差的drop table性能。这可能导致显而易见的服务器端阻塞，有如下两个原因：</p>
<ul>
<li>删除表需要从文件系统层去删除文件，这可能在某些文件系统(ext3)上会很慢。可以通过欺骗文件系统来缩短这个过程：把.ibd文件链接到一个0字节的文件，然后手动删除这个文件，而不用等待MySQL来做。</li>
<li>让打开这个选项，每张表都在InnoDB中使用自己的表空间。结果是，移除表空间实际上需要InnoDB锁定和扫描缓冲池，查找属于这个表空间的页面，在一个有庞大的缓冲池的服务器上做这个操作是非常慢的。如果打算删除很多InnoDB表（包括临时表）并且用了innodo_file_per_table，可能会从percona esrver包含的一个修复中获益，它可以让服务器慢慢滴清理掉属于被删除表的页面。只需要设置innodb_lazy_drop_table这个选项。</li>
</ul>
<p>我们建议使用innodb_file_per_table并且给共享表空间设置大小范围，这样可以舒服点（不用处理那些空间回收的事）。如果遇到任何头痛的场景，考虑使用percona的修复</p>
<p>事实上没有必要把innodb文件放在传统的文件系统上。像许多的传统数据库服务器一样，InnoDB提供使用裸设备的选项，例如，一个没有格式化的分区作为它的存储。然而，今天的文件系统已经可以存放足够大的文件，所以已经没有必要使用这个选项。使用裸设备可能提升几个百分点的性能，但是我们不认为这点效提升足以抵消这样做带来的坏处，我们不能直接用文件管理数据。当把数据存在一个裸设备分区时，不能使用mv,cp等任何其他工具来操作它。最终，这点小的性能收益显然不值得。</p>
<p>行的旧版本和表空间。在一个写压力大的环境下，innodb的表空间可能增长得非常大。如果事物保持打开状态很久（即使它们没有做任何事），并且使用默认的repeatable read事务隔离级别，innodb将不能删除旧的行版本，因为没提交的事务依然需要看到它们。innodb把旧版本存在非共享表空间，所以如果有更多的数据在更新，共享表空间会持续增长。有时这个问题并非是没提交的事务的原因，也坑那是工作负载的问题：清理过程只有一个线程处理，直到最近的MySQL版本才改进，这可能导致清理线程处理速度跟不上旧版本行增加的速度。</p>
<p>无论发生何种情况，show innodb status的数据都可以帮助定位问题。查看历史链表的长度会显示了回滚日志的大小，以页为单位。</p>
<p>分析transactios部分的第一行和第二行可以证实这个观点，这部分展示了当前事务号以及清理线程完成到了哪个点。如果这个差距很大，可能有大量的没有清理的事务。例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transactios</span><br><span class="line">trx id counter 90157601</span><br><span class="line">purge done for trx&apos;s n:o &lt;0 90157601 undo n:0&lt;0 0</span><br></pre></td></tr></table></figure>
<p>事务标识表示是一个64比特的数字。有两个32比特的数字组成，所以需要一点数学计算来计算差距。我在这个例子中就很简单了，因为这个例子中有3028个潜在的没有被清理的事物（innotop可以做这个计算）。我们说潜在的,是因为这跟有很多没有清理的行是有很大差别的。只有改变了数据的事务，才会创建旧版本的行，但是有很多事务，没有修改数据。与此相反，一个事务也可能修改很多行。</p>
<p>如果有个很大的回滚日志，并且表空间因此增长很快，可以强制MySQL减速来使innodb的清理线程可以跟得上。这听起来不怎么样，但是没有办法。否则，innobd将保持数据持续写入，填充磁盘最后磁盘空间爆满，或者表空间大于定义的上限。</p>
<p>为了控制写入速度，可以设置innodb_max_purge_lag变量为一个大于0的值。这个值标识innobd开始延迟后面的语句更新数据之前，可以等待被清除的最大的实物数量。你必须知道工作负载以决定一个合理的值。例如，事务平均影响1KB的行,并且可以允许表空间里有100mb的未清理行,那么可以设置这个值为100000.</p>
<p>牢记，没有清理的行版本会对所有查询产生影响，因为他们事实上使得表和索引更大了。如果清理线程确实跟不上，性能可能显著的下降。设置innodb_max_purge_lag变量也会降低性能，但是伤害较少。</p>
<p>在更新版本的MySQL中，清理过程已经显著地提升了性能，并且从其他内部工作任务中分离出来。甚至可以创建多个专用的清理线程来更快地做这个后台工作。如果可以利用这些特性，会比限制副武器的服务能力要好得多。</p>
<h4><span id="双写缓冲doublewrite-buffer">双写缓冲（Doublewrite buffer）</span></h4><hr>
<p>innodb使用双写缓冲来避免页没写完整所导致的数据损坏。当一个磁盘写操作不能完整的完成时，不完整的页写入就可能发生。16KB的页可能只有一部分被写到磁盘上有多种多样的原因。可能导致页没有写完整,双写缓冲，在这种情况发生时可以保证数据完整性。</p>
<p>双写缓冲是表空间一个特殊的保留区域,在一些连续的块中足够保存100个页.本质上是有个最近写回的页面的备份拷贝。档innodb从缓冲池刷新页面到磁盘时，首先把他们写到双鞋缓冲。然后再把它们写到其所属的数据区域中。这可保证每个页面都写入都是原子，并且持久化的.</p>
<p>这意味着每个页都要写两遍。但是因为innodb写页面到双写缓冲是顺序的。并且只调用一次fsync刷新到磁盘。尽管实际上对性能的冲击是比较小的。通常只有几个百分点。肯定没有一半那么多。这个开销在固态硬盘上更明显。这个策略允许日日文件更加高效。因为双写缓冲给了innodb一个非常牢固的保障。数据页不会损坏，innodb日志记录没必要包含整个页，它们更像是页面的二进制变化量。</p>
<p>如果有一个不完整的页写到了双写缓冲。原始的页依然会在磁盘上它的真实位置。当innodb回复时，他用原始页面替换了双鞋缓冲中的损坏页面。然而，如果双写缓冲成功写入，但写到页的真实位置失败了，innodb在恢复时将使用双写缓冲中的拷贝来替换。innodb知道什么时候页面损坏了，因为每个页面在末尾都有校验值，限值是最后写到页面的东西。如果应用的内容和校验值不匹配，说明这个页面是损坏的。因此在恢复的时候，innodb只需要读取双鞋缓冲中每个页面，并且验证校验值，如果一个页面的校验值不对，就从它的原始位置读取这个页面。</p>
<p>有些场景下，双写缓冲确实没必要。例如，你也许想在备库上禁止双写缓冲。此外一些文件系统（ZFS）做了同样的事，所以没有必要再让innodb做一遍。可以通过设置innodb_doublewrite为0来关闭双写缓冲。</p>
<h4><span id="其他的io配置项">其他的IO配置项</span></h4><p><strong><em>sync_binlog</em></strong>选项控制MySQL怎么刷新二进制日志到磁盘。默认值是0，意味着MySQL并不刷新，有操作系统自己决定什么时候刷新缓存到持久化设备。如果这个值比0大，他指定了两次刷新到磁盘的动作之间间隔多少次二进制日志写操作（如果autocommit被设置了，每个独立的语句都是一次写，否则就是一个事务一次写）。把它设置为0和1以外的值是很罕见的。</p>
<p>如果没有知识sync_binlog为1，那么崩溃以后可能导致二进制日志没有同步事务数据。这可以轻易地导致复制终端，并且使得及时回复变得不可能。无论如何，可以把这个值设置为1来获得安全的报账。这样就会要求MySQL同步把二进制日志和事务日志这两个文件刷新到两个不同的位置。这坑你需要磁盘寻道，相对来说是个很慢的操作。</p>
<p>像innodb日志文件一样，把二进制日志放到一个带有电池保护的写缓存的RAID卷，可以极大地提升性能。事实上，写和刷新二进制缓存其实比innodb事务日志要昂贵多了，因为不像innodb事务日志，每次写二进制日志都会增加它们的大小。这需要me次写入文件系统都更新元信息。所以，设置sync_binlog=1可能比innodb+flush_log_at_trx_commit=1对性能的孙海要大得多，尤其是网络文件系统弄个，例如NFS。</p>
<p>一个跟性能无感的提示，关于二进制文件。如果需要哪个expire_logs_day选项来自定清理旧的二进制日志，就不要用rm命令去删。服务器会感到困惑并且拒绝自动删除它们，并且purge master logs也将停止工作。解决的办法是，如果发现了这种情况，就手动重新同步“主机名-bin.index”文件，可以用磁盘上现有日志文件的列表来更新。</p>
<p>把带有电池保护写缓存的高质量RAID控制器设置为使用写回策略，可以支持每秒数千的写入，并且依然会保证写到持久化存储，数据写到了带有电池的高速缓存。所以即使系统断电它也能存在，但电源恢复时，RAID控制器将会在磁盘被设置为可用前,把数据从缓存中写到磁盘。因此，一个带有电池保护写缓存的RAID控制器可以显著地提升性能。这是非常值得的投资当然固态硬盘也是另一个选择</p>
<h3><span id="myisam的io配置">myisam的IO配置</span></h3><hr>
<p>myisam通常每次写操作之后就把索引变更刷新到磁盘。如果你打算在一张表上做很多修改，那么毫无疑问批量，操作操作会更快一些。一种办法是用lock tables延迟写入，直到解锁这些表。这是个提升性能的很有价值的技巧。因为它使得你精确控制哪些写被延迟，以及什么时候把它们刷到磁盘。可以精确延迟那些希望延迟的语句。</p>
<p>通过设置delay_key_write变量，也可以延迟索引的写入。如果这么做，修改的键缓冲块知道表被关闭才会刷新。可能的配置如下：</p>
<ul>
<li><p>off</p>
<p>  myisam每次写操作后刷新键缓冲（键缓存，key buffer）中的脏块到磁盘，除非表被lock tables锁定了</p>
</li>
<li><p>on</p>
<p>  打开延迟键写入，但是只对用delay_key_write选项创建的表有效。</p>
</li>
<li><p>all</p>
<p>  所有的myisam表都会使用延迟键写入。</p>
</li>
</ul>
<p>延迟键写入在某些场景下可能很有帮助，但是通常不会带来很大的性能提升。当键缓冲的读命中很好但写命中不好时，数据有比较小，这可能很有用。当然也有一小部分缺点：</p>
<ul>
<li>如果服务器并且块没有刷到磁盘，索引可能会损坏。</li>
<li>如果很多写被延迟了，MySQL可能需要花费更长时间去关闭表，因为必须等待缓冲刷新到磁盘。在MySQL 5这可能引起很长的表缓存锁</li>
<li>由于上面提到的原因，flush tables可能需要很长时间。如果为了做逻辑卷快照或者其他备份操作，而执行flush tables with read lock，那可能增加操作的时间。</li>
<li>键缓冲中没有刷回去的脏块可能占用空间，导致从磁盘上读取的新块没有空间存放。因此，查询语句可能需要等待myisam释放一些键缓存的空间</li>
</ul>
<p>另外，除了配置myisam的索引IO可以配置myisam怎样尝试从损坏中恢复。myisam_recover选项控制myisam怎样寻找和修复错误。需要在配置文件或者命令行中设置这个选项。可以通过下面的sql语句查看选项的值，但是不能修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'myisam_recover_options'</span></span><br></pre></td></tr></table></figure>
<p>打开这个选项通知MySQL在表打开时，检查是否损坏，并且在找到问题的时候进行修复。可以设置的值如下</p>
<ul>
<li><p>default</p>
<p>  使MySQL尝试修复任何被标记为崩溃或者没有标记为完全关闭的表。默认值不要求在恢复时执行其他动作。跟大多数变量不同，这里default值不是充值变量的值为编译值，本质上意味着没有值。</p>
</li>
<li><p>backup</p>
<p>  让MySQL将数据文件的备份写到.BAK文件，以便随后进行检查。</p>
</li>
<li><p>force </p>
<p>  即使.MYD文件中丢失的数据可能超过一行，也让恢复继续。</p>
</li>
<li><p>quick</p>
<p>  除非有删除快，否则跳过恢复。块中有已经删除的行也依然会占用空间，但是可以被后面的insert语句重用。这可能比较有用，因为myisam大表的恢复可能花费相当长的时间。</p>
</li>
</ul>
<p>可以使用多个配置，用逗号分隔，例如，backup,force 会强制恢复并且创建备份。</p>
<p>建议打开这个选项，尤其是只有一些小的myisam表时。服务器运行着一些损坏的myisam表时很危险的，因为它们有时可以导致更多数据损坏，甚至服务器崩溃。然而， 如果有很大的表，原子恢复是不切实际的：它导致服务器打开所有的myisam表时都会检查和修复，这是低效的做法。在这段时间，MySQL会阻止连接做任何工作。如果有一大堆的myisam表，比较好的主意还是启动后用check tables 和 repair table命令来做，这样对服务器影响比较小。不管哪种方式，检查和修复表都是很重要的。</p>
<p>打开数据文件的内存映射访问是另一个有用的myisam选项，内存映射使得myisam直接通过操作系统的页面缓存访问.myd文件，表面系统调用的开销。在MySQL5.1和更新的版本中，可以通过myisam_use_mmap选项打开内存映射。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL架构与历史，基础</title>
    <url>/2020/12/23/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/6-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<p><strong>InnoDB</strong></p><p>innodb使用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是Repeatable read，并且通过间隙锁策略防止欢度的出现。间隙锁使得innodb不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p><a id="more"></a>

<p>innodb表是基于聚簇索引建立的。聚簇索引对主键查询有很高的性能。不过它的二级索引中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。innodb的存储格式是平台独立的，也就是说可以将数据和索引文件从intel平台复制到其他平台。</p>
<p><strong>MyISAM</strong></p>
<p>MyISAM支持全文索引，压缩、空间函数。但是myisam不支持事务和行级锁，而且有个缺陷就是崩溃后无法安全恢复。但是，对于只读的数据，或者表比较小，可以忍受repair操作，依然可以使用myisam。</p>
<p>myisam会将表存储在两个文件中，数据文件和索引文件，分别以.MYD和.MYI为扩展名。myisam表可以包含动态或者静态行。MySQL会根据标的定义来决定采用何种行格式。myisam表可以存储的行的记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。</p>
<p>MySQL 5.0中，myisam表如所示变长行，则默认配置只能处理256T的数据，因为指向数据记录的指针长度是六个字节。更早的版本中，指针长度是4字节，所以只能处理4G的数据，而所有的MySQL版本都支持8字节的指针。要改变myisam表指针的长度，可以通过修改表的MAX_ROWS和AVG_ROW_LENGTH选项的值来实现，两者相乘就是表可能达到的最大大小。修改这两个参数将会导致重建整个表和表的所有索引，这可能需要很长的时间才能完成。</p>
<p>myisam的特性有下面的这些</p>
<ul>
<li><p>加锁与并发</p>
<p>  myisam对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同事，也可以往表中插入新的记录，成为并发插入</p>
</li>
<li><p>修复</p>
<p>  对于myisam表，MySQL可以手工或者自动执行检查和修复操作，但这里说的修复和食物恢复以及崩溃恢复是不同的概念。执行标的修复可能导致一些数据丢失，而且修复操作是很慢的。可以通过check table mytable检查标的错误，如果有错误可以通过执行repair table mysql进行修复。</p>
</li>
<li><p>索引特性</p>
<p>  对于myisam表，即使是blob和text字段，也可以基于其前500个字符传建索引，myisam也支持全文索引，基于分词创建，可以支持复杂的查询</p>
</li>
<li><p>延迟更新索引键</p>
<p>  创建myisam表的时候，如果制定了delay_key_write选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是回写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候，才对将对应的索引快写入到磁盘。这种方式可以极大地提升写入心梗，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置</p>
</li>
</ul>
<p>如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表或许适合采用myisam压缩表。</p>
<p>可以使用myisampack对myisam表进行压缩，压缩表示不能进行修改的。压缩表可以极大地减少磁盘占用，因此也可以减少磁盘IO，从而提升查询性能。压缩表也支持索引，但是索引也是只读的。</p>
<p>读取压缩表数据的解压带来的开销影响不大，而减少IO带来的好处则要大很多.压缩时表中的记录是独立压缩的,所以读取单行的时候不需要去解压整个表，甚至也不解压行所在的整个页面。</p>
<p><strong>多版本并发控制</strong></p>
<p>可以认为MVCC是行级锁的一个变种，它在很多情况下避免了枷锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一个时刻看到的数据可能是不一样的。</p>
<p>不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制</p>
<p>innodb的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作比较，下面是在repeatable read隔离级别下，MVCC具体是如何操作的</p>
<ul>
<li><p>SELECT</p>
<p>  InnoDB会根据下面两个条件检查每行记录</p>
<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，需要大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除</li>
<li>只有符合上面两个条件的记录，才能返回作为查询结果</li>
</ul>
</li>
<li><p>INSERT</p>
<p>  InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p>delete</p>
<p>  InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
</li>
<li><p>update</p>
<p>  InnoDB为插入一条新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数读操作都可以不用枷锁。这样设计使得读数据操作简单，性能很好，而且也能保证只会读到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护操作。</p>
<p>MVCC只在repeatable read和 read committed两个隔离级别下工作。其他两个隔离级别和MVCC不兼容。因为read uncommitted总是读取最新的数据行，而不是符合当前事务版本的数据行。而serializable则会对所有读取的行都加锁。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询性能的优化</title>
    <url>/2020/12/18/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/4-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>| 1.简介</p><p>查询的生命周期大致可以按照顺序来看：<strong>客户端，服务器，在服务器上进行解析，生成执行计划，执行，返回结果给客户端，执行可以认为是整个生性周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组</strong>。在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的IO操作上消耗时间，根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。</p><a id="more"></a>

<p>| 2.慢查询基础：优化数据访问</p>
<p>查询性能低下最根本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。两个步骤：<strong>1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的航，但有时候也可能是访问了太多的列。2.确认MySQL服务器层是否在分析大量超过需要的数据行。</strong></p>
<p>| 2.1 是否想数据库请求了不需要的数据</p>
<ol>
<li><p>查询不需要的记录</p>
<p> 比如说，JDBC的结果集是缓存的查询语句的所有结果，获取前几行，关闭之后，剩余的数据就会被抛弃，这种情况应当加上limit</p>
</li>
<li><p>多表关联时返回全部列</p>
<p> 只选择需要的列</p>
</li>
<li><p>总是取出全部列</p>
<p> 也就是说，避免<code>select *</code>，这种查询，优化器无法完成覆盖扫描这类优化，还会带来额外的IO，内存和CPU的消耗。如果表设计不完善，比如所有字段都在一张表（包括大字段），那么<code>select*</code>就是灾难</p>
</li>
<li><p>重复查询相同的数据</p>
<p> 缓存热点数据，避免重复查询</p>
</li>
</ol>
<p>| 2.2 MySQL是否在扫描额外的记录</p>
<p>最简单的三个指标：<strong><em>响应时间，扫描的行数，返回的行数</em></strong>。这三个指标会记录到MySQL的慢日志中。</p>
<p><strong>响应时间</strong></p>
<p>响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间—可能是等待IO，也可能是行锁，很难做到逐个测量，一般常见的是IO和锁等地啊.</p>
<p><strong>扫描的行数和返回的行数</strong></p>
<p>较短的行访问速度更快，内存中的行也比磁盘中的行的访问速度要快。理想情况下，扫描多少行返回多少行，但是实际上不可能发生，比如关联查询，需要扫描多行才能生成结果集中的一行，比率一般在1：1和10：1之间，也有可能非常大。</p>
<p>在explain语句中的type列反应了访问类型。访问类型有很多种，从<strong>全表扫描到索引扫描、范围扫描、唯一索引扫描、常数引用等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大（感觉书里写错了）。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment"># +--+-----------+----------+----------+----+--------------+--------------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="comment"># |id|select_type|table     |partitions|type|possible_keys |key           |key_len|ref  |rows|filtered|Extra|</span></span><br><span class="line"><span class="comment"># +--+-----------+----------+----------+----+--------------+--------------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="comment"># |1 |SIMPLE     |film_actor|NULL      |ref |idx_fk_film_id|idx_fk_film_id|2      |const|10  |100     |NULL |</span></span><br><span class="line"><span class="comment"># +--+-----------+----------+----------+----+--------------+--------------+-------+-----+----+--------+-----+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里能看到，在索引idx_fk_film_id上使用了ref访问类型来执行查询。explain的结果也显示MySQL预估需要访问10行数据。换句话说，查询优化器认为这种访问类型可以高效地完成查询。</span></span><br><span class="line"><span class="comment"># 但是如果没有索引话，MySQL就不得不使用一种更糟糕的访问类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> film_actor <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> fk_film_actor_film;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> film_actor <span class="keyword">drop</span> <span class="keyword">key</span> idx_fk_film_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment"># +--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----------+</span></span><br><span class="line"><span class="comment"># |id|select_type|table     |partitions|type|possible_keys|key |key_len|ref |rows|filtered|Extra      |</span></span><br><span class="line"><span class="comment"># +--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----------+</span></span><br><span class="line"><span class="comment"># |1 |SIMPLE     |film_actor|NULL      |ALL |NULL         |NULL|NULL   |NULL|5462|10      |Using where|</span></span><br><span class="line"><span class="comment"># +--+-----------+----------+----------+----+-------------+----+-------+----+----+--------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时候再看，访问类型变成了一个全表扫描，这里的using where 标识MySQL将通过where条件来筛选存储引擎返回的记录。</span></span><br></pre></td></tr></table></figure>
<p>一般MySQL能使用下面三种方式应用where条件，从好到坏依次为：</p>
<ol>
<li><p>在索引中使用where条件来过滤不匹配的记录。这是在存储引擎完成的。</p>
</li>
<li><p>使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。</p>
</li>
<li><p>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</p>
</li>
</ol>
<p>不过，MySQL不会告诉我们生成结果实际上需要扫描多少行数据，而只会告诉我们生成结果时一共扫描了多少行数据。扫描的行数中的大部分都很可能是被where条件过滤掉的，对最终的结果集没有贡献。上面的例子中，删除索引后，看到MySQL需要扫描所有记录然后根据where条件过滤，最终只返回10行结果。可以尝试以下技巧进行优化</p>
<ol>
<li><p>使用索引覆盖扫描，把所有需要用到的列都放到索引中，这样存储引擎无需回表获取对应行就可以返回结果</p>
</li>
<li><p>改变库表结构，比如使用单独的汇总表</p>
</li>
<li><p>重写复杂查询，让MySQL优化器能够以更有花的方式执行这个查询。</p>
</li>
</ol>
<p>| 3.1 一个复杂查询还是多个简单查询</p>
<p>首先，个人观点，尽量避免复杂查询，外包公司可能是从oracle遗传下来的习惯，很喜欢各种复杂sql处理，因为以前的网络通信，查询解析和优化代价很高，但是这样，会导致数据库层成为瓶颈，而且，都2020年了，不思进取的老人也该被淘汰了。</p>
<p>MySQL从设计上让连接和断开都很轻量级，在返回一个小的查询结果方面很高效。MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MySQL相应数据给客户端就慢很多。相同条件下，使用尽可能少的查询当然是好的。但是，很多时候，将一个大查询分解为多个小查询是很有必要的。</p>
<p>| 3.2 切分查询</p>
<p>分治，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。<strong>删除旧的数据就是一个很好的例子：如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源、阻塞很多小的但是很重要的查询。将一个大的delete语句分割成多个较小的查询可以尽可能小的影响MySQL性能，还可以减少MySQL复制的延迟。</strong>例子如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> messages <span class="keyword">where</span> created &lt; <span class="keyword">date_sub</span>(<span class="keyword">now</span>(),<span class="built_in">interval</span> <span class="number">3</span> <span class="keyword">month</span> )</span><br></pre></td></tr></table></figure>
<p>可以改用下面的方法完成</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">rows_affected = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  rows_affected = do_query(<span class="string">"delete from messages where created &lt; date_sub(now(),interval 3 month ) limit </span></span><br><span class="line"><span class="string">10000"</span>)</span><br><span class="line">&#125;<span class="keyword">while</span> rows_affected&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>一次删除一万行数据一般来说是一个比较高效而且对服务器影响也最小的做法（如果是事务性引擎，很多时候小事务能够更高效）。同时需要注意的是，如果每次删除数据后，都暂停一会再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。</p>
<p>| 3.3 分解关联查询</p>
<p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表都进行一次单表查询，然后将结果在应用程序中进行关联，比如说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> tag</span><br><span class="line">         <span class="keyword">join</span> tag_post <span class="keyword">on</span> tag_post.tab_id = tag.id</span><br><span class="line">         <span class="keyword">join</span> post <span class="keyword">on</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">where</span> tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="comment"># 可以分解为下面的查询：</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag <span class="keyword">where</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag_post <span class="keyword">where</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> post <span class="keyword">where</span> post.id <span class="keyword">in</span> (<span class="number">123</span>,<span class="number">46</span>,<span class="number">456</span>,<span class="number">9992</span>,<span class="number">9998</span>);</span><br></pre></td></tr></table></figure>
<p>看起来可能会说，这有什么好处，结果不一样么，但是，用这种方式，有下面这些优势：</p>
<ul>
<li>让缓存的效率更高。许多应用程序可以方便地缓存单边查询对应的结果对象。例如，上面查询的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123,46,456,的内容，那么第三个查询的in中，就能少几个ID。另外，对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>查询本身效率也可能会有所提升。例子中，用in代替关联查询，可以让MySQL按照ID顺序进行查询,这可能比随机的关联更高效</li>
<li>可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录，应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗</li>
<li>更进一步，这样做相当于在应用中实现了hash关联，而不是使用MySQL的嵌套循环关联。某些场景hash关联的效率要高很多。</li>
</ul>
<p>| 4.执行查询的基础</p>
<p>图例在这里</p>
<p>| 4.1 MySQL客户端/服务器通信协议</p>
<p>MySQL客户端和服务器之间的通信协议是<strong>半双工</strong>的，这意味着，在任何一个时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，两个动作不能同时发生。所以也无法将一个消息切成小块独立来发送。</p>
<p>这种协议让MySQL同心简单快速，但是也从很多地方限制了MySQL。一个明显的限制是，这意味着没法进行流量控制。一旦一端开始发生消息，另一端要接收完整个消息才能响应它。就像扔沙包。</p>
<p>客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候，参数max_allowed_packet就特别重要了。一旦客户端发送了请求，它能做的事情就只是等待结果。</p>
<p>相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这种情况下，客户端若接收完整的结果，然后取前面几条需要的结果，或者接收完几条结果后就粗暴地断开连接，都不是好主意。这也就是在要的时候，一定要在查询中加limit的原因。</p>
<p>多数链接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放相应的资源。</p>
<p>| 4.2 查询缓存</p>
<p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会</p>
<p>| 4.3 查询优化</p>
<p>太多，不写了</p>
<p><strong>MySQL如何执行关联查询</strong></p>
<p>总的来说，MySQL认为任何一个查询都是一次关联，并不仅仅是一个查询需要到两个表匹配才叫关联，所以在MySQL中，每一个查询，每一个片段（包括子查询，甚至于单表的select）都可能是关联。</p>
<p>比如union查询的例子。对于union查询，MySQL先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成union查询。在MySQL的概念中，每个查询都是一次关联，所以读取结果临时表也是一次关联。</p>
<p>当前MySQL关联执行的策略很简单：MySQL对任何关联都执行嵌套循环关联操作，即MySQL现在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的航，依次下去，直到找到所有表中匹配的行位置。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL返回到上一层次关联表，看是否能找到更多的匹配记录，以此类推迭代执行。</p>
<p>按照这样的方式查找第一个表记录，再嵌套查询下一个关联表，然后回溯到上一个表，在MySQL中是通过嵌套循环的方式实现——<strong>嵌套循环关联</strong>。</p>
<p><strong>执行计划</strong></p>
<p>MySQL执行计划是一颗左侧深度优先的树。</p>
<p><strong>关联查询优化器</strong></p>
<p>MySQL优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的管理按顺序来获得相同的执行结果。关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联查询。</p>
<p>下面的查询可以通过不同顺序的关联最后都获得相同的结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name</span><br><span class="line"><span class="keyword">from</span> film</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> film_actor <span class="keyword">using</span> (film_id)</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> actor <span class="keyword">using</span> (actor_id)</span><br><span class="line"><span class="comment"># explain 结果如下</span></span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+-------------------------+----+--------+-----------+</span></span><br><span class="line">|<span class="keyword">id</span>|select_type|<span class="keyword">table</span>     |<span class="keyword">partitions</span>|<span class="keyword">type</span>  |possible_keys|<span class="keyword">key</span>    |key_len|<span class="keyword">ref</span>                      |<span class="keyword">rows</span>|filtered|Extra      |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+-------------------------+----+--------+-----------+</span></span><br><span class="line">|<span class="number">1</span> |SIMPLE     |actor     |<span class="literal">NULL</span>      |<span class="keyword">ALL</span>   |PRIMARY      |<span class="literal">NULL</span>   |<span class="literal">NULL</span>   |<span class="literal">NULL</span>                     |<span class="number">200</span> |<span class="number">100</span>     |<span class="literal">NULL</span>       |</span><br><span class="line">|<span class="number">1</span> |SIMPLE     |film_actor|<span class="literal">NULL</span>      |<span class="keyword">ref</span>   |PRIMARY      |PRIMARY|<span class="number">2</span>      |sakila.actor.actor_id    |<span class="number">27</span>  |<span class="number">100</span>     |<span class="keyword">Using</span> <span class="keyword">index</span>|</span><br><span class="line">|<span class="number">1</span> |SIMPLE     |film      |<span class="literal">NULL</span>      |eq_ref|PRIMARY      |PRIMARY|<span class="number">2</span>      |sakila.film_actor.film_id|<span class="number">1</span>   |<span class="number">100</span>     |<span class="literal">NULL</span>       |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+-------------------------+----+--------+-----------+</span></span><br></pre></td></tr></table></figure>
<p>从上面看到，MySQL与我们前面的计划按照相反的顺序进行关联，这样效率是否更高？使用straight_join关键字，按照之前的顺序执行看看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">straight_join</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name</span><br><span class="line"><span class="keyword">from</span> film</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> film_actor <span class="keyword">using</span> (film_id)</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> actor <span class="keyword">using</span> (actor_id);</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+--------------------------+----+--------+-------------------------------------------------------+</span></span><br><span class="line">|id|select_type|table     |partitions|type  |possible_keys|key    |key_len|ref                       |rows|filtered|Extra                                                  |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+--------------------------+----+--------+-------------------------------------------------------+</span></span><br><span class="line">|1 |SIMPLE     |film      |NULL      |ALL   |PRIMARY      |NULL   |NULL   |NULL                      |1000|100     |NULL                                                   |</span><br><span class="line">|1 |SIMPLE     |film_actor|NULL      |index |PRIMARY      |PRIMARY|4      |NULL                      |5462|10      |Using where; Using index; Using join buffer (hash join)|</span><br><span class="line">|1 |SIMPLE     |actor     |NULL      |eq_ref|PRIMARY      |PRIMARY|2      |sakila.film_actor.actor_id|1   |100     |NULL                                                   |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+--------------------------+----+--------+-------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>可以看到，关联顺序到转后，扫描的行数减少的不是一点，速度很快。也就是倒转的关联顺序会让查询进行更少的嵌套循环和回溯操作。为了验证优化器的选择是否正确，单独执行这两个查询，并且看看对应的Last_Query_Cost状态，能看到，倒转的预估成本为：2529.432367，原来的查询的预估成本为：601068.477855。</p>
<p>上面的栗子说明MySQL是如何选择合适的管理按顺序让查询执行的成本尽可能低的。重新定义关联的顺序是优化器非常重要的一部分功能。不过有的时候，优化器给出的并不是最优的关联顺序。这时可以使用<strong>straight_join</strong>关键字重写查询。不过大多数时候，选择器做出的选择都比普通人的判断更准确。</p>
<p>有时，各个查询的顺序并不能随意安排，这时关联优化器可以根据这些规则大大减少搜索空间，比如，左连接，相关子查询。这是因为，后面的表的查询需要依赖前面表的查询结果。这种依赖关系通常可以帮助优化器大大减少需要扫描的执行计划数量。</p>
<p><strong>排序优化</strong></p>
<p>从性能角度，应当尽可能避免排序或者尽可能避免对大量数据进行排序。</p>
<p>当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为<strong>文件排序（filesort）</strong>，即使完全是内存排序不需要任何磁盘文件时也是如此。</p>
<p>如果需要排序的数据量小于”排序缓冲区“，MySQL使用内存进行快速排序操作。如果内存不够排序，那么MySQL会现将数据分块，对每个独立的块使用快排，然后将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。</p>
<p>两种排序算法：</p>
<ul>
<li>两次传输排序（旧版本）</li>
<li>单词传输排序（新版本）</li>
</ul>
<p>MySQL在进行文件排序的时候需要时候的临时存储空间可能会比想象的要大得多。原因在于MySQL在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。这个定长空间必须足够长以容纳其中最长的字符串。例如，如果是varchar列则需要分配其完整长度；如果是UTF-8字符集，那么MySQL将会为每个字符预留三个字节。</p>
<p>在关联的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。如果order by 子句中的所有列都来自关联的第一个表，那么MySQL在关联处理第一个表的时候就进行文件排序。如果是这样，那么在MySQL的explain结果中可以看到extra字段会有<strong>Using filesort</strong>。除此之外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后在所有的关联都结束后，再进行文件排序。这种情况下，在MySQL的explain结果的extra列字段可以看到<strong>Using temporary; Using filesort</strong>。如果查询中有limit的话，limit也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大。</p>
<p>随着MySQL的升级，当只需要返回部分排序结果的时候，例如使用了LIMIT子句，MySQL不再对所有的结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后再进行排序。</p>
<p>| 4.4 查询执行引擎</p>
<p>查询执行引擎根据执行计划完成整个查询。调用存储引擎实现的接口，也就是handler api，来完成。</p>
<p>| 4.5 返回结果给客户端</p>
<p>即使查询不需要返回结果集给客户端，MySQL仍然会返回这个查询的一些信息，如该查询影响到的行数。如果查询可以被缓存，那么MySQL也会在这个阶段将结果存到查询缓存中。</p>
<p>MySQL将结果集返回客户端是一个增量、逐步返回的过程。一旦服务器处理完最后一个关联表，开始生层第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</p>
<p>这样有两个好处：服务端无需存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。另外，MySQL客户端也能第一时间获得返回的结果。</p>
<p>| 5. MySQL查询优化器的局限性</p>
<p>5.6之后，很多限制都会消除，更多的查询效率会变得更高。</p>
<p>| 5.1 关联子查询</p>
<p><strong><em>很重要的一点，MySQL8.x之后，得到了优化。下面说的，全部都是基于5.6版本。</em></strong></p>
<p>MySQL的子查询实现非常差。最糟糕的一类查询是where条件中包含IN()的子查询。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> film_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line"><span class="comment"># 这是8.x 之后的执行计划</span></span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+-------------------------+----+--------+-----------+</span></span><br><span class="line">|id|select_type|table     |partitions|type  |possible_keys|key    |key_len|ref                      |rows|filtered|Extra      |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+-------------------------+----+--------+-----------+</span></span><br><span class="line">|1 |SIMPLE     |film_actor|NULL      |ref   |PRIMARY      |PRIMARY|2      |const                    |19  |100     |Using index|</span><br><span class="line">|1 |SIMPLE     |film      |NULL      |eq_ref|PRIMARY      |PRIMARY|2      |sakila.film_actor.film_id|1   |100     |NULL       |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+------+-------------+-------+-------+-------------------------+----+--------+-----------+</span></span><br></pre></td></tr></table></figure>
<p>因为MySQL对IN()列表中的选项有专门的优化策略，一般会认为MySQL会先执行子查询返回所有包含actor_id为1的film_id。一般来说，IN()列表查询速度很快，所以我们以为的查询的执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">106</span>,<span class="number">140</span>,<span class="number">166</span>,<span class="number">277</span>,<span class="number">361</span>,<span class="number">438</span>,<span class="number">499</span>,<span class="number">506</span>,<span class="number">509</span>,<span class="number">605</span>,<span class="number">635</span>,<span class="number">749</span>,<span class="number">832</span>,<span class="number">939</span>,<span class="number">970</span>,<span class="number">980</span>);</span><br></pre></td></tr></table></figure>
<p>但是，MySQL不是这么做的。MySQL会将相关的外层表压到子查询中，他认为这样可以更高效率地找到数据行，也就是说，会被改写为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> film</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">              <span class="keyword">select</span> *</span><br><span class="line">              <span class="keyword">from</span> film_actor</span><br><span class="line">              <span class="keyword">where</span> actor_id = <span class="number">1</span></span><br><span class="line">                <span class="keyword">and</span> film_actor.film_id = film.film_id</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>这时，子查询需要根据film_id来关联外部表film，因为需要film_id字段，所以MySQL认为无法先执行这个子查询。</p>
<p>通过explain可以看到，MySQL先选择对file表进行全表扫描，然后根据返回的film_id逐个执行子查询。如果是一个很小的表，这个查询糟糕的性能可能还不会引起注意，但是如果外层的表是一个非常大的表，那么这个查询性能会非常糟糕。所以。可以用下面的办法重写查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> film.*</span><br><span class="line"><span class="keyword">from</span> film</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> film_actor <span class="keyword">using</span> (film_id)</span><br><span class="line"><span class="keyword">where</span> actor_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>另一个优化的办法是使用group_concat在in中构造一个由分号分割的列表。有时候这比上面使用关联改写更快。因为使用IN加子查询，性能经常会非常糟糕，所以通常建议使用EXISTS等效的改写查询来获取更好的效率。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span></span><br><span class="line">    <span class="keyword">and</span> film_actor.film_id = film.film_id</span><br><span class="line">                             )</span><br></pre></td></tr></table></figure>
<p>其他的不写了，MySQL推出了Materialization这个特性用于子查询。上面的都没用了。</p>
<p>| 5.2 union的限制</p>
<p>有时，MySQL无法将限制条件从外层下推到内层，这使得能够限制不拿分返回结果的条件无法应用到内层查询的优化上。</p>
<p>如果希望UNION的各个子句能够根据LIMIT只取部分结果集，或者希望能够先排好序再合并结果集的话，就需要在UNION的各个子句中分别使用这些子句。例如，想将两个子查询联合起来，然后再取前20条记录，那么MySQL会将两个表都存放到同一个临时表中，然后再取出前20行记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> first_name, last_name <span class="keyword">from</span> actor <span class="keyword">order</span> <span class="keyword">by</span> last_name)</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> first_name, last_name <span class="keyword">from</span> customer <span class="keyword">order</span> <span class="keyword">by</span> last_name)</span><br><span class="line"><span class="keyword">limit</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>这条查询将会把actor中的200条记录和customer表中的599条记录存放在一个临时表中，然后再从临时表中取出前20条。可以通过在UNION的两个子查询中分别加上一个LIMIT 20来减少临时表中的数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> first_name,last_name <span class="keyword">from</span> actor <span class="keyword">order</span> <span class="keyword">by</span> last_name <span class="keyword">limit</span> <span class="number">20</span>)</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">(<span class="keyword">select</span> first_name,last_name <span class="keyword">from</span> customer <span class="keyword">order</span> <span class="keyword">by</span> last_name  <span class="keyword">limit</span> <span class="number">20</span>) <span class="keyword">limit</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>现在的话，中间的临时表只会包含40条记录了，除了性能考虑之外，这里还需要注意，从临时表中取出数据的顺序并不一定是一定的，所以如果想获得正确的顺序，还需要加上一个全局的order by 和 limit 操作。</p>
<p>| 5.3 索引合并优化</p>
<p>在5.0以后，当where子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</p>
<p>| 5.4 等值传递</p>
<p>某些时候，等值传递会带来一些意想不到的额外消耗。例如，有一个非常大的IN列表,而MySQL优化器发现存在where、on或者using的子句，将这个列表的值和另外一个表的某个列相关联。</p>
<p>那么优化器会将IN的列表都复制应用到关联的各个表中。通常，因为各个表新增了过滤条件，优化器可以更高效的从存储引擎过滤记录。但是如果这个列表非常大，泽会导致优化和执行都会变慢。</p>
<p>| 5.5 并行执行</p>
<p>MySQL无法利用多核特性来并行执行查询。</p>
<p>| 5.6 哈希关联</p>
<p>MySQL并不支持哈希关联，MySQL的所有关联都是嵌套循环关联。</p>
<p>| 5.7 松散索引扫描</p>
<p>MySQL并不支持松散索引扫描，5.0之后，某些特殊的场景可以使用松散索引扫描，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> actor_id,<span class="keyword">max</span>(film_id) <span class="keyword">from</span> film_actor <span class="keyword">group</span> <span class="keyword">by</span> actor_id;</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+-----+----------------------+-------+-------+----+----+--------+------------------------+</span></span><br><span class="line">|id|select_type|table     |partitions|type |possible_keys         |key    |key_len|ref |rows|filtered|Extra                   |</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+-----+----------------------+-------+-------+----+----+--------+------------------------+</span></span><br><span class="line">|1 |SIMPLE     |film_actor|NULL      |range|PRIMARY,idx_fk_film_id|PRIMARY|2      |NULL|201 |100     |Using index for group-by|</span><br><span class="line">+<span class="comment">--+-----------+----------+----------+-----+----------------------+-------+-------+----+----+--------+------------------------+</span></span><br></pre></td></tr></table></figure>
<p>在explain的extra字段显示“Using index for gruop-by”，表示这样将使用松散索引扫描</p>
<p>| 5.8 MySQL的最大值和最小值优化并不好</p>
<p>| 5.9 在同一表上查询和更新</p>
<p>MySQL不允许对同一张表同时进行查询和更新。但是其实并不是优化器的限制，改用JOIN可以解决</p>
<p>| 6 查询优化器的提示</p>
<ul>
<li>HIGI_PRIORITY 和 LOW_PRIORITY</li>
<li>DELAYED</li>
<li>STRAIGHT_JOIN</li>
<li>SQL_SMALL_RESULT 和 SQL_BIG_RESULT</li>
<li>SQL_BUFFER_RESULT</li>
<li>SQL_CACHE  和 SQL_NO_CACHE</li>
<li>SQL_CALC_FOUND_ROWS</li>
<li>FOR UPDATE 和 LOCK IN SHARE MODE</li>
<li>USE INDEX 、 IGNORE INDEX 和 FORCE INDEX</li>
<li>optimizer_search_depth</li>
<li>optimizer_prune_level</li>
<li>optimizer_switch</li>
</ul>
<p>| 7 优化特性类型的查询</p>
<p>| 7.1 优化count()查询</p>
<p>count是一个特殊的函数，有两种非常不同的作用：<strong>可以用来统计某个列值的数量，也可以统计行数</strong>。在统计列值时，要求列值是非空的（不能为null）。如果在count()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>另一个作用是统计结果集的行数。当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用count(<em>)的时候，这种情况下通配符</em>并不会向我们猜想的那样扩展城所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p>
<p>通常来说，count()都需要扫描大量的行才能活着精确的结果，因此是很难有花的。在MySQL层面还能做的就是覆盖索引扫描了。如果还不够，就需要考虑修改应用的架构，增加汇总表，或者memcached这样的外部缓存系统</p>
<p>| 7.2 优化关联查询</p>
<ul>
<li>确保on或者using子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列C关联的时候，如果有花期的管理按顺序是B、A，那么就不需要在B表的对应列建上索引。没有用到的索引只会带来额外的附带。一般来说，除非有其他理由，否则只需要在管理按顺序中的第二个表的相应列上创建索引。</li>
<li>确保确保任何的group by 和 order by 中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li>
<li>当升级MySQL的时候需要注意：关联语法、运算符优先级等其他可能会发生变化的地方。因为以前是普通关联的地方可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果等。</li>
</ul>
<p>| 7.3 子查询优化，MySQL5.6之后不用管</p>
<p>| 7.4 优化group by 和 distinct</p>
<p>这两类都可以使用索引来优化，这也是最有效的优化办法。</p>
<p>在MySQL中，当无法使用所以你的时候，group by使用相中策略来完成：使用临时表或者文件排序来做分组。对于任何查询语句，这两种策略的性能都有可以提神的地方。可以通过使用提示SQL_BIG_RESULT和SQL_SMALL_RESULT来让优化器按照你希望的方式运行。</p>
<p>如果需要对关联查询做分组，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识列分组的效率会比其他列更高。例如下面的查询效率不会很好</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> actor.first_name,actor.last_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> film_actor <span class="keyword">inner</span> <span class="keyword">join</span> actor <span class="keyword">using</span>(actor_id) <span class="keyword">group</span> <span class="keyword">by</span>  actor.first_name, actor.last_name;</span><br></pre></td></tr></table></figure>
<p>但是如果查询按照下面的写法效率则会更高：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> actor.first_name,actor.last_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> film_actor <span class="keyword">inner</span> <span class="keyword">join</span> actor <span class="keyword">using</span>(actor_id) <span class="keyword">group</span> <span class="keyword">by</span> actor.actor_id;</span><br></pre></td></tr></table></figure>
<p>虽然效率更高，但显然不是所有的关联语句的分组都可以改写成在select中使用非分祖列的形式。如果sql_mode禁用，可以使用min或者max来跳过。但是一定要清楚，select后面出现的非分祖列一定是直接依赖分组列，并且在每个组内的值是唯一的，</p>
<p><strong>优化GROUP BY WITH ROLLUP</strong></p>
<p>最好的办法是尽可能的将WITH ROLLUP功能转移到应用程序中处理</p>
<p>| 7.5 limit分页优化</p>
<p>偏移量很大的时候，代价非常高，想要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。</p>
<p>一个组简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的咧。对于偏移量很大的时候，这样做的效率会提升非常大。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment"># 如果这个表非常大，查询最好改写为：</span></span><br><span class="line"><span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> film_id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span></span><br><span class="line">    ) <span class="keyword">as</span> lim <span class="keyword">using</span> (film_id)</span><br></pre></td></tr></table></figure>
<p>这里的延迟关联将大大提升查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列返回原表查询需要的所有列。这个技术也可以用于优化关联查询中的limit子句。</p>
<p>有时候也可以将limit转换查询为已知位置的查询，让MySQL通过范围扫描获得对应的结果，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">position</span> <span class="keyword">between</span> <span class="number">50</span> <span class="keyword">and</span> <span class="number">54</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">position</span>;</span><br></pre></td></tr></table></figure>
<p>limit和offset的问题，其实是offset的问题，会导致MySQL查询大量不需要的行然后再抛弃掉，如果可以使用数钱记录上次取数据的位置，那么下次就可以直接从概述前记录的位置开始扫描，遮掩的话就可以避免使用offset。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> rental <span class="keyword">order</span> <span class="keyword">by</span> rental_id <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment"># 假设上面的查询返回的是主键为16049到16030的租借记录，那么下一页的查询就可以从16030这个点开始</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> rental <span class="keyword">where</span> rental_id &lt; <span class="number">16030</span> <span class="keyword">order</span> <span class="keyword">by</span> rental_id <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，不管翻页到多么后面，新跟那个都会很好。</p>
<p>| 7.7 优化union查询</p>
<p>需要经常手工地将where，limit，order by等子句下推到union的各个子查询中，以便于优化器优化。</p>
<p>除非确实需要服务器消除重复的行，否则就一定要使用union all，如果没有all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性检查，代价很高。</p>
<p>| 7.8 用户自定义变量</p>
<p>大部分时候，普通开发用不到</p>
<p>| 8.2 计算两点之间的距离</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> locations(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    lat <span class="built_in">float</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    lon <span class="built_in">float</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> locations(<span class="keyword">name</span>, lat, lon)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">       (<span class="string">'Charlottesville'</span>,<span class="number">38.03</span>,<span class="number">-78.48</span>) ,</span><br><span class="line">       (<span class="string">'Chicago'</span>,<span class="number">41.85</span>,<span class="number">-87.65</span>),</span><br><span class="line">       (<span class="string">'Washington，DC'</span>,<span class="number">38.89</span>,<span class="number">-77.04</span>);</span><br><span class="line"><span class="comment"># 单位是度，假设地球是原的，然后使用连点所在最大圆公式来计算两点之间的距离</span></span><br><span class="line"><span class="comment"># 计算出来是一个弧度，如果需要转换为英里或者千米，需要乘以地球的半径，也就是3959英里或者6371千米</span></span><br><span class="line"><span class="comment"># ACOS (</span></span><br><span class="line"><span class="comment">#     COS(latA) * COS(latB) * COS(lonA - lonB) + SIN(latA) * Sin(latB)</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> locations <span class="keyword">where</span> <span class="number">6371</span> * <span class="keyword">ACOS</span>(</span><br><span class="line">    <span class="keyword">COS</span>(<span class="keyword">RADIANS</span>(lat)) * <span class="keyword">COS</span>(<span class="keyword">RADIANS</span>(<span class="number">38.03</span>)) * <span class="keyword">COS</span>(<span class="keyword">RADIANS</span>(lon)-<span class="keyword">RADIANS</span>(<span class="number">-78.48</span>))</span><br><span class="line">        + <span class="keyword">SIN</span>(<span class="keyword">RADIANS</span>(lat)) * <span class="keyword">SIN</span>(<span class="keyword">RADIANS</span>(<span class="number">38.03</span>))</span><br><span class="line">    )&lt;=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>这类查询无法使用索引，还会非常消耗CPU时间,给服务器带来很大的压力，还得重复计算。一般情况不推荐在MySQL中进行地理位置信息的计算。</p>
<p>| 8.3 用户自定义函数</p>
<p>使用C或者C++自定义</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL创建高性能索引</title>
    <url>/2020/12/17/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/3-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>| 1.1 索引的类型</p><p>索引是在存储引擎层实现，非服务器层实现，所以，不同的存储引擎之间，索引的工作方式不一样，也不是所有的存储引擎都实现了某一个索引，即使实现了，工作方式也很有可能不一样。</p><a id="more"></a>

<p>一般常说的索引指的是<strong>B-Tree索引</strong>，但是实际上一般是B+tree，因为B+tree每一个叶子节点都指向下一个叶子节点，有助于范围区间的查询遍历。</p>
<p>示例图如下</p>
<p>B-tree能提高数据访问速度，不再需要全表扫描，而是通过索引，从root节点开始搜索，树的深度和表的大小直接相关，因为b-tree是顺序存储，因此很适合范围查找数据，比如，整数的顺序，字母的顺序，非常高效。</p>
<p>B-tree适合于<strong>全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引</strong>等查询。而且，索引树种的节点是有序的，因此，能用于查询，也就能用于order by 排序。</p>
<p>B-tree索引的限制（最左匹配原则）：</p>
<ol>
<li>如果不是按照索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，那么右边的所有列都无法使用索引优化查找</li>
</ol>
<p><strong>Hash索引</strong>的话，必须是精确匹配所有的查询列才会生效，只有Memery引擎显示支持hash索引。hash找数据非常快，但是也有其自身的一些限制</p>
<ol>
<li>hash索引只包含hash值和指针，无法避免回表</li>
<li>hash索引并不是按照索引值顺序排列的，也就无法用于排序</li>
<li>不支持部分匹配查找</li>
<li>只支持等值匹配查找</li>
<li>hash碰撞（冲突）很多的话，极端情况，会变化为链表</li>
</ol>
<p>同时，InnoDB有一个功能叫”自适应hash索引“，当某些索引值使用的非常频繁的时候，会在内存中，基于B-Tree索引之上再创建一个hash索引，用户无法控制，但是这个功能可以关闭。</p>
<p>同时，如果想在InnoDB中使用hash索引的话，可以手动实现一个，其实就是插入前使用hash函数，但是需要注意，使用CRC32()函数比较合适，推荐使用整数，并不推荐使用SHA1和MD5，这种函数是为了最大化避免hash冲突，实际过程中，并不是那么的有必要。同时，由于生日悖论，hash冲突的出现会比想象中快很多，最好手动维护一个64位的hash函数使用。</p>
<p><strong>R-Tree 空间索引</strong></p>
<p>用作地理数据存储，但是必须使用GIS相关函数来维护数据</p>
<p><strong>全文索引</strong></p>
<p>MySQL不常用，更适合用搜索引擎来做</p>
<p>| 1.2 索引的优点</p>
<ol>
<li>大大减少了服务器需要扫描的数据量</li>
<li>可以帮助服务器避免排序和临时表</li>
<li>可以将随机I/O变为顺序IO</li>
</ol>
<p>| 1.3 高性能索引策略</p>
<ol>
<li><p>独立的列</p>
<p> 如果查询的列不是独立的，那么无法使用索引，也就是说，索引列不能是表达式的一部分，也不能是函数的参数，比如：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> to_day(<span class="keyword">current_date</span>) - to_day(<span class="keyword">current_date</span>) &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p> But，与MySQL8 测试，这个查询正常走了索引，估计是优化器进行了优化吧</p>
</li>
<li><p>前缀所以和索引的选择性</p>
<p> 先说很重要的一点：<strong>MySQL无法使用前缀索引进行order by和group by，也无法使用前缀索引做覆盖扫描</strong>。</p>
<p> 有时候需要索引很长的字符列，这样的话，索引会变的又大又慢，一个策略是使用伪hash索引，但是通常情况下，可以索引开始的部分字符，这样可以大大节省索引空间，提升索引效率。但是同时也会降低索引的选择性。索引的选择性是指：<strong>不重复的索引值和数据表的记录总数的比值，范围从1/T - 1 之间</strong>，索引的选择性越高，则查询效率越高，因为选择性越高的索引在查询时能过滤掉更多的行，唯一索引的选择性为1，是性能最好的索引选择性。</p>
<p> 对于很长的text，varchar，blob，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p> 诀窍在于选择足够长的前缀以保证较高的选择性，同时不能太长（节约空间），前缀应该足够长，使得选择性接近与索引整个列。  </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算完成列的选择性</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> city)/<span class="keyword">count</span>(*) <span class="keyword">from</span> city_demo;</span><br><span class="line"><span class="comment"># 如何在一个查询中计算不同前缀长度的选择性</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">3</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel3,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">4</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel4,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">5</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel5,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">6</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel6,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">7</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel7</span><br><span class="line"><span class="keyword">from</span> city_demo</span><br></pre></td></tr></table></figure>
<p> 这样的话，有助于帮助找到最合适的前缀索引长度。然后开始创建前缀索引。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> city_demo <span class="keyword">add</span> <span class="keyword">key</span>(city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>多列索引</p>
<p> 一个常见错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<p> MySQL引入了一种叫<strong>索引合并（index merge）</strong>的策略，一定程度上可以利用表上的多个单列索引来定位指定的行。比如下面代码所示</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> film_id =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p> 在某些语句的extra列中，还能看到嵌套操作。索引合并是一种优化的结果，但是也说明，索引实际上建的非常糟糕。</p>
<ul>
<li>当服务器对多个索引做相交操作时（多个AND条件），通常意味着需要一个包含相关列的多列索引，而不是多个独立的单列索引。</li>
<li>当服务器需要对多个索引做联合操作时（多个OR条件），通常需要消耗大量的CPU和内存资源在算法的缓存，排序和合并操作上，特别是其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。</li>
<li>更重要的是，优化器不会把这些计算算到”查询成本（cost）“中，优化器只关心随机页面读取。这样会使得查询的成本被低估，导致该执行计划还不如全表扫描。这样不仅可能会消耗更多的CPU和内存资源，还可能会影响查询的并发性。还不如改写成union。</li>
</ul>
</li>
<li><p>选择合适的索引列顺序</p>
<p> 说明：<strong><em>只适用于b-tree索引</em></strong></p>
<p> 在一个多列b-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的order by, group by 和 distinct等子句的查询需求。</p>
<p> 有的建议是：将选择性最高的列放到索引最前列。但是这个建议，<strong>通常不如避免随机IO和排序那么重要</strong>。</p>
<p> 当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好地。这时候索引的作用只适用于优化where条件的查找。这种情况下，这样索引能最快地过滤出所需要的行，对于在where子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。示例如下</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> payment <span class="keyword">where</span> staff_id = <span class="number">2</span> <span class="keyword">and</span> customer_id = <span class="number">584</span>;</span><br><span class="line"><span class="comment"># 应该创建一个(staff_id,customer_id)还是应该颠倒以下顺序？可以跑一些查询来确定在这个表中的分布情况，并确定哪个列的选择性更高。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(staff_id=<span class="number">2</span>),<span class="keyword">sum</span>(customer_id=<span class="number">584</span>) <span class="keyword">from</span> payment;</span><br><span class="line"><span class="comment"># sum(staff_id=2)：7992</span></span><br><span class="line"><span class="comment"># sum(customer_id=584)：30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(staff_id=<span class="number">2</span>) <span class="keyword">from</span> payment <span class="keyword">where</span> customer_id = <span class="number">584</span>;</span><br><span class="line"><span class="comment"># sum(staff_id=2)：17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是，查询的结果非常依赖与选定的具体值，如果这样来，服务器的整体性能可能会更糟，或者不如预期</span></span><br><span class="line"><span class="comment"># 最好还是按照经验法则来，考虑全局技术和选择性，而不是某个具体查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> staff_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> staff_id_selectivity,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> customer_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> customer_id_selectivity,</span><br><span class="line">    <span class="keyword">count</span>(*) <span class="keyword">from</span> payment;</span><br><span class="line"><span class="comment"># 由结果可知，customer_id的选择性更高，所以它是索引列的第一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> payment <span class="keyword">add</span> <span class="keyword">key</span> (customer_id,staff_id)</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚簇索引</p>
<p> InnoDB的聚簇索引实际上在同一个结构中保存了B-tree索引和数据行。当表有局促索引时，它的数据行实际上存放在索引的叶子页中。因为无法同时把数据航存放在两个不同的地方，所以一个表只能有一个聚簇索引（覆盖索引可以模拟多个局促索引的情况）。</p>
<p> 图例在这</p>
<p> 如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p>
<p> 聚簇索引的一些优点：</p>
<ul>
<li>可以把相关数据保存在一起。避免每一次都是磁盘IO</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-tree中，从聚簇索引中获取数据通常比在非聚簇索引中查找要快</li>
<li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</p>
<p>聚簇索引的一些缺点：</p>
</li>
<li><p>最大限度的提高了I/O密集型应用的性能，但是数据如果全部都放在内存中，则反问的顺序就没有那么重要，聚簇索引也就没有什么优势</p>
</li>
<li>插入速度严重依赖与插入顺序，按照主键的顺序插入是加载数据到InnoDB表中速度最快的，但是如果不是按照主键顺序加载，那么加载完成后，需要使用optimize table重新组织一下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临”页分裂（page split）“的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将改页分裂成两个页面来运行，页分裂会导致表占用更多的磁盘空间</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂，导致的数据存储不连续的时候</li>
<li>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li><p>二级索引访问需要两次索引查找，而不是一次</p>
<p>因为二级索引中保存的不是指向行的物理位置的指针，而是行的主键值。意味着通过二级索引查找行，存储引擎需要到二级索引的叶子节点获得对应的主键，然后根据这个值，去聚簇索引中查找到对应的行。自适应hash索引能减少这样的重复操作。</p>
<p>Innodb和myisam的数据分布对比：</p>
<p>myisam按照数据插入的顺序存储在磁盘上，每一行有个行号，因为行是定长的，所以myisam可以从表的开头跳过所需的字节找到需要的行。</p>
<p>myisam的图在这里</p>
<p>要注意的是，在innodb中，聚簇索引“就是表”，所以不想myisam那样需要独立的行存储。</p>
<p>聚簇索引的每一个叶子节点都包含了主键值，事务ID，用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，innodb也会包含完整的主键列和剩下的其他列。</p>
<p>innodb的二级索引和聚簇索引很不相同。innodb的二级索引的叶子节点中，存的不是行指针，而是主键值，以此作为行的指针。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键值当指针会让二级索引占用更多的空间，但是好处是，innodb在移动行的时候无需更新行指针</p>
<p>聚簇索引，非聚簇索引，myisam保存数据和索引的区别，看这个图。</p>
<p>从性能角度考虑，使用UUID作为聚簇索引会很糟糕，会使得聚簇索引的插入变得完全随机，最坏情况会导致数据没有任何聚集特性，而且插入不仅花费的时间更长，索引占用的空间也更大，页分裂和碎片化也更多。</p>
</li>
</ul>
</li>
<li><p>覆盖索引</p>
<p> 如果一个索引包含（或者是覆盖）所有需要查询的字段的值，不需要再次回表查询，称之为覆盖索引。覆盖索引的好处有这些</p>
<ul>
<li>避免回表</li>
<li>索引数目远小于数据行大小，因此如果只需要读取索引，就能够极大的减少数据访问量对于IO密集的应用友好，索引也容易全部放到内存里面，有利于myisam的索引压缩</li>
<li>在单个页内，索引是按照顺序存储的，对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO少得多</li>
<li>一些存储引擎如myisam在内存中之缓存索引，数据则依赖于操作系统来缓存，因此，访问数据需要一次系统调用。可能会导致严重的性能问题，尤其是系统调用占了数据访问中的最大开销的场景。</li>
<li><p>由于InnoDB的聚簇索引，覆盖索引对InnoDB很有用。二级索引在叶子节点中保存了行的主键值，所以如果二级索引能覆盖查询，可以避免对主键索引的二次查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,store_id <span class="keyword">from</span> inventory;</span><br></pre></td></tr></table></figure>
<p>当执行这条sql的时候，extra列显示为Using index，这表示，索引覆盖了查询。但是覆盖索引有很多坑可能会导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了where条件中的字段，但不是整个查询涉及的字段。如果条件为false，MySQL5.5也总是会回表获取数据行，尽管并不需要这一行而且最终会被过滤掉。如果需要解决这个问题的话，需要使用<strong>延迟关联</strong>。</p>
</li>
</ul>
</li>
<li><p>使用索引扫描来做排序</p>
<p> MySQL有两种方式可以生成有序的结果：<strong>通过排序操作；或者按照搜因顺序扫描；</strong>。如果explain出来的type列的值为index，说明MySQL使用了索引扫描来做排序。</p>
<p> 索引的扫描是很快的，从一条移动到下一条即可，但是，如果说索引没有覆盖扫描行的话，每一条索引记录都需要回表查询一次对应的行，基本都是随机IO，因此按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是IO密集型的工作负载时。</p>
<p> 因此，应该尽可能，既满足排序，又满足查找行，这样最好。<strong>只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能使用索引对结果做排序。如果查询需要关联多张表，则只有当order by 子句引用的字段全部为第一个表时，才能使用索引做排序。order by 子句和查找型查询的限制是一样的：需要满足最左前缀的要求；否则；MySQL都需要执行排序操作，而无法利用索引排序。</strong></p>
<p> 有一种情况下order by 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果where子句或者join子句中对这些列制定了常量，就可以弥补索引的不足。</p>
</li>
</ol>
<ol>
<li><p>索引压缩</p>
<p> 不太重要，myisam使用场景不多，不予考虑</p>
</li>
<li><p>冗余和重复索引</p>
<p> 重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应当避免，发现后应当立即删除</p>
<p> 冗余索引大多数情况下都不需要，应当尽量扩展已有的索引而不是创建新索引。但是有时候，扩展已有的索引会导致其变的太多，从而影响其他使用该索引的查询的性能。同时，表中的索引越多插入的速度越慢。</p>
</li>
<li><p>未使用的索引</p>
<p>赶紧删了，可以通过information_schema.index_statistics表，获取到每个索引的使用频率</p>
</li>
<li><p>索引和锁</p>
<p>索引可以让查询锁定更少的行。如果查询从不访问那些不需要的行，那么就会锁定更少的行，从这方面来看对性能是有好处的。因为innodb虽然行锁效率高，内存使用少，当时锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>
<p>InnoDB只有在访问行的时候才对其枷锁，而索引能减少Innodb访问的行数，从而减少锁的数量。但是只有当innodb在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤无效的行，那么在innodb检索到数据并返回给服务器层以后，MySQL服务器才能应用where子句。这时候已经无法避免锁定行了：innodb已经锁住了这些行，适当的时候才会释放。</p>
<p>示例：</p>
<p><strong>explain出现了using where，这表示MySQL服务器将存储引擎返回行以后再应用过滤条件</strong>。Innodb在二级索引上使用共享锁（读），但访问主键索引需要排他锁（写）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的Schema和数据类型优化</title>
    <url>/2020/12/16/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/2-Schema%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>| 1. 选择数据类型时候的基本原则</p><ol>
<li><strong>更小的通常更好</strong>，占用更少的磁盘，内存和CPU缓存，处理时需要的CPU时钟周期也少，但是不建议项目初期就弄，不然改起来也太费劲了，超级痛苦。</li>
<li><strong>简单的更好</strong>，比如能使用整形就不适用字符，能用date就不用字符串，因为字符集和排序规则使得字符串相比整形复杂。</li>
<li><strong>避免为null</strong>，滴滴的数据表，全都是not null的，因为有null的列更难优化，耗费的成本更高，索引，统计更麻烦，浪费更多的存储空间，</li>
</ol><a id="more"></a>

<p>| 1.1 整数类型</p>
<p>分为两种，整数（real number）和实数（real number），整数有这么几种：<strong>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT</strong>，分别使用8，16，24，32，64位存储空间，存储的值为 -2^n-1 到 2^(n-1)-1，同时有可选的<strong>UNSIGNED</strong>属性，不允许负值，可以将正数上限提高一倍。<strong>INT(11)</strong>不会限制值的合法范围，只是规定了一些交互工具显示字符的个数。</p>
<p>| 1.2 实数类型</p>
<p>DECIMAL可以存比BIGINT更大的整数，也可以存储精确的小数，<strong>CPU原生支持浮点运算，但是DECIMAL需要MySQL实现，因此浮点比DECIMAL运算更快。decimal计算中，会转换为double，因此，虽然DECIAML支持65个数字，但是实际上并不支持</strong>。同时，建议选择数据类型，不建议选择decimal的精度。可以使用BIGINT取代decimal，避免运算代价过高。</p>
<p>| 1.3 varchar和char类型</p>
<p>varchar比定长更节省空间，因为它只使用必要的空间，除非使用row_format=fixed，但是varchar需要1-2个字节记录字符串长度。虽然varchar对于性能有好处，但是，由于行是变长的，因此update操作可能使得行比原先变的更长，这时候，innodb就会进行分裂页，是数据能够放入页内。</p>
<p>下面这几种情况使用varchar更合适：<strong>字符串列的最大长度比平均长度长很多；列的更新很少，碎片不是问题；使用了复杂字符集，比如utf-8，每个字符都是用不同的字节数进行存储</strong>。</p>
<p>char会删除末尾空格，由于定长，也不容易产生碎片，而且在存储空间上也更有效率，没有存储长度的多余字节。</p>
<p>| 1.3.1 Blob和Text类型</p>
<p>分别属于两组：<strong>TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT  和 TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB</strong>。区别是，blob存储的是二进制数据，没有排序规则和字符集，而text有排序规则和字符集。如果数据过大的话，MySQL会在外部存储区域进行存储实际的值，每个值在行内用1-4个字节存储一个指针。</p>
<p>| 1.4 时间和日期类型</p>
<p>MySQL能存储的最小时间单位粒度为秒，datetime可以存储1001-9999的数据，<strong>使用8个字节的存储空间</strong>。而timestamp，<strong>保存的是标准时间，只能从1970-2038，使用4个字节进行存储，依赖于时区，默认为NOT NULL，效率也比datetime更高</strong>。</p>
<p>如果想存储微秒级别的时间戳，可以使用bigint，或者使用MariaDB。</p>
<p>| 1.5 位数据类型</p>
<p>bit列的最大长度是64个位，MySQL把bit当成字符串类型使用，同时和上下文环境有关系，比如直接查询，可能是显示的这个二进制对应的ASCII码表的内容，但是如果与数字一起运算，得到的就是数字结果，谨慎使用。</p>
<p>如果需要很多true/false值，可以使用set，在MySQL内部是以一系列打包的位的集合表示的，能够有效利用存储空间，但是该变列的话，需要alter table.</p>
<p>总的来说不太推荐这种方式，并不如redis的位图来的直观好用。</p>
<p>| 1.6 选择标识符（identifier）</p>
<p>要确保所有关联表中都使用同样的类型，要精确匹配。<strong>最好使用整数，快，而且可以使用AUTO_INCREMENT，要避免使用uuid，会有6倍左右的性能下降，会导致insert和select语句很慢</strong>。</p>
<p><strong><em>因为插入的时候，会随机写到索引的不同位置，使得insert语句很慢，会导致页分裂，磁盘随机访问，以及聚簇索引碎片；select语句也会很慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方；随机值导致缓存对所有类型的查询语句效果都很差，会使得缓存赖以工作的访问局部性原理失效，如果数据都是热数据，那么缓存哪一部分到内存都没好处，如果工作集比内存大，缓存将会有很多刷新和不命中</em></strong></p>
<p>如果使用UUID，应当移除“-”符号，更好的做法应该是使用unhex函数转换uuid为16字节的数字，并且存在binary(16)的列中。检索时，通过hex()函数来格式化为十六进制。UUID虽然分布也不均匀，但还是有一点顺序，但是还是不如递增的整数好用。</p>
<p>| 2. schema设计中的陷阱（应当避免）</p>
<ol>
<li><p>太多的列</p>
<p> MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，单然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。</p>
</li>
<li><p>太多的关联</p>
<p> MySQL限制了每个关联操作最多只能有61张表，同时，最好在12个表以内做关联。</p>
</li>
<li><p>全能的枚举</p>
</li>
<li>变相的枚举</li>
<li>用魔法数字代替null</li>
</ol>
<p>| 3. 数据库范式和反范式</p>
<p>三范式如下：</p>
<p>1．第一范式(确保每列保持原子性)</p>
<p>2．第二范式(确保表中的每列都和主键相关)</p>
<p>3．第三范式(确保每列都和主键列直接相关,而不是间接相关)</p>
<p>范式化的优点很明显：</p>
<ol>
<li>范式化的更新操作通常比反范式化更快</li>
<li>很少或者没有重复数据，只需要修改更少的数据</li>
<li>表更小，能更好的放内存里，执行起来会更快</li>
<li>更好的distinct和group by语句</li>
</ol>
<p>缺点也很明显：</p>
<ol>
<li>干个啥都得关联查询</li>
<li>稍微复杂一点的语句在schema上都可能至少需要一次关联</li>
</ol>
<p>反范式化的优点</p>
<ol>
<li>避免关联，对查询来说是极大的优化</li>
<li>能使用更有效的缓存策略</li>
</ol>
<p>| 缓存表和汇总表</p>
<p>| 物化视图</p>
<p>| 计数器表</p>
<p>更新的时候核能会碰到并发问题，记录会有一个全局的互斥锁，使得一些事务只能穿行执行，可以将数据保存为多行，随机选择一行进行更新，获得更高的并发更新性能。</p>
<p>| 5. 加快 alter table 操作的速度</p>
<p>使用alter column改变列，防止表重建，会直接修改.frm文件</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询性能剖析</title>
    <url>/2020/12/16/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/1-MySQL%E6%9F%A5%E8%AF%A2%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>首先，也是最重要的一点，需要记录慢查询日志，然后针对日志，进行分析。假设已经定位到问题是查询语句的问题，如果不是，需要自顶而下进行考虑，外部接口慢？文件解析慢？正则滥用？还是暴力搜索算法等。</p><a id="more"></a>
<p>剖析工具</p>
<p>| Profile分析</p>
<p>profile分析最重要的还是在语句执行期间剖析服务器的具体操作，当一条查询到了数据库后，会记录信息到一张临时表，并且给一个整数的id作为标识符，方便查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nicer_but_slower_film_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span> ;</span><br><span class="line"><span class="comment"># show prifiles 会显示出刚刚那条查询语句的查询id，获取到后</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="comment"># 会打印出这条查询的详细信息，由于打印出来的信息不太直观，可以优化一下，如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @query_id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> state,</span><br><span class="line">       <span class="keyword">sum</span>(<span class="keyword">duration</span>)            <span class="keyword">as</span> total_r,</span><br><span class="line">       <span class="keyword">round</span>(<span class="number">100</span> * <span class="keyword">sum</span>(<span class="keyword">duration</span>) /</span><br><span class="line">             (<span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">duration</span>) <span class="keyword">from</span> information_schema.PROFILING <span class="keyword">where</span> QUERY_ID = @query_id), <span class="number">2</span></span><br><span class="line">           )                    <span class="keyword">as</span> pct_r,</span><br><span class="line">       <span class="keyword">count</span>(*)                 <span class="keyword">as</span> calls,</span><br><span class="line">       <span class="keyword">sum</span>(<span class="keyword">duration</span>) / <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="string">"r/call"</span></span><br><span class="line"><span class="keyword">from</span> information_schema.PROFILING</span><br><span class="line"><span class="keyword">where</span> QUERY_ID = @query_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> state</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total_r <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>这个工具能告诉我们哪些活动花费了很长时间，但是并不会告诉我们为什么，还是需要我们具体情况具体分析。</p>
<p>| show status  || show global status</p>
<p>这个工具只是一个计数器，但是并不是剖析工具，用来显示一些活动的频繁程度，但是无法给出消耗了多少时间。只有一条信息显示的是操作时间(Innodb_row_lock_time)，而且是全局的，无法测量会话级别。</p>
<p>虽然无法知道哪些操作耗时最长，但是可以猜测。最有用的句柄计数器(handle counter)，临时文件和表计数器。示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">status</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nicer_but_slower_film_list;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">where</span> Variable_name <span class="keyword">like</span> <span class="string">'Handler%'</span> <span class="keyword">or</span> Variable_name <span class="keyword">like</span> <span class="string">'Created%'</span>;</span><br></pre></td></tr></table></figure>
<p>从执行结果中可以看到，使用了三张临时表，其中两个磁盘临时表，而且有很多没有用到索引的读操作(Handler_read_rnd_next)，这个查询有可能是使用了join多表关联查询，但是没有合适的索引，或者是一个子查询创建了临时表，并且和其他表做联合查询，而用于保存子查询结果的临时表没有索引等。</p>
<p>show status 可以类比为explain，它们两者可以得到相似的结果，但是explain是预估的结果，而show status是精确测量的结果，比如explain无法告诉你临时表是否是磁盘表还是内存临时表。</p>
<p>| performance_schema</p>
<p>performance_schema无法提供查询阶段的细节和计时信息，但是，能够知道其他很多有意思的信息，比如：user_variables_by_thread, global status,global_variables,session_variables等，可以用排错或者定位问题使用</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-RabbitMQ</title>
    <url>/2020/12/16/Interview/RabbitMQ/</url>
    <content><![CDATA[<ol>
<li><p>知道MQ么，MQ是什么，MQ的作用是什么？</p>
<p> Message Queue，顾名思义，消息队列，基于生产者-消费者模式。作用可分为下面几点，但是MQ在单机环境下并不适用，更加适用于多系统，多服务的环境。</p>
<ul>
<li>异步处理，提高系统吞吐量</li>
<li>应用解耦，不用关系其他系统怎么处理</li>
<li>流量削峰，缓解短时间内的高并发请求，可通过控制mq长度来处理</li>
<li>消息通讯，聊天室，点对点传输等</li>
<li>日志处理，解决大量日志传输 </li>
<li>详细回答……</li>
</ul>
</li>
<li><p>MQ的缺点是什么？</p>
<ul>
<li>增加系统复杂性</li>
<li>降低系统可用性</li>
<li>数据一致性</li>
<li>详细回答</li>
</ul>
</li>
<li><p>RabbitMQ 和 其他MQ之间的区别有哪些？为什么选择RabbitMQ？</p>
<ul>
<li>虽然是Erlang开发，但是有很高的社区活跃度，可以保证可用性以及bug修复的及时性，国内外已经有很多公司使用rabbitMQ，并且有了很好的工程实践</li>
<li>有良好的的web管理界面</li>
<li>对于MQ没有特别强烈的定制需求，已有功能足以满足业务需求</li>
</ul>
</li>
<li><p>RabbitMQ有哪些常见问题？如何避免这些问题？</p>
<ul>
<li>消息的乱序问题</li>
<li>消息的重复发送问题</li>
</ul>
</li>
<li><p>Rabbit的工作模式</p>
<ol>
<li>simple模式，最简单的收发模式</li>
<li>消费者监听模式（customer）</li>
<li>work工作模式，信息被消费者竞争</li>
<li>publish/subscribe 发布/订阅模式，每个消费者监听自己的队列</li>
<li>routing 路由模式</li>
<li>topic 模式</li>
</ol>
</li>
<li><p>如何保证信息消费时的幂等性？</p>
</li>
<li><p>如何保证消息的可靠传输？</p>
</li>
<li><p>消息队列满了怎么处理？过期失效怎么办？有消息积压怎么办？</p>
</li>
</ol>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity 负载均衡</title>
    <url>/2020/12/15/Spring%20Security/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>想弄一下SpringSecurity的负载均衡是怎么实现的，就找了找资料，在此记录一下。</p><p>首先，需要两个依赖：</p><a id="more"></a>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation(<span class="keyword">group</span> = <span class="string">"org.springframework.boot"</span>, name = <span class="string">"spring-boot-starter-data-redis"</span>)</span><br><span class="line">implementation(<span class="keyword">group</span> = <span class="string">"org.springframework.session"</span>, name = <span class="string">"spring-session-data-redis"</span>, version = <span class="string">"2.4.1"</span>)</span><br></pre></td></tr></table></figure>
<p>引入这两个依赖之后，需要在properties或者yaml里配置一下redis的路径和端口，默认为127.0.0.1和6379，但是由<code>RedisAutoConfiguration</code>可知，需要配置spring.redis的相关属性后，才会生效，因此虽然有默认值，还是写一下吧。。。</p>
<p>然后配置nginx的upstream：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcat &#123;</span><br><span class="line">		<span class="attribute">server</span> localhost:<span class="number">8080</span>;</span><br><span class="line">		<span class="attribute">server</span> localhost:<span class="number">8081</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://tomcat;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了之后，先生成个jar包，然后使用<code>--server.port=8080</code>的方法，启动两个实例。这时，我们请求接口的话，就能看到打印的sessionId是一致的，且两个实例轮流打印日志，说明负载均衡配置成功。同时查看redis，session信息已经保存了进去。</p>
<p>图在这里。</p>
<p>| tips</p>
<p>还是有点地方需要注意</p>
<ol>
<li>如果项目中有缓存，不要使用直接基于内存的，比如静态的hashmap等，最好使用第三方的分布式缓存工具，比如memcached，redis等，否则，原有的缓存会失效，一致性也会无法得到保证</li>
<li><p>有个地方很坑，如果想获取所有在线用户的话，注册<code>sessionRegistry</code>获取，<code>spring-sessoin</code>的实现类是<code>SpringSessionBackedSessionRegistry</code>，然后点进去源码一看</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getAllPrincipals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"SpringSessionBackedSessionRegistry does not support retrieving all principals, "</span> +</span><br><span class="line">            <span class="string">"since Spring Session provides no way to obtain that information"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 大爷的，咋就不能用了，从redis查一下不就好了，如果有使用在线用户方法的，需要避免这个问题。。。同样，使用第三方来管理session吧，或者重写它的方法，手动从redis中查询也可以。</p>
</li>
<li>获取当前登录用户是没问题的</li>
<li>登录的时候，会把当前实现了UserDetais的实体序列化到redis中，一定要实现Serializable接口，不然会报错，或者可以手动修改序列化的方式，改为json，但是如果是json的话，需要避免循环依赖导致OOM的问题.</li>
</ol>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-Redis篇章</title>
    <url>/2020/12/06/Interview/Redis/</url>
    <content><![CDATA[<ol>
<li><p>Redis常见的数据类型有哪些？</p>
<p>String,List,hash,set,zset</p>
</li>
<li><p>解释一下redis的二进制安全</p>
<p>需要客户端给它字节数组</p>
</li>
</ol>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-MySQL篇</title>
    <url>/2020/11/16/Interview/MySQL/</url>
    <content><![CDATA[<h3><span id="想提升还是得连环炮方式的提问">想提升，还是得连环炮方式的提问</span></h3><ol>
<li><p>你们对线上的数据有没有做一些优化？怎么优化的？</p>
<ol>
<li><p>如果回答的是索引</p>
<ol>
<li><p>来说一说什么是索引？有哪几种索引？索引有什么优点？</p>
<p>用于存储引擎快速找到记录的一种数据结构，存储引擎会先在索引中找到对应值，然后根据匹配的索引记录找到对应的记录行，索引可以包含一个或者多个列的值</p>
<p>B-Tree索引，（准确的说是B+Tree，B-Tree和B+Tree有什么区别？）哈希索引，空间数据索引，全文索引，分行树索引</p>
<p>优点：1.大大减少服务器需要扫描的数据量，2.可以帮助服务器避免排序和临时变，3.索引可以将随机IO变为顺序IO。</p>
</li>
<li><p>这些索引采取的是哪种数据结构？</p>
<p>B-Tree索引用的B+Tree，哈希索引用的哈希表</p>
</li>
<li><p>为什么采取B+Tree？这种数据结构有什么好处么？</p>
<p>B+Tree对索引列是按照顺序组织存储的，适用于<strong>全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引的查询</strong>。因为节点有序，还可用于查询中的order by操作。</p>
<p>但是，如果<strong>不是按照索引的最左列开始查找，则无法使用索引；不能跳过索引中的列；如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</strong>。</p>
</li>
<li><p>和哈希表相比，有什么优点或者有什么不同？</p>
<p>Hash索引基于哈希表，会在哈希表中保存指向每个数据行的指针，<strong>只有精确匹配索引所有列的查询才有效</strong>。但是Hash并不是就一定会很快，因为hash值重复的话，会以链表的方式存放多个记录指针到一个条目中，所以说，极端情况下，会变成为链表。</p>
<p>B+ Tree索引和Hash索引区别 哈希索引适合等值查询，但是无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
</li>
<li><p>MySQL中B+Tree的叶子节点能存什么东西？</p>
<p>首先，叶子节点会有索引列的数据，其次，B+Tree的叶子节点会保存数据行，MySQL中会保存数据库表的聚簇索引，主键（如果没有，首先会选择一个唯一的非空索引来代替，如果还没有，会隐式定义一个主键作为聚簇索引），然后会根据主键，进行回表，获取所需数据。</p>
</li>
<li><p>什么是聚簇索引和非聚簇索引？</p>
<p>聚簇索引将<strong>索引和数据放在同一行</strong>，非聚簇索引将<strong>索引和数据分开存放</strong>。</p>
<p>一个表仅有一个聚簇索引</p>
<p>聚簇索引的插入速度依赖于插入顺序，如果使用UUID，可能导致插入页分裂降低速度。</p>
<p>更新主键（聚簇索引）的时候，会导致被更新的行移动</p>
<p><strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>
</li>
<li><p>查询的时候有什么区别？</p>
<p>当取一定范围内的数据时，聚簇索引相比较非聚簇索引也会更快</p>
<p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>
<p>因为非聚簇索引查询时，会先扫描一遍B+Tree，获取到叶子节点的主键ID，然后根据ID进行回表，而聚簇索引，会包含整行数据，每次会把共同一个页的数据都加载到内存里，读取同一页的数据，避免了磁盘查找，速度会更快。同时，使用ID获取数据时，会更快。少了一次根据ID回表的过程。但是，比如有一个code，普通索引，查询这个code的时候，应为不需要获取其他数据，少了回表的过程，应该也算是聚簇索引。</p>
<blockquote>
<p>覆盖索引 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol><a id="more"></a>
<pre><code>  8. 联合索引是怎么使用的？为什么使用联合索引？说一说最左前缀匹配

     给需要查询的列，或者是需要排序的列，添加联合索引，比如说(k1,k2,k3)这么一个联合索引，会相当于(k1),(k1,k2),(k1,k2,k3)三个索引，这就是最左前缀匹配。

  9. 各个MySQL版本中，对索引有哪些方面的优化？

     5.6版本的MySQL做了索引下推。

     people表中（zipcode，lastname，firstname）构成一个索引

     SELECT * FROM people WHERE zipcode=&#39;95054&#39; AND lastname LIKE &#39;%etrunia%&#39; AND address LIKE &#39;%Main Street%&#39;;

     如果没有使用索引下推技术，则MySQL会通过zipcode=&#39;95054&#39;从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE &#39;%etrunia%&#39;和address LIKE &#39;%Main Street%&#39;来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=&#39;95054&#39;的索引，然后根据lastname LIKE &#39;%etrunia%&#39;和address LIKE &#39;%Main Street%&#39;来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

  10. 通过什么情况，能知道是否走了索引？

     使用explain语句进行分析

  11. 什么情况下会发生创建了索引，但是没有走索引的情况？

      查询发生隐式转换，比如数据库定义的是string，但是查询的时候使用的是int

      对索引列进行运算，导致索引失效

      使用&lt;&gt;，not in , not exist 等会导致索引失效

      如果变量为空，使用 = null ，会导致索引失效

      查询优化器 一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个，可能会优化器认为全表扫描的代价小于使用索引

  12. 不同类型的值，比如说varchar，int，等，使用索引会有什么变化？

      如果column定义的为是varchar，但是查询使用的是int，会走索引

      如果column定义的是int，查询用的是string，存在隐式转换，不会走索引
</code></pre><ol>
<li><p>加缓存，memcache，redis等</p>
<p>memcache，redis等问题放到其他章节</p>
</li>
<li><p>主从复制，或者主主复制，读写分离</p>
<ol>
<li>MySQL复制的方法有哪几种？分别有什么优缺点？</li>
<li>主从的延迟问题你们怎么解决？</li>
<li>解释一下半同步复制和并行复制</li>
<li>MySQL能否一主多从？或者多主多从？</li>
</ol>
</li>
<li><p>分区表</p>
<ol>
<li>解释一下分区表，有哪几种类型？</li>
<li>分区表的优缺点？</li>
</ol>
</li>
<li><p>分库分表</p>
<ol>
<li>分库分表有哪几种类型？你们平时都是怎么处理的？</li>
<li>水平分表和垂直分表的优缺点？</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>React中碰到的生命周期问题</title>
    <url>/2020/11/09/Frontend/React/01/</url>
    <content><![CDATA[<p>先上代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  componentWillMount() &#123;</span><br><span class="line">    const &#123; params &#125; = this.props.location;</span><br><span class="line">    const &#123; dispatch &#125; = this.props;</span><br><span class="line">    if (params?.id) &#123;</span><br><span class="line">      roleDetail(params.id).then((role) =&gt; &#123;</span><br><span class="line">        if (dispatch) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: &apos;roleForm/saveRoleBasic&apos;,</span><br><span class="line">            payload: role,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">getCurrentStepAndComponent = (current?: string) =&gt; &#123;</span><br><span class="line">    switch (current) &#123;</span><br><span class="line">      case &apos;permission&apos;:</span><br><span class="line">        return &#123; step: 1, component: &lt;RolePermission/&gt; &#125;;</span><br><span class="line">      case &apos;complete&apos;:</span><br><span class="line">        return &#123; step: 2, component: &lt;RoleComplete/&gt; &#125;;</span><br><span class="line">      case &apos;basic&apos;:</span><br><span class="line">        return &#123; step: 0, component: &lt;RoleBasic/&gt; &#125;;</span><br><span class="line">      default:</span><br><span class="line">        return &#123; step: 3, component: &lt;RoleBasic/&gt; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; step, component &#125; = this.getCurrentStepAndComponent(this.props.current);</span><br><span class="line">    return &lt;&gt;</span><br><span class="line">      &lt;Card bordered=&#123;false&#125; bodyStyle=&#123;&#123; padding: 73 &#125;&#125;&gt;</span><br><span class="line">        &lt;Steps current=&#123;step&#125; style=&#123;&#123; marginBottom: 60 &#125;&#125;&gt;</span><br><span class="line">          &lt;Step title=&quot;角色基本信息&quot;/&gt;</span><br><span class="line">          &lt;Step title=&quot;角色权限信息&quot;/&gt;</span><br><span class="line">          &lt;Step title=&quot;完成&quot;/&gt;</span><br><span class="line">        &lt;/Steps&gt;</span><br><span class="line">        &#123;component&#125;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    &lt;/&gt;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>如代码所见，一个tab，角色保存的三个步骤，当进入Form的时候，会去获取角色ID，然后保存到saveRoleBasic里，以供第一个tab来进行角色信息的回显。代码类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  const &#123; data &#125; = this.props;</span><br><span class="line">  this.formRef.current!!.setFieldsValue(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，使用的时候发现问题，form请求了后台数据，但是页面的数据并没有如期正确回显。</p>
<p>首先能肯定的时候，后台的数据肯定是正确的，经过日志的验证，数据也确实返回去了，但是为何没有触发回显？</p>
<p>随后又加了几条日志，发现，data使用的仍然是之前的数据，除非再来一次，它才会进行刷新，这就表示，先执行的RoleBasic的componentDidMount，后执行的父类的componentWillMount，也就是说，子组件优先于父组件初始化，不过，本当如此。</p>
<p>为了解决这个问题，需要做的就是，子组件修改为在componentDidUpdate进行数据的初始化，这样的话，父类组件修改props的数据时，子类组件的componentWillMount会进行执行，数据回显就正常了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/06/30/Language/English/New%20Concept/Chapter1/lesson67/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>greengrocer 蔬菜水果零售商<ol>
<li>grocer 零售商</li>
<li>at <strong>the</strong> greengrocer’s 在蔬菜水果零售店</li>
<li>at the butcher’s 在肉店</li>
<li>at the doctor’s 在诊所</li>
<li>at the grocer’s 在零售店</li>
</ol>
</li>
<li>absent adj. 缺席的<ol>
<li>He is absent today.</li>
<li>He is absent from school today.</li>
<li><strong>be absent from …</strong>   <strong>school / work / class…</strong></li>
<li>She is not absent from work.</li>
</ol>
</li>
<li>keep v. 保持，保留，（身体健康）处于（装填）<ol>
<li>keep healthy</li>
</ol>
</li>
<li>spend v. 度过<ol>
<li><strong>spend + 时间 + 地点</strong><ol>
<li>He spends two days in Beijing.</li>
<li>He stays in Beijing for two days.</li>
</ol>
</li>
<li><strong>spend + 时间 + with sb.</strong><ol>
<li>He spends two weeks with his girlfriend.</li>
</ol>
</li>
</ol>
</li>
<li>weekend 周末</li>
<li>country 乡村<ol>
<li>in the country 在乡下</li>
<li>in the city  在城里</li>
<li>in the village 在村里</li>
<li>国家，in my country</li>
</ol>
</li>
<li>lucky  adj. 幸运的<ol>
<li>You are so lucky!</li>
<li>You are a lucky dog.</li>
</ol>
</li>
<li>Sunday（SUN） 周日  </li>
<li>Monday（MON） 周一  </li>
<li>Tuesday（TUE） 周二 </li>
<li>Wednesday（WED） 周三 </li>
<li>Thursday（THUR） 周四 </li>
<li>Friday（FRI） 周五 </li>
<li>Saturay（SAT） 周六 </li>
<li><strong>首字母大写</strong></li>
<li><strong>on + 天</strong></li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>at <strong>the</strong> butcher<strong>‘s</strong>  在肉店<ol>
<li>Were you at the butcher’s？ 你刚刚在肉店么？</li>
<li>Were 过去式</li>
<li>Are you at the butcher’s</li>
</ol>
</li>
<li>How<strong>‘s</strong> Jimmy today?<ol>
<li>How is …?</li>
<li>How was …?</li>
<li>How has …?</li>
</ol>
</li>
<li>Was he absent from school last week?<ol>
<li>be absent from …</li>
</ol>
</li>
<li>How are you (all keeping)?</li>
<li>We’re going to spend three days in the country.<ol>
<li><strong>spend + 时间 +地点</strong></li>
</ol>
</li>
<li>at my mother’s 在我妈妈家<ol>
<li>at the butcher’s</li>
</ol>
</li>
<li>Aren’t you lucky! 你们可真幸运啊</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h5><span id="一般现在时态">一般现在时态</span></h5><ol>
<li>经常的状态<ol>
<li>主语 + is / am /are </li>
</ol>
</li>
<li>习惯的动作<ol>
<li>主语 + v.</li>
</ol>
</li>
<li>真理<ol>
<li>主语 + is / am /are</li>
<li>主语 + v</li>
</ol>
</li>
</ol>
<h5><span id="一般过去时态">一般过去时态</span></h5><ol>
<li><strong>过去</strong>的状态：<ol>
<li>主语 + was / were</li>
</ol>
</li>
<li><strong>过去的</strong>动作：<ol>
<li>主语 + v.（动词过去式）</li>
</ol>
</li>
</ol>
<p>My boyfriend is 27, he is a little fat. He is a clerk. He is in Beijing too.</p>
<p>My boyfriend was 27  last year, he was a little fat. He wes a clerk. He was in Beijing too two years ago.</p>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>church 教堂<ol>
<li>at church</li>
</ol>
</li>
<li>dairy 乳品店<ol>
<li>at the dairy</li>
</ol>
</li>
<li>baker 面包师傅<ol>
<li>at the baker’s</li>
</ol>
</li>
<li>grocer 食品杂货商<ol>
<li>at the grocer’s </li>
</ol>
</li>
<li>Where were you on Sunday, Jan. 1st?</li>
<li>I was at church.</li>
<li>When were you at the bucher’s?</li>
<li>I was at the butcher’s on Wed, Apr, 4th.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/06/29/Language/English/New%20Concept/Chapter1/lesson65/</url>
    <content><![CDATA[<a id="more"></a><ol>
<li>Dad  爸爸（口语）</li>
<li>key 钥匙<ol>
<li>门的钥匙：the key <strong>to</strong> the door</li>
<li>车的钥匙：the key <strong>to</strong> the car</li>
<li>书的颜色：the color of the book</li>
<li>张艺谋的电影：ZhangYimou’s movie</li>
</ol>
</li>
<li>baby 婴儿，宝贝<ol>
<li>baby - kid(child) - teenager</li>
<li>baby, honey, sweetheart….</li>
</ol>
</li>
<li>hear 听见<ol>
<li>Listen! Can you hear it.</li>
<li>Look! Can you see it?</li>
<li>Look for it! Can your find it?</li>
</ol>
</li>
<li>enjoy 玩的开心<ol>
<li>en- 使得</li>
<li>enlarge, endanger, enslave, enjoy…</li>
<li>过得愉快，玩的开心<ol>
<li>I enjoy my holiday.</li>
</ol>
</li>
<li>喜欢<ol>
<li>I enjoy the song very much.</li>
</ol>
</li>
<li>mum 妈妈</li>
</ol>
</li>
</ol><a id="more"></a>

<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You must be home at half past ten.<ol>
<li><strong>must / can + be + 非动词</strong></li>
<li>他能够在这呆很久。</li>
<li>He can be here for a long time.</li>
<li>他们必须9点到这。</li>
<li>They must be here at 9:90.</li>
</ol>
</li>
<li>回家<ol>
<li>be home / get home / come home / arrive home…</li>
</ol>
</li>
<li>… the key to the front door.<ol>
<li>the front door &amp; the back door</li>
<li>the key to …</li>
<li>the answer to the question</li>
<li>the exit to the building</li>
<li>the ticket to the movie</li>
</ol>
</li>
<li>年龄的表达<ol>
<li>… years old</li>
<li>…year -old</li>
<li>19岁：nineteen years old / nineteen-year-old</li>
</ol>
</li>
<li>Enjoy yourself. 玩的开心<ol>
<li>Enjoy your holiday.</li>
<li>Enjoy your class.</li>
<li>Enjoy your dinner party.</li>
<li>Have a nice day.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="反身代词">反身代词</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>我（们）自己</th>
<th>你（们）自己</th>
<th>他自己</th>
<th>她自己</th>
<th>它自己</th>
</tr>
</thead>
<tbody>
<tr>
<td>单数</td>
<td>myself</td>
<td>yourself</td>
<td>himself</td>
<td>herself</td>
<td>itself</td>
</tr>
<tr>
<td>复数</td>
<td>ourselves</td>
<td>yourselves</td>
<td>themselves</td>
<td>themselves</td>
<td>themselves</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>英语中为什么有反身代词</li>
<li>何时用？<ol>
<li>强调主语 &amp; 宾语<ol>
<li>He <u>himself</u> sent me a gift.他亲自送我一件礼物</li>
<li>I see JayChou himself.</li>
</ol>
</li>
<li>不言而喻的宾语<ol>
<li>Take good care of <u>yourself</u>.</li>
<li>Enjoy <strong>yourself</strong>.</li>
</ol>
</li>
<li>用法？<ol>
<li>介词+反身代词<ol>
<li><strong>by oneself 独自</strong></li>
<li>I’m going to swim by myself.</li>
<li>He’s going to learn English by himself.</li>
<li><strong>between oneself  私下</strong></li>
<li>It’s just between ourselves.</li>
</ol>
</li>
<li>动词 + 反身代词<ol>
<li><strong>enjoy oneself 玩的开心，过得愉快</strong></li>
<li>They enjoy themselves.</li>
<li><strong>help oneself 随意</strong></li>
<li>Help yourselves, please.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><p>What’s the time?</p>
<ol>
<li><p><strong>past 过</strong></p>
</li>
<li><p><strong>to 差</strong></p>
</li>
<li><p><strong>a quarter 15分钟</strong>  </p>
</li>
<li><p>时间的读法</p>
<ol>
<li>3:00 three o’clock</li>
<li>7:30 seven thirty</li>
<li>half past seven</li>
<li>half to eight</li>
<li>4:20 four twenty</li>
<li>twenty past four</li>
<li>forty to five</li>
<li>10:15 ten fifteen</li>
<li>fifteen past ten</li>
<li>a quarter past ten</li>
<li>2:45 two forty five</li>
<li>forty five past two</li>
<li>three quarters past two</li>
<li>fifteen to three</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 63</title>
    <url>/2020/06/29/Language/English/New%20Concept/Chapter1/lesson63/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>better adj. 形容词well的比较级<ol>
<li>good-better-well</li>
<li>I’m well.   I’m better.</li>
</ol>
</li>
<li>certainly  adv.当然</li>
<li>get up 起床<ol>
<li>go to bed /  go to sleep</li>
<li>三单形式：</li>
<li><strong>gets up / goes to bed / goes to sleep</strong></li>
</ol>
</li>
<li>yet adv. 还，仍<ol>
<li>否定，疑问句末</li>
<li>你还不能去上班呢</li>
<li>You can’t go to work yet.</li>
<li>He can’t drive yet.</li>
</ol>
</li>
<li>rich adj. 油腻的<ol>
<li>rich food 油腻的食物</li>
<li>a rich man  一个富有的人</li>
<li>rich silk  华丽的丝绸</li>
<li>rich land 肥沃的</li>
</ol>
</li>
<li>food 食物<ol>
<li>rich food. 油腻的食物</li>
<li>mild food.  清淡的食物</li>
<li>spicy food. 辛辣的食物</li>
<li>green food 绿色食品</li>
<li>fast food 快餐</li>
<li>sea food 海鲜</li>
</ol>
</li>
<li>remain v. 保持，继续<ol>
<li>remain in bed.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You <u>look</u> very <u>well</u>.<ol>
<li>感官动词 - adj.</li>
<li>你看起来很开心啊。</li>
<li>You look very happy.</li>
<li>He looks very busy.</li>
</ol>
</li>
<li>你现在好多了，但你还不能去上学呢。<ol>
<li>You are better now, but you mustn’t go to school yet.</li>
<li><strong>yet，否定疑问句末</strong></li>
<li><strong>mustn’t，绝对不可以</strong></li>
</ol>
</li>
<li>你必须再卧床两天。<ol>
<li>You must stay in bed two days again.    Wrong.</li>
<li>again 再一次地<ol>
<li>Try again.  Say it again.</li>
<li>another two days</li>
</ol>
</li>
<li>two days</li>
<li><strong>for + two days</strong>    <strong>for + 时间段，长达</strong></li>
<li><strong>at + 点</strong></li>
<li><strong>on + 天</strong></li>
<li><strong>in + 月，季，年</strong></li>
<li>You must stay in bed for another two days.  Right</li>
<li>我必须在北京再戴两周</li>
<li>我们必须再学两年英语</li>
</ol>
</li>
<li>have a temperature<ol>
<li>have a fever</li>
<li><strong>三单：has</strong><ol>
<li>He has a fever.</li>
<li>Do you have a fever.</li>
<li>Does he have a fever.</li>
<li>I don’t have a fever.</li>
<li>He doesn’t have a fever.</li>
</ol>
</li>
</ol>
</li>
<li>卧床<ol>
<li>stay in bed</li>
<li>remain in bed</li>
</ol>
</li>
<li>他每天可以起床大约两小时<ol>
<li>He every day can get up abour two hours.   Wrong.</li>
<li><strong>谁？干什么？</strong></li>
<li><strong>for +时间段，长达</strong></li>
<li>He can get up for about two hours every day.</li>
<li>every day &amp; each day</li>
<li><strong>every 整体</strong></li>
<li><strong>each 个体</strong></li>
<li>Hi, every one!</li>
<li>Each man has his own name.</li>
</ol>
</li>
<li>You must keep the room warm.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="must">must</span></h4><ol>
<li>疑问：<ol>
<li>我必须清扫屋子么？</li>
<li>Must I clean the room?</li>
</ol>
</li>
<li>否定：<ol>
<li>I mustn’t clean the room.     Wrong.</li>
<li><strong>mustn’t 绝对不可以，禁止</strong></li>
<li>你绝对不可以在这里大吵</li>
<li>You mustn’t make noise here.</li>
<li>你绝对不可以在这吸烟</li>
<li>You mustn’t smoke here.</li>
<li>I <strong>don’t neet to</strong> clean the room.</li>
<li><strong>dont’t neet to… 不必，不需要</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>play v. 完<ol>
<li>play games  玩游戏</li>
<li>play the violin 弹奏，拉琴</li>
<li>play football / basketball 打球，踢球</li>
</ol>
</li>
<li>match 火柴<ol>
<li>matches </li>
</ol>
</li>
<li>talk 谈话<ol>
<li>talk to sb. 与…谈话</li>
<li>Don’t talk to me like that!</li>
<li>Don’t talk to strangers.</li>
</ol>
</li>
<li>library 图书馆<ol>
<li>in the library</li>
</ol>
</li>
<li>drive<ol>
<li>drive the car</li>
</ol>
</li>
<li>so adv. 如此的<ol>
<li>so beautiful / so much</li>
</ol>
</li>
<li>quickly adv. 快的<ol>
<li>He drives so quickly.</li>
</ol>
</li>
<li>lean out of 身体探出<ol>
<li>lean  倾斜，偏向，弯斜</li>
<li>lean out of the window</li>
</ol>
</li>
<li>break v.打破</li>
<li>noise n. 喧闹声<ol>
<li>发出噪音</li>
<li><strong>make the noise</strong></li>
<li><strong>have make take get</strong></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 61</title>
    <url>/2020/06/28/Language/English/New%20Concept/Chapter1/lesson61/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>feel 感觉</li>
<li>look 看起来</li>
<li>must 必须</li>
<li>call 叫、请</li>
<li>doctor  医生</li>
<li>telephone 电话<ol>
<li>call sb.</li>
<li>phone sb.</li>
<li>give sb. a call</li>
<li>give sb. a phone</li>
</ol>
</li>
<li>remember 记得，记住，想起来了<ol>
<li>Do you remember?</li>
<li>oh, yeah, I remember.</li>
</ol>
</li>
<li>mouth 嘴巴</li>
<li>tongue 舌头<ol>
<li>Tongue twister 绕口令</li>
</ol>
</li>
<li>bad 严重的<ol>
<li>a bad cold：严重的感冒</li>
</ol>
</li>
<li>cold 感冒<ol>
<li>a cold day  寒冷的一天</li>
<li>a cold handshake 冷淡的，不热情</li>
<li>the cold color 冷色调</li>
</ol>
</li>
<li>news 消息<ol>
<li>a piece of news</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>in bed （生病卧床）<ol>
<li>He is in bed.</li>
<li>He is in the bed.</li>
<li>in hospital,  in the hospital</li>
</ol>
</li>
<li>What’s the matter with him?<ol>
<li>What’s the matter <strong>with</strong> sb.?</li>
<li>What’s wrong with sb.?</li>
<li>What’s up?</li>
</ol>
</li>
<li>所以他必须在床上待一周<ol>
<li>So he must stay in bed for a week.</li>
<li><strong>for +段时间，表示长达</strong></li>
<li>I have classes for eight hours today.</li>
<li>He must stay in Beijing for ten years.</li>
</ol>
</li>
<li>That’s good news for Jimmy.<ol>
<li>for ， 对于某人来说</li>
<li>English is very easy for him.</li>
<li>It is to dry for her to stay in Beijing.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="感官动词">感官动词</span></h4><ol>
<li>sound</li>
<li>look</li>
<li>smell</li>
<li>feel</li>
<li>taste</li>
</ol>
<h5><span id="感官动词-半系动词">感官动词 - 半系动词</span></h5><ol>
<li>一半实义动词<ol>
<li>do - does, drink - drinks</li>
<li>look - looks , sound - sounds, feel - feelds, smell - smells, taste - tastes</li>
</ol>
</li>
<li>一半系动词<ol>
<li>She is <u>listening</u> to music <strong>carefully</strong>.</li>
<li>I <u>eat</u> my breakfast <strong>quickly</strong>.</li>
<li><strong><u>实义动词=&gt;副词   感官动词=&gt;形容词</u></strong></li>
<li>You <u>look</u> <strong>young</strong>.</li>
<li>It <u>tastes</u> <strong>good</strong>.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>headache 头疼</li>
<li>earache 耳朵疼</li>
<li>toothache 牙疼</li>
<li>stomach ache 胃疼<ol>
<li><strong>ache - 表示疼痛，长时间的疼痛</strong></li>
</ol>
</li>
<li>backache 背疼<ol>
<li>v.  My head aches. 我头疼</li>
<li>have a headache</li>
<li>have a toothache</li>
<li>have a cold</li>
</ol>
</li>
<li>flu 流感</li>
<li>bird flu  禽流感</li>
<li>swine flu 猪流感<ol>
<li>Have flu / have bird flu…</li>
</ol>
</li>
<li>measles 麻疹<ol>
<li>have measles</li>
</ol>
</li>
<li>mumps 腮腺炎<ol>
<li>have mumps</li>
</ol>
</li>
<li>dentist 牙医<ol>
<li>scientist 科学家</li>
<li>tourist 旅行的人</li>
<li>typist 打字员</li>
</ol>
</li>
<li>medicine 药（不可数）</li>
<li>temperature 温度<ol>
<li>have a temperature / fever 发烧</li>
</ol>
</li>
</ol>
<h5><span id="生病amp解决办法">生病&amp;解决办法</span></h5><ol>
<li>He has a headache. What must he do?<ol>
<li>He must <strong>take</strong> an aspirin.</li>
</ol>
</li>
<li>The baby has a temperature. What must we do?<ol>
<li>He must see the doctor.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 59</title>
    <url>/2020/06/28/Language/English/New%20Concept/Chapter1/lesson59/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>envolope 信封</li>
<li>writing paper 信纸<ol>
<li>a piece of writing paper</li>
<li>two pieces of writing paper</li>
</ol>
</li>
<li>shop assistant 售货员</li>
<li>size  尺寸，尺码，大小<ol>
<li>S/M/L</li>
<li>S - small</li>
<li>M - medium </li>
<li>L - large</li>
<li>XS - extra small</li>
<li>XL - extra large</li>
<li>small / medium / large size</li>
<li>size 6 / 7…</li>
</ol>
</li>
<li>Pad  信笺薄</li>
<li>glue 胶水<ol>
<li>a bottle of ~</li>
</ol>
</li>
<li>chalk 粉笔</li>
<li>change 零钱，找给的钱<ol>
<li>small change,   keep the change </li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>买东西时用来询问的句型：<ol>
<li>I want some …</li>
<li>Do you have any … ?</li>
<li>n. + please</li>
</ol>
</li>
<li>一盒粉笔    a box of chalk<ol>
<li>一大盒粉笔：a large box of chalk</li>
<li>一瓶可乐：a bottle of cola</li>
<li>一大瓶可乐：a large bottle of cola</li>
</ol>
</li>
<li>only   adv.  仅仅，只有<ol>
<li>I have two watches.</li>
<li>I <strong>only</strong> have two watches.</li>
<li>I have <strong>only</strong> two watches.</li>
</ol>
</li>
<li>I only have large ones.<ol>
<li>ones - large pads</li>
</ol>
</li>
<li>That’s all, thank you.<ol>
<li>就这些了，谢谢！</li>
<li>That’s all, thank you for your listening.</li>
<li>使用时机<ol>
<li>发言完毕时；</li>
<li>讲课结束时；</li>
<li>购物时…</li>
</ol>
</li>
</ol>
</li>
<li>What else?<ol>
<li>Who else?</li>
<li>Which else?</li>
<li>Where else?</li>
<li>What else do you want?</li>
<li>Who else do you like?</li>
<li>Which else is your favorite?</li>
<li>Where else do you want to go?</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="数词">数词</span></h4><h5><span id="整十">整十</span></h5><p>one, two , three, four , five , six, seven , eight, nine, ten , eleven , twelve</p>
<p>thir<strong>teen</strong>, four<strong>teen</strong> , fif<strong>teen</strong>,  six<strong>teen</strong>, seven<strong>teen</strong>, eigh<strong>teen</strong>, nine<strong>teen</strong></p>
<p>twen<strong>ty</strong> thir<strong>ty</strong>  for<strong>ty</strong>  fif<strong>ty</strong>   fix<strong>ty</strong>  secen<strong>ty</strong> eigh<strong>ty</strong>  nine<strong>ty</strong></p>
<h5><span id="非整十">非整十</span></h5><p>23: twenty - three    36: thirty-six   42:fouth-two   57:fifty-seven</p>
<p>64:sixty-four  78:seventy-eight   85:eight-five   91:ninety-one</p>
<h5><span id="点钟的读法">点钟的读法</span></h5><p>3:10  three ten </p>
<p>10:20 ten twenty</p>
<p>6:15 six fifteen</p>
<p>8:30 eight thirty</p>
<p>4:53 four fifty-three</p>
<p>12:49 tweleve forty-nine</p>
<h5><span id="日期的读法">日期的读法</span></h5><p>第一：first，第二：second，第三：third，第四：forth，第五：fifth，第六：sixth</p>
<p>第七：seventh，第八：eighth，第九：ninth，第十：tenth，第十一：eleventh，第十二：twelfth</p>
<p>第十三：thirteenth  第二十：twentieth  第二十一：twenty-first  第二十二：twenty-second </p>
<p>第二十三：thenty - third  第二十四：twenty-forth  第二十五：twenty-fifth</p>
<p>第三十：thirtieth   第三十一：thirty-first  第三十二：thirty-second  第三十三：thirth-third</p>
<p>8月2日：Aug.2nd.    </p>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>Do you have any …?<ol>
<li>+可数名词复数<ol>
<li>friends / envelopes / bananas…</li>
</ol>
</li>
<li>+不可数名词<ol>
<li>coffee /  tea / time…</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 57</title>
    <url>/2020/06/27/Language/English/New%20Concept/Chapter1/lesson57/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>o’clock 点钟，整点<ol>
<li>8点整 eight o’clock</li>
</ol>
</li>
<li>shop 商店（规模较小，出售同一类商品）<ol>
<li>department store （美） store （英） 百货商店</li>
</ol>
</li>
<li>moment 片刻，瞬间<ol>
<li>at the moment 此刻</li>
<li>She is learning English at the moment.</li>
<li>Wait a moment = Wait a minute.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>It is …<ol>
<li>天气</li>
<li>点钟</li>
<li>电话</li>
<li>示例<ol>
<li>春天天气很糟糕。It is terrible in spring.</li>
<li>现在是八点整。It is eight o’clock now.</li>
<li>是我，Venus。 It’s me, Venus.</li>
</ol>
</li>
</ol>
</li>
<li>The children go to school <strong>by car</strong> every day.<ol>
<li>on foot </li>
<li>by bike</li>
<li>by bus</li>
<li>by car</li>
<li>By train</li>
<li>by air</li>
<li>你是怎么去学校的？</li>
<li>How do you go to school?</li>
</ol>
</li>
<li>But today, they <u>are going to</u> school on foot.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="一般现在时-amp-现在进行时">一般现在时 &amp; 现在进行时</span></h4><ol>
<li>使用情况不同<ol>
<li>一般现在：习惯的状态，经常的动作，真理</li>
<li>现在进行：此时此刻正在做，一段时间内一直</li>
</ol>
</li>
<li>结构不同<ol>
<li>一般现在：主语 + is / am / are ，主语+v</li>
<li>现在进行：主语 + is / am / are + doing</li>
</ol>
</li>
<li>时间状语不同<ol>
<li>一般现在：every … always, usually, often , sometimes…</li>
<li>现在进行：now, at the moment…</li>
</ol>
</li>
<li>示例<ol>
<li>我通常12点吃饭，但今天都这会了，2点才吃呢</li>
<li>I usually have lunch at 12.AM. But I am having lunch now at 2.PM</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>What’s the time?<ol>
<li>What’s time is it?<br>2.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 55</title>
    <url>/2020/06/26/Language/English/New%20Concept/Chapter1/lesson55/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>live v. 住，生活<ol>
<li>长期居住</li>
<li>live + at   小</li>
<li>live + in   大</li>
<li>She lives at 23 Haidian Street.</li>
<li>I live in Beijing.</li>
<li>live - evil adj.  邪恶的</li>
</ol>
</li>
<li>stay v. 待在，停留<ol>
<li>短暂停留</li>
<li>stay + at 小</li>
<li>stay + in 大</li>
<li>stay at home</li>
<li>stay at the hotel</li>
<li>stay in New York</li>
</ol>
</li>
<li>arrive 到达<ol>
<li>arrive + at 小</li>
<li>arrive + in  大</li>
<li>He arrives at the classroom early.</li>
<li>I arrive in Shanghai late.</li>
</ol>
</li>
<li>home <ol>
<li>n. 家</li>
<li>adv. 在家，到家</li>
</ol>
</li>
<li>housework 家务<ol>
<li>homework 家庭作业</li>
<li>不可数</li>
<li>do some housework / homework</li>
<li>She never does the housework.</li>
</ol>
</li>
<li>lunch n. 午饭<ol>
<li>breakfast 早饭</li>
<li>dinner / supper 晚饭</li>
<li>eat / have breakfast / lunch / dinner / supper</li>
</ol>
</li>
<li>afternoon 下午<ol>
<li>after 之后</li>
<li>noon 正午</li>
<li>morning 早晨</li>
<li>evening 傍晚</li>
<li>night 夜晚</li>
<li>in the morning  / afternoon / evening</li>
<li>at night</li>
<li>an evening dress 晚礼服</li>
</ol>
</li>
<li>usually  adv. 通常<ol>
<li>usual adj. 平常的</li>
</ol>
</li>
<li>together adv. 一起<ol>
<li>他们通常一起喝咖啡。</li>
<li>They usually drink coffee together.</li>
<li>咱一块干吧！</li>
<li>Let’s do it together.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>the Sawyer family<ol>
<li>the Sawyers </li>
<li>姓…一家人</li>
<li>the  + 姓氏 + family /  the 姓氏+s</li>
<li>the Lee family</li>
<li>the Lees</li>
<li>the Smith family</li>
<li>the Smiths</li>
</ol>
</li>
<li>… live at 87 King Street<ol>
<li>海淀路9号：9 Haidian Road</li>
<li>海淀区海淀路9号：9 Haidian Road, Haidain District</li>
<li>district  行政区域</li>
<li>Chaoyang District</li>
<li>北京市海淀区海淀路9号：9 Haidian Roat, Haidian District, Beijing.</li>
<li>小 - 大</li>
<li>北京市朝阳区幸福街4号</li>
<li>4 Xingfu Stree, Chaoyang District, Beijing.</li>
</ol>
</li>
<li>动词短语<ol>
<li>go to work 去上班</li>
<li>go to school 去上学</li>
<li>take sb. to … 送…去</li>
<li>stay at home 待在家里</li>
<li>see her friends 去见朋友</li>
<li>come home from work 下班回家</li>
<li>come home from school 放学回家</li>
<li>go to bed 去睡觉</li>
<li>read newspaper 读报纸</li>
<li>watch television 看电视</li>
<li><strong>谁？干什么？</strong></li>
<li>我送妹妹去火车站。</li>
<li>I take my sister to the train station.</li>
<li>他每天都上班</li>
<li>He goes to wrod every day.</li>
<li>她经常下班回家很早</li>
<li>She often comes home from work early.</li>
<li>我通常晚上11点睡觉</li>
<li>I usually go to bed at 11:00 at night.</li>
<li>我老爸有时早上看报纸。</li>
<li>My father sometimes reads newspapers in the morning.</li>
<li>我老妈周一都呆在家里</li>
<li>My mother usually stays at home on Monday.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>home<ol>
<li>go to school</li>
<li>go to work</li>
<li>go to beg</li>
<li>go to Shanghai</li>
<li>回家<ol>
<li>go home</li>
<li>arrive home</li>
<li>come home</li>
<li><strong>没啥没to?</strong></li>
<li>adv. - v.</li>
<li>home - n.家  adv. 在家，到家</li>
<li>这是我的家</li>
<li>This is my home.</li>
</ol>
</li>
<li>表示地点的副词：<ol>
<li><strong>home / there / here / upstairs / downstairs…</strong></li>
<li>stay here</li>
<li>go there</li>
<li>come upstairs</li>
<li>go downstairs</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><strong>名词的复数</strong><ol>
<li><strong>+s</strong><ol>
<li><strong>a book - book</strong></li>
<li><strong>a cat - cats</strong></li>
<li><strong>a bottle - bottles</strong></li>
</ol>
</li>
<li><strong>辅音 + y + ies</strong><ol>
<li><strong>a lady - ladies</strong></li>
<li><strong>a baby - a babies</strong></li>
</ol>
</li>
<li><strong>s / sh / ch / x + es</strong><ol>
<li><strong>a watch - watches</strong></li>
<li><strong>a bus - buses</strong></li>
<li><strong>a dish - dished</strong></li>
</ol>
</li>
<li><strong>o + es</strong><ol>
<li><strong>a potato - potatoes</strong></li>
<li><strong>a hero - heroes</strong></li>
</ol>
</li>
</ol>
</li>
<li><strong>动词的第三人称单数</strong><ol>
<li><strong>+s</strong><ol>
<li><strong>come - comes</strong></li>
<li><strong>dust - dusts</strong></li>
<li><strong>make - makes</strong></li>
</ol>
</li>
<li><strong>辅音+ y + ies</strong><ol>
<li><strong>study - studies</strong></li>
<li><strong>try - tries</strong></li>
</ol>
</li>
<li><strong>s / sh / ch / x + es</strong><ol>
<li><strong>watch - watches</strong></li>
<li><strong>pass - passes</strong></li>
<li><strong>wish - wishes</strong></li>
</ol>
</li>
<li><strong>o + es</strong><ol>
<li><strong>go - goes</strong></li>
<li><strong>do - does</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 53</title>
    <url>/2020/06/26/Language/English/New%20Concept/Chapter1/lesson53/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>mild 温和的，温暖的<ol>
<li>It is mild in fall. 秋天天气很温和。</li>
<li>mild food 清淡的食物</li>
<li>spicy food 辛辣的食物</li>
<li>hot food 辣的食物</li>
</ol>
</li>
<li>always 总是，一直，永远</li>
<li>north 北方</li>
<li>east 东方</li>
<li>west 西方</li>
<li>south 南方<ol>
<li>in the north …</li>
<li>in the north of …</li>
</ol>
</li>
<li>news  新闻、消息<ol>
<li>East, west, home is best.</li>
</ol>
</li>
<li>wet 潮湿的<ol>
<li>water - wash - wine - wave - well - weep - woman</li>
</ol>
</li>
<li>season 季节<ol>
<li>There are four seasons in a year.</li>
<li>There are spring, summer, autumn / fall and winter.</li>
</ol>
</li>
<li>best 最  adv. 最好的 adj.<ol>
<li>Green is my favorite color.</li>
<li>I like green best.（行前动后）</li>
<li>Beijing is my favorite city.</li>
<li>I like Beijing best.</li>
<li>Spring is his favorite seasion.</li>
<li>He likes spring best.</li>
<li>Chinese is her favorite langue.</li>
<li>She likes Chinese best.</li>
</ol>
</li>
<li>night 夜晚，深夜<ol>
<li>evening 傍晚</li>
</ol>
</li>
<li>rise 升起</li>
<li>set 落下<ol>
<li>太阳每天6点升起，7点落下</li>
<li>The sun rises at 6:00 in the morning and sets at 7:00 in the evennig.</li>
</ol>
</li>
<li>early 早的 adj.  adv.</li>
<li>late 晚的 adj. adv.<ol>
<li>I am late today.  adj.</li>
<li>I come late today.</li>
</ol>
</li>
<li>interesting 有趣的</li>
<li>subject 话题、科目<ol>
<li>What’s the subject we are going to talk about today?</li>
<li>We have nine subjects this term.</li>
</ol>
</li>
<li>conversation 谈话</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>An interestion climate</li>
<li>What’s the climate / weather like in … + （月份、季节、地点）？</li>
<li>描述天气的句型结构：<ol>
<li>It is … in …</li>
<li>春天天气很糟糕。  It is terrible in spring.</li>
<li>西边气候很干燥。 It is dry in the west.</li>
<li>厦门天气很宜人。It is pleasant in Xiamen.</li>
</ol>
</li>
<li>Which seasons do you like best?<ol>
<li>Which is your favorite season?  不等价</li>
<li>Which are your favorite seasons. 等价</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>频率副词：<ol>
<li>never</li>
<li>seldom</li>
<li>sometimes</li>
<li>often</li>
<li>usually</li>
<li>always</li>
</ol>
</li>
<li>频率副词的位置：<ol>
<li>情、系后，实义前<ol>
<li>She is seldom ill.</li>
<li>He can never sleep.</li>
<li>He always loves her.</li>
<li>他老是迟到。</li>
<li>He is always late.</li>
<li>他经常给女孩写情书。</li>
<li>He often writes love letters to girls.</li>
</ol>
</li>
<li>表达强调时，可调整位置。<ol>
<li>我永远也记不住</li>
<li>I can never remember.</li>
<li>I never can remember.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>Australia - Australian 澳大利亚，澳大利亚人</li>
<li>Austria - Austrain</li>
<li>Canada - Canadian</li>
<li>China - Chinese </li>
<li>Finland - Finnish</li>
<li>India - Indian</li>
<li>Japan - Japanese</li>
<li>Nigeria - Nigerian</li>
<li>Turkey - Turkish</li>
<li>Korea - Korean</li>
<li>Poland - Polish</li>
<li>Thai - Thailand</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 51</title>
    <url>/2020/06/25/Language/English/New%20Concept/Chapter1/lesson51/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>Greece 希腊</li>
<li>Greek  希腊人</li>
<li>Athens 雅典</li>
<li>climate  气候<ol>
<li>宜人的气候：a pleasant climate</li>
</ol>
</li>
<li>country 国家<ol>
<li>in my/your country</li>
</ol>
</li>
<li>pleasant   adj. 宜人的<ol>
<li>The weather is very pleasant.</li>
<li>令人开心的、愉快的</li>
<li>a pleasant dream 美梦</li>
<li>a pleasant manner 随和的态度</li>
</ol>
</li>
<li>weather 天气<ol>
<li>How is the weather today?</li>
<li>The weather is fine / pleasant / terrible.</li>
</ol>
</li>
<li>spring 春季</li>
<li>summer 夏天</li>
<li>autumn / fall 秋天</li>
<li>winter 冬天</li>
<li>春节，the Spring Festival</li>
<li>windy adj. 有风的<ol>
<li>It’s windy today.</li>
</ol>
</li>
<li>warm adj. 温暖的<ol>
<li>It’s warm today</li>
</ol>
</li>
<li>hot 炎热的</li>
<li>cold 寒冷的</li>
<li>cool 凉爽的</li>
<li>rain v.下雨<ol>
<li>It is often rain here</li>
<li>It often rain here.</li>
<li>It often rains here.     对的</li>
</ol>
</li>
<li>snow 下雪<ol>
<li>It often snows here.</li>
</ol>
</li>
<li>sometimes adv. 有时</li>
<li>Jan. 1月</li>
<li>Feb. 2月</li>
<li>Mar.  3月</li>
<li>Apr. 4月</li>
<li>May. 5月</li>
<li>June. 6月</li>
<li>July. 7月</li>
<li>Aug. 8月</li>
<li>Sept.  9月</li>
<li>Otc. 10月</li>
<li>Nov. 11月</li>
<li>Dec. 12月</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>你来自哪里？<ol>
<li>Where do you come from?</li>
<li>不能用 are </li>
<li>come v.</li>
<li>from  prep.</li>
<li>do  -   动词</li>
<li>are   -  非动词</li>
<li>回答：I come from …</li>
<li>Where are you from?  I am from…</li>
</ol>
</li>
<li>What’s the climate like?<ol>
<li>like   像</li>
<li>例句：What’s her boyfriend like?</li>
<li>How’s the cliamte?</li>
<li>How’s the weather?</li>
<li>How’s her boyfriend?</li>
<li><strong>What’s sth. / sb. like ?  &lt;=&gt;  How’s sth. / sb. ?</strong></li>
<li>What’s the climate like <strong>in … + 国家、城市、季节、月份？</strong> </li>
</ol>
</li>
<li>三月经常是风天<ol>
<li>It’s often windy in March.</li>
<li>主语~</li>
<li>介词~</li>
<li><strong>It’s + 天气形容词 + in _.</strong></li>
<li>练习<ol>
<li>四月和五月经常很暖和。</li>
<li>It’s often warm in April and May.</li>
<li>六七八月经常狠炎热。</li>
<li>It’s often hot in June, July and August.</li>
<li>四月和五月有时会下雨。</li>
<li><strong>rain - rainy    snow - snowy     v. - adj.</strong></li>
<li>It’s sometimes rainy in April and May.</li>
<li>It sometimes rains in April and May.</li>
</ol>
</li>
<li><strong>It + 天气动词 + in _.</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般现在时态<ol>
<li>经常的状态：主语 + is / am / are.</li>
<li>习惯的动作：主语 + v.</li>
<li>真理</li>
<li>示例<ol>
<li>这里冬天经常是雪天</li>
<li>It’s often snowy in winter here.</li>
<li>这里冬天经常下雪</li>
<li>It often snows in winter here.</li>
<li>这工作很简单</li>
<li>The work is easy.</li>
<li>他在北京工作</li>
<li>He works at Beijing.</li>
</ol>
</li>
</ol>
</li>
<li>介词<ol>
<li>可翻译出意思的介词<ol>
<li>on </li>
<li>behind</li>
<li>under</li>
</ol>
</li>
<li>翻译为汉语时不需要， 介词 + 时间</li>
<li>示例<ol>
<li>冬天非常冷</li>
<li>It’s cold in winter.</li>
</ol>
</li>
<li><strong>at / on / in + 时间</strong><ol>
<li><strong>at + 点</strong></li>
<li><strong>on + 天</strong></li>
<li><strong>in + 月、季、年</strong></li>
</ol>
</li>
<li>示例<ol>
<li>我经常8点起床</li>
<li>I often get up at 8:00.</li>
<li>他周一很忙</li>
<li>He is busy on Monday.</li>
<li>他们计划5月4号回来</li>
<li>They are going to come back on May 4th.</li>
<li>三月很暖和</li>
<li>It’s very warm in March.</li>
<li>夏天经常是雨天</li>
<li>It’s often rainy in summer.</li>
<li>我打算2017年去旅行</li>
<li>I am going to travel in 2017.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>the U.S  美国</li>
<li>the United States Of America</li>
<li>American 美国人</li>
<li>Brazil 巴西</li>
<li>Brazilian 巴西人</li>
<li>Holland 荷兰</li>
<li>Dutch 荷兰人</li>
<li>England 英国</li>
<li>English 英国人</li>
<li>France 法国</li>
<li>French 法国人</li>
<li>Germany 德国</li>
<li>German 德国人</li>
<li>Italy 意大利</li>
<li>Italian 意大利人</li>
<li>Norway 挪威</li>
<li>Norwegian 挪威人</li>
<li>Russia 俄罗斯</li>
<li>Russian  俄罗斯人</li>
<li>Spain 西班牙</li>
<li>Spanish 西班牙人</li>
<li>Sweden 瑞典</li>
<li>Swedish 瑞典人</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 49</title>
    <url>/2020/06/23/Language/English/New%20Concept/Chapter1/lesson49/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>butcher 卖肉的，屠夫<ol>
<li><strong>at the</strong> butcher’s： 在肉店</li>
<li><strong>at the</strong> doctor’s：在诊所</li>
<li><strong>at the</strong> hairdresser’s：在理发店</li>
<li><strong>at the</strong> baker’s：在面包店</li>
</ol>
</li>
<li>meat  肉，不可数名词<ol>
<li>a pound of meat</li>
</ol>
</li>
<li>beef 牛肉</li>
<li>lamb 羔羊肉</li>
<li>mutton 羊肉</li>
<li>steak 牛排</li>
<li>mince 肉馅</li>
<li>chicken 鸡肉</li>
<li>pork 猪肉<ol>
<li>a pound of …</li>
</ol>
</li>
<li>husband 丈夫</li>
<li>tell 告诉<ol>
<li>tell sb. sth. 告诉某人某件事</li>
</ol>
</li>
<li>truth 实情，事实</li>
<li>true adj. 真实的</li>
<li>either 也，否定句</li>
<li>too  也，陈述句，疑问句<ol>
<li>I don’t know either.</li>
<li>Do you love English, too?</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Do you want any meat …?<ol>
<li>Are you …?<ol>
<li>Are you + 非动词？</li>
<li>第三人称  Is she / he / it …?</li>
</ol>
</li>
<li>Do you …?<ol>
<li>Do you + 动词？</li>
<li>第三人称  Does she / he / it …?</li>
</ol>
</li>
<li>先看词性：动词 or 非动词<ol>
<li>Are you …?</li>
<li>Is she / he / it…?</li>
</ol>
</li>
<li>再看人称：三单 or 非三单（第三人称单数）<ol>
<li>Do you …?</li>
<li>Does she /he / it…?</li>
</ol>
</li>
</ol>
</li>
<li>Yes, please.<ol>
<li>No, thank you.</li>
</ol>
</li>
<li>But my husband doesn’t.<ol>
<li>isn’t, aren’t, don’t &amp; doesn’t</li>
<li>isn’t + 非动词， aren’t + 非动词，don’t + 动词，doesn’t + 动词</li>
<li>先看词性：动词 or 非动词   再看人称：三单 or 非三单</li>
</ol>
</li>
<li>To tell you the truth,…</li>
</ol>
<blockquote>
<p>语法讲解</p>
</blockquote>
<p>一般现在时态：</p>
<ol>
<li>何时用？<ol>
<li>经常的状态</li>
<li>习惯的动作</li>
<li>真理</li>
</ol>
</li>
<li>结构？<ol>
<li>经常的状态；主语 + is / am / are</li>
<li>习惯的动作；主语 + v.</li>
<li>真理。主语 + is / am / are， 主语 + v.</li>
<li>举例<ol>
<li>They are very bad.</li>
<li>They often cheat in the exams.</li>
<li>The earth is round.</li>
<li>The sun rises in the east.</li>
</ol>
</li>
</ol>
</li>
<li>动词？<ol>
<li>主语 + v.</li>
<li><strong>主语为非三单 + 动词原形</strong></li>
<li><strong>主语为三单 + 动词s/es</strong><ol>
<li><strong>He loves</strong> his girlfriend very much.</li>
<li>Jim and Lily <strong>walk</strong> to school every day.</li>
<li>They <strong>drink</strong> beer every night.</li>
<li><strong>My dog watches</strong> TV at night.</li>
<li>She <strong>goes</strong> to school on foot.</li>
</ol>
</li>
</ol>
</li>
<li>变疑问句？<ol>
<li>They drink beer every night.</li>
<li>He loves his grilfriend very much.</li>
<li>先看词性，再看人称</li>
</ol>
</li>
<li>否定句？<ol>
<li>They drink beer every night.</li>
<li>They don’t drink beer every night.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>tomato 西红柿</li>
<li>potato 土豆</li>
<li>cabbage 卷心菜</li>
<li>lettuce 莴苣</li>
<li>pea 豌豆</li>
<li>bean 豆角，豆子</li>
<li>pear 梨</li>
<li>grape 葡萄</li>
<li>peach 桃子</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 47</title>
    <url>/2020/06/23/Language/English/New%20Concept/Chapter1/lesson47/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>like v. 喜欢，想要<ol>
<li>I like football.  我喜欢足球</li>
<li>I like football very much.</li>
<li>I like playing football. 我喜欢踢足球</li>
<li>I like going shopping. 我喜欢购物</li>
<li>I like swimming.</li>
</ol>
</li>
<li>want v. 想</li>
<li>think 考虑，认为<ol>
<li>I want a new car.</li>
<li>I want a new car very much.</li>
<li>I want <strong>to buy</strong> a new car.</li>
<li>I want <strong>to go</strong> shopping.</li>
<li>I want <strong>to swim</strong>.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Do you like coffee?<ol>
<li><strong>Do you like books</strong>?</li>
</ol>
</li>
<li>Do you wan any sugar?<ol>
<li>Yes, please.</li>
<li>Do you want any milk?</li>
<li>No, thank you.</li>
</ol>
</li>
<li>I don’t like milk <strong>in</strong> my coffee.<ol>
<li>I don’t like English in Chinese.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li><p>Are they + 形容词、名词、介词…</p>
<ol>
<li>Are they happy?</li>
<li>Are they students?</li>
<li>Are they on the subway?</li>
</ol>
</li>
<li><p>一般疑问句：</p>
<ol>
<li>be +形容词、名词、介词…</li>
<li>Do + 动词<ol>
<li>Do you speak English？</li>
<li>Do you like coffee?</li>
<li>Do you want any sugar?</li>
<li>Do you often eat breakfast.</li>
</ol>
</li>
<li>现在进行时态：<ol>
<li>主语 + is / am / are + doing</li>
</ol>
</li>
<li>动词否定<ol>
<li>You are eating breakfast.</li>
<li>Are you eating breakfast?</li>
</ol>
</li>
</ol>
</li>
<li>否定句<ol>
<li>They are not + 形容词、名词、介词…</li>
<li>be + not + 形容词、名词、介词…</li>
<li>动词否定<ol>
<li>do not + 动词</li>
</ol>
</li>
<li>I don’t speak English.</li>
<li>You don’t often eat breakfast.</li>
</ol>
</li>
<li>动词<ol>
<li>疑问句：<ol>
<li>Do + 动词</li>
</ol>
</li>
<li>否定句<ol>
<li>do not + 动词</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>fresh adj. 新鲜的<ol>
<li>the fresh air</li>
</ol>
</li>
<li>egg n. 鸡蛋  可数名词</li>
<li>butter 黄油 不可数</li>
<li>pure adj. 纯净的<ol>
<li>the pure water</li>
</ol>
</li>
<li>honey n. 蜂蜜</li>
<li>ripe adj. 成熟的<ol>
<li>mature 成熟的，特之人</li>
</ol>
</li>
<li>banana 香蕉</li>
<li>jam 果酱<ol>
<li>traffic jam 交通堵塞</li>
</ol>
</li>
<li>sweet adj. 甜的<ol>
<li>her sweet voice</li>
</ol>
</li>
<li>orange 橙子</li>
<li>Scotch Whisky </li>
<li>choice  adj. 上等的，精选的<ol>
<li>some choice apples</li>
<li>n. 选择</li>
<li>He can make a wise choice.</li>
</ol>
</li>
<li>apple n. 苹果</li>
<li>wine n. 果酒</li>
<li>beer n. 啤酒</li>
<li>blackboard 黑板<ol>
<li>whiteboard 白板</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 45</title>
    <url>/2020/06/23/Language/English/New%20Concept/Chapter1/lesson45/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>can 能够，可以</li>
<li>boss 老板</li>
<li>manager 经理</li>
<li>minute 分钟，一会儿<ol>
<li>Wait a minute 等一会，等一下</li>
</ol>
</li>
<li>hour 小时</li>
<li>second 秒钟</li>
<li>ask 请求，问<ol>
<li>Can I ask you a question?</li>
<li>aks the way 问路</li>
</ol>
</li>
<li>handwriting 书写<ol>
<li>他的字写得很好</li>
<li>His handwriting is very nice.</li>
</ol>
</li>
<li>terrible 糟糕的</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Can you come here a minute please?<ol>
<li>a minute 一会，一下</li>
</ol>
</li>
<li>next door 在隔壁，与…相邻<ol>
<li>She is next door. 她在隔壁。</li>
<li>She is next door to us. 她与我们相邻。</li>
<li>There is a school next door to the park. 公园的隔壁有一所学校</li>
</ol>
</li>
<li>next-door adj. 隔壁的<ol>
<li>The next-door girl is very beautiful. 隔壁的女孩很漂亮</li>
<li>The old man next-door is going to leave. 隔壁的老人就要离开了。</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="情态动词">情态动词</span></h4><ul>
<li>分类<ul>
<li>连系动词</li>
<li>情态动词</li>
<li>实义动词</li>
<li>助动词</li>
</ul>
</li>
</ul>
<ol>
<li>概念：表示情感，态度<ol>
<li>You must go out!</li>
<li>Can you please stand up?</li>
</ol>
</li>
<li>包括：can, must, may…</li>
<li>用法： + 动词，且原型</li>
<li>没有人称和数的变化<ol>
<li>She is …   I am …</li>
<li>She can… I can …</li>
</ol>
</li>
<li>疑问句：提前</li>
<li>否定句：<ol>
<li>can - can’t , cannot（不可用 can not）</li>
<li>must - mustn’t 禁止</li>
<li>may - may not </li>
</ol>
</li>
<li>示例<ol>
<li>Tom can swim well.<ol>
<li>Can Tom swim well?</li>
</ol>
</li>
<li>The students must finish their homework tonight.<ol>
<li>The student don’t neet to finish their homework tonight.</li>
</ol>
</li>
<li>Can I have a cup of tea? （改写）<ol>
<li>May I have a cup of tea?</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>lift 举起<ol>
<li>Can you lift this heavy case?</li>
<li>电梯（英式直梯，美式：elevator）</li>
<li>There are thirteen people in this lift, it’s overweight.</li>
</ol>
</li>
<li>cake 蛋糕  可数名词</li>
<li>biscuit 饼干，可数名词</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 43</title>
    <url>/2020/06/22/Language/English/New%20Concept/Chapter1/lesson43/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>of course 当然</li>
<li>certainly 一定 更加正式一些</li>
<li>Of course not. 当然没有</li>
<li>kettle 水壶</li>
<li>behind prep. 在…后面</li>
<li>teapot n. 茶壶<ol>
<li>hot pot, 火锅</li>
</ol>
</li>
<li>now 现在，此刻<ol>
<li>What are you doing now?</li>
<li>I am learning English.</li>
<li>What are you going to do now?</li>
<li>I am going to swim.</li>
</ol>
</li>
<li>find v. 找到<ol>
<li><strong>Look</strong>! Can you <strong>see</strong> it?</li>
<li><strong>Listen</strong>! Can you <strong>hear</strong> it?</li>
<li><strong>Look for</strong> it! Can you <strong>find</strong> it?</li>
</ol>
</li>
<li>boil v. 沸腾，开<ol>
<li>The water is boiling.</li>
<li>boiled，已经烧开的</li>
<li>boiled water 开水</li>
<li>boil v. 煮  boil an egg</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Hurry up! 快点<ol>
<li>Be quick!</li>
</ol>
</li>
<li>make the tea 沏茶<ol>
<li>make sone coffee 冲咖啡</li>
<li>make the bed 整理床铺</li>
<li>What make is it? 这个什么牌子的？</li>
</ol>
</li>
<li>It’s over there. 就在那儿。<ol>
<li>right here  就在这儿</li>
</ol>
</li>
<li>Can you see it?<ol>
<li>Can you find it?</li>
<li>look - see</li>
<li>listen - hear</li>
<li>Look for - find</li>
</ol>
</li>
<li>There it is.<ol>
<li>Here they are.</li>
<li>Here I am.</li>
<li>There he is.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="可以吗">可以吗？</span></h4><p>Can you …?   Are you …?</p>
<p>Can she …?   Is she …?</p>
<p>Can he …?   Is he …?</p>
<p>Can we …?  Are we …?</p>
<p>Can they …?  Are they …?</p>
<p><strong>can可以用于任何人称</strong></p>
<p>你可以帮我么？</p>
<p>Can you help me?</p>
<p>你可以做这事么？</p>
<p>Can you do it?</p>
<p>我们可以一起游泳么？</p>
<p>Can we swim together?</p>
<p><strong>can + 动词，必须是原型</strong></p>
<p>Can you make the tea?</p>
<p>Can you see it?</p>
<p>Can you find them?</p>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>只有可数名词才有复数形式</li>
<li>Are there any …?<ol>
<li>Are there any + 复数。</li>
</ol>
</li>
<li>Is there any…?<ol>
<li>Is there any + 不可数。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 41</title>
    <url>/2020/06/22/Language/English/New%20Concept/Chapter1/lesson41/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>cheese 奶酪<ol>
<li>Say cheese!</li>
</ol>
</li>
<li>bread 面包</li>
<li>soap 肥皂</li>
<li>soup 汤</li>
<li>chocolate 巧克力</li>
<li>sugar 糖（白砂糖）</li>
<li>candy 糖果</li>
<li>sugar coat.<ol>
<li>Can you sugar coat a little?  你可以稍微委婉一点么？</li>
</ol>
</li>
<li>coffee 咖啡</li>
<li>tea 茶</li>
<li>tobacco 烟草</li>
<li>cigarette 香烟</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Not very.  不是非常…<ol>
<li>It is not very heavy.</li>
</ol>
</li>
<li>What’s in it?<ol>
<li>What’s <strong>on / under / over / behind</strong> it ?</li>
</ol>
</li>
<li>量词：<ol>
<li>a piece of … 一片，一块的…</li>
<li>a loat of … 一个，一条的…</li>
<li>a bar of… 一条，一块的…</li>
<li>a bottle of…   一瓶的…</li>
<li>a pound of…  一磅的</li>
<li>a tin of…  一罐的</li>
<li>a cup of… 一杯…</li>
<li>a box of…   一箱…</li>
<li>a spoon of…  一勺…</li>
</ol>
</li>
<li>pound:  <ol>
<li>价格<ol>
<li>英镑<ol>
<li>one pound / two pounds</li>
</ol>
</li>
<li>便士<ol>
<li>one penny / two pence</li>
</ol>
</li>
<li>dollar 美元<ol>
<li>one dollar / two dollars</li>
</ol>
</li>
<li>cent 分<ol>
<li>one cent / two cents</li>
</ol>
</li>
</ol>
</li>
<li>重量<ol>
<li>a pound 一磅<ol>
<li>a pound of cheese.</li>
</ol>
</li>
<li>half a pound of  半磅</li>
<li>a quarter of a pound of … 四分之一磅</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="名词">名词</span></h4><ol>
<li>冠词 + 名词</li>
<li>名词所有格： ‘s / of</li>
<li>单&amp;复数</li>
<li>可数&amp;不可数</li>
<li>不可数名词<ol>
<li>概念：不可以数的，不可以计算的名词；</li>
<li>包括<ol>
<li>液体状的东西；water / tea / coffee / milk / beer….</li>
<li>物质名词：soap / bread / chocolate / rice / tobacco …</li>
<li>抽象名词：love / friendship / work / homework …</li>
</ol>
</li>
<li>用法：<ol>
<li>前面不可以加one，two，three…</li>
<li>前面不可以加 a / an</li>
<li>后面不可以加s，永远是单数</li>
</ol>
</li>
<li>与量词的搭配：<ol>
<li>a piece of bread 一片面包</li>
<li>a loaf of bread 一个面包</li>
<li>a bar of soat 一条肥皂</li>
<li>a bottle of cola</li>
<li>a pound of …</li>
<li>a tin of cola</li>
<li>a cup of coffee</li>
<li>a box of tea</li>
<li>a spoon of sugar</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><p>bird 鸟</p>
</li>
<li><p>any 一些</p>
</li>
<li><p>some 一些</p>
<ol>
<li><p>some / any + 复数名词或不可数名词时，”一些”，some用在肯定句中，any用在否定、疑问句中</p>
<ol>
<li>some students / some water / any cups / any money</li>
<li>Is there a + 可数名词单数?</li>
<li>Is there any + 不可数名词?</li>
</ol>
</li>
<li><p>但在表请求，建议的疑问句中用some。</p>
<ol>
<li>Could you lend me some money?</li>
</ol>
</li>
<li><p>some / any + 单数名词，some翻译为 “某一”，any 翻译为“任一”</p>
<ol>
<li>Some day, he can be some one.</li>
<li>You can buy it in any supermarket.</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 39</title>
    <url>/2020/06/22/Language/English/New%20Concept/Chapter1/lesson39/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>front n. 前面</li>
<li>in front of 在…之前<ol>
<li>in the front of </li>
<li>The man is in front of the car.</li>
<li>The man is in the front of the car.</li>
</ol>
</li>
<li>careful 小心的，小心的</li>
<li>vase 花瓶<ol>
<li>vases 复数</li>
</ol>
</li>
<li>drop v. 掉下</li>
<li>flower 花<ol>
<li>flowers 复数</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>What are you going to <strong>do with</strong> …?<ol>
<li>你打算怎么处理…？</li>
</ol>
</li>
<li>Give it to me.<ol>
<li>祈使句<ol>
<li>没有主语</li>
<li>动词打头</li>
<li>Be careful!</li>
<li>Be + adj. / prep. …</li>
</ol>
</li>
<li>Give it to me.<ol>
<li>You give the vase to me.</li>
<li>双宾语</li>
<li>give / show / take / teach  … 可以接双宾语</li>
<li>give sth. to sb. = give sb. sth.</li>
<li>I give some money to him. I give him some money.</li>
<li>I give a flower to my mother.  I give my mother a flower.</li>
<li>我给了他们一些新书。<ol>
<li>I give some new boos to them.</li>
<li>I give them some new books.</li>
</ol>
</li>
<li>我给了她一只猫<ol>
<li>I give a cat to her.</li>
<li>I give her a cat.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>There we are.<ol>
<li>瞧，看~</li>
<li>就这么着吧~</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="说不">说不</span></h4><ol>
<li>构成： is not / am not / are not<ol>
<li>This is my name. This is not my name.</li>
<li>She is pretty.</li>
<li>You are busy.</li>
<li>I am in the front.</li>
</ol>
</li>
<li>Don’t (Do not) + v.<ol>
<li>Do it!  Don’t do it!</li>
<li>Come in!   Don’t come in!</li>
<li>Don’t litter !  Don’t fall !  Don’t enter !</li>
<li>Don’t drop it!</li>
<li>Don’t do that!</li>
<li>Don’t put it there!</li>
<li>Don’t work.</li>
<li>Don’t swim.</li>
<li>Don’t drive.</li>
<li>Don’t eat.</li>
<li>Don’t cook.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>show v. 给…看</li>
<li>send v. 送给</li>
<li>take  v. 带给</li>
<li>I’m going to send my grandma a letter.</li>
<li>I’m going to show my friend my new dress.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 37</title>
    <url>/2020/06/21/Language/English/New%20Concept/Chapter1/lesson37/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>work 工作<ol>
<li>I workin NO School. v.</li>
</ol>
</li>
<li>hard 努力地  adv(副词)<ol>
<li>副词的功能：用来修饰 adj / v / adv<ol>
<li>修饰adj<ol>
<li>I am tired.  I am <strong>very</strong> tired. I am <strong>so</strong> tired. I am <strong>too</strong> tired. I am <strong>awfully</strong> tired.</li>
</ol>
</li>
<li>修饰 v<ol>
<li>I love you. I love you <strong>very much</strong>. I love you <strong>awfully</strong>.</li>
</ol>
</li>
</ol>
</li>
<li>副词的位置：通常情况，行前动后</li>
<li>例子<ol>
<li>I swim well.</li>
<li>I know him well.</li>
</ol>
</li>
<li>hard 词性讨论：<ol>
<li>努力地  adv</li>
<li>勤奋的，艰苦的  adj</li>
</ol>
</li>
<li>hard word： 艰苦的工作</li>
<li>word hard：努力工作</li>
</ol>
</li>
<li>make 做<ol>
<li>What make is it? 这是什么牌子？</li>
<li>make the bed. 整理床铺</li>
<li>make a bookcase / bookshelf 制作一个书架</li>
</ol>
</li>
<li>bookcase 书架</li>
<li>hammer 锤子</li>
<li>paint 涂色，上色<ol>
<li>painting n 画</li>
<li>Chinese paintings 中国国画</li>
</ol>
</li>
<li>pink 粉色</li>
<li>favourite （favorite） 最喜欢的<ol>
<li>Facorite color / city / school / book / girl</li>
<li>What’s your favorite …?</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You are working hard, …  你正忙着呢！</li>
<li>Give me …</li>
<li>I’m going to paint it(the bookcase) pink（宾补）.<ol>
<li>宾补：对宾语的补充和说明，使句子更加简洁。</li>
<li>我发现那屋子是黑的</li>
<li>I find the room <del>is</del> dark.</li>
<li>大家务必保持教室干净。</li>
<li>We must keep the classroom clean.</li>
<li>历史使人明智。Histories make men wise.</li>
<li>诗歌使人灵秀。Poems make men witty.</li>
<li>数学使人缜密。Math make men subtle.</li>
<li>哲学使人深刻。Philosophy make men deep.</li>
</ol>
</li>
<li>It’s for my daughter.<ol>
<li>for<ol>
<li>为了…某人而…  It’s for you.</li>
<li>对于某人来说…   Math is so difficult for me.</li>
<li>表原因…  What are you sorry for?</li>
<li>长达… I study Yoga for two years.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般将来时</li>
<li>be going to 句型<ol>
<li>何时用？ 预先计划和打算要做的事</li>
<li>固定形式：主 + is / am / are + going to</li>
<li>要求： 后面接动词原形</li>
<li>示例<ol>
<li>我打算周末去逛街</li>
<li>I am going to <strong>go shopping</strong> this weekend.</li>
<li>他打算把旧车卖了买新车</li>
<li>He’s going to <strong>sell</strong> his old car, and <strong>buy</strong> a new one.</li>
<li>I am gonna be happy this year. </li>
<li>I’m going to <strong>be</strong> happy this year.</li>
</ol>
</li>
<li>口语中：be going to = be gonna</li>
</ol>
</li>
<li>be going to do / be going to be + adj. n. prep<ol>
<li>示例<ol>
<li>我打算下周开始忙起来。</li>
<li>I am going be busy next week.</li>
<li>他计划这周末呆家里。</li>
<li>He is going to be at home this weekend.</li>
<li>这个孩子打算以后成为医生。</li>
<li>This kid is going to be a doctor.</li>
</ol>
</li>
<li>其他形式：<ol>
<li>疑问： be 提前</li>
<li>否定：be + not</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>homework 家庭作业</li>
<li>housework 家务活</li>
<li>listen 听<ol>
<li>Listen to the music / radio ..</li>
</ol>
</li>
<li>dish 盘子</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 35</title>
    <url>/2020/06/18/Language/English/New%20Concept/Chapter1/lesson35/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>photograph 照片</li>
<li>village 村庄<ol>
<li>in the village</li>
</ol>
</li>
<li>valley 山谷<ol>
<li>in a valley</li>
</ol>
</li>
<li>between prep 在…之间<ol>
<li>Just between you and me, don’t tell others.</li>
<li>between A and B</li>
<li>The lady is between her daughter and her friend.</li>
</ol>
</li>
<li>hill 小山</li>
<li>mountain 大山</li>
<li>another 另一个</li>
<li>Here is another photo of my school.</li>
<li>wife 妻子<ol>
<li>wives 复数</li>
</ol>
</li>
<li>alone prep  沿着</li>
<li>bank 河岸</li>
<li>water 水</li>
<li>swim 游泳<ol>
<li>swimming 进行时</li>
<li>He is swimming in the water.</li>
</ol>
</li>
<li>building 大楼<ol>
<li>the school building 教学大楼</li>
</ol>
</li>
<li>park 公园<ol>
<li>in the park</li>
<li>park  v  停车</li>
<li>park the car</li>
</ol>
</li>
<li>into prep 进入<ol>
<li>I <strong>come into</strong> the bedroom.</li>
<li>I <strong>jump into</strong> the water.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>a photograph of our village</li>
<li>My wife and I walking along…<ol>
<li>My classmate and I …</li>
<li>My father and I …</li>
</ol>
</li>
<li>Here is another photograph…<ol>
<li>another 另一个（大于等于3）</li>
<li>the other 另一个（等于2）</li>
<li>I have two best friends. One is a teacher, the other is a doctor.</li>
</ol>
</li>
<li>Some children are coming out of…<ol>
<li>out of … 出来</li>
<li>come out of…</li>
<li>walk out of…</li>
<li>run out of…</li>
</ol>
</li>
<li>Some of them <strong>are</strong> going into the park.<ol>
<li>some of them 他们中的一些</li>
<li>some of us 我们中的一些</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<p>谁谁谁“的”</p>
<ol>
<li>物主代词<ol>
<li>我的 my</li>
<li>你的 your</li>
<li>她的 her</li>
<li>他的 his</li>
<li>我们的 our</li>
<li>你们的 your</li>
<li>他们的 their</li>
</ol>
</li>
<li>‘s  必须是有生命的<ol>
<li>Lucy’s friend</li>
<li>Lily’s book</li>
<li>my mother’s bag</li>
<li>the driver’s watch</li>
</ol>
</li>
<li>of   必须是没有生命的<ol>
<li>我学校的照片：the photo of my school</li>
<li>这首歌的名字：the name of the song</li>
<li>那辆车的颜色：the color of the car</li>
<li>这房间的窗户：the window of the room</li>
</ol>
</li>
<li>联系<ol>
<li>那只小狗的名: the dog’s name</li>
<li>那本书的颜色：the color of the book</li>
<li>我妈妈的手提包：my mother’s handbag</li>
<li>那位男士的妻子：the man’s wife</li>
<li>他们的教师：their classroom</li>
<li>世界地图：the map of the world</li>
<li>我们的老师：our teacher</li>
<li>那部电影的名字：the name of the movie</li>
<li>我老板的办公室：my boss’s office</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>beside prep 在…的旁边<ol>
<li>there is a bed table beside the bed.</li>
</ol>
</li>
<li>off prep. 离开<ol>
<li>take off</li>
<li>drive off </li>
<li>jump off </li>
</ol>
</li>
<li>test 测试提交</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 33</title>
    <url>/2020/06/14/Language/English/New%20Concept/Chapter1/lesson33/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>day 日子、天<ol>
<li>today 今天</li>
<li>yesterday 昨天</li>
<li>holiday 假日</li>
</ol>
</li>
<li>cloud 云<ol>
<li>There are some clouds in the sky.</li>
</ol>
</li>
<li>sky 天空<ol>
<li>in the sky</li>
</ol>
</li>
<li>sun 太阳<ol>
<li>sunhat 遮阳帽</li>
<li>sunglass</li>
<li>sunblock</li>
</ol>
</li>
<li>shine 照耀<ol>
<li>The sun is shining. 阳光灿烂</li>
</ol>
</li>
<li>with  和…一起<ol>
<li>He is with his new girlfriend.他和他的新女朋友在一起</li>
<li>I am with my new sunglass. 我待着我的新墨镜</li>
<li>The hourse is with a garden. 这栋房子带着一个花园</li>
<li>人与人，人与物，物与物</li>
</ol>
</li>
<li>family 家庭<ol>
<li>a family meeting 家庭会议</li>
<li>We are a family. 我们是一家人</li>
<li>Are you the family of …? 你们是…的家属么？</li>
</ol>
</li>
<li>walk 走路，步行<ol>
<li>I walk to school</li>
</ol>
</li>
<li>over 跨越，上方<ol>
<li>He is walking over the bridge.他正走着跨过那座桥。</li>
<li>The bird is flying over the river.</li>
</ol>
</li>
<li>bridge 桥<ol>
<li>过桥   over the bridge</li>
<li>他正在过桥   He is overing the bridge. 错误</li>
<li>He is going / walking / running over the bridge.</li>
</ol>
</li>
<li>boat 小船<ol>
<li>dream boat 梦中情人</li>
</ol>
</li>
<li>river 河</li>
<li>ship 轮船</li>
<li>aeroplane 飞机</li>
<li>fly 飞</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>描述天气：it作主语<ol>
<li>今天天气很好。It is fine today.</li>
<li>春天天气很糟糕。It is bad in spring.</li>
<li>夏天天气很好。It is nice in summer.</li>
<li>描述天气的句型结构：it is + adj. + 时间</li>
</ol>
</li>
<li>…is with his family.<ol>
<li>with: 介词，动词 + 介词</li>
<li>The desk <strong>is</strong> near the window.</li>
<li>She <strong>is</strong> with her friends.</li>
</ol>
</li>
<li>仿写<ol>
<li>今天的天气真好。天空飘着几朵白云，但是阳关灿烂，Lucy和她的男朋友在一块。他们正在开车。Lucy正在看一只漂亮的小鸟。小鸟正从天上飞过。一些人从天桥上走过，他们很忙。</li>
<li>It is fine today. There are some clouds in the sky. But sun is shinning. Lucy is with her bodfriends. Her boyfriend is driving. Lucy is looking at a beautiful bird. The bird is flying in the sky. Some people are walking over the bridge. They are busy.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>时态：<ol>
<li>时间</li>
<li>状态</li>
</ol>
</li>
<li>现在进行时态<ol>
<li>主 + is / am / are + doing</li>
<li>The cowl is swiming in water.</li>
<li>He is reading on the grass.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>sleep 睡觉</li>
<li>shave 刮胡子</li>
<li>shaver 刮胡刀</li>
<li>cry 哭<ol>
<li>The baby is cyring.</li>
</ol>
</li>
<li>wash 洗<ol>
<li>wash my face / wash my hads</li>
</ol>
</li>
<li>wait 等待<ol>
<li>look at</li>
<li>listen to</li>
<li>wait for me</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 31</title>
    <url>/2020/06/14/Language/English/New%20Concept/Chapter1/lesson31/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>garden 花园<ol>
<li>in the garden 在花园里 / a gardener 园艺师</li>
</ol>
</li>
<li>under prep 在…之下<ol>
<li>There is a chair under the bed.</li>
</ol>
</li>
<li>tree 树<ol>
<li>under the tree</li>
<li>a family tree 家谱</li>
</ol>
</li>
<li>climb  v.  爬，攀登<ol>
<li>climb the mountain 爬山</li>
</ol>
</li>
<li>who 谁</li>
<li>run v 跑<ol>
<li>run after 追赶</li>
<li>a runner 跑步运动员</li>
<li>Liu xiang is a runner.</li>
</ol>
</li>
<li>grass 草地</li>
<li>after prep 在…之后<ol>
<li>After you! 您先请。</li>
</ol>
</li>
<li>across prep 穿过<ol>
<li>go across the street</li>
<li>walk across the street</li>
<li>run across the street</li>
</ol>
</li>
<li>cat 猫</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>There are two people in the room.</li>
<li>Ther are talking.</li>
<li>There is a boy in the tree.</li>
<li>He is climbing the tree.</li>
<li>There is a gril under the tree.</li>
<li>She is reading.</li>
</ol>
<ol>
<li>She is sitting under the tree.<ol>
<li>sit - sitting</li>
</ol>
</li>
<li>He is climbing the tree.<ol>
<li>climb - climbing</li>
</ol>
</li>
<li>I beg your pardon?<ol>
<li>beg  祈求</li>
<li>Pardon? Excuse me? Sorry? Say it again.</li>
</ol>
</li>
<li>What about …?<ol>
<li>I am a teacher. What about you ?</li>
<li>I am learing English. What about you ?</li>
<li>I like rice. What about you?</li>
</ol>
</li>
<li>他正穿过那片草地<ol>
<li>He is acrossing the grass.  错误，across 是介词，不能加ing</li>
<li>He is going / walking / running across the grass.</li>
</ol>
</li>
<li>It’s running after a cat.<ol>
<li>run after 追赶</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>时态（简单区分）<ol>
<li>时间<ol>
<li>过去</li>
<li>现在</li>
<li>将来</li>
</ol>
</li>
<li>状态<ol>
<li>一般</li>
<li>进行</li>
<li>完成</li>
</ol>
</li>
</ol>
</li>
<li>现在进行时<ol>
<li>时间：现在</li>
<li>状态：进行</li>
<li>此时此刻正在做的动作。</li>
<li>动词中心说</li>
<li>总结<ol>
<li>一般 + ing</li>
<li>以不发音的e结尾，去e + ing</li>
<li>辅元辅，双写辅音字母+ing，除了opening.</li>
</ol>
</li>
</ol>
</li>
<li>现在进行时态的构成：<ol>
<li>主语 + is / am / are + doing</li>
<li>He is eating.   Is he eating?</li>
<li>He is reating.   Is he reading?</li>
<li>She is dringking. Is she dringking?</li>
<li>He is sleeping. Is he sleeping?</li>
<li>He is playing. Is he playing? No, he isn’t. he is running</li>
<li>Ther are singing. Are they singing?</li>
<li>He is swiming. Is he swiming?</li>
<li>He is running.  Is he running?</li>
<li>She is writing. Is she writing?</li>
</ol>
</li>
<li>现在进行时态的一般疑问<ol>
<li>Is / Am / Are + 主语 + doning</li>
<li>What is she doing?<ol>
<li>She is teaching.</li>
</ol>
</li>
<li>Where is she teaching?<ol>
<li>She is teaching in the classroom.</li>
</ol>
</li>
<li>What is she teaching?<ol>
<li>She is teaching math.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>type v 打字<ol>
<li>typeing</li>
</ol>
</li>
<li>letter 信<ol>
<li>a love letter 情书</li>
</ol>
</li>
<li>basket 篮子<ol>
<li>basketball 篮球</li>
</ol>
</li>
<li>eat 吃<ol>
<li>eating </li>
</ol>
</li>
<li>bone 骨头</li>
<li>clean v 清洗<ol>
<li>clean adj  干净的</li>
<li>clean the room</li>
<li>cleaning</li>
</ol>
</li>
<li>tooth 牙齿<ol>
<li>复数  teeth</li>
<li>foot - feet</li>
<li>toothbrush</li>
</ol>
</li>
<li>cook 做饭<ol>
<li>cooking</li>
<li>My mother is cooking.</li>
</ol>
</li>
<li>milk 牛奶</li>
<li>meal 饭，一顿饭<ol>
<li>cook a meal</li>
</ol>
</li>
<li>drink 喝<ol>
<li>drinking</li>
<li>She is drinking some wather.</li>
</ol>
</li>
<li>tap 水龙头<ol>
<li>打开水龙头   open the tap</li>
<li>turn on the tap</li>
<li>turn off the tap</li>
</ol>
</li>
<li>What’s she / he / it doing?<br>14.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 29</title>
    <url>/2020/06/10/Language/English/New%20Concept/Chapter1/lesson29/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>shut 关门<ol>
<li>The door is shut.  门是管着的</li>
<li>Shut the door. 关门。</li>
</ol>
</li>
<li>bedroom 卧室<ol>
<li>in the bedroom</li>
</ol>
</li>
<li>untidy 不干净的<ol>
<li>un-  不，表示否定</li>
<li>clean  unclean</li>
<li>easy uneasy</li>
<li>happy unhappy</li>
</ol>
</li>
<li>must 必须  model verb<ol>
<li>情态动词——情感，态度</li>
<li>You must go out.</li>
<li>Can you got out please?</li>
</ol>
</li>
<li>open 打开<ol>
<li>The window is open. </li>
<li>Open the window.</li>
</ol>
</li>
<li>air 通风，使空气流通<ol>
<li>The air is fresh. 空气清新</li>
<li>Open the windows and air the kitchen.</li>
<li>打开窗户，让厨房通下气</li>
<li>What is the <strong>color</strong>?</li>
<li><strong>Color</strong> the picture.给图片上个色</li>
<li>I like milk.</li>
<li>Milk it. 给奶球挤牛奶</li>
<li>This is my <strong>book</strong>.</li>
<li><strong>Book</strong> a ticket. 预定一张票</li>
<li>There is some water in the glass.</li>
<li><strong>Water</strong> the flower.给花浇水</li>
<li>There is some <strong>dust</strong>.</li>
<li><strong>Dust</strong> the table. 把桌上的灰尘清扫掉</li>
</ol>
</li>
<li>put 放置，搁<ol>
<li>把书放桌上：Put the book on the table.</li>
<li>把手穿兜里  Put your hand in your pocket.</li>
</ol>
</li>
<li>clothes 衣服 （单复数同形）<ol>
<li>people / hair / fish / sheep</li>
</ol>
</li>
<li>wardrobe 大衣柜<ol>
<li>把外套放在大衣柜里</li>
<li>Put your coat in the wardrobe.</li>
</ol>
</li>
<li>sweep 清扫<ol>
<li>Sweep the floor please.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>祈使句<ol>
<li>没有主语</li>
<li>东西开头<ol>
<li>Come in</li>
<li>Go out</li>
<li>Shut the door.</li>
<li>Open the window</li>
<li>Air the room.</li>
</ol>
</li>
</ol>
</li>
<li>What must I do?<ol>
<li>What must I say / read / clean … ?</li>
<li>Where must I go / live / stay…?</li>
<li>Who must I meet / love / care…?</li>
</ol>
</li>
<li>make the bed </li>
<li>sweep the floor</li>
<li>dust the table</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>祈使句：用来表示命令、请求、建议等；<ol>
<li>表示命令：东西原型+…<ol>
<li>Shut the door.</li>
</ol>
</li>
<li>表示请求： please + 动词原型 + …<ol>
<li>Please give me it.</li>
</ol>
</li>
<li>表示建议：Let’s + 动词原型+…<ol>
<li>Let’s go, ok?</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>empty<ol>
<li>My mind is empty. adj</li>
<li>Empty the bottle please. v</li>
</ol>
</li>
<li>read 读，看<ol>
<li>读书，看报，看杂志：read a book / newspaper / a magazine</li>
</ol>
</li>
<li>sharpen 使锋利<ol>
<li>adj + en = v</li>
<li>sharp + en = 使锋利</li>
<li>short + en = 缩短</li>
<li>weak + en = 削弱</li>
</ol>
</li>
<li>put on &amp;&amp; take off<ol>
<li>戴上眼镜，项链，戒指</li>
</ol>
</li>
<li>turn on &amp;&amp; turn off<ol>
<li>打开带电的设备</li>
<li>turn on / off the television</li>
<li>turn on / off the radio</li>
<li>turn on / off the light</li>
<li>turn on / off the tap(水龙头)</li>
</ol>
</li>
<li>句型：What must I do?<ol>
<li>What must I say / read /clean?</li>
<li>Where must I go / live /stay</li>
<li>Who must I meet/love/find.</li>
<li>Which must I like/take/find/</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 27</title>
    <url>/2020/06/10/Language/English/New%20Concept/Chapter1/lesson27/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>living room 客厅</li>
<li>near prep  靠近、旁边<ol>
<li>电视靠近桌子</li>
<li>The television is near  the table</li>
</ol>
</li>
<li>window 窗户</li>
<li>armchair 扶手椅<ol>
<li>arm 胳膊</li>
<li>chair 椅子</li>
</ol>
</li>
<li>door 门</li>
<li>picture 图画，照片</li>
<li>wall 墙<ol>
<li>the great wall 长城</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>There is a television in the room.</li>
<li>There are some magazines on the table.<ol>
<li>There is a + 单数名次</li>
<li>There are some  + 复数名词</li>
</ol>
</li>
<li>There is a sofa in the room.</li>
<li>There is a television in the room.</li>
<li>There are some pictures on the wall.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>介词 prep<ol>
<li>媒婆，连接两个词或句子</li>
<li>on in of near</li>
<li>使用介词时，不能忘记动词！</li>
<li>The television is near the windows.</li>
<li>The money is in the bag.</li>
<li>The picture is on the wall.</li>
<li>The wather is in the glass.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>trousers 长裤</li>
<li>pants 长裤</li>
<li>jeans 牛仔裤</li>
<li>shorts 短裤</li>
<li>shoes 鞋子</li>
<li>socks 袜子</li>
<li>gloves 手套</li>
<li>glasses 眼镜</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 25</title>
    <url>/2020/06/09/Language/English/New%20Concept/Chapter1/lesson25/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>Mrs 夫人</li>
<li>kitchen 厨房<ol>
<li>in the kitchen</li>
</ol>
</li>
<li>refrigerator 电冰箱<ol>
<li>frige</li>
</ol>
</li>
<li>right 右边<ol>
<li>on the right</li>
<li>The desk is on the right.</li>
</ol>
</li>
<li>left 左边</li>
<li>electric 带电的，可通电的<ol>
<li>an electric cooker</li>
<li>an electric shaver</li>
</ol>
</li>
<li>cooker 炉子，炊具</li>
<li>middle 中间<ol>
<li>in the middle of  在…的中间</li>
<li>The table is in the middle of the room.</li>
</ol>
</li>
<li>of （属于）……的</li>
<li>room 房间<ol>
<li>living room</li>
<li>dinning room</li>
<li>bedroom</li>
<li>bathroom</li>
</ol>
</li>
<li>cup 杯子</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Mrs.Smith’s kitchen is small.<ol>
<li>第一句话——总述</li>
</ol>
</li>
<li>描述物体的方式<ol>
<li>There is … in the kitchen.</li>
<li>The … is blue.</li>
<li>It is on the left.</li>
<li>所在位置，颜色，具体位置，状态</li>
<li>卧室里有一张床，是绿色的，在屋子中间，上面很干净</li>
<li>There is a bed in the bedroom.</li>
<li>The bed is green.</li>
<li>It is in the middle of the room.</li>
<li>And it is very clean.</li>
<li>所在位置： there be 句型</li>
<li>颜色： it is + 颜色</li>
<li>具体位置：on the right/left, in the middle of…</li>
<li>状态： it is clean / empty / large / small</li>
</ol>
</li>
<li>冠词用法复习<ol>
<li>初次出现，不了解，不确定，用不定冠词a /an</li>
<li>再次出现，了解，确定，用定冠词 the</li>
<li>那有一个人，这个人穿着蓝色的衣服，他是以为机械师</li>
<li>There is a man, the man is in blue. And he is a machanic</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>There be 句型<ol>
<li>构成： There be + 地点</li>
<li>用法：<ol>
<li>有 -&gt; 拥有  have</li>
<li>有 -&gt; 存在   There be …</li>
</ol>
</li>
<li>分类<ol>
<li>There is … + 单数名次</li>
<li>There are … +复数名次</li>
</ol>
</li>
<li>翻译<ol>
<li>There is one in my heart.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>Where 哪里</li>
<li>in  在…里面<ol>
<li>Where is it?</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 23</title>
    <url>/2020/06/08/Language/English/New%20Concept/Chapter1/lesson23/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>on: prep 在…之上<ol>
<li>on the table</li>
<li>on the floor</li>
</ol>
</li>
<li>shelf 架子、隔板<ol>
<li>shelves</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Which glasses?<ol>
<li>哪几个、哪些杯子？</li>
<li>which + 单数名词，表示哪个</li>
<li>which + 复数名词，表示哪些</li>
</ol>
</li>
<li>Give me some glasses.<ol>
<li>some : 一些 + 复数名词</li>
<li>some books</li>
<li>some cups</li>
<li>some boxes</li>
<li>some knifves</li>
<li>give me / him /her /us / them</li>
</ol>
</li>
<li>The ones on the shelf. 架子上的那些<ol>
<li>the ones [on the shelf] </li>
<li>介词短语后置，倒着翻译</li>
<li>the book on the desk</li>
<li>the cup on the table</li>
<li>the knife in the box</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>介词  prep<ol>
<li>介词：媒婆，连接两个词或词与句子</li>
<li>媒婆：on<ol>
<li>The book <strong>on</strong> the desk.  XXX</li>
<li>The book <strong>is on</strong> the desk.</li>
<li>使用介词时，不能忘记动词！</li>
</ol>
</li>
<li>那个玻璃杯在桌子上<ol>
<li>The glass is on the table.</li>
</ol>
</li>
<li>那个勺子在盘子上<ol>
<li>The spoon is on the table</li>
</ol>
</li>
<li>那个瓶子在盒子上<ol>
<li>The bottle is on the box.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>desk 课桌</li>
<li>table 桌子<ol>
<li>a bed table/ a tea table</li>
</ol>
</li>
<li>plate 盘子</li>
<li>cupboard 食厨</li>
<li>cigarette 香烟</li>
<li>television 电视机<ol>
<li>TV</li>
</ol>
</li>
<li>floor 地板<ol>
<li>It’s on the floor.</li>
</ol>
</li>
<li>dressing table 梳妆台</li>
<li>magazing 杂志</li>
<li>beg 床</li>
<li>newspaper 报纸<ol>
<li>news 新闻</li>
<li>paper 纸张</li>
</ol>
</li>
<li>stereo 立体声音响</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 21</title>
    <url>/2020/06/08/Language/English/New%20Concept/Chapter1/lesson21/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>give 给<ol>
<li>give me / her / him / them / us</li>
</ol>
</li>
<li>one 一个  pron(代词)<ol>
<li>the blue one = the blue coat</li>
<li>the short one = the short girl</li>
</ol>
</li>
<li>which 哪一个，哪一些<ol>
<li>Which book?</li>
<li>Which tourists?</li>
<li>哪本书好？ Which book is good?</li>
<li>哪些游客来此北京？ Which tourists are from Beijing?</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You give me a book.<ol>
<li>主谓宾 宾</li>
</ol>
</li>
<li>This one? = This book?</li>
<li>Not that one. = Not that book.</li>
<li>The red one. = The red book.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>双宾语动词<ol>
<li>You give me a book.</li>
</ol>
</li>
<li>简单句的句型机构：<ol>
<li>主谓</li>
<li>主谓宾</li>
<li>主谓宾宾</li>
<li>主谓宾宾补</li>
<li>主系表</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><p>empty 空的</p>
</li>
<li><p>full 满的</p>
<ol>
<li>I’m full. 我饱了</li>
<li>a full stop 句号</li>
<li>a full time job 一份全职工作</li>
</ol>
</li>
<li><p>large 大的（强调面积）</p>
<ol>
<li>China is a large country.</li>
<li>This room is large. 这房间很大</li>
</ol>
</li>
<li><p>little 小的</p>
<ol>
<li>a little gril  一个小女孩（可爱的）</li>
</ol>
</li>
<li><p>sharp 锋利的</p>
<ol>
<li>The knife is sharp. </li>
</ol>
</li>
<li><p>blunt 钝的</p>
<ol>
<li>The knife is blunt. </li>
<li>My English is blunt.</li>
</ol>
</li>
<li><p>small 小的</p>
<ol>
<li>Small world … 世界真小，又见面了。</li>
</ol>
</li>
<li><p>big 大的（体积）</p>
</li>
<li><p>box 盒子，箱子</p>
<ol>
<li>a small box</li>
<li>a big box</li>
</ol>
</li>
<li><p>glass 玻璃杯子</p>
</li>
<li><p>cup 茶杯</p>
</li>
<li><p>bottle 瓶子</p>
</li>
<li><p>tin 罐头瓶、易拉罐</p>
</li>
<li><p>knife 刀子</p>
</li>
<li><p>fork 叉子  forks</p>
</li>
<li><p>spoon 勺子</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 19</title>
    <url>/2020/06/07/Language/English/New%20Concept/Chapter1/lesson19/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>matter 事情<ol>
<li>What’s matter ?  wrong.</li>
<li>What’s the matter?  right.</li>
</ol>
</li>
<li>children  孩子们<ol>
<li>child 孩子</li>
<li>kid  -  kids  </li>
</ol>
</li>
<li>tired 累，疲乏<ol>
<li>I am tired.</li>
<li>Are you tired?</li>
<li>I am not tired.</li>
</ol>
</li>
<li>boy 男孩</li>
<li>thirsty 口渴的<ol>
<li>He’s thirsty.</li>
</ol>
</li>
<li>Mum 妈妈</li>
<li>sit down 坐下<ol>
<li>Sit down, please. Have a seat.</li>
</ol>
</li>
<li>right 好，可以<ol>
<li>All right.</li>
</ol>
</li>
<li>ice cream 冰激凌</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>又渴又累<ol>
<li>thirsty <strong>and</strong> tired</li>
</ol>
</li>
<li>又好看有善良<ol>
<li>Kind and beautiful</li>
</ol>
</li>
<li>又高又帅<ol>
<li>Tall and handsome</li>
</ol>
</li>
<li>又年轻又有钱<ol>
<li>young and rich</li>
</ol>
</li>
<li>高富帅<ol>
<li>tall, rich and handsome</li>
</ol>
</li>
<li>There’s an ice cream man.<ol>
<li>There be (is / are ) 句型</li>
<li>There’s a mailman.</li>
</ol>
</li>
<li>Two ice creams, please.</li>
<li>These ice creams are nice.</li>
<li>这个冰激凌真好吃</li>
<li>This ice cream is nice</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>复数 &amp; 句子<ol>
<li>Those children _ tired.</li>
<li>We _ thirsty.</li>
<li>This child _ very young.</li>
<li><strong>__</strong> children are tired.<ol>
<li>The  Those These</li>
</ol>
</li>
<li>__ mother is busy.<ol>
<li>My His Her Their</li>
</ol>
</li>
<li>__ friends are tall.<ol>
<li>My your his her our their</li>
</ol>
</li>
<li>__ brother is a taxi driver.<ol>
<li>My Your His Her</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>big 大的<ol>
<li>风大，雨大，雪大，heavy</li>
<li>声音大  loud</li>
<li>年纪大  old</li>
<li>面积大  large</li>
</ol>
</li>
<li>small 小的<ol>
<li>声音小  light</li>
<li>年龄小  young</li>
</ol>
</li>
<li>open 开着的<ol>
<li>The door is open.</li>
<li>The window is open.</li>
<li>Open the door.</li>
</ol>
</li>
<li>shut 关着的<ol>
<li>The windows is shut.</li>
</ol>
</li>
<li>light 轻的</li>
<li>heavy 重的</li>
<li>long 长的<ol>
<li>时间，东西</li>
</ol>
</li>
<li>shoe 鞋<ol>
<li>a shoe 一只鞋</li>
<li>a pair of shoes：一双鞋</li>
</ol>
</li>
<li>grandfather: 祖父，外祖父</li>
<li>grandmother  祖母，外祖母</li>
<li>you sister brother</li>
<li>mother father</li>
<li>husband   wife</li>
<li>son daughter</li>
<li>mother -&gt; uncle aunt</li>
<li>father -&gt; uncle aunt </li>
<li>father -&gt; grandmother grandfather</li>
<li>mother -&gt; 同</li>
<li>in- law  结婚后的亲属关系，后缀<ol>
<li>mother in-low</li>
<li>father in-low</li>
<li>sister in-low</li>
<li>brother in-low</li>
</ol>
</li>
<li>step 后的，继的    前缀<ol>
<li>step mother</li>
<li>step father</li>
<li>step sister</li>
</ol>
</li>
<li>ex- 前任的<ol>
<li>ex-girlfriend</li>
<li>ex-boyfriend</li>
<li>ex-wife</li>
<li>ex-husband</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 17</title>
    <url>/2020/06/07/Language/English/New%20Concept/Chapter1/lesson17/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>employee 雇员<ol>
<li>employ 雇佣</li>
<li>employer 雇佣者，雇主</li>
<li>-er  ..的人</li>
<li>-ee  被…的人</li>
<li>trainer  培训者</li>
<li>trainee 被培训的人</li>
</ol>
</li>
<li>hard-working 勤奋的<ol>
<li>构词：adj + doing</li>
<li>good-looking  好看的</li>
<li>easy-going 好相处的</li>
</ol>
</li>
<li>sales rep  推销员<ol>
<li>sales reps 复数</li>
<li>sales representative</li>
</ol>
</li>
<li>man  人，男人<ol>
<li>Hi, man!</li>
<li>men  复数</li>
</ol>
</li>
<li>office 办公室<ol>
<li>office buildings 办公大楼</li>
<li>office hours 办公时间</li>
</ol>
</li>
<li>assistant 助手<ol>
<li>an office assistant 办公室助理</li>
<li>a shop assistant 商场售货员</li>
<li>a classroom assistant 助教</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>打招呼<ol>
<li>Hello</li>
<li>How are you?</li>
<li>How are you doing?</li>
<li>How do you do?  幸会，使用场合非常正式</li>
<li>回答 —- How do you do.</li>
</ol>
</li>
<li>Come and meet …<ol>
<li>过来坐吧： Come and sit down.</li>
<li>过来喝一杯：Come and have a drink.</li>
<li>过来见见我的朋友：Come and meet my friend.</li>
</ol>
</li>
<li>What are their jobs?<ol>
<li>What is your job?</li>
<li>单词的复数 &amp; 句子的复数</li>
<li>This is my name.</li>
<li>These are their names.</li>
<li>That is her car.</li>
<li>Those are our cars.</li>
<li>He is an assistant.</li>
<li>They are assistant.</li>
<li>总结：句子的复数形式需要考虑代词，名词，动词的一致性。</li>
<li>Who is the young girl?</li>
<li>Who are the young girls?</li>
<li>What is your job?</li>
<li>What are their jobs?</li>
<li>He is a tourist.</li>
<li>They are tourists.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>名词的单复数<ol>
<li>books jobs</li>
<li>buses, boxes, brushes, benches, potatoes</li>
<li>wife-wifves, leaf-leaves</li>
<li>baby - babies</li>
<li>man-men  woman-women</li>
<li>foot-feet    tooth-teeth</li>
<li>child - children</li>
</ol>
</li>
<li>句子的复数<ol>
<li>单数名词 + is</li>
<li>复数名词 + are</li>
<li>Her passport _ green,</li>
<li>The men _ keyboard operators.</li>
<li>This assistant _ busy.</li>
<li>Our classroom _ large.</li>
<li>These umbrellas _ useful.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>What are their jobs?</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 15</title>
    <url>/2020/06/06/Language/English/New%20Concept/Chapter1/lesson15/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>customs 海关<ol>
<li>customer 顾客</li>
</ol>
</li>
<li>officer 官员<ol>
<li>customs officer 海关官员</li>
<li>CEO 首席执行官 Chief Executive Officer</li>
</ol>
</li>
<li>girl 女孩<ol>
<li>my girl</li>
</ol>
</li>
<li>Danish 丹麦人，丹麦的<ol>
<li>Denmark 丹麦</li>
<li>Chinese &amp; China</li>
</ol>
</li>
<li>friend 朋友<ol>
<li>a new friend / an old friend</li>
</ol>
</li>
<li>Norwegian 挪威人<ol>
<li>Norway 挪威</li>
</ol>
</li>
<li>passport 护照<ol>
<li>pass 通过</li>
<li>port 港口</li>
</ol>
</li>
<li>visa 签证</li>
<li>brown 棕色的<ol>
<li>brown tea 红茶</li>
<li>brown sugar 红糖</li>
</ol>
</li>
<li>tourist 旅游者<ol>
<li>-ist</li>
<li>artist  dentist</li>
<li>-er<ol>
<li>teacher worker driver</li>
</ol>
</li>
<li>-or<ol>
<li>doctor director</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Your passports, please.<ol>
<li>n. + please </li>
<li>点餐时</li>
<li>购物时</li>
<li>检票时</li>
</ol>
</li>
<li>We are Danish. 我们是丹麦人<ol>
<li>They are Norwegian. 他们是挪威人</li>
<li>我   I         am 我们   we  are</li>
<li>你  you     are 你们  you  are</li>
<li>他  he      is     他们  they  are</li>
<li>她  she    is     她们  they  are</li>
</ol>
</li>
<li>这些是你们的箱子么？<ol>
<li>Are these your cases?</li>
</ol>
</li>
<li>我们的箱子是棕色的<ol>
<li>Our cases are brown.</li>
<li>复数关乎整个句子，而非一个单词</li>
</ol>
</li>
<li>这是我的书。<ol>
<li>This is my book.</li>
</ol>
</li>
<li>这些是我们的书。<ol>
<li>These are our books.</li>
</ol>
</li>
<li>那是她的车。<ol>
<li>That is her car.</li>
</ol>
</li>
<li>那些是她们的车。<ol>
<li>Those are their cars.</li>
</ol>
</li>
<li>复数 物主代词<ol>
<li>我们的 our</li>
<li>他们的  their<ol>
<li>our books / their cars</li>
<li>our mum / school</li>
<li>their teacher / house</li>
</ol>
</li>
</ol>
</li>
<li>Here they are.</li>
<li>That’s fine.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>名词的单数 &amp; 复数<ol>
<li>定义<ol>
<li>单数：1</li>
<li>复数：2 或 以上</li>
<li>a car - two cars</li>
<li>a bag - three bags</li>
</ol>
</li>
<li>规则<ol>
<li>一般的名字 +s<ol>
<li>a girl  —- girls</li>
<li>an officer —-  officers</li>
<li>a coat  —- coats</li>
</ol>
</li>
<li>以s , sh , x , ch 结尾的加  es <ol>
<li>a bus   —-  buses</li>
<li>a box   —-  boxes</li>
<li>a brush  —- brushes</li>
</ol>
</li>
<li>以 f ,  fe  结尾的变 f, fe —- ves<ol>
<li>a wife —- wives</li>
<li>a shelf —- shelves</li>
<li>a knife —- knives</li>
<li>a leaf —- leaves</li>
</ol>
</li>
<li>辅音字母+y结尾的名词，变y-i   + es<ol>
<li>a baby — babies</li>
<li>a lady —- ladies</li>
</ol>
</li>
<li>元音 + o  结尾  + s<ol>
<li>a zoo —- zoos</li>
<li>a radio  —- radios</li>
<li>辅音+o结尾 ， +  es</li>
<li>a hero —- heroes</li>
<li>a potato   —- patatoes</li>
<li>a tomato —- tomatoes</li>
</ol>
</li>
</ol>
</li>
<li>单数-复数名词在句子中<ol>
<li>单数  + is</li>
<li>复数 + are</li>
<li>The tourists  _ from Norway.</li>
<li>The teacher _ Aamercan.</li>
<li>These cars _ brown.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>Russian  俄罗斯人<ol>
<li>Russia 俄罗斯</li>
</ol>
</li>
<li>Dutch 荷兰人<ol>
<li>Holland / Netherland 荷兰</li>
</ol>
</li>
<li>these  这些<ol>
<li>this  这个    these  这些</li>
<li>that  那个    those 那些</li>
<li>这是他的手表。  This is his watch. These are their watches..</li>
</ol>
</li>
<li>red 红色的</li>
<li>grey  灰色的<ol>
<li>gray</li>
<li>grey hair 花白的头发</li>
</ol>
</li>
<li>black  黑色的</li>
<li>black tea 红茶</li>
<li>black coffee 纯咖啡</li>
<li>yellow 黄色的</li>
<li>orange 橘黄色的</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 13-14</title>
    <url>/2020/06/02/Language/English/New%20Concept/Chapter1/lesson13/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>color / colour 颜色<ol>
<li>What color?</li>
<li>What color is it?</li>
</ol>
</li>
<li>green 绿色<ol>
<li>a green hand 新手</li>
<li>green tea 绿茶</li>
</ol>
</li>
<li>come 来<ol>
<li>come here 过来</li>
</ol>
</li>
<li>upstairs 楼上<ol>
<li>come upstairs 上楼来</li>
<li>go downstairs 下楼去</li>
</ol>
</li>
<li>smart 时髦的，漂亮的<ol>
<li>beautiful / smart</li>
</ol>
</li>
<li>same 相同的<ol>
<li>the same color / name / city</li>
</ol>
</li>
<li>lovely 可爱的，漂亮的<ol>
<li>beautiful / smart / lovely / nice</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>What color is your _?</li>
<li>Come and see her.<ol>
<li>Come and meet my mom.</li>
<li>Come and do it.</li>
<li>Come and sit down …</li>
</ol>
</li>
<li>here it is —— It is here.<ol>
<li>Here + 主语 + 动词</li>
<li>I am here.  Here I am.</li>
<li>He is here.  Here he is.</li>
<li>Here we go …</li>
</ol>
</li>
<li>漂亮 /  好看<ol>
<li>beautiful / lovely / nice</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>特殊疑问词<ol>
<li>语序：特殊疑问词 + be + n</li>
<li>你的名字是什么？</li>
<li>What is you name?</li>
<li>你的工作是什么？</li>
<li>What is you job?</li>
<li>你的外套是什么颜色的？</li>
<li>What color is your _?</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>case 箱子<ol>
<li>suitcase 手提箱</li>
</ol>
</li>
<li>carpet 地毯<ol>
<li>car 汽车 + pet 宠物</li>
</ol>
</li>
<li>dog 狗<ol>
<li>a lucky dog 幸运儿</li>
</ol>
</li>
<li>What color is your _?<ol>
<li>umbrella</li>
<li>car</li>
<li>shirt</li>
<li>coat</li>
<li>case </li>
<li>carpet</li>
<li>blouse</li>
<li>tie</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>docker一些参数修改</title>
    <url>/2020/06/02/Docker/docker%E5%8F%82%E6%95%B0%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>有时候需要修改docker的一些参数，如restart，或者command命令，但是不想重新构建容器，这时候可以这么做：</p><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/lib/docker/containers/ID/</span><br></pre></td></tr></table></figure>
<p>进入到ID对应目录，里面有两个文件config.v2.json  hostconfig.json，config.v2.json里可以修改command的相关命令，hostconfig.json可以修改端口绑定，地址映射等配置。</p>
<p>修改时需要stop掉，完事之后才start，才生效。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 11-12</title>
    <url>/2020/06/01/Language/English/New%20Concept/Chapter1/lesson11/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>whose 谁的<ol>
<li>what 什么</li>
<li>whose pen / whose shirt / whose car</li>
</ol>
</li>
<li>blue 蓝色<ol>
<li>忧郁的 You are blue today</li>
<li>不健康的 It’s blue book.</li>
<li>贵族的  blue blood</li>
</ol>
</li>
<li>perhaps 大概<ol>
<li>Perhaps it is. 可能是这样吧。</li>
<li>Perhaps so.</li>
<li>Perhaps not.</li>
</ol>
</li>
<li>white 白色<ol>
<li>the White House 白宫</li>
<li>white lie 善意的谎言</li>
</ol>
</li>
<li>catch 抓住，接着<ol>
<li>catch the thief</li>
<li>catch the ball</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Whose shirt is that?<ol>
<li>whose shirt / shose car / show friends</li>
<li>That is whose shirt?</li>
<li><strong>特殊疑问词 + be + 名词n</strong></li>
<li>Whose is that shirt?</li>
<li>Whose shirt is that?</li>
<li><strong>特殊疑问词 + 名词 + be + 代词</strong></li>
<li>这是谁的车？  Whose is this car? Whose car is this?</li>
<li>那是谁的包？ Whose is that bag? Whose bag is this?</li>
</ol>
</li>
<li>Is this your shirt, Dave?<ol>
<li>Excuse me , sir.</li>
<li>Hello, Mr. Lee.</li>
</ol>
</li>
<li>Here you are. 给你</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>谁谁谁的 <ol>
<li>我的：my</li>
<li>你的：your</li>
<li>Lucy的：Lucy’s</li>
<li>Lucy的朋友：Lucy’s frined</li>
<li>Lily的书：Lily’s book</li>
<li>我妈妈的包：my mother’s bag</li>
<li>司机的手表：the driver’s watch</li>
<li>医生的车：the doctor’s car</li>
<li>有生命的才能用’s</li>
<li>Jay’s son</li>
<li>Zhouxun’s daughter</li>
<li>Mr. Chen’s son</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>father 父亲<ol>
<li>day / daddy </li>
</ol>
</li>
<li>mother 母亲<ol>
<li>mom / mum / mummy</li>
</ol>
</li>
<li>blouse 女衬衫</li>
<li>sister 姐姐</li>
<li>tie 领带</li>
<li>brother 兄弟</li>
<li>his 他的</li>
<li>her 她的<ol>
<li>物主代词<ol>
<li>我的 my</li>
<li>你的 your</li>
<li>他的 his</li>
<li>她的  her</li>
</ol>
</li>
<li>my book</li>
<li>your house</li>
<li>his tie</li>
<li>Her sister is his girfriend.</li>
<li>His wife is her good friend.</li>
<li>His brother is her boss.</li>
</ol>
</li>
<li>Whose is this handbag?<ol>
<li>Whose handbag is this?</li>
</ol>
</li>
<li>Whose is this car?<ol>
<li>Whose car is this?</li>
</ol>
</li>
<li>Whose is this coat?<ol>
<li>Whose coat is this? It’s Sophies’</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 0-10</title>
    <url>/2020/05/31/Language/English/New%20Concept/Chapter1/lesson9/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>hello</li>
<li>hey</li>
<li>hi</li>
<li>how 如何，怎样<ol>
<li>How are you ?</li>
<li>How is your mother?</li>
<li>How is the weather?</li>
</ol>
</li>
<li>today 今天</li>
<li>tonight 今晚</li>
<li>well 身体好</li>
<li>thanks 感谢<ol>
<li>Thanks a lot.  非常感谢。</li>
<li>Thank you very much.</li>
</ol>
</li>
<li>good-bye 再见</li>
<li>see 看见<ol>
<li>See you.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>打招呼<ol>
<li>Hello</li>
<li>How are you?</li>
<li>How are you doing?</li>
</ol>
</li>
<li>How are you? 的回应<ol>
<li>Fine. Very well. Thank you, and you </li>
<li>Not bad.</li>
<li>very bad. Terrible.</li>
</ol>
</li>
<li>How are you 句型替换<ol>
<li>How _ your fater?</li>
<li>How _ Lucy?</li>
<li>How _ they?</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>冠词<ol>
<li>概念：待在名词头上的帽子，没有特殊情况不能摘<ol>
<li>国家，国际，人名，城市名</li>
</ol>
</li>
<li>读音<ol>
<li>an egg/ a dress / the student / the Italian car</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>fat 胖的<ol>
<li>a fat cat</li>
<li>a littne heavy</li>
</ol>
</li>
<li>woman 女人<ol>
<li>lady </li>
<li>an old woman</li>
<li>an old lady</li>
</ol>
</li>
<li>thin 瘦的<ol>
<li>slim 苗条的</li>
<li>You are so slim.</li>
</ol>
</li>
<li>tall 高的<ol>
<li>short 矮的</li>
</ol>
</li>
<li>dirty 脏的</li>
<li>clean 干净的</li>
<li>hot 热的<ol>
<li>It is hot today. </li>
<li>The girl is very hot.</li>
<li>Lady GaGa is hot now.</li>
</ol>
</li>
<li>cold 冷的<ol>
<li>It is very cold today. 今天天气很冷</li>
<li>I have a cold welcome. 我受到了冷遇</li>
</ol>
</li>
<li>old 老的，旧的<ol>
<li>He is an old man.</li>
<li>It is an old story.</li>
<li>That is my old book.</li>
</ol>
</li>
<li>young 年轻的<ol>
<li>He is a young man.</li>
</ol>
</li>
<li>busy 忙的<ol>
<li>It is a busy day.</li>
<li>He is very busy.</li>
</ol>
</li>
<li>lazy 懒惰的</li>
</ol>
<blockquote>
<p> 重点句型</p>
</blockquote>
<ol>
<li>Look at … 看<ol>
<li>meet you / him / her</li>
<li>look at &amp; see 看 &amp; 看见</li>
<li>Look at the man. He is very busy.</li>
<li>I see him in the street.<br>5.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 7-8</title>
    <url>/2020/05/31/Language/English/New%20Concept/Chapter1/lesson7/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>I 我<ol>
<li>me 我（宾格）</li>
<li>_ love English.</li>
<li>He loves _.</li>
</ol>
</li>
<li>am  be动词现在时第一人称单数<ol>
<li>be:  am / is / are</li>
</ol>
</li>
<li>are be动词现在时复数<ol>
<li>You are … = You’re</li>
<li>We are … = We’re</li>
</ol>
</li>
<li>is<ol>
<li>He is … = He’s</li>
<li>She is … = She’s</li>
<li>It is … = It’s</li>
</ol>
</li>
<li>name 名字<ol>
<li>my name / English name / Chinese name</li>
</ol>
</li>
<li>what 什么</li>
<li>nationality 国籍</li>
<li>job 工作（职业）<ol>
<li>a good job</li>
</ol>
</li>
<li>keyboard 电脑键盘<ol>
<li>key 钥匙</li>
<li>board 板子</li>
</ol>
</li>
<li>operator 操作人员<ol>
<li>director 导演</li>
</ol>
</li>
<li>engineer 工程师<ol>
<li>teacher 老师</li>
<li>worker 工作人员</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>I am a new student.</li>
<li>My name’s Robert.</li>
<li>Are you French?</li>
<li>I’m Italian</li>
<li>What nationality are you?<ol>
<li>My nationality is China.</li>
<li>I’m Chinese.</li>
</ol>
</li>
<li>What’s your job?<ol>
<li>I’m a worker.</li>
<li>I have no job. I’m a student.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般疑问句<ol>
<li>功能：询问</li>
<li>构成：is / am / are 置于句前</li>
<li>Are you French?  You are French.</li>
<li>Are you a teacher? You are a teacher.</li>
<li>She is a doctor. Is she a doctor?</li>
<li>He is a student. Is he a student?</li>
<li>I am Chinese. Are you Chinese?</li>
<li>This is my teacher. Is this my teacher?</li>
</ol>
</li>
<li>特殊疑问句<ol>
<li>什么、谁、谁的、哪个…</li>
<li>What…<ol>
<li>你的工作是什么？ </li>
<li>What is you job?</li>
<li>你的名字是什么？</li>
<li>What is your name?</li>
<li>你的电话号码是多少？</li>
<li>What’s you phone number?</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>policeman 警察</li>
<li>police 警方</li>
<li>police car 警车</li>
<li>policewoman 女警察</li>
<li>taxi driver 出租车司机<ol>
<li>taxi 出租车</li>
<li>cab 的士</li>
</ol>
</li>
<li>airhostess 空姐<ol>
<li>air 空气 / 航空</li>
<li>airline 航线 / 航空公司</li>
<li>host 主人</li>
<li>hostess 女主人</li>
<li>-ess 表示女性的后缀</li>
</ol>
</li>
<li>waiter 男服务员<ol>
<li>waitress 女服务员</li>
</ol>
</li>
<li>tiger 老虎<ol>
<li>tigress 母老虎</li>
</ol>
</li>
<li>actro 演员<ol>
<li>actress 女演员</li>
</ol>
</li>
<li>lion<ol>
<li>lioness 母狮子</li>
</ol>
</li>
<li>postman 邮递员<ol>
<li>post 邮政</li>
<li>mailman E-mail</li>
</ol>
</li>
<li>nurse 护士</li>
<li>mechanic 机械师</li>
<li>haredresser 理发师</li>
<li>housewife 家庭主妇<ol>
<li>house 房子</li>
<li>wife 妻子</li>
</ol>
</li>
<li>milkman 送牛奶的人<ol>
<li>man 标识人的后缀</li>
<li>policeman / superman / milkman</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 5-6</title>
    <url>/2020/05/31/Language/English/New%20Concept/Chapter1/lesson5/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>Mr. : 先生<ol>
<li>Miss 未婚女性</li>
<li>Mrs 已婚女性</li>
<li>王先生：Mr. Wang</li>
<li>李叔叔 Uncle Li</li>
</ol>
</li>
<li>good 好<ol>
<li>well 身体好</li>
</ol>
</li>
<li>morning 早晨<ol>
<li>Good morning.</li>
</ol>
</li>
<li>new 新的</li>
<li>old 旧的<ol>
<li>a new car/ a new coat/ a new house</li>
</ol>
</li>
<li>student 学生、</li>
<li>nice </li>
<li>meet 遇见<ol>
<li>meet you  / him / her / me</li>
</ol>
</li>
<li>too 也（肯定，疑问句末）</li>
<li>Frence 法国<ol>
<li>French 法国人，法语的，法国的</li>
<li>I am in France.</li>
<li>I can speak French.</li>
</ol>
</li>
<li>Germany 德国<ol>
<li>German 德国人，德语，德国的</li>
</ol>
</li>
<li>Japan 日本<ol>
<li>Janpanese 日本人，日语的，日本的</li>
</ol>
</li>
<li>Korea 韩国<ol>
<li>Korean 韩国人，韩语，韩国的</li>
</ol>
</li>
<li>China 中国<ol>
<li>Chinese 中国人，中国的，汉语</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>早上见面打招呼：<ol>
<li>Good morning.</li>
<li>Morning!</li>
<li>下午见面打招呼：<ol>
<li>Good afternoon.</li>
</ol>
</li>
<li>晚上见面打招呼<ol>
<li>Good evening</li>
</ol>
</li>
</ol>
</li>
<li>介绍认识：<ol>
<li>This is _.</li>
<li>Nice to meet you.</li>
</ol>
</li>
<li>详细介绍<ol>
<li>She is _.</li>
<li>He is _.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>冠词<ol>
<li>概念：戴在名词头上的帽子，没有<strong>特殊情况</strong>不能摘帽子。<ol>
<li>特殊情况：国家（简写）、国籍、人名、城市名</li>
</ol>
</li>
<li>a nice car/ a big house/ a good name</li>
<li>包括： a / an / the</li>
<li>意思：a \ an  一个，一间，一台，一…<ol>
<li>The 这，那，这些，那些</li>
<li>the student 这个</li>
<li>the students 这些</li>
</ol>
</li>
<li>分类<ol>
<li>定冠词 the —— 确定的、知道的</li>
<li>不定冠词 a \ an  —— 不确定的，不知道的<ol>
<li>There is a monk. 那有一个和尚</li>
<li>The monk is Jack.  那个和尚叫Jack</li>
</ol>
</li>
<li>a / an 的却别<ol>
<li>an + 元音发音开头的单词，其余用a<ol>
<li>an egg</li>
<li>an orange</li>
<li>an hour</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>make 牌子<ol>
<li>What make is _?</li>
<li>What make is you car?</li>
<li>What make are you shoes?</li>
</ol>
</li>
<li>Sweden 瑞典<ol>
<li>Swendish 瑞典人，瑞典的</li>
</ol>
</li>
<li>England 英格兰<ol>
<li>English 英国的，英国人，英语</li>
</ol>
</li>
<li>America 美国<ol>
<li>American 美国人，美国的</li>
<li>The United States of America</li>
</ol>
</li>
<li>Italy 意大利<ol>
<li>Italian 意大利人，意大利语，意大利的</li>
</ol>
</li>
<li>This is a Swedish car.</li>
<li>This is a French car.</li>
<li>This is a German car.</li>
<li>This is Janpanese car.</li>
<li>This is an American car.</li>
<li>This an Italian car.<br>12.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA EntityManager的一个问题</title>
    <url>/2020/05/28/Spring%20Data%20JPA/EntityManager/</url>
    <content><![CDATA[<p>JPA实体生命周期有四种状态</p><ol>
<li><p>New：瞬时对象，尚未有id，还未和Persistence Context建立关联的对象。</p>
</li>
<li><p>Managed：持久化受管对象，有id值，已经和Persistence Context建立了关联的对象。</p>
</li>
<li><p>Datached：游离态离线对象，有id值，但没有和Persistence Context建立关联的对象。</p>
</li>
<li><p>Removed：删除的对象，有id值，尚且和Persistence Context有关联，但是已经准备好从数据库中删除</p>
</li>
</ol><a id="more"></a>

<p>由于JPAQuery绑定EntityManager，查询出来的实体还有ID，实际上是处于Managed状态，查询完毕之后，每一条都会执行一条update语句来更新数据库，比较浪费资源，如果不想这么做的话，可以使用new JPAQuery，而不是JPAQueryFactory，查询完毕，手动执行entityManager.clear()来讲对象改为Detached状态，这样，便不会每一条都执行一遍update操作。</p>
]]></content>
      <categories>
        <category>Spring Data JPA</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 3-4</title>
    <url>/2020/05/26/Language/English/New%20Concept/Chapter1/lesson3/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>umbrella 雨伞</li>
<li>please 请<ol>
<li>求你了</li>
<li>please do 拜托</li>
</ol>
</li>
<li>here 这里<ol>
<li>there 那里</li>
<li>where 哪里</li>
</ol>
</li>
<li>my 我的<ol>
<li>my school</li>
<li>my friend</li>
<li>This is my school.</li>
<li>This is my friend.</li>
</ol>
</li>
<li>your 你的<ol>
<li>your school</li>
<li>your friend</li>
</ol>
</li>
<li>ticket 票<ol>
<li>a train ticket</li>
<li>a move ticket</li>
</ol>
</li>
<li>number 号码<ol>
<li>No. one</li>
</ol>
</li>
<li>five 五</li>
<li>sorry 对不起</li>
<li>sir 先生</li>
<li>cloakroom 衣帽存放处</li>
</ol>
<blockquote>
<p> 课文</p>
</blockquote>
<ol>
<li>My coat and umbrella, please.<ol>
<li>请拿一下我的外套和雨伞</li>
<li>n. + please<ol>
<li>点餐时  A roast duck, please.</li>
<li>购物时  This shirt, please</li>
<li>进站时  Your ID card, please</li>
</ol>
</li>
</ol>
</li>
<li>Here is my ticket.<ol>
<li>My ticket is here.</li>
<li>我的票在这里</li>
</ol>
</li>
<li>Here’s your umbrella and your coat.<ol>
<li>这里是你的雨伞和外套</li>
<li>Your coat and your umbrella are here.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>否定句<ol>
<li>功能：说不</li>
<li>构成：is not/ am not/ are not</li>
<li>This is my name. This is not my name.</li>
<li>I am Venus. I am not Venus.</li>
<li>You are my friend. You are not my friend.</li>
<li>She is pretty. She is not pretty.</li>
<li>这不是我的车。This is not my car. </li>
<li>我不是老师。 I am not a techer.</li>
</ol>
</li>
<li>is not = isn’t<ol>
<li>She is not here.  She isn’t here.</li>
</ol>
</li>
<li>am not = ‘m not<ol>
<li>I am not Linda. I’m not Linda.</li>
</ol>
</li>
<li>are not = aren’t<ol>
<li>You are Tom. You aren’t Tom.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>suit 一套衣服</li>
<li>school 学校<ol>
<li>小学： primary school</li>
<li>中学： middle school</li>
<li>大学：university</li>
</ol>
</li>
<li>teacher 老师<ol>
<li>王老师：Mr.Wang/ Miss Wang</li>
</ol>
</li>
<li>son 儿子</li>
<li>daughter 女儿<br>6.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 1-2</title>
    <url>/2020/05/24/Language/English/New%20Concept/Chapter1/lesson1/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>excuse<ol>
<li>Excuse me<ol>
<li>对不起，打扰了</li>
<li>借过一下，让一让</li>
<li>失陪了</li>
<li>麻烦再说一遍</li>
</ol>
</li>
</ol>
</li>
<li>me <ol>
<li>主格  I   <ol>
<li>I</li>
<li>you </li>
<li>she </li>
<li>he </li>
<li>it</li>
</ol>
</li>
<li>宾格 me<ol>
<li>me</li>
<li>you</li>
<li>her</li>
<li>him</li>
<li>it</li>
</ol>
</li>
<li>简单句 并列句 从句</li>
<li>简单句句型结构<ol>
<li>主+谓</li>
<li>主+谓+宾<ol>
<li>I love you.</li>
<li>I love him.</li>
<li>You love me.</li>
</ol>
</li>
<li>主+谓+宾+宾</li>
<li>主+谓+宾+宾补</li>
<li>主+系（is, am, are）+表<ol>
<li>She is beautiful.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>yes 是的<ol>
<li>yes? 什么事？</li>
</ol>
</li>
<li>is （be动词现在时，第三人称单数）<ol>
<li>be  — is, am, are</li>
</ol>
</li>
<li>this <ol>
<li>this book 这本书</li>
<li>that student 那位学生</li>
</ol>
</li>
<li>your<ol>
<li>your friend 你的朋友</li>
<li>your name 你的名字</li>
</ol>
</li>
<li>handbag <ol>
<li>hand 手  bag 包</li>
</ol>
</li>
<li>pardon 原谅，再说一遍</li>
<li>it  代替物体、地方、天气<ol>
<li>It is a desk.</li>
<li>It is Beijing.</li>
<li>It is find today.</li>
</ol>
</li>
<li>thank you 感谢<ol>
<li>Thanks!</li>
<li>Thanks a lot!</li>
</ol>
</li>
<li>very much 非常地<ol>
<li>I love you very much. </li>
<li>Thank you very much.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Excuse me.<ol>
<li>对不起，打扰了</li>
<li>借过一下，让一让</li>
<li>失陪了</li>
<li>麻烦再说一遍</li>
</ol>
</li>
<li>Yes? 什么事？</li>
<li>Is this your handbag?</li>
<li>Pardon? 麻烦您再说一遍<ol>
<li>Sorry?</li>
<li>Excuse me?</li>
<li>Say it again.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般疑问句<ol>
<li>功能：询问</li>
<li>构成：be动词置于句子前面</li>
<li>This is your name.  Is this your name?</li>
<li>I am nice.  Am I nice?</li>
<li>You are my friend. Are you my friend?</li>
<li>She is pretty.  Is she pretty?</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>pen 钢笔</li>
<li>pencil 铅笔</li>
<li>book 书<ol>
<li>an English book</li>
<li>a book store</li>
<li>book one, book two, book three, book four</li>
</ol>
</li>
<li>watch 手表<ol>
<li>look at my watch</li>
<li>Swatch</li>
</ol>
</li>
<li>coat 外套</li>
<li>dress 连衣裙</li>
<li>skirt 短裙</li>
<li>car 小车</li>
<li>bus 公共汽车</li>
<li>coach 长途汽车</li>
<li>house 别墅<ol>
<li>flat 公寓楼  英</li>
<li>apartment 公寓楼 美</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>数词</title>
    <url>/2020/05/24/Language/English/New%20Concept/Word/Numeral/Numeral/</url>
    <content><![CDATA[<p>常见数词</p>
<a id="more"></a>
<blockquote>
<p>基数词</p>
</blockquote>
<ol>
<li>one 一</li>
<li>two 二</li>
<li>three 三</li>
<li>four 四</li>
<li>five 五</li>
<li>six 六</li>
<li>seven 七</li>
<li>eight 八</li>
<li>nine 九</li>
<li>ten 十</li>
<li>eleven 十一</li>
<li>twelve 十二</li>
<li>thirteen 十三</li>
<li>fourteen 十四</li>
<li>fifteen 十五</li>
<li>sixteen 十六</li>
<li>seventeen 十七</li>
<li>eighteen 十八</li>
<li>nineteen 十九</li>
<li>twenty 二十</li>
<li>thirty 三十</li>
<li>forty 四十</li>
<li>fifty 五十</li>
<li>sixty 六十</li>
<li>seventy 七十</li>
<li>eighty 八十</li>
<li>ninety 九十</li>
<li>hundred 百</li>
<li>thousand 千</li>
<li>million 百万</li>
<li>billion 十亿</li>
<li>twenty one 二十一</li>
<li>fifty nine 五十九</li>
<li>one hundred (and) thirty 一百三</li>
<li>two thousand, five hundred and eight.</li>
<li>six million, five hundred fourty three thousand, two hundred seventy eight.</li>
</ol>
<blockquote>
<p>序数词</p>
</blockquote>
<ol>
<li>first 第一</li>
<li>second 第二</li>
<li>third 第三</li>
<li>fourth 第四</li>
<li>fifth 第五</li>
<li>sixth 第六</li>
<li>seventh 第七</li>
<li>eighth 第八</li>
<li>ninth 第九</li>
<li>tenth 第十</li>
<li>eleventh 第十一</li>
<li>twelfth 第十二</li>
<li>thirteenth 第十三</li>
<li>fourteenth 第十四</li>
<li>fifteenth 第十五</li>
<li>sixteenth 第十六</li>
<li>seventeenth 第十七</li>
<li>eighteenth 第十八</li>
<li>nineteenth 第十九</li>
<li>twentieth 第二十</li>
<li>twenty first 第二十一</li>
<li>twenty second 第二十二</li>
<li>twenty third 第二十三</li>
<li>twenty fourth 第二十四</li>
<li>twenty fifth 第二十五</li>
<li>twenty sixth </li>
<li>twenty seventh</li>
<li>twenty eighth</li>
<li>twenty ninth</li>
<li>thirtieth 第三十</li>
<li>thirth first<br>32.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>连词</title>
    <url>/2020/05/23/Language/English/New%20Concept/Word/Conjunction/Conjunction/</url>
    <content><![CDATA[<p>常见连词</p>
<a id="more"></a>
<ol>
<li>and 和，然后<ol>
<li>Do it slowly and carefully.</li>
<li>She came in and sat down.</li>
</ol>
</li>
<li>or 或者；否则<ol>
<li>Is the baby a boy or a girl?</li>
<li>Wear your coat or you’ll catch cold.</li>
</ol>
</li>
<li>but 但是<ol>
<li>It’s an old car, but it’s very good.</li>
<li>I’d like to go but I’m too busy.</li>
</ol>
</li>
<li>when 当…时<ol>
<li>It was raining when we arrived.</li>
<li>I loved history when I was at school.</li>
</ol>
</li>
<li>while 在…期间，当…时；然而<ol>
<li>He fell aslleep while (he was) doing his homework.</li>
<li>Tom is good at English while his brother doesn’t.</li>
</ol>
</li>
<li>as 当…时；想…一样；由于<ol>
<li>I saw Peter as I was getting off the bus.</li>
<li>They did as I had asked.</li>
<li>As you weren’t there I left a message.</li>
</ol>
</li>
<li>before 在…以前<ol>
<li>Do it before you forget.</li>
<li>Did she leave a message before she left?</li>
</ol>
</li>
<li>after 在…以后<ol>
<li>I’ll call you after I get off the plane.</li>
<li>They arrived shortly after I left.</li>
</ol>
</li>
<li>as soon as 一…就…<ol>
<li>As soon as I saw her, I knew there was something wrong.</li>
<li>He left as soon as he heard the news.</li>
</ol>
</li>
<li>since 自从…以来；既然<ol>
<li>Where have you been since I last saw you ?</li>
<li>Since we have money, we can buy a new car.</li>
</ol>
</li>
<li>until 直到<ol>
<li>Wait until the rain stops.</li>
<li>Don’t leave until I arrive.</li>
</ol>
</li>
<li>because 因为<ol>
<li>I decided to go with them, because I had nothing to do.</li>
<li>Why can’t I go? Because you’re not old enough.</li>
</ol>
</li>
<li>for 因为，由于<ol>
<li>I believed her, for she would not lie to me.</li>
<li>He had to give up smoking, for his wife was pregnant.</li>
</ol>
</li>
<li>so 因此<ol>
<li>The shops were closed so I didn’t get any milk.</li>
<li>I was hungry, so I made myself a sandwich.</li>
</ol>
</li>
<li>if 如果<ol>
<li>If it is necessary I will come at 6.</li>
<li>You can stay to dinner if you like.</li>
</ol>
</li>
<li>unless 除非<ol>
<li>He won’t go to sleep unless you tell him a story.</li>
<li>I can’t leave you unless I know you are all right.</li>
</ol>
</li>
<li>although 尽管，虽然</li>
<li>though<ol>
<li>Although we all tried our best, we lost the game.</li>
<li>Although he entered the game for fun, he won first prize.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>介词</title>
    <url>/2020/05/18/Language/English/New%20Concept/Word/Prepositions/Prepositions/</url>
    <content><![CDATA[<p>常见介词</p>
<a id="more"></a>
<ol>
<li>about  关于<ol>
<li>Tell me about it.</li>
<li>There’s nothing I can do about it.</li>
</ol>
</li>
<li>above 在…之上；超过<ol>
<li>We were flying above the clouds.</li>
<li>We don’t accept children above the age of 10.</li>
</ol>
</li>
<li>across 横穿；在…对面<ol>
<li>He swam across the river.</li>
<li>My house is just across the street.</li>
</ol>
</li>
<li>after 在…后面；在…以后<ol>
<li>After you.</li>
<li>We’ll leave after lunch.</li>
</ol>
</li>
<li>against 反对；紧靠<ol>
<li>Most people are against the plan.</li>
<li>He was leaning against a tree.</li>
</ol>
</li>
<li>alone 沿着<ol>
<li>We walked slowly along the road.</li>
<li>Houses were built along both sides of the river.</li>
</ol>
</li>
<li>among 在…中间<ol>
<li>He found it among a pile of old books.</li>
<li>She was the eldest among them.</li>
</ol>
</li>
<li>around 围绕；在附近；大约；到处<ol>
<li>The earth moves around the sun.</li>
<li>It’s somewhere around here.</li>
<li>See you around 7:30.</li>
<li>travel around the world</li>
</ol>
</li>
<li>as 作为；像<ol>
<li>You can use that glass as a vase.</li>
<li>They were all dressed as clowns.</li>
</ol>
</li>
<li>at 在<ol>
<li>They arrived at the airport.</li>
<li>We left at 2 o’clock.</li>
</ol>
</li>
<li>before 在…之前<ol>
<li>the day before yesterday</li>
<li>Larry arrived home before me.</li>
</ol>
</li>
<li>behind 在…的后面<ol>
<li>Who’s the girl standing behind Richard?</li>
<li>I hid behind a tree.</li>
</ol>
</li>
<li>below 在…下面，低于..<ol>
<li>Please do not write below this line.</li>
<li>The temperatures remained below zero all day.</li>
</ol>
</li>
<li>beside 在…旁边<ol>
<li>Sit beside your sister.</li>
<li>Put it on the table beside the bed.</li>
</ol>
</li>
<li>besides 除…之外（还有）<ol>
<li>We have lots of things in common besides music.</li>
<li>There will be five of us, besides John.</li>
</ol>
</li>
<li>between 在…之间<ol>
<li>Peter sat between Mary and Jane.</li>
<li>I don’t eat between meals.</li>
</ol>
</li>
<li>beyond 超过，越过<ol>
<li>It won’t go on beyound midnight.</li>
<li>The bicycle is beyond repair.</li>
</ol>
</li>
<li>but 除…之外<ol>
<li>Everyone was there but him.</li>
<li>Nobody but you could be so selfish.</li>
</ol>
</li>
<li>down 向下；沿着…向下<ol>
<li>The stone rolled down the hill.</li>
<li>Go down the road till you reach the traffic lights.</li>
</ol>
</li>
<li>during 在…期间<ol>
<li>During the summer she worked as a lifeguard.</li>
<li>He was taken to the hospital during the night.</li>
</ol>
</li>
<li>except 除…外<ol>
<li>They all came except Matt.</li>
<li>The restaurant is open every day except Monday.</li>
</ol>
</li>
<li>for 为，为了<ol>
<li>Is the present for me?</li>
<li>What can I do for you?</li>
</ol>
</li>
<li>from 从…;来自;<ol>
<li>We’re open from 8 to 7 every day.</li>
<li>Where are you from?</li>
</ol>
</li>
<li>in 在…里面，在…以内；进入；在…之后<ol>
<li>the highest mountain in the world</li>
<li>What have you got in your hand?</li>
<li>Throw it in the fire.</li>
<li>I’ll be back in two hours.</li>
</ol>
</li>
<li>inside 在（往）…里面<ol>
<li>Go inside the house.</li>
<li>There was a gold watch inside the box.</li>
</ol>
</li>
<li>into 进入…中<ol>
<li>There must be another way into the cave.</li>
<li>I nearly ran into a bus.</li>
</ol>
</li>
<li>like 像（某人/某事物），类似<ol>
<li>He’s like his father.</li>
<li>What’s she like?</li>
</ol>
</li>
<li>near 接近，靠近<ol>
<li>They live near London.</li>
<li>Don’t sit near the door.</li>
</ol>
</li>
<li>of 属于…的；关于；表示数量<ol>
<li>a friend of mine</li>
<li>the rights of man</li>
<li>a map of China</li>
<li>a piece of paper</li>
</ol>
</li>
<li>off 从…落下或离开<ol>
<li>Keep off the grass.</li>
<li>The ball rolled off the table.</li>
</ol>
</li>
<li>on 在…上；在…之时；在某一天<ol>
<li>Put the glasses on the table.</li>
<li>On hearing the news, she cried.</li>
<li>I was born on November 29th.</li>
</ol>
</li>
<li>outside 在…的外面；超出…的范围<ol>
<li>You can park your car outside our house.</li>
<li>The matter is outside my area of responsibility.</li>
</ol>
</li>
<li>over 越过；在…上面<ol>
<li>There is a bridge over the river.</li>
<li>There was a lamp over the table.</li>
</ol>
</li>
<li>past 在…之后；经过<ol>
<li>half past two</li>
<li>She walked past me without saying hi.</li>
</ol>
</li>
<li>since 自从<ol>
<li>I haven’t eaten since breakfast.</li>
<li>We’ve been waiting here since two o’clock.</li>
</ol>
</li>
<li>through 穿过<ol>
<li>He got in through the window.</li>
<li>The River Thames flows through London.</li>
</ol>
</li>
<li>throughout 遍及…；自始至终<ol>
<li>News spread throughout the country.</li>
<li>He remained in Paris throughout the war.</li>
</ol>
</li>
<li>till 直到<ol>
<li>We’re open till 6 o’clock.</li>
<li>The street is full of traffic from morning till night.</li>
</ol>
</li>
<li>to 向，朝着；到<ol>
<li>I’m on my way to the airport.</li>
<li>I’m free from Monday to Friday.</li>
</ol>
</li>
<li>towards 朝，向</li>
<li>toward<ol>
<li>All the windows face towards the river.</li>
<li>Two policemen were coming towards him.</li>
</ol>
</li>
<li>under 在…下面<ol>
<li>The cat was under the table.</li>
<li>Have you looked under the bed?</li>
</ol>
</li>
<li>until 直到<ol>
<li>Wait until tomorrow.</li>
<li>Until now I haven’t heard from him.</li>
</ol>
</li>
<li>with 和，跟；有；用<ol>
<li>She lives with her parents.</li>
<li>Do you see the girl with red hair?</li>
<li>Cut it with a knife.</li>
</ol>
</li>
<li>within 在…内<ol>
<li>You will receive a reply within seven days.</li>
<li>Is it within walking distance?</li>
</ol>
</li>
<li>without 没有<ol>
<li>Don’t go out without you coat.</li>
<li>He left without saying goodbye.</li>
</ol>
</li>
<li>worth 值得<ol>
<li>The house must be worth a lot of money now.</li>
<li>The film is well worth seeing.<br>3.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Security碰到的一些问题</title>
    <url>/2020/05/18/Spring%20Security/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Problems/</url>
    <content><![CDATA[<p>2020-05-18 碰到的问题</p><p>添加了@PreAuthorize注解后，访问某些方法，在这些方法体内，对象无法自动注入，因此会直接抛出NullPointerException，经查，使用该注解的方法，必须为public，否则，无法自动注入。</p><a id="more"></a>

<p>原因为，SpringSecurity使用AOP来进行包装，而AOP，只能对公共方法进行运行时修改。</p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>代词</title>
    <url>/2020/05/17/Language/English/New%20Concept/Word/Pronoun/Pronoun/</url>
    <content><![CDATA[<p>常见代词</p>
<a id="more"></a>
<ol>
<li>I 我<ol>
<li>I moved to this city six years ago.</li>
<li>I am late again.</li>
</ol>
</li>
<li>me 宾格 我<ol>
<li>Give it to me.</li>
<li>Hello, it’s me.</li>
</ol>
</li>
<li>my determiner  我的<ol>
<li>He alaways forgets my birthday.</li>
<li>Where’s my hat?</li>
</ol>
</li>
<li>mine 我的<ol>
<li>That book is mine.</li>
<li>He’s a friend of mine.</li>
</ol>
</li>
<li>myself 我自己<ol>
<li>I can look after myself.</li>
<li>I cut myself with a knife.</li>
</ol>
</li>
<li>we 我们<ol>
<li>Shall we stop for a coffee?</li>
<li>We’ll move to Australia.</li>
</ol>
</li>
<li>us 宾格 我们<ol>
<li>Please help us.</li>
<li>My mother is coming to stay with us.</li>
</ol>
</li>
<li>our determiner 我们的<ol>
<li>When is our next meeting?</li>
<li>We’re expecting our first baby.</li>
</ol>
</li>
<li>ours 我们的<ol>
<li>I’ll show you to your room. Ours is next door.</li>
<li>Their house is very similar to ours.</li>
</ol>
</li>
<li>ourselves 我们自己<ol>
<li>We built the house ourselves.</li>
<li>Let’s just relax and enjoy ourselves.</li>
</ol>
</li>
<li>you 你，你们<ol>
<li>How are you?</li>
<li>I love you.</li>
</ol>
</li>
<li>your determiner 你的，你们的<ol>
<li>Do you like your new job?</li>
<li>Don’t worry. It’s not your fault.</li>
</ol>
</li>
<li>yours 你的，你们的<ol>
<li>Is that book yours?</li>
<li>My hair is thicker than yours.</li>
</ol>
</li>
<li>yourself 你自己<ol>
<li>Have you hurt yourself?</li>
<li>Go and buy yourself an ice cream.</li>
</ol>
</li>
<li>yourselves 你们自己<ol>
<li>Help yourselves.</li>
<li>You yourselves are the guilty ones.</li>
</ol>
</li>
<li>he 他<ol>
<li>Who is he?</li>
<li>He is my best friend.</li>
</ol>
</li>
<li>him 他<ol>
<li>Do you love him?</li>
<li>Don’t believe him.</li>
</ol>
</li>
<li>his determiner 他的<ol>
<li>I love his sense of humour.</li>
<li>My eyesight is better than his.</li>
</ol>
</li>
<li>himself 他自己<ol>
<li>He cut himself.</li>
<li>It must be true - he said so himself.</li>
</ol>
</li>
<li>she 她<ol>
<li>She is my cousin.</li>
<li>She looks like her mother.</li>
</ol>
</li>
<li>her determiner 她，她的<ol>
<li>I don’t know her.</li>
<li>She’s looking for her key.</li>
</ol>
</li>
<li>hers 她的<ol>
<li>The idea was hers.</li>
<li>The handbag must be hers.</li>
</ol>
</li>
<li>herself 她自己<ol>
<li>She hurt herself.</li>
<li>She must be proud of herself.</li>
</ol>
</li>
<li>it 它<ol>
<li>It’s such a cute puppy!</li>
<li>Did you see it?</li>
</ol>
</li>
<li>its 它的<ol>
<li>The dog had hurt its paw.</li>
<li>The hotel has its own pool.</li>
</ol>
</li>
<li>itself 它自己<ol>
<li>The cat licked itself all over.</li>
<li>The machine will start by itself in a few seconds.</li>
</ol>
</li>
<li>they 他们<ol>
<li>I’ve got two sisters. They’re both doctors.</li>
<li>They went for a walk.</li>
</ol>
</li>
<li>them 他们<ol>
<li>Tell them the news.</li>
<li>We needn’t worry about them.</li>
</ol>
</li>
<li>their determiner 他们的<ol>
<li>The twins spend all their time together.</li>
<li>Which is their house?</li>
</ol>
</li>
<li>theirs 他们的<ol>
<li>Our cat is dark gray, but theirs is black.</li>
<li>Your yard is big, but I think theirs is bigger.</li>
</ol>
</li>
<li>themselves 他们自己<ol>
<li>They seemed to be enjoying themselves.</li>
<li>The children can look after themselves for a couple of hours.</li>
</ol>
</li>
<li>this 这，这个<ol>
<li>Listen to this.</li>
<li>We must make sure this doesn’t happen again.</li>
</ol>
</li>
<li>that 那，那个<ol>
<li>Who’s that?</li>
<li>That’s a nice dress.</li>
</ol>
</li>
<li>these 这些<ol>
<li>These are my children.</li>
<li>I bought these shoes in HK.</li>
</ol>
</li>
<li>those 那些<ol>
<li>Those are nice paintings.</li>
<li>Who are those people?</li>
</ol>
</li>
<li>such 这样的事物（人）<ol>
<li>There is no such thing as a free lunch.</li>
<li>Reading is boring. Such is her opinion before she met Dan.</li>
</ol>
</li>
<li>so 如此，这样<ol>
<li>I think so.</li>
<li>Is that so?</li>
</ol>
</li>
<li>same 同一事物，同样的人<ol>
<li>Their ages are <strong>the same</strong>.</li>
<li>I’ll have a coffee. Same for me, please.</li>
</ol>
</li>
<li>who 谁<ol>
<li>Who is that woman?</li>
<li>Who are you calling?</li>
</ol>
</li>
<li>whom 谁<ol>
<li>Whom did they invite?</li>
<li>Whom are you talking about?</li>
</ol>
</li>
<li>whose 谁的<ol>
<li>Whose is this jacket?</li>
<li>That’s the man whose car is damaged.</li>
</ol>
</li>
<li>which 哪一个，哪一些<ol>
<li>Which book are you looking for?</li>
<li>Which way is quicker, by bus or by train?</li>
</ol>
</li>
<li>what 什么<ol>
<li>What did you say?</li>
<li>What does it mean?</li>
</ol>
</li>
<li>whoever 无论谁<ol>
<li>Whoever says that is a liar.</li>
<li>I’ll take whoever wants to go.</li>
</ol>
</li>
<li>whichever 无论哪个<ol>
<li>Whichever they choose, we must accept their decision.</li>
<li>Whichever you buy, I’ll pay for it.</li>
</ol>
</li>
<li>whatever 无论什么<ol>
<li>You can eat whatever you like.</li>
<li>Keep calm, whatever happens.</li>
</ol>
</li>
<li>one 一个，任何人<ol>
<li>I forget to bring a pen. Could you lend me one?</li>
<li>One is never too old to learn.</li>
</ol>
</li>
<li>some 一些<ol>
<li>I’ve just made a pot of coffee. Would you like some?</li>
<li>Some of the chairs are broken.</li>
</ol>
</li>
<li>any 任何，一些<ol>
<li>Have you got any?</li>
<li>She didn’t spend any of the money.</li>
</ol>
</li>
<li>each 每个<ol>
<li>Red or blue? I’ll take one of each, please.</li>
<li>We each have our own car.</li>
</ol>
</li>
<li>every 每一<ol>
<li>Every day seemed the same to him.</li>
<li>We enjoyed every minute of our stay.</li>
</ol>
</li>
<li>no 没有<ol>
<li>I’ve got no money.</li>
<li>There’s no bread left.</li>
</ol>
</li>
<li>many 很多<ol>
<li>Many of the students were from Japan.</li>
<li>How many do you want?</li>
</ol>
</li>
<li>much 很多<ol>
<li>I’ve got too much to do.</li>
<li>Is there any milk? Not much.</li>
</ol>
</li>
<li>few 很少<ol>
<li>Few of his books are worth reading.</li>
<li>Few can live to 100.</li>
</ol>
</li>
<li>little 很少<ol>
<li>I understood little of what he said.</li>
<li>We read a lot of poetry as school. I remember very little now.</li>
</ol>
</li>
<li>a few 少数，一点儿<ol>
<li>A few of the seats were empty.</li>
<li>I recognized a few of the guests.</li>
</ol>
</li>
<li>a little 很少<ol>
<li>There was a lot of ood but I only ate a little.</li>
<li>I’ve only read a little of the book.</li>
</ol>
</li>
<li>other 其他的（人或物）<ol>
<li>He walked from one side of the road to the other.</li>
<li>Have you told the others?</li>
</ol>
</li>
<li>another 另一个<ol>
<li>Can I have another?</li>
<li>Not another!</li>
</ol>
</li>
<li>all 全部，一切<ol>
<li>All of the toys were broken.</li>
<li>Not all of them were invited.</li>
</ol>
</li>
<li>both 二者都<ol>
<li>His parents are both dead.</li>
<li>Both of us want to go to the party.</li>
</ol>
</li>
<li>none 没有人（物）<ol>
<li>None of the guests wants to stay.</li>
<li>None of the money is mine.</li>
</ol>
</li>
<li>neither 两者都不<ol>
<li>Neither of them can cook.</li>
<li>Whick do you like ? Neithre. I think they’re both ugly.</li>
</ol>
</li>
<li>either 任何一个（两者之中）<ol>
<li>You can park on either side of the street.</li>
<li>Does either of you speak French?</li>
</ol>
</li>
<li>something 某物，某事<ol>
<li>I want something to eat.</li>
<li>There’s something in my eye.</li>
</ol>
</li>
<li>somebody 某人，有人</li>
<li>someone<ol>
<li>There’s somebody at the door.</li>
<li>Somebody from your office called.</li>
</ol>
</li>
<li>anything 任何东西<ol>
<li>You can buy anything you want.</li>
<li>Is there anything I can do to help?</li>
</ol>
</li>
<li>anybody 任何人</li>
<li>anyone<ol>
<li>Did anybody see you?</li>
<li>I didn’t tell anybody.</li>
</ol>
</li>
<li>everything 每件事物，一切<ol>
<li>Everything’s fine.</li>
<li>I decided to tell her everything.</li>
</ol>
</li>
<li>everybody 每人</li>
<li>everyone<ol>
<li>Everybody knows Tom.</li>
<li>Everybody likes birthday cake.</li>
</ol>
</li>
<li>nothing 没有东西<ol>
<li>There’s nothing in this box.</li>
<li>What’s that in your pocket? Oh, nothing.</li>
</ol>
</li>
<li>nobody 没有人</li>
<li>no one<ol>
<li>Nobody came to see me.</li>
<li>I knocked on the door but nobody answered.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>常见副词</title>
    <url>/2020/05/13/Language/English/New%20Concept/Word/Adverbs/Adverbs/</url>
    <content><![CDATA[<p>常见副词</p>
<a id="more"></a>
<ol>
<li><p>about 大约</p>
<ol>
<li>We left the restaurant at about 10:30.</li>
<li>They waited for about an hour.</li>
</ol>
</li>
<li><p>above 在上面；以上；上述</p>
<ol>
<li>Put it on the shelf above.</li>
<li>children aged 12 and above</li>
<li>Write to the address above for further information.</li>
</ol>
</li>
<li><p>abroad 到国外，在国外</p>
<ol>
<li>I’ve never lived abroad before.</li>
<li>She often goes abroad on business.</li>
</ol>
</li>
<li><p>across 横过，越过</p>
<ol>
<li>Can you swim across?</li>
<li>Why don’t you go across and say hello?</li>
</ol>
</li>
<li><p>actually 实际上，事实上</p>
<ol>
<li>I’ve known Lily for years. Since we were babies, actually.</li>
<li>Disappointed? No, autually I’m rather glad.</li>
</ol>
</li>
<li><p>ago 以前</p>
<ol>
<li>not long ago</li>
<li>Her husband died 14 years ago.</li>
</ol>
</li>
<li><p>almost 几乎，差不多</p>
<ol>
<li>It’s almost time to go.</li>
<li>Dinner’s almost ready.</li>
</ol>
</li>
<li><p>alone 单独地，独自地</p>
<ol>
<li>She lives alone.</li>
<li>You shouldn’t leave a child alone in the house.</li>
</ol>
</li>
<li><p>along 向前， 往前</p>
<ol>
<li>The policeman told the crowds to move along.</li>
<li>Come along or we’ll be late.</li>
</ol>
</li>
<li><p>aloud 高声，大声</p>
<ol>
<li>He read the letter aloud to us.</li>
<li>What did you say?  Sorry, I was just thinking aloud.</li>
</ol>
</li>
<li><p>absolutely 绝对的，完全地</p>
<ol>
<li>It’s absolutely impossible</li>
<li>You’re absolutely right.</li>
</ol>
</li>
<li><p>already 已经</p>
<ol>
<li>I’ve already seen that film.</li>
<li>You already told me that.</li>
</ol>
</li>
<li><p>also 也，并且</p>
<ol>
<li>He is young and good-looking and also very rich.</li>
<li>My boyfriend was also called Dave.</li>
</ol>
</li>
<li><p>always 总是，一直</p>
<ol>
<li>He always wear a tie.</li>
<li>I’ve always wanted to go to Paris.</li>
</ol>
</li>
<li><p>anytime 任何时候</p>
<ol>
<li>You can come and see me anytime you like.</li>
</ol>
</li>
<li><p>anywhere 任何地方</p>
<ol>
<li>I can’t see it anywhere.</li>
<li>We can go anywhere you like.</li>
</ol>
</li>
<li><p>around 大约；到处；在周围</p>
<ol>
<li>around 100 people</li>
<li>He traveled around in Europe for six weeks.</li>
</ol>
</li>
<li><p>back 回到以前的位置、状况或阶段；向后地</p>
<ol>
<li>Put the book back on the shelf.</li>
<li>I’ll be back by six o’clock.</li>
<li>Sit back in your chair.</li>
</ol>
</li>
<li><p>badly 坏地；非常，在很大程度上</p>
<ol>
<li>I did badly in my exams.</li>
<li>I miss you badly.</li>
<li>They wanted to win so badly.</li>
</ol>
</li>
<li><p>before 先前，以前</p>
<ol>
<li>Have we met before?</li>
<li>I’ve seen that film before.</li>
</ol>
</li>
<li><p>below 在下面，到下面</p>
<ol>
<li>They live on the floor below.</li>
<li>Captain Parker went below.</li>
</ol>
</li>
<li><p>besides 而且，此外</p>
<ol>
<li>I don’t really want to go. Besides, it’s too late now.</li>
</ol>
</li>
<li><p>carefully 小心地，仔细地</p>
<ol>
<li>Think carefully before you answer me.</li>
</ol>
</li>
<li><p>carelessly 粗心大意地</p>
<ol>
<li>He carelessly left the door unlocked.</li>
</ol>
</li>
<li><p>certainly 当然</p>
<ol>
<li>May I se you passport, Mr.Scott?  Certainly.</li>
<li>May I go? Certainly not!</li>
</ol>
</li>
<li><p>clearly 清楚的，明确的，显然的</p>
<ol>
<li>She explained everything very clearly.</li>
<li>Clearly, you should tell her the truth.</li>
</ol>
</li>
<li><p>directly 直接地，径直的</p>
<ol>
<li>He looked directly at me.</li>
<li>He drove her directly to her totel.</li>
</ol>
</li>
<li><p>down （做躺倒）下；向下</p>
<ol>
<li>Please sit down.</li>
<li>He had to go and lie down for a while.</li>
<li>Turn the music down!</li>
</ol>
</li>
<li><p>downstairs 在楼下，到楼下</p>
<ol>
<li>They’re waiting for us dwonstairs.</li>
<li>He fell downstairs and broke his leg.</li>
</ol>
</li>
<li><p>early 早</p>
<ol>
<li>We arrived early.</li>
<li>She went out early in the morning.</li>
</ol>
</li>
<li><p>easily 容易的，轻易地</p>
<ol>
<li>They won quite easily.</li>
<li>I can easily finish it tonight.</li>
</ol>
</li>
<li><p>either 也（否定句中）</p>
<ol>
<li>Pete can’t go and I can’t either.</li>
<li>I know a good Italian restaurant. It’s not far from here, either.</li>
</ol>
</li>
<li><p>else 其他</p>
<ol>
<li>Did you see anybody else?</li>
<li>Ask somebody else to help you.</li>
</ol>
</li>
<li><p>enough 足够的，充足的</p>
<ol>
<li>Tell them it’s just not good enough.</li>
<li>She’e old enough to decide for herself.</li>
</ol>
</li>
<li><p>especially 尤其的，专门的</p>
<ol>
<li>I love Beijing, especially in the spring.</li>
<li>I made it especially for you.</li>
</ol>
</li>
<li><p>even 甚至</p>
<ol>
<li>Even a child can understand the book.</li>
<li>It is cold there even in summer.</li>
</ol>
</li>
<li><p>eventually 最终，最后</p>
<ol>
<li>Eventually, she got a job and moved to London.</li>
<li>Did he pay you back? Yes, eventually.</li>
</ol>
</li>
<li><p>ever 曾经，永远</p>
<ol>
<li>Have you ever been to Pairs?</li>
<li>Nothing lasts for ever?</li>
</ol>
</li>
<li><p>everywhere 到处，处处</p>
<ol>
<li>I’ve looked everywhere but I can’t find my phone.</li>
<li>You must have seen the posters, they’re everywhere.</li>
</ol>
</li>
<li><p>exactly 精确地，确切地</p>
<ol>
<li>I know exactly how she felt.</li>
<li>Do exactly as I tell you.</li>
</ol>
</li>
<li><p>extremely 极端地，非常</p>
<ol>
<li>She found it extremely difficult to get a job.</li>
<li>I’m extremely sorry to have kept you waiting.</li>
</ol>
</li>
<li><p>far 有多远；到很大程度</p>
<ol>
<li>How far is it to London from here?</li>
<li>We didn’t go far.</li>
<li>How far can we trust him.</li>
</ol>
</li>
<li><p>fast 快，迅速地</p>
<ol>
<li>Slow down -you’re driving too fast.</li>
<li>My son grows up so fast these days.</li>
</ol>
</li>
<li><p>finally 最后，终于</p>
<ol>
<li>The plane finally took off an hour later.</li>
<li>And finally, I would like to thank you all for coming here today.</li>
</ol>
</li>
<li><p>first 最早，首次，首先</p>
<ol>
<li>Ladies first.</li>
<li>I’ll finish my work first.</li>
<li>When did you first meet him?</li>
<li>First, I’d like to thank everyone for coming.</li>
</ol>
</li>
<li><p>forever 永远</p>
<ol>
<li>I’ll love you forever!</li>
<li>It takes her forever to get dressed.</li>
</ol>
</li>
<li><p>free 免费的</p>
<ol>
<li>Children under four can travel free.</li>
<li>He offered to do the work for free.</li>
</ol>
</li>
<li><p>frequently 频繁的的，经常</p>
<ol>
<li>The questoin is frequently asked.</li>
</ol>
</li>
<li><p>happily 快乐的，幸福的</p>
<ol>
<li>Michael smiled happily.</li>
<li>So she married the prince, ant they lived happily ever after.</li>
</ol>
</li>
<li><p>hard 努力的，猛力的</p>
<ol>
<li>She has worked hard all her life.</li>
<li>It was raining very hard.</li>
</ol>
</li>
<li><p>hardly 几乎不</p>
<ol>
<li>I hardly know her.</li>
<li>I can hardly believe it.</li>
</ol>
</li>
<li><p>heavily 大量的</p>
<ol>
<li>It’s been raining heavily all day.</li>
<li>Paul was drinking heavily then.</li>
</ol>
</li>
<li><p>high 高的</p>
<ol>
<li>He kicked the ball high into the air.</li>
<li>I can’t jump any higher.</li>
</ol>
</li>
<li><p>highly 高度的，非常</p>
<ol>
<li>She speaks highly of you.</li>
<li>a highly successful move</li>
</ol>
</li>
<li><p>home 在家，回家</p>
<ol>
<li>He went home.</li>
<li>She’s on her way home.</li>
<li>I like to stay home in the evenings.</li>
</ol>
</li>
<li><p>how 怎样；以任何方式</p>
<ol>
<li>How are you?</li>
<li>How can i help you ?</li>
<li>How did you get here?</li>
</ol>
</li>
<li><p>however 然而；无论如何</p>
<ol>
<li>Later, however, he changed his mind.</li>
<li>You won’t move that stone, however strong you are.</li>
</ol>
</li>
<li><p>immediately 立即，马上</p>
<ol>
<li>The telephone rang, and he asnwered it immediately.</li>
<li>He left the party immediately.</li>
</ol>
</li>
<li><p>in 进入；在家，在工作处</p>
<ol>
<li>Come in.</li>
<li>Nobody was in when I called.</li>
<li>I’m afraid the manager isn’t in today.</li>
</ol>
</li>
<li><p>indeed 的确，确实</p>
<ol>
<li>Was he very angry? Indeed he was.</li>
<li>That is indeed remarkable!</li>
</ol>
</li>
<li><p>just 刚刚；仅仅；正好</p>
<ol>
<li>I just got home.</li>
<li>Don’t be too hard on him - he’s just a kid.</li>
<li>It’s just my size.</li>
</ol>
</li>
<li><p>largely 大部分的，主要的</p>
<ol>
<li>The country is largely desert.</li>
<li>I want to leave Beijing largely because of the weather.</li>
</ol>
</li>
<li><p>last 上一次；最后</p>
<ol>
<li>When did you last see him?</li>
<li>They arrived last of all.</li>
</ol>
</li>
<li><p>later 后来</p>
<ol>
<li>See you later.</li>
<li>She later became a doctor.</li>
</ol>
</li>
<li><p>little 少许，一点</p>
<ol>
<li>I slept very little last night.</li>
<li>I was a little surprised.</li>
</ol>
</li>
<li><p>luckily 幸运的</p>
<ol>
<li>Luckily, I was not at home.</li>
<li>Luckily for them, he stopped the car in time.</li>
</ol>
</li>
<li><p>mainly 大部分的，主要的</p>
<ol>
<li>Her illness was caused mainly by stress.</li>
<li>I didn’t come mainly because I didn’t feel very well.</li>
</ol>
</li>
<li><p>maybe 也许，有可能</p>
<ol>
<li>Maybe they’re right, but maybe not.</li>
<li>Is that true? Maybe, I’m not sure.</li>
</ol>
</li>
<li><p>mostly 大部分，多半</p>
<ol>
<li>Green teas are mostly from China or Japan.</li>
<li>There were about fifteen people at the party, mostly women.</li>
</ol>
</li>
<li><p>muc 非常；差不多；很多的</p>
<ol>
<li>Thatk you very much.</li>
<li>You worry too much.</li>
<li>She’s much better today.</li>
<li>The other car was much too expensive.</li>
</ol>
</li>
<li><p>nearby 在附近</p>
<ol>
<li>Do you live nearby?</li>
<li>The car is parked nearby.</li>
</ol>
</li>
<li><p>nearly 几乎，差不都</p>
<ol>
<li>We’re nearly there.</li>
<li>It’s nearly time to leave.</li>
</ol>
</li>
<li><p>necessarily 必要的，必须的</p>
<ol>
<li>That is not necessarily true.</li>
<li>Biggest doesn’t necessarily mean best.</li>
</ol>
</li>
<li><p>never 从不，从来没有</p>
<ol>
<li>He has never been abroad.</li>
<li>It is never too late to give up smoking.</li>
</ol>
</li>
<li><p>next 接下去；然后</p>
<ol>
<li>Who’s next?</li>
<li>What did you do next?</li>
</ol>
</li>
<li><p>no 不</p>
<ol>
<li>Just say yes or no.</li>
<li>Are you ready? No, I’m not.</li>
<li>She’s feeling no better this morning.</li>
</ol>
</li>
<li><p>not 不</p>
<ol>
<li>I did not see him.</li>
<li>Will she be there? I hope not.</li>
<li>Who did it? Not me.</li>
</ol>
</li>
<li><p>now 现在</p>
<ol>
<li>It’s too late now.</li>
<li>He’ll be home by now.</li>
<li>It’s broken. Now I’ll have to get a new one.</li>
</ol>
</li>
<li><p>nowadays 现在，当今</p>
<ol>
<li>Nowadays most kids prefer watching TV to reading.</li>
<li>Lots of people get divorced nowadays.</li>
</ol>
</li>
<li><p>obviously 明显的</p>
<ol>
<li>He was obviously drunk.</li>
<li>They’re obviously not coming.</li>
</ol>
</li>
<li><p>occasionally 偶尔，有时候</p>
<ol>
<li>We only see each other occasionally.</li>
<li>We occasionally meet for a drink after work.</li>
</ol>
</li>
<li><p>off 离开；关掉</p>
<ol>
<li>Take your coat off.</li>
<li>He ran off with the money.</li>
<li>Make sure the TV is off.</li>
</ol>
</li>
<li><p>often 常常，经常</p>
<ol>
<li>It often rains here in April.</li>
<li><strong>How often</strong> do you go to the cinema?</li>
</ol>
</li>
<li><p>on （穿，放，连接）上；（继续）下去；在接通或使用中</p>
<ol>
<li>Put on your coat.</li>
<li>She talked on for two hours without stopping.</li>
<li>The lights were all on.</li>
</ol>
</li>
<li><p>once 一次；曾经</p>
<ol>
<li>I’ve only been there once.</li>
<li>Once bitten, twice shy.</li>
<li>I once met your mother.</li>
</ol>
</li>
<li><p>only 只，仅仅</p>
<ol>
<li>It was only a joke.</li>
<li>It’s only eight o’clock.</li>
<li>Only in Paris do you find bars like this.</li>
</ol>
</li>
<li><p>out 离开某地；不在家，不在工作地点；表示某事物已经暴露，不在隐蔽</p>
<ol>
<li>Get out!</li>
<li>I called Sally but she was out.</li>
<li>The secret is out.</li>
</ol>
</li>
<li><p>outside 在外面；在户外</p>
<ol>
<li>Please wait outside.</li>
<li>It’s warm enough to eat outside.</li>
</ol>
</li>
<li><p>over 结束；倒下；从一边倒另一边；穿过，横过</p>
<ol>
<li>Their relationship is over.</li>
<li>Don’t knock that vase over.</li>
<li>Turn over the page.</li>
<li>I’m on my way over.</li>
</ol>
</li>
<li><p>partly 在一定程度上；部分的</p>
<ol>
<li>He was only partly responsible for the accident.</li>
<li>I didn’t enjoy the trip very much, partly beacuse of the weather.</li>
</ol>
</li>
<li><p>past 经过，超过</p>
<ol>
<li>I called out to him as he ran past.</li>
<li>A week went past and nothing had changed.</li>
</ol>
</li>
<li><p>perhaps 也许</p>
<ol>
<li>Perhaps it will snow tomorrow.</li>
<li>Perhaps we’ve met before.</li>
</ol>
</li>
<li><p>pretty 相当，挺</p>
<ol>
<li>I’m pretty sure he’ll say yes.</li>
<li>The twins are pretty much the same.</li>
</ol>
</li>
<li><p>probably 很可能</p>
<ol>
<li>It’s probably the best movie I have ever seen.</li>
<li>Is he going to be there? Probably not.</li>
</ol>
</li>
<li><p>quite 相当，很，完全</p>
<ol>
<li>The house is quite big.</li>
<li>I’m sorry. That’s quite impossible.</li>
</ol>
</li>
<li><p>rarely 很少</p>
<ol>
<li>She rarely complains.</li>
<li>We rarely see each other now.</li>
</ol>
</li>
<li><p>rather 有点，相当</p>
<ol>
<li>The book is rather long.</li>
<li>I didn’t fail the exam; in fact I did rather well.</li>
</ol>
</li>
<li><p>really 事实上，实际上，真正的</p>
<ol>
<li>I’m really, really sorry.</li>
<li>She’s going to resign. Really? Are you sure?</li>
</ol>
</li>
<li><p>recently 最近，近来</p>
<ol>
<li>I haven’t seen them recently.</li>
<li>I received a letter from him recently.</li>
</ol>
</li>
<li><p>right 正确的，正好，立即，马上</p>
<ol>
<li>Have I guessed right or wrong?</li>
<li>It’s there, right in front of you!</li>
<li>I’ll be right back.</li>
</ol>
</li>
<li><p>round 朝另一方向（相反）；转一整圈</p>
<ol>
<li>He turned round and looked at me.</li>
<li>She watched the clock hands go round.</li>
</ol>
</li>
<li><p>seriously 认真的，严肃的，uamside</p>
<ol>
<li>Seriously, I think Toby likes you.</li>
<li>Was she seriously hurt?</li>
</ol>
</li>
<li><p>shortly 马上，立刻，不久</p>
<ol>
<li>I will be back shortly.</li>
<li>She arrived shortly after us.</li>
</ol>
</li>
<li><p>simply 简单地；仅仅</p>
<ol>
<li>To put it simply, he was fired.</li>
<li>It’s not simply a question of money.</li>
</ol>
</li>
<li><p>since 以后，此后</p>
<ol>
<li>He left home two weeks ago and we haven’t heart from him since.</li>
<li>They went to the UK in 1974 and have lived there <strong>ever since</strong>.</li>
</ol>
</li>
<li><p>slightly 轻微地，有一点</p>
<ol>
<li>I feel slightly better today.</li>
<li>Are you worried? Only slightly.</li>
</ol>
</li>
<li><p>slowly 缓慢地，慢腾腾的</p>
<ol>
<li>He shook his head slowly.</li>
<li>That’s true, said Joe slowly.</li>
</ol>
</li>
<li><p>so 这么，那么，很（程度）</p>
<ol>
<li>It was so embarrassing!</li>
<li>He was so weak that he could hardly stand up.</li>
</ol>
</li>
<li><p>someday （将来）有一天</p>
<ol>
<li>Someday we’ll be together.</li>
<li>Someday he’ll be famous.</li>
</ol>
</li>
<li><p>sometime 在（将来或过去）某个时候</p>
<ol>
<li>I saw him sometime last summer.</li>
<li>Call me sometime next week.</li>
</ol>
</li>
<li><p>sometimes 有时候</p>
<ol>
<li>I sometimes have to work late.</li>
<li>He sometimes calls me.</li>
</ol>
</li>
<li><p>somewhere 在某处，到某处</p>
<ol>
<li>I’ve seen him somewhere before.</li>
<li>I’m going somewhere else this evening.</li>
</ol>
</li>
<li><p>soon 不久，很快</p>
<ol>
<li>He’ll be here very soon.</li>
<li>We soon got there.</li>
</ol>
</li>
<li><p>still 还，仍然</p>
<ol>
<li>I’m still hungry.</li>
<li>Do you still have Julie’s phone number?</li>
</ol>
</li>
<li><p>straight 径直，成直线的</p>
<ol>
<li>He went straight home after the meeting.</li>
<li>Sit up straight.</li>
</ol>
</li>
<li><p>suddenly 突然</p>
<ol>
<li>He stood up suddenly.</li>
<li>Suddenly the eagle opened its wings.</li>
</ol>
</li>
<li><p>then 那时，到时候；然后；那么</p>
<ol>
<li>Things were very different back then.</li>
<li>I’ll see you then.</li>
<li>Mix the flour and butter, then add the eggs.</li>
<li>If you don’t tell him, then I will.</li>
</ol>
</li>
<li><p>there 在那里，到那里</p>
<ol>
<li>We are nearly there.</li>
<li>Who’s that man over there?</li>
</ol>
</li>
<li><p>today 今天，现今</p>
<ol>
<li>What are we doing today?</li>
<li>Women today no longer accept such treatment.</li>
</ol>
</li>
<li><p>together 在一起</p>
<ol>
<li>Let’s go for a walk together.</li>
<li>We grew up togeter.</li>
</ol>
</li>
<li><p>tomorrow 明天</p>
<ol>
<li>See you tomorrow.</li>
<li>She’s getting married tomorrow.</li>
</ol>
</li>
<li><p>tonight 今晚</p>
<ol>
<li>It’s cold tonight</li>
<li>I think I’ll go to bed early tonight.</li>
</ol>
</li>
<li><p>too 也；太</p>
<ol>
<li>I’ve been to Paris too.</li>
<li>There are too many cars on the road.</li>
</ol>
</li>
<li><p>totally 完全</p>
<ol>
<li>That’s a totally different matter.</li>
<li>She’s so cute! Totally!</li>
</ol>
</li>
<li><p>twice 两次；两倍</p>
<ol>
<li>I have seen the film twice.</li>
<li>Cats sleep twice as much as people.</li>
</ol>
</li>
<li><p>up 在上面；起来</p>
<ol>
<li>John’n up in his bedroom.</li>
<li>It’s time to get up.</li>
</ol>
</li>
<li><p>upstairs 在楼上，到楼上</p>
<ol>
<li>I went upstairs and had a shower.</li>
<li>I was upstairs when it happened.</li>
</ol>
</li>
<li><p>usually 通常，经常</p>
<ol>
<li>Women usually live longer than men.</li>
<li>What time do you usually go to bed?</li>
</ol>
</li>
<li><p>very 很，非常</p>
<ol>
<li>Thank you very much.</li>
<li>It’s very kind of you to help.</li>
</ol>
</li>
<li><p>well 好</p>
<ol>
<li>Did you sleep well?</li>
<li>Well done!</li>
</ol>
</li>
<li><p>when 什么时候</p>
<ol>
<li>When are we leaving?</li>
<li>When can I see you again?</li>
</ol>
</li>
<li><p>where 在哪里，到哪里</p>
<ol>
<li>Where are you going?</li>
<li>where do they live?</li>
</ol>
</li>
<li><p>why 为什么</p>
<ol>
<li>Why were you late?</li>
<li>Do you know why the door is locked?</li>
</ol>
</li>
<li><p>yes 是</p>
<ol>
<li>Coffee? Yes, please.</li>
<li>Can I have a glass of water? Yes, of course.</li>
</ol>
</li>
<li><p>yesterday 在昨天</p>
<ol>
<li>What did you do yesterday?</li>
<li>Anna left yesterday afternoon.</li>
</ol>
</li>
<li><p>yet 还</p>
<ol>
<li><p>Are you ready? No, not yet.</p>
</li>
<li><p>I haven’t asked him yet.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>gson转换LocalDateTime时碰到的问题</title>
    <url>/2020/05/08/Work%20Record/CAAS/GsonTimeHandler/</url>
    <content><![CDATA[<p>当使用gson转换为LocalDateTime的属性时，因为LocalDateTime相当于是个数组，而元数据为 yyyy-MM-dd HH:mm:ss的字符串，转换时会发生错误，需要进行如下的配置</p><a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认日期时间格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DATE_TIME_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认日期格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DATE_FORMAT = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认时间格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TIME_FORMAT = <span class="string">"HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Gson <span class="title">gson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">            .registerTypeAdapter(LocalDateTime.class,</span><br><span class="line">                    (JsonDeserializer&lt;LocalDateTime&gt;) (json, type, jsonDeserializationContext)</span><br><span class="line">                            -&gt; LocalDateTime.parse(json.getAsString(), dateTimeFormatter))</span><br><span class="line">            .registerTypeAdapter(LocalDate.class,</span><br><span class="line">                    (JsonDeserializer&lt;LocalDate&gt;) (json, type, jsonDeserializationContext)</span><br><span class="line">                            -&gt; LocalDate.parse(json.getAsString(), dateFormatter))</span><br><span class="line">            .registerTypeAdapter(LocalTime.class,</span><br><span class="line">                    (JsonDeserializer&lt;LocalTime&gt;) (json, type, jsonDeserializationContext)</span><br><span class="line">                            -&gt; LocalTime.parse(json.getAsString(), timeFormatter))</span><br><span class="line">            .create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>常见形容词</title>
    <url>/2020/04/28/Language/English/New%20Concept/Word/Adjectives/Adjectives/</url>
    <content><![CDATA[<p>常见形容词</p>
<a id="more"></a>
<ol>
<li>broken 破碎的，打碎的<ol>
<li>a broken window</li>
<li>a broken leg</li>
<li>a broken heart</li>
</ol>
</li>
<li>busy 忙碌的<ol>
<li>She’s <strong>busy with</strong> her homework.</li>
<li>Rachel’s <strong>busy studying</strong> fro her exams.</li>
</ol>
</li>
<li>calm 镇定的；平静的<ol>
<li>Keep calm.</li>
<li>The sea was calm again.</li>
</ol>
</li>
<li>careful 仔细的，小心的<ol>
<li>Be careful -there’s broken glass on the floor!</li>
<li>Be careful not to wake the baby.</li>
</ol>
</li>
<li>careless 不小心的，粗心的<ol>
<li>a careless driver</li>
<li>It was careless of me to leave the door open.</li>
</ol>
</li>
<li>cautions 小心的，谨慎的<ol>
<li>a cautious driver</li>
<li>He was cautions about everything.</li>
</ol>
</li>
<li>certain 确信的，确定的<ol>
<li>One thing is certain: I’m not coming here again.</li>
<li>She saw me. I’m <strong>certain of</strong> that.</li>
</ol>
</li>
<li>charming 迷人的，有魅力的<ol>
<li>He’s a very charming man.</li>
<li>She gave him a charming smile.</li>
</ol>
</li>
<li>cheap 便宜的，廉价的；小气的<ol>
<li>A good education is not cheap.</li>
<li>Don’t be so cheap!</li>
</ol>
</li>
<li>cheerful 兴高采烈的，快乐的<ol>
<li>Youe’re very cheerful today.</li>
<li>He felt cheerful and full of energy.</li>
</ol>
</li>
<li>chief 主要的，首要的<ol>
<li>The chief thing is to be honet.</li>
<li>CEO: Chief Executive Officer</li>
</ol>
</li>
<li>chilly 寒冷的<ol>
<li>It’s chilly today.</li>
<li>The bathroom’s a bit chilly.</li>
</ol>
</li>
<li>Chinese 中国的<ol>
<li>He married a Chinese girl.</li>
</ol>
</li>
<li>clean 干净的，清洁的<ol>
<li>clean hands</li>
<li>clean air</li>
</ol>
</li>
<li>clear 清楚的，清晰的，清澈的<ol>
<li>a clear day</li>
<li>a clear voice </li>
<li>a clear mountain lake</li>
</ol>
</li>
<li>clever 聪明的<ol>
<li>Clever girl!</li>
<li>Lucky is quite clever and does well at school.</li>
</ol>
</li>
<li>cloudly 多云的，阴天的<ol>
<li>It will be cloudy tomorrow.</li>
</ol>
</li>
<li>cold 寒冷的；冷淡的<ol>
<li>He slept on the cold ground.</li>
<li>Dinner is getting cold.</li>
<li>Martin was really cold to me at the party.</li>
</ol>
</li>
<li>colorful 五颜六色的，多姿多彩的<ol>
<li>a colorful painting</li>
<li>My uncle had a long and colorful career.</li>
</ol>
</li>
<li>comfortable 舒适的；安逸的<ol>
<li>Sit down and make yourself comfortable.</li>
<li>She lives a comfortable life.</li>
</ol>
</li>
<li>common 普通的，常见的<ol>
<li>the common cold</li>
<li>common sense</li>
<li>Daisies are very common flowers.</li>
</ol>
</li>
<li>confused 迷惑的<ol>
<li>I’m totally confused. Could you explain that again?</li>
</ol>
</li>
<li>cool 凉爽的；冷静的；非常棒的<ol>
<li>The evening air was cool.</li>
<li>He has a cool head.</li>
<li>You look pretty cool with that new haircut.</li>
</ol>
</li>
<li>crazy 疯狂的，不理智的<ol>
<li>Are you crazy?</li>
<li>That noise is driving me crazy.</li>
<li>He’s <strong>crazy about</strong> her.</li>
</ol>
</li>
<li>creepy 令人毛骨悚然的，不寒而栗的<ol>
<li>a creepy ghost story</li>
<li>The whole place feels creepy.</li>
</ol>
</li>
<li>crowded 拥挤的<ol>
<li>crowded streets</li>
<li>The train was very crowded, and me had to stand.</li>
</ol>
</li>
<li>cruel 残忍的，残酷的<ol>
<li>Sometimes life seems cruel.</li>
<li>Don’t tease him about his weight - it’s cruel.</li>
</ol>
</li>
<li>curious 好奇的；爱管闲事的<ol>
<li>I’m curious to know what she said.</li>
<li>curious neighbors</li>
</ol>
</li>
<li>cute 可爱的，漂亮的<ol>
<li>The baby’s so cute.</li>
<li>Why are you so cute?</li>
</ol>
</li>
<li>daily 每日的，日常的<ol>
<li>daily life</li>
<li>a daily newspaper</li>
</ol>
</li>
<li>dangerous 危险的<ol>
<li>The dog is dangerous.</li>
<li>Air pollution has reached dangerous levels in some cities.</li>
</ol>
</li>
<li>dark 黑暗的；邪恶的；深色的<ol>
<li>The church was dark and quiet.</li>
<li>There was a dark side to his nature.</li>
<li>dark blue</li>
</ol>
</li>
<li>dazzling 耀眼的，光彩夺目的<ol>
<li>a dazzling white light</li>
<li>You look dazzling.</li>
</ol>
</li>
<li>dead 死的<ol>
<li>We didn’t know if she was dead or alive.</li>
<li>You are dead.</li>
</ol>
</li>
<li>dear 亲爱的，极为珍贵的<ol>
<li>my dear son</li>
<li>Her daughter is very dear to her.</li>
</ol>
</li>
<li>deep 深的；深奥的<ol>
<li>a deep well</li>
<li>This discussion’s getting deep for me.</li>
</ol>
</li>
<li>delicious 美味的<ol>
<li>Who cooked this? It’s delicious.</li>
<li>It smells delicious!</li>
</ol>
</li>
<li>dependent 依靠的，依赖的<ol>
<li>You can’t be <strong>dependent on</strong> you parents all your life.</li>
</ol>
</li>
<li>depressed 沮丧的；萧条的<ol>
<li>She felt lonely and depressed.</li>
<li>Britain’s depressed real estate market.</li>
</ol>
</li>
<li>different 不同的<ol>
<li>She is wearing a different dress every time i see her.</li>
<li>Her jacket’s different from mine.</li>
</ol>
</li>
<li>difficult 困难的<ol>
<li>It’s really difficult to read you writing.</li>
<li>That’s rather difficult for me to explain.</li>
</ol>
</li>
<li>dirty 肮脏的；下流的<ol>
<li>How did you get so dirty?</li>
<li>a dirty joke</li>
</ol>
</li>
<li>disgusting 令人厌恶的，恶心的<ol>
<li>You are disgusting.</li>
<li>Smoking is a really disgusting habit.</li>
</ol>
</li>
<li>dizzy 头晕的，眩晕的<ol>
<li>After another glass of whisky i began to feel dizzy.</li>
</ol>
</li>
<li>drunk 醉的<ol>
<li>You’re drunk.</li>
<li>She was too drunk to remember anything about the party.</li>
</ol>
</li>
<li>dry 干旱的，干燥的，干的<ol>
<li>Is my shirt dry yet?</li>
<li>The weather was hot and dry.</li>
<li>the dry season</li>
</ol>
</li>
<li>dull 钝的；迟钝的；枯燥的<ol>
<li>a dull knife</li>
<li>a dull girl</li>
<li>a dull movie</li>
</ol>
</li>
<li>eager 渴望的，热切地<ol>
<li>He’s a bright kid and eager to learn.</li>
<li>I am eager to go to Australia.</li>
</ol>
</li>
<li>early 早的，早期的<ol>
<li>The bus was ten minutes early.</li>
<li>She is in her early twenties.</li>
</ol>
</li>
<li>easy 容易的；舒适的<ol>
<li>The test was easy.</li>
<li>lead an easy life</li>
</ol>
</li>
<li>embarrassed 尴尬的，窘迫的<ol>
<li>I’ve never felt so embarrassed in my life.</li>
</ol>
</li>
<li>embarrassing 令人尴尬的<ol>
<li>She asked a lot of embarrassing questions.</li>
</ol>
</li>
<li>empty 空的；空虚的<ol>
<li>Your glass is empty.</li>
<li>empty streets</li>
<li>Her life felt empty and meaningless.</li>
</ol>
</li>
<li>energetic 精力充沛的，精力旺盛的<ol>
<li>You are so energetic.</li>
</ol>
</li>
<li>English 英国的<ol>
<li>I love the English countryside.</li>
</ol>
</li>
<li>equal 平等的，相等的<ol>
<li>All men are equal.</li>
<li>equal pay for equal work</li>
</ol>
</li>
<li>excellent 杰出的，优秀的<ol>
<li>She speaks excellent French.</li>
<li>What an excellent idea!</li>
<li>You can all come? Excellent!</li>
</ol>
</li>
<li>excited 兴奋地，激动地<ol>
<li>The children were <strong>excited about</strong> opening their presents.</li>
<li>I’m so excited that we’re going to New York.</li>
</ol>
</li>
<li>exciting 使人兴奋的，令人激动的<ol>
<li>I’ve got some very exciting news for you.</li>
<li>‘Julia and Paul are getting married!’ ‘Oh, how exciting!’</li>
</ol>
</li>
<li>expensive 昂贵的，豪华的<ol>
<li>Houses are very expensive in this area.</li>
<li>I can’t afford it, It’s too expensive.</li>
<li>an expensive restaurant</li>
</ol>
</li>
<li>exotic 异国的，有异国风情的<ol>
<li>exotic birds</li>
<li>He was attracted by her exotic beauty.</li>
</ol>
</li>
<li>fabulous 极好的，绝妙的<ol>
<li>You look fabulous!</li>
<li>Jane is a fabulous cook.</li>
</ol>
</li>
<li>fair 公平的；美丽的<ol>
<li>Life isn’t always fair.</li>
<li>London bridge is falling down, my fair lady.</li>
</ol>
</li>
<li>false 错误的；假的<ol>
<li>A whale is a fish. Ture or false?</li>
<li>The man gave a false name and address.</li>
</ol>
</li>
<li>familiar 熟悉的<ol>
<li>I’m not really <strong>familiar with</strong> her poetry.</li>
<li>Her poetry isn’t <strong>familiar to</strong> me.</li>
</ol>
</li>
<li>famous 著名的，出名的<ol>
<li>France is <strong>famous for</strong> its wine.</li>
<li>Many famous people have stayed in the hoital.</li>
</ol>
</li>
<li>fantastic 极好的，极大地<ol>
<li>I’ve passed my driving test. Fantastic!</li>
<li>Their wedding cost a fantastic amount of money.</li>
</ol>
</li>
<li>far 远的<ol>
<li>We can walk to my house from here. It isn’t far.</li>
</ol>
</li>
<li>fast 快的，迅速的<ol>
<li>He’s one of the fastest runners in the world.</li>
<li>I’m fast learner.</li>
</ol>
</li>
<li>fat 肥的，胖的<ol>
<li>If you eat too much chocolate you’ll get fat.</li>
<li>He’s got a rather fat face.</li>
</ol>
</li>
<li>few 很少的<ol>
<li>Few people live to be 100.</li>
<li>I have to by a few things at the supermarket.</li>
</ol>
</li>
<li>fine 好的<ol>
<li>We’re meeting at 8.30.  Okay, fine.</li>
<li>Hou are you?  Fine, thanks, how are you .</li>
<li>More coffee? No, I’m fine, thanks.</li>
</ol>
</li>
<li>flat 平的<ol>
<li>houses with flat roofs</li>
</ol>
</li>
<li>foolish 愚蠢的，傻的<ol>
<li>I was young and foolish at the time.</li>
<li>I was foolish enough to believe him.</li>
</ol>
</li>
<li>fortunate 幸运的<ol>
<li>I was fortunate to have a good teacher.</li>
</ol>
</li>
<li>free 自由的；免费的；空闲的<ol>
<li>He was a free man again.</li>
<li>free tickets</li>
<li>I’m free next weekend.</li>
</ol>
</li>
<li>fresh 新的，新鲜的<ol>
<li>Eat plenty of fresh fruit and vegetables.</li>
<li>We need some fresh ideas.</li>
</ol>
</li>
<li>friendly 友好的<ol>
<li>a friendly smile</li>
<li>Everyone was very friendly towards me.</li>
</ol>
</li>
<li>frightened 害怕的<ol>
<li>Don’t be frightened. We’re not going to hurt you.</li>
<li>I’m frightened of walking home alone.</li>
</ol>
</li>
<li>frighting 可怕的<ol>
<li>The noist is frighting.</li>
</ol>
</li>
<li>full 满的<ol>
<li>Don’t talk with you mouth full.</li>
<li>The kitchen was full of smoke.</li>
</ol>
</li>
<li>funny 有趣的，可笑的<ol>
<li>a funny story</li>
<li>What’s so funny?</li>
</ol>
</li>
<li>gentle 温和的，文雅的<ol>
<li>Be gentle with the baby.</li>
<li>Arthur was a very gentle person.</li>
</ol>
</li>
<li>giant 巨大的<ol>
<li>What a giant tree!</li>
</ol>
</li>
<li>good 好的<ol>
<li>Her English is very good.</li>
<li>It’s good to see you again.</li>
<li>He’s very good with children.</li>
</ol>
</li>
<li>graceful 优美的，优雅的<ol>
<li>The dancers were all tall and  graceful.</li>
</ol>
</li>
<li>grateful 感激的，感谢的<ol>
<li>I am grateful to you for your help.</li>
</ol>
</li>
<li>great 大的，重大的，好极的<ol>
<li>The movie was a great success.</li>
<li>The wedding was a great occasion.</li>
<li>It’s great to be home.</li>
</ol>
</li>
<li>greedy 贪婪地，贪吃的<ol>
<li>He stared at the diamonds with greedy eyes.</li>
<li>Have eaten them all, you greedy pig?</li>
</ol>
</li>
<li>handsome 英俊的，帅气的<ol>
<li>Sam was tall, dark and handsome.</li>
</ol>
</li>
<li>happy 幸福的，快乐的<ol>
<li>They had a very happy marriage.</li>
<li>I’m very happy for you.</li>
</ol>
</li>
<li>hard 困难的；努力的；硬的<ol>
<li>She found it hard to decide.</li>
<li>a hard worker</li>
<li>a hard wooden chair</li>
</ol>
</li>
<li>healthy 健康的<ol>
<li>a healthy baby boy</li>
<li>a healthy lifestyle</li>
</ol>
</li>
<li>heavy 重的；大量的<ol>
<li>The box is too heavy for me to carry.</li>
<li>He is a heavy smoker.</li>
</ol>
</li>
<li>helpful 给予帮助的，愿意帮忙的<ol>
<li>Thank you for your advice; it’s been very helpful.</li>
<li>I’m only trying to be helpful.</li>
</ol>
</li>
<li>high 高的<ol>
<li>How high is Mount Everest?</li>
<li>The wall is six feet high.</li>
</ol>
</li>
<li>homeless 无家可归的<ol>
<li>A forest fire made hundreds of people homeless.</li>
</ol>
</li>
<li>horrible 可怕的；糟糕的<ol>
<li>a horrible dream</li>
<li>The coffee tasted horrible.</li>
</ol>
</li>
<li>hot 热的；辣的；性感的<ol>
<li>It’s so hot in here.</li>
<li>She likes hot food.</li>
<li>The girls all think he’s hot.</li>
</ol>
</li>
<li>huge 巨大的<ol>
<li>a huge dog</li>
<li>The movie was a huge success.</li>
</ol>
</li>
<li>humorous 幽默的，风趣的<ol>
<li>He is quite humorous, and i like that about him.</li>
</ol>
</li>
<li>hungry 饥饿的，渴望的<ol>
<li>You must be hungry.</li>
<li>Stan was hungry to learn.</li>
</ol>
</li>
<li>ill 生病的；不好的，坏的<ol>
<li>He’s been ill for two weeks.</li>
<li>He can’t join the army because of ill health.</li>
</ol>
</li>
<li>important 重要的，重大的<ol>
<li>an important meeting</li>
<li>VIP: very important person</li>
<li>Happiness is more important than money.</li>
</ol>
</li>
<li>impossible 不可能的<ol>
<li>Mission impossible</li>
<li>I find it impossible to lie to her.</li>
</ol>
</li>
<li>incredible 不可思议的，难以置信的，非常好的<ol>
<li>What an incredible story!</li>
<li>The view is just incredible.</li>
</ol>
</li>
<li>innocent 无辜的，清白的<ol>
<li>Nobody would believe that i was innocent.</li>
</ol>
</li>
<li>interested 感兴趣的<ol>
<li>There’s a talk on Italian art - are you interested?</li>
<li>I’ve always been <strong>interested in</strong> music.</li>
</ol>
</li>
<li>interesting 令人感兴趣的，有趣的<ol>
<li>That’s an interesting question.</li>
<li>Did you meet any interesting people?</li>
</ol>
</li>
<li>kind 亲切的，和蔼的<ol>
<li>Ther’ve been very kind to me.</li>
<li>It was really kind of you to help me.</li>
</ol>
</li>
<li>large 大的<ol>
<li>He has a large house.</li>
<li>large sums of money</li>
</ol>
</li>
<li>last 最后的，上一个的<ol>
<li>She was the last one to arrive.</li>
<li>Did you see the game on TV last night?</li>
</ol>
</li>
<li>late 晚的，迟到的<ol>
<li>Sorry I’m late.</li>
<li>Dont’t be late for school.</li>
</ol>
</li>
<li>lazy 懒惰的<ol>
<li>He’s not stupid, just lazy.</li>
<li>We spent a lazy day at the beach.</li>
</ol>
</li>
<li>legal 法律的；合法的<ol>
<li>take legal action</li>
<li>What i have done is perfectly legal.</li>
</ol>
</li>
<li>light 轻的；浅色的<ol>
<li>You can carry this bag -it’s fairly light.</li>
<li>You look nice in light colors.</li>
</ol>
</li>
<li>little 小的，幼小的<ol>
<li>six little puppies</li>
<li>I didn’t have toys like this when i was little.</li>
</ol>
</li>
<li>lonely 孤独的，寂寞的<ol>
<li>a lonely old man</li>
<li>a lonely journey</li>
</ol>
</li>
<li>long 长的；长时间的<ol>
<li>You hair is longer than mine.</li>
<li>I haven’t been there for a long time.</li>
</ol>
</li>
<li>loud 响亮的，大声的<ol>
<li>That music’s too loud.</li>
<li>Who’s there?  asked David in a loud voice.</li>
</ol>
</li>
<li>lovely 可爱的，美丽的，令人愉快的<ol>
<li>You look lovely in that dress.</li>
<li>What a lovely house!</li>
<li>What a lovely day!</li>
</ol>
</li>
<li>low 低的，矮的<ol>
<li>a low wall</li>
<li>The river is very low today.</li>
</ol>
</li>
<li>lucky 幸运的<ol>
<li>You are so lucky!</li>
<li>You lucky dog!</li>
<li>Seven is my lucky number.</li>
</ol>
</li>
<li>married 已婚的<ol>
<li>Are you married or single?</li>
<li>They’ve been married for eight years.</li>
<li>We’re getting married next mouth.</li>
</ol>
</li>
<li>messy 凌乱的，散乱的<ol>
<li>Sorry my room is so messy.</li>
<li>The house was always messy.</li>
</ol>
</li>
<li>modern 现代的，当代的<ol>
<li>in the modern world</li>
<li>modern dance</li>
</ol>
</li>
<li>naive 幼稚的，天真的<ol>
<li>a naive young girl</li>
<li>Jim can be so naive sometimes.</li>
</ol>
</li>
<li>narrow 狭窄的，狭隘的<ol>
<li>a narrow bed</li>
<li>The road was too narrow for cars to pass.</li>
</ol>
</li>
<li>nasty 恶心的，令人讨厌的，不善良的<ol>
<li>a nasty smell</li>
<li>He has a nasty temper.</li>
<li>Don’t be nasty to you little brother.</li>
</ol>
</li>
<li>natural 自然的，天生的<ol>
<li>the natural world</li>
<li>My hair soon grew back to its natural color.</li>
</ol>
</li>
<li>naughty 顽皮的，淘气的<ol>
<li>You’re a very naughty boy!</li>
</ol>
</li>
<li>near 近的<ol>
<li>His flat’s very near.</li>
<li>Where’s the nearest bus-stop?</li>
</ol>
</li>
<li>neat 整洁的，干净的，好的<ol>
<li>His clothes were always neat and clean.</li>
<li>That’s a really neat idea.</li>
</ol>
</li>
<li>necessary 必要的，必须的<ol>
<li>Sleep is necessary for one’s health.</li>
<li>It’s not necessary to wear a tie.</li>
</ol>
</li>
<li>nervous 紧张的，焦虑的<ol>
<li>You’re making me nervous.</li>
<li>She was so nervous about her exams that she couldn’t sleep.</li>
</ol>
</li>
<li>new 新的，新到的<ol>
<li>Do you like my new dress?</li>
<li>They’ve just moved into their new house.</li>
</ol>
</li>
<li>nice 美好的，愉快的<ol>
<li>It’s such a nice day.</li>
<li>What a nice story!</li>
<li>You look nice in that suit.</li>
</ol>
</li>
<li>noisy 嘈杂的，喧闹的<ol>
<li>The kids have been really noisy today.</li>
<li>The bar was very noisy.</li>
</ol>
</li>
<li>normal 正常的<ol>
<li>It’s normal to feel nervous before an exam.</li>
<li>Her room was messy, but that was quite normal.</li>
</ol>
</li>
<li>odd 奇怪的，奇数的<ol>
<li>She gets odder as she grows older.</li>
<li>How odd!</li>
<li>odd numbers</li>
</ol>
</li>
<li>open 敞开的；公开的<ol>
<li>All the windows were wide open.</li>
<li>I was so sleepy, I couldn’t keey my eyes open.</li>
<li>It is an open secret.</li>
</ol>
</li>
<li>ordinary 普通的，平常的<ol>
<li>It’s just an ordinary camera.</li>
<li>The book is about ordinary people.</li>
<li>The meal was very ordinary.</li>
</ol>
</li>
<li>organic 有机的<ol>
<li>organic vegetables</li>
<li>The shop sells organic food.</li>
</ol>
</li>
<li>outstanding 杰出的，优秀的<ol>
<li>an outstanding student</li>
<li>His performance was outstanding.</li>
</ol>
</li>
<li>painful 痛苦的，疼的<ol>
<li>The divorce was painful for both of them.</li>
<li>Is you back still painful?</li>
</ol>
</li>
<li>past 过去的，以前的<ol>
<li>The past month has been a difficult one for him.</li>
<li>From past experience I’d say she was a liar.</li>
</ol>
</li>
<li>perfect 完美的，极好的<ol>
<li>That’s perfect!</li>
<li>His English was perfect.</li>
<li>Nobody is perfect.</li>
</ol>
</li>
<li>plain 清楚的；相貌平平的<ol>
<li>He made it plain that we should leave.</li>
<li>She had grown into a beautiful woman from a rather plain child.</li>
</ol>
</li>
<li>polite 有礼貌的<ol>
<li>She’s always very polite.</li>
<li>It’s not polite to talk with your mouth full.</li>
</ol>
</li>
<li>poor 贫穷的；可怜的<ol>
<li>He came from a poor family</li>
<li>Poor kid!</li>
</ol>
</li>
<li>possible 可能的<ol>
<li>Is it possible to get tickets for the game?</li>
<li>I need the monty as soon as possible.</li>
</ol>
</li>
<li>powerful 强大的；权力大的<ol>
<li>Jed was a powerful man.</li>
<li>a very powerful family</li>
<li>a powerful speech</li>
</ol>
</li>
<li>precious 宝贵的，珍贵的<ol>
<li>precious stones</li>
<li>You’re wasting precious time!</li>
</ol>
</li>
<li>present 目前的；出席的<ol>
<li>the present situation</li>
<li>Everyone is present.</li>
</ol>
</li>
<li>pretty 漂亮的<ol>
<li>a pretty little girl</li>
<li>What a pretty dress!</li>
</ol>
</li>
<li>previous 以前的<ol>
<li>He was there the previous day.</li>
<li>Do you have any previous experiene?</li>
</ol>
</li>
<li>private 私人的；秘密的；私立的<ol>
<li>This is a private house.</li>
<li>Don’t read that - it’s private.</li>
<li>a private hospital</li>
</ol>
</li>
<li>proud 骄傲的，自豪的<ol>
<li>I’m very <strong>proud of</strong> you.</li>
<li>You make me proud.</li>
</ol>
</li>
<li>public 公共的；公立的<ol>
<li>public places</li>
<li>public shcools</li>
</ol>
</li>
<li>quick 快的，迅速的<ol>
<li>Be quick!</li>
<li>Tax is are quicker than buses.</li>
<li>I had to make a quick decision.</li>
</ol>
</li>
<li>quiet 安静的，平静的<ol>
<li>Be quiet, please!</li>
<li>You’re very quiet, Tom -is anything the matter?</li>
<li>The sea looks quieter now.</li>
</ol>
</li>
<li>rainy 下雨的，多雨的<ol>
<li>a rainy morning</li>
<li>the rainy season</li>
</ol>
</li>
<li>ready 准备好的<ol>
<li>Are you ready?</li>
<li>Dinner is ready.</li>
<li>I’m not <strong>ready for</strong> the test yet.</li>
</ol>
</li>
<li>real 真的，真实的<ol>
<li>Tell me the real reason.</li>
<li>The children know that Santa Claus isn’t a real person.</li>
</ol>
</li>
<li>regular 有规律的，定期的<ol>
<li>regular meetings</li>
<li>our regular customers</li>
<li>His breathing was slow and regular.</li>
</ol>
</li>
<li>responsible 承担责任的，有责任感的<ol>
<li>I’ll find out who’s responsible.</li>
<li>He was <strong>responsible for</strong> the accident.</li>
</ol>
</li>
<li>rich 富有的，油腻的<ol>
<li>She was both beautiful and rich.</li>
<li>a rich cake</li>
</ol>
</li>
<li>right 右方的；正确的；合适的<ol>
<li>He had a knife in his right hand.</li>
<li>I think you’re right.</li>
<li>I’m glad you broke up. She wasn’t right for you.</li>
</ol>
</li>
<li>romantic 浪漫的<ol>
<li>How romantic!</li>
<li>romantic music</li>
</ol>
</li>
<li>round 圆形的<ol>
<li>a big round table</li>
<li>round cheeks</li>
</ol>
</li>
<li>sad 伤心的，难过的<ol>
<li>John is sad because his dog has died.</li>
<li>I’m sad you’re leaving.</li>
</ol>
</li>
<li>safe 安全的<ol>
<li>You are safe here.</li>
<li>You secret is safe with me.</li>
</ol>
</li>
<li>salty 含盐的，咸的<ol>
<li>salty food</li>
<li>The soup is a little bit salty.</li>
</ol>
</li>
<li>same 相同的，同样的<ol>
<li>He is <strong>the same</strong> age as his wife.</li>
<li>I bought <strong>the same </strong>car <strong>as</strong> yours.</li>
</ol>
</li>
<li>selfish 自私的<ol>
<li>selfish behavior</li>
<li>How can you be so selfish?</li>
</ol>
</li>
<li>serious 严肃的，认真的；严重的<ol>
<li>Are you serous?</li>
<li>This a very serious matter.</li>
</ol>
</li>
<li>sharp 锋利的；剧烈的<ol>
<li>a sharp knife</li>
<li>a sharp drop in prices</li>
</ol>
</li>
<li>shocked 震惊的<ol>
<li>He is shocked at what happened.</li>
<li>We were deeply shocked to hear of his death.</li>
</ol>
</li>
<li>shocking 令人震惊的<ol>
<li>shocking news</li>
<li>It is shocking that he was killed in the accident.</li>
</ol>
</li>
<li>short 短的；短缺的；矮的<ol>
<li>Winter is coming and the days are getting shorter.</li>
<li>I’m afraid I’m alittle <strong>short of</strong> money this month.</li>
<li>He’s a bit shorter than me.</li>
</ol>
</li>
<li>shy 害羞的<ol>
<li>Don’t be shy - come and say hello.</li>
<li>He was too shy to speak to her.</li>
</ol>
</li>
<li>sick 生病的；恶心的，病态的<ol>
<li>His mother’s very sick.</li>
<li>Emma has just called in sick.</li>
<li>You’re sick!</li>
</ol>
</li>
<li>silent 寂静的，无声的<ol>
<li>Alan was silent.</li>
<li>The children went out, and the room was silent.</li>
</ol>
</li>
<li>silly 愚蠢的，傻的<ol>
<li>Don’t be silly!</li>
<li>Stop asking silly questions.</li>
</ol>
</li>
<li>simple 简单的<ol>
<li>There is no simple answer to this question.</li>
<li>This machine is very simple to use.</li>
</ol>
</li>
<li>slow 慢的，迟钝的<ol>
<li>Oh you’re so slow; come on, hurry up!</li>
<li>My watch is five minutes slow.</li>
<li>He’s the slowest in the class.</li>
</ol>
</li>
<li>small 小的，少的<ol>
<li>The shirt was too small for him.</li>
<li>a small amount of money</li>
</ol>
</li>
<li>smart 聪明的；漂亮的，帅气的<ol>
<li>Smart boy!</li>
<li>You look very smart in your new suit.</li>
</ol>
</li>
<li>soft 软的，柔软的；温和的<ol>
<li>I like soft pillows.</li>
<li>a baby’s soft skin</li>
<li>His voice was softer now.</li>
</ol>
</li>
<li>sour 有酸味的，酸的；馊的<ol>
<li>This apple is really sour!</li>
<li>The milk’s turned sour.</li>
</ol>
</li>
<li>special 特殊的，特别的，专门的<ol>
<li>Are you doing anything special for Christmas?</li>
<li>She’s a very special friend.</li>
<li>a special train</li>
</ol>
</li>
<li>spicy 辛辣的<ol>
<li>Do you like spicy food?</li>
</ol>
</li>
<li>strange 奇怪的；陌生的<ol>
<li>It’s strange that we’ve never met before.</li>
<li>At first the place was <strong>strange to</strong> me.</li>
</ol>
</li>
<li>strong 强的，强壮的；坚强的；强烈的<ol>
<li>Jack was tall and strong.</li>
<li>I must be strong.</li>
<li>The temptation is very strong.</li>
</ol>
</li>
<li>stupid 愚蠢的<ol>
<li>I made a stupid mistake.</li>
<li>He understands - he’s not stupid.</li>
<li>This stupid car won’t start.</li>
</ol>
</li>
<li>successful 成功的<ol>
<li>The play was very successful on Broadway.</li>
</ol>
</li>
<li>super 极好的<ol>
<li>What a super idea!</li>
<li>You’ll like her. She’s super.</li>
</ol>
</li>
<li>sweet 甜的；温柔的，可亲的<ol>
<li>This tea is too sweet.</li>
<li>a sweet smile</li>
<li>How sweet of you to remember my birthday.</li>
</ol>
</li>
<li>tall 高的，高大的<ol>
<li>He was young and tall.</li>
<li>She’s a little taller than her sister.</li>
</ol>
</li>
<li>tasty 美味的，可口的<ol>
<li>This soup is very tasty.</li>
</ol>
</li>
<li>terrible 可怕的；糟糕的<ol>
<li>What terrible news!</li>
<li>He’s terrible driver.</li>
<li>I feel terrible - I think I’ll go to bed.</li>
</ol>
</li>
<li>terrific 极好的<ol>
<li>That’s a terrific idea.</li>
<li>You look terrific in that dress.</li>
</ol>
</li>
<li>thankful 感谢的，感激的<ol>
<li>I was thankful that the meeting didn’t last long.</li>
</ol>
</li>
<li>thick 厚的；浓的，茂密的<ol>
<li>a thick coat</li>
<li>a thick forest</li>
<li>thick hair</li>
</ol>
</li>
<li>thin 薄的；瘦的<ol>
<li>That ice is too thin to stand on.</li>
<li>He’s tall and thin.</li>
</ol>
</li>
<li>tidy 整洁的，整齐的<ol>
<li>Ellen’s room is always tidy.</li>
</ol>
</li>
<li>tight 紧的，绷紧的<ol>
<li>The drawer is so tight I can’t open it.</li>
<li>tight jeans</li>
</ol>
</li>
<li>tiny 极小的，微小的<ol>
<li>a <strong>tiny little</strong> baby</li>
<li>Through she was tiny, she had a very loud voice.</li>
</ol>
</li>
<li>tired 疲倦的；厌烦的<ol>
<li>I’m tired.</li>
<li>I’m <strong>tired of</strong> watching television; let’s go for a walk.</li>
</ol>
</li>
<li>true 真正的，真实的<ol>
<li>true love</li>
<li>This is a true story.</li>
<li>This is too good to be true.</li>
</ol>
</li>
<li>ugly 难看的，丑陋的<ol>
<li>an ugly face</li>
<li>The Ugly Duckling</li>
</ol>
</li>
<li>unable 不能的，无能力的<ol>
<li>She is <strong>unable to</strong> walk.</li>
<li>Some of the children were unable to read or wrote.</li>
</ol>
</li>
<li>upset 难过的，失望的，沮丧的<ol>
<li>Why are you so upset?</li>
<li>She feels upest that we didn’t tell her the truth.</li>
</ol>
</li>
<li>useful 有用的，有益的<ol>
<li>The book is full of useful information.</li>
<li>He might be useful to us.</li>
</ol>
</li>
<li>useless 无用的，无效的<ol>
<li>It was useless to complain.</li>
<li>All out efforts were useless.</li>
</ol>
</li>
<li>violent 暴力的<ol>
<li>Her husband was a violent man.</li>
<li>Children should not be allowed to watch violent movies.</li>
</ol>
</li>
<li>warm 暖和的，保暖的；热情的<ol>
<li>It’s nice and warm in here.</li>
<li>Take some warm clothes.</li>
<li>We received a warm welcome.</li>
</ol>
</li>
<li>weak 虚弱的，软弱的<ol>
<li>She is still weak after her illness.</li>
<li>a weak leader</li>
</ol>
</li>
<li>wealthy 富有的<ol>
<li>He’s a very wealthy man.</li>
<li>Early to bed, early to rise, makes a man healthy, wealthy and wise.</li>
</ol>
</li>
<li>wet 湿的；下雨的<ol>
<li>Try not to get your shoes wet.</li>
<li>a wet day</li>
</ol>
</li>
<li>wide 宽的；有某种宽度的<ol>
<li>a wide river</li>
<li>The garden is thirty feet wide.</li>
</ol>
</li>
<li>wild 野生的，野的<ol>
<li>wild animals</li>
<li>wild flowers</li>
</ol>
</li>
<li>windy 有风的<ol>
<li>a cold windy day</li>
<li>It’s too windy to go out today.</li>
</ol>
</li>
<li>wise 有智慧的，明智的<ol>
<li>a wise old man</li>
<li>a wise choice</li>
</ol>
</li>
<li>wonderful 极好的，精彩的<ol>
<li>We had a wonderful time last night.</li>
<li>It’s wonderful to see you!</li>
</ol>
</li>
<li>worried 担心的，焦虑的<ol>
<li>You look worried. What’s the matter?</li>
<li>I’m really <strong>worred about</strong> you.</li>
</ol>
</li>
<li>wrong 错误的，有毛病的<ol>
<li>Wrong answer</li>
<li>You are wrong.</li>
<li>Is anything wrong?</li>
<li>What’s wrong with you?<br>5.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>常见动词</title>
    <url>/2020/04/23/Language/English/New%20Concept/Word/Verb/Verb/</url>
    <content><![CDATA[<p>常见动词</p>
<a id="more"></a>
<ol>
<li>act 采取行动；演出<ol>
<li>We must act at once.</li>
<li>She first started acting when she was 12 years old.</li>
</ol>
</li>
<li>admit 承认<ol>
<li>I admit that I was wrong.</li>
<li>He admitted having stolen the car.</li>
</ol>
</li>
<li>advise 建议<ol>
<li>Ethan advised him to leave London.</li>
<li>We advised that they should start early.</li>
</ol>
</li>
<li>afford 负担得起<ol>
<li>You can’t afford the house.</li>
<li>I’d love to go on holiday but I can’t afford the time.</li>
</ol>
</li>
<li>agree 统一<ol>
<li>He agreed to let me go home early.</li>
<li>I couldn’t agree more.</li>
</ol>
</li>
<li>answer 回答，答复<ol>
<li>Think carefully before you answer.</li>
<li>He still hadn’t answered my question.</li>
</ol>
</li>
<li>apologize 道歉<ol>
<li>I think you should <strong>apologize to</strong> you brother.</li>
<li>I apologize for losing my temper.</li>
</ol>
</li>
<li>appear 出现<ol>
<li>A man suddenly appeared from behind at tree.</li>
</ol>
</li>
<li>appreciate 感激，欣赏<ol>
<li>I really appreciate your help.</li>
<li>Her family doesn’t appreciate her.</li>
</ol>
</li>
<li>arrive 到达<ol>
<li>They will <strong>arrive in</strong> New York at noon.</li>
<li>He arrived late as usual.</li>
</ol>
</li>
<li>ask 问<ol>
<li>Don’t be afraid of asking questions.</li>
<li>I asked them their names.</li>
</ol>
</li>
<li>be 是<ol>
<li>I am your new teacher.</li>
<li>Is there a God?</li>
<li>There are many such people.</li>
</ol>
</li>
<li>bear 忍受<ol>
<li>The pain was more than he could bear.</li>
<li>I can’t bear cats in the house.</li>
</ol>
</li>
<li>beat 打，打败，（心脏）跳动<ol>
<li>He was beaten.</li>
<li>Our team was easily beaten.</li>
<li>His heart stopped beating.</li>
</ol>
</li>
<li>become 变为，成为<ol>
<li>She became a doctor.</li>
<li>That child is to become a great leader.</li>
</ol>
</li>
<li>begin 开始<ol>
<li>The meeting will begin at nine.</li>
</ol>
</li>
<li>behave 表现<ol>
<li>He behaved like a child.</li>
<li>Behave yourself.</li>
</ol>
</li>
<li>believe 相信<ol>
<li>I don’t believe your.</li>
<li><strong>Believe it or not</strong>.</li>
</ol>
</li>
<li>bite 咬<ol>
<li>Does your dog bite?</li>
<li>Stop biting your nails.</li>
</ol>
</li>
<li>blame 职责，责备<ol>
<li>Don’t blame me  -it’s not my fault.</li>
</ol>
</li>
<li>book 预定<ol>
<li>I’d like to book a table for two for 8 o’clock tonight.</li>
<li>I’m sorry - we’re fully booked.</li>
</ol>
</li>
<li>borrow 借<ol>
<li>Can I borrow you pen for a minute?</li>
<li>You are allowed to borrow six books from the library at a time.</li>
</ol>
</li>
<li>break 打破，破碎<ol>
<li>I had to break a window to get into the house.</li>
<li>You broke my heart.</li>
<li>Glass breaks easily.</li>
</ol>
</li>
<li>breathe 呼吸<ol>
<li>Breathe deeply.</li>
<li>She’s still breathing.</li>
</ol>
</li>
<li>bring 带来<ol>
<li>I’ll bring a bottle of wine.</li>
<li>She brought her boyfriend to the party.</li>
</ol>
</li>
<li>build 建造<ol>
<li>He is building a house.</li>
<li>Rome wasn’t built in a day.</li>
</ol>
</li>
<li>burn 燃烧，烧毁<ol>
<li>Parts of the building are still burning.</li>
<li>The house was burnt to the ground.</li>
</ol>
</li>
<li>buy 买<ol>
<li>Where did you buy that coat?</li>
<li>Let me buy you a drink.</li>
</ol>
</li>
<li>call 喊叫，打电话<ol>
<li>I heard someone calling.</li>
<li>I’ll call you soon.</li>
</ol>
</li>
<li>can modal v. 能够<ol>
<li>He can speak French.</li>
<li>Can you cook?</li>
</ol>
</li>
<li>care 关系，在乎<ol>
<li>Of course I care about you.</li>
<li>I don’t care!</li>
<li>Who cares?</li>
</ol>
</li>
<li>carry 携带<ol>
<li>She carried her baby in her arms.</li>
<li>He always carries a knife to protect himself.</li>
</ol>
</li>
<li>catch 接住；捉住；赶上<ol>
<li>I threw a ball to her and she caught it.</li>
<li>Cats catch mice.</li>
<li>I’m catching a bus.</li>
</ol>
</li>
<li>change 改变<ol>
<li>Our plans have changed.</li>
<li>I won’t <strong>change my mind.</strong></li>
</ol>
</li>
<li>chat 聊天<ol>
<li>What are you <strong>chatting about</strong>?</li>
<li>You spend too much time <strong>chatting on line.</strong></li>
</ol>
</li>
<li>cheat 欺骗，作弊<ol>
<li>I feel cheated.</li>
<li>Don’t look at my cards - that’s <strong>cheating</strong>.</li>
</ol>
</li>
<li>check 检查<ol>
<li>Could you go and check if the baby’s asleep?</li>
<li>Check the oil and water before setting off.</li>
</ol>
</li>
<li>cheer 欢呼，高兴<ol>
<li>The crowd cheered loudly as the Queen appeared.</li>
<li>Cheer up!</li>
</ol>
</li>
<li>choose 选择<ol>
<li>Which one do you choose?</li>
<li>You chose wisely.</li>
</ol>
</li>
<li>clean 使…干净<ol>
<li>You shoes need cleaning.</li>
<li>You have to clean your own room.</li>
</ol>
</li>
<li>climb 攀登，爬<ol>
<li>The boy was climbing a tree.</li>
<li>She climbed up the stairs.</li>
</ol>
</li>
<li>close 关<ol>
<li>The door closed quietly.</li>
<li>Close your eyes.</li>
</ol>
</li>
<li>collect 收集，收藏<ol>
<li>to collect stamps</li>
<li>Annie collects teddy bears.</li>
</ol>
</li>
<li>consider 考虑<ol>
<li>We are considering going to Canada.</li>
</ol>
</li>
<li>continue 继续<ol>
<li>to be continued</li>
<li>He continued typing while he spoke.</li>
</ol>
</li>
<li>control 控制，管理<ol>
<li>Can’t you control you child?</li>
<li>By the age of 21 he controlled the cpmpany.</li>
</ol>
</li>
<li>cook 做饭<ol>
<li>Where did you learn to cook?</li>
<li>He cooked me lunch.</li>
</ol>
</li>
<li>copy 复制，抄写，模仿<ol>
<li>To copy a file, press F3.</li>
<li>He copied my answer.</li>
<li>Children often copy what they see on television.</li>
</ol>
</li>
<li>cost 花费<ol>
<li>How much does it cost?</li>
<li>The meal cost us 30 dollars.</li>
</ol>
</li>
<li>cover 覆盖<ol>
<li>Dan covered his face with his hands.</li>
<li>Much of the country is covered by snow.</li>
</ol>
</li>
<li>cry 哭，喊<ol>
<li>The child was crying for his mother.</li>
<li>‘Help! Help!’ he cried.</li>
</ol>
</li>
<li>cut 切，割，砍，剪<ol>
<li>Do you want me to cut the cake?</li>
<li>I am going to have my hair cut.</li>
</ol>
</li>
<li>dance 跳舞<ol>
<li>Would you like to dance?</li>
<li>He danced with her all night.</li>
</ol>
</li>
<li>decide 决定<ol>
<li>It’s up to you to decide.</li>
<li>I can’t decide what to wear.</li>
</ol>
</li>
<li>defeat 打败，难倒<ol>
<li>Newcastle were defeated by 3 goals to 2.</li>
<li>The last question defeated me.</li>
</ol>
</li>
<li>depend 依靠，取决于<ol>
<li>‘How long are you staying?’ ‘I don’t know; <strong>it depends.</strong>‘</li>
<li>I don’t want to depend too much on my parent.</li>
</ol>
</li>
<li>describe 描述，形容<ol>
<li>Words cannot describe the beauty of the scene.</li>
<li>Can you describe him to me?</li>
</ol>
</li>
<li>destory 摧毁，毁坏<ol>
<li>The school was completely destoryed by fire.</li>
<li>They’ve destoryed all the evidence.</li>
</ol>
</li>
<li>develop 发展<ol>
<li>Chicago developed into a big city.</li>
</ol>
</li>
<li>devote 奉献，致力于<ol>
<li>She devoted herself to her career.</li>
</ol>
</li>
<li>die 死亡<ol>
<li>He died in 1985 at the age of 76.</li>
<li>Flowers soon die without water.</li>
</ol>
</li>
<li>discover 发现<ol>
<li>Columbus discovered America.</li>
<li>She discovered that she was pregnant.</li>
</ol>
</li>
<li>discuss 讨论<ol>
<li>Have you discussed the problem with anyone?</li>
<li>I’m not prepared to discuss this on the phone.</li>
</ol>
</li>
<li>do 做<ol>
<li>What are you doing this evening?</li>
<li>What can i do for you?</li>
<li>Why can’t you do as you’re told?</li>
</ol>
</li>
<li>doubt 怀疑<ol>
<li>You can complain, but I doubt if it’ll make any difference.</li>
<li>‘Do you think there’ll be any tickets left?’ ‘I doubt it.’</li>
</ol>
</li>
<li>draw 绘画，拉<ol>
<li>She drew a house.</li>
<li>She drew me onto the balcony.</li>
</ol>
</li>
<li>dream 做梦；梦想<ol>
<li>I dreamt about you last night.</li>
<li>She dreamed of becoming a movie star.</li>
</ol>
</li>
<li>dress 穿衣<ol>
<li>Hurry up and <strong>get dressed!</strong></li>
<li>Is she old enough to <strong>dress herself?</strong></li>
<li>He <strong>was dressed in</strong> a blue jacket.</li>
</ol>
</li>
<li>drink 喝；喝酒<ol>
<li>What wold you like to drink?</li>
<li>Don’t drink and drive.</li>
</ol>
</li>
<li>drive 驾驶，开车<ol>
<li>Can you drive?</li>
<li>When did you learn to drive?</li>
</ol>
</li>
<li>drop 落下<ol>
<li>She dropped the torch.</li>
<li>The apples are beginning to drop from the trees.</li>
</ol>
</li>
<li>eat 吃，吃饭<ol>
<li>Would you like something to eat?</li>
<li>Where shall we eat tonight?</li>
</ol>
</li>
<li>enjoy 享受；从…获得乐趣<ol>
<li>Thanks for a great evening. I really enjoyed it.</li>
<li>They all enjoyed themselves at the party.</li>
</ol>
</li>
<li>expect 期望；预料<ol>
<li><strong>As expected</strong>, the whole family was shocked the news.</li>
<li>I didn’t expect him to stay so long.</li>
</ol>
</li>
<li>explain 解释<ol>
<li>Let me explain what i mean.</li>
<li>Wait! I can explain everything.</li>
</ol>
</li>
<li>face 面对，正视<ol>
<li>She turned and faced him.</li>
<li>She’s <strong>faced with</strong> a difficult decision.</li>
<li>Let’s <strong>face it</strong>, we’re not going to win.</li>
</ol>
</li>
<li>fail 失败；不及格<ol>
<li>Doctors <strong>failed to</strong> save the gril’s life.</li>
<li>He failed his driving-test.</li>
</ol>
</li>
<li>fall 落下；跌倒<ol>
<li>One of the kids fell into the river.</li>
<li>Rob fell down the stairs.</li>
</ol>
</li>
<li>feed 喂养<ol>
<li>Have you fed the chickens.</li>
</ol>
</li>
<li>feel 感觉<ol>
<li>How are you feeling today?</li>
<li>I’m feeling a little better today.</li>
</ol>
</li>
<li>fetch 接来，取来<ol>
<li>Quick! <strong>Go and fetch</strong> a doctor.</li>
<li>Please fetch the children from school.</li>
</ol>
</li>
<li>fight 打架，战斗<ol>
<li>Stop fighting, boys!</li>
<li>He fought in Vietnam.</li>
</ol>
</li>
<li>find 发现，找到<ol>
<li>Look what i’ve found.</li>
<li>I can’t find the car keys.</li>
</ol>
</li>
<li>finish 结束，完成<ol>
<li>Have you finished that book yet?</li>
<li>I’ve nearly finished.</li>
</ol>
</li>
<li>fire 开火<ol>
<li>The officer ordered his men to fire.</li>
</ol>
</li>
<li>fit 适合<ol>
<li>His clothes did not fit him very well.</li>
<li>I tried the dress on but it didn’t fit.</li>
</ol>
</li>
<li>fix 安装，修理<ol>
<li>He is fixing a shelf to the wall.</li>
<li>The car won’t start. Can you fix it?</li>
</ol>
</li>
<li>fly 飞<ol>
<li>A big bird flew past us.</li>
<li>She’s flying back to she States tomorrow.</li>
</ol>
</li>
<li>follow 跟随<ol>
<li>He followed her into the house.</li>
<li>Follow me please. I’ll show you the way.</li>
</ol>
</li>
<li>force 强迫<ol>
<li>I had to force myself to get up this morning.</li>
</ol>
</li>
<li>forget 忘记<ol>
<li>Sorry, I forgot.</li>
<li>He forgot her birthday.</li>
<li>Don’t forget to feed the cat.</li>
</ol>
</li>
<li>forgive 原谅，宽恕<ol>
<li>I’ll never forgive her for what she did.</li>
<li>Forgive and forget.</li>
</ol>
</li>
<li>get 得到，收到<ol>
<li>What did you get for Christmas?</li>
<li>I got a letter from Dave this morning.</li>
</ol>
</li>
<li>give 给<ol>
<li>Give me your hand.</li>
<li>I didn’t steal it! Maria gave it to me!</li>
</ol>
</li>
<li>go 去，走<ol>
<li>Go wash your hands.</li>
<li>Where are you going?</li>
<li>Let’s go home.</li>
<li>Let me go.</li>
</ol>
</li>
<li>grow 生长；种植<ol>
<li>A growing child needs plenty of sleep.</li>
<li>grow roses</li>
</ol>
</li>
<li>guess 猜<ol>
<li><strong>Guess what</strong>? I’m taking a day off tomorrow!</li>
<li>I don’t really know. I’m just guessing.</li>
<li>You guessed right.</li>
<li>You guessed wrong.</li>
</ol>
</li>
<li>hand 传递<ol>
<li>Please hand me that book.</li>
<li>Please hand that book to me.</li>
</ol>
</li>
<li>handle 处理，应付<ol>
<li>Leave it to me. I’ll handle it.</li>
<li>He doesn’t handle stress very well.</li>
</ol>
</li>
<li>happen 发生<ol>
<li>What happened next?</li>
<li>If anything <strong>happens to</strong> him, let me know.</li>
</ol>
</li>
<li>hate 讨厌，憎恨<ol>
<li>He hates his job.</li>
<li>I hate to see you unhappy.</li>
<li>I hate to say it, but I don’t think their marriage will last.</li>
</ol>
</li>
<li>have 有<ol>
<li>He has a good memory.</li>
<li>Do you have any pets?</li>
<li>They’ve got two cars.</li>
</ol>
</li>
<li>hear 听说；听见<ol>
<li>I couldn’t hear anything.</li>
<li>Did you hear him go out?</li>
<li>I’m getting married. So i’ve heard.</li>
</ol>
</li>
<li>help 帮助<ol>
<li>Can I help you?</li>
<li>He always <strong>helps with</strong> the housework.</li>
</ol>
</li>
<li>hide 隐藏，躲避<ol>
<li>Harry hid under the bed.</li>
<li>The sun was hidden by the clouds.</li>
</ol>
</li>
<li>hit 打，击<ol>
<li>She hit him on the head with a book.</li>
<li>His parents never hit him.</li>
<li>I was hit by a falling stone.</li>
</ol>
</li>
<li>hold 握住，保住，保持不变<ol>
<li>Hold my hand.</li>
<li>Mom, hold me.</li>
<li>Hold that pose.</li>
</ol>
</li>
<li>hope 希望<ol>
<li><strong>I hope so.</strong></li>
<li><strong>I hope not.</strong></li>
<li>Hope to see you soon.</li>
</ol>
</li>
<li>hunt 打猎；搜索<ol>
<li>Lions sometimes hunt alone.</li>
<li>The police are still hunting the killer.</li>
</ol>
</li>
<li>hurry 匆忙，赶紧<ol>
<li>Hurry up, we’re late!</li>
<li>She hurried away without saying goodbye.</li>
</ol>
</li>
<li>hurt 伤害；感到疼痛<ol>
<li>You are hurting me.</li>
<li>You hurt my heart.</li>
<li>Ouch, it hurts.</li>
<li>Where does it hurt?</li>
</ol>
</li>
<li>introduce 介绍<ol>
<li>Allow me to introduce my wife.</li>
<li>I don’t think we’ve been introduced.</li>
</ol>
</li>
<li>invent 发明<ol>
<li>Who invented the steam engine?</li>
<li>I wish mobile phones had never been invented.</li>
</ol>
</li>
<li>invite 邀请<ol>
<li>I’m afraid I wasn’t invited.</li>
<li>Who should we invite to the party?</li>
</ol>
</li>
<li>join 加入，参加<ol>
<li>Will you join us for lunch?</li>
<li>I decided to join the army.</li>
</ol>
</li>
<li>judge 审判，评判<ol>
<li>You should never judge a person by their looks.</li>
<li>Are you judgeing me?</li>
</ol>
</li>
<li>jump 跳<ol>
<li>Quick, jump! he shouted.</li>
<li>Fans were jumping up and down and cheering.</li>
</ol>
</li>
<li>last 持续<ol>
<li>This weather won’t last.</li>
<li>Whe war lasted for eight years.</li>
</ol>
</li>
<li>laugh 笑<ol>
<li>laugn out loud</li>
<li>He who laughs last laughs longest.</li>
<li>Don’t laugh, but I’ve decided to teach myself French.</li>
</ol>
</li>
<li>lead 领导，带领<ol>
<li>I’ll take part, but I don’t want to lead.</li>
<li>He led us into the house.</li>
</ol>
</li>
<li>learn 学习，学会<ol>
<li>He’s learning to dance.</li>
<li>I learned a lot from my father.</li>
<li>Watch and learn!</li>
</ol>
</li>
<li>leave 离开；使处于什么状态<ol>
<li>It’s time for us to leave.</li>
<li>When are you leaving?</li>
<li>Leave the door open.</li>
<li><strong>Leave me alone</strong>!</li>
</ol>
</li>
<li>lend 借给<ol>
<li>Can you lend me 5 dollars? I’ll pay you back tomorrow.</li>
<li>I’ve lent the car to a friend.</li>
</ol>
</li>
<li>let 让，允许<ol>
<li>Let me in.</li>
<li>Let me out.</li>
<li>Let me go.</li>
<li>Let’s go home.</li>
</ol>
</li>
<li>lie 躺；位于；撒谎<ol>
<li>Don’t lie in bed all morning!</li>
<li>The town lies on the coast.</li>
<li>He’s lying.</li>
</ol>
</li>
<li>lift 举起，抬起<ol>
<li>Lift me up, mommy. I can’t see.</li>
<li>The news lifted our spirits.</li>
</ol>
</li>
<li>light 点燃<ol>
<li>She lit a candle.</li>
<li>He stopped to light a cigarette.</li>
</ol>
</li>
<li>like 喜欢<ol>
<li>She likes him, but doesn’t love him.</li>
<li>She’s never liked swimming.</li>
<li>Would you like something to eat?</li>
</ol>
</li>
<li>listen 听<ol>
<li>Listen! Someone is knocking at the door.</li>
<li>I like listening to music.</li>
<li>I told him not to go, but he just wouldn’t listen.</li>
</ol>
</li>
<li>live 居住；生活<ol>
<li>Where do you live?</li>
<li>The doctors said he only had six months to live.</li>
<li>How long do elephants live?</li>
</ol>
</li>
<li>look 看<ol>
<li>Look! I’m sure that’s Brad Pitt.</li>
<li>She <strong>looked at</strong> me and smiled.</li>
<li>Are you still <strong>looking for</strong> a job?</li>
</ol>
</li>
<li>lose 丢失，失去<ol>
<li>I’ve lost my keys.</li>
<li>He’s lost his job.</li>
</ol>
</li>
<li>love 爱，热爱<ol>
<li>I love you.</li>
<li>I’ve always loved children.</li>
<li>I love my country.</li>
</ol>
</li>
<li>make 制造，做<ol>
<li><strong>made in</strong> France</li>
<li>She makes her own clothes.</li>
<li>I made a cake myself.</li>
</ol>
</li>
<li>marry 嫁，娶<ol>
<li>Will you marry me?</li>
<li>He married a German.</li>
</ol>
</li>
<li>may （modal v）可以；可能<ol>
<li>May I come in?</li>
<li>Thank you. You may go now.</li>
<li>I may be late, so don’t wait for me.</li>
</ol>
</li>
<li>mean 意思是<ol>
<li>What do you mean?</li>
<li>Do you know what i mean?</li>
<li>You mean we have to start all over again?</li>
</ol>
</li>
<li>meet 见面；遇见；人事<ol>
<li>I hope we’ll meet again soon.</li>
<li>I met her in the street.</li>
<li><strong>Nice to meet you .</strong></li>
</ol>
</li>
<li>mend 修理，修补<ol>
<li>It’s never too late to mend your fence.</li>
<li>Tim can mend any broken toy.</li>
</ol>
</li>
<li>mention 提到，提及<ol>
<li>Don’t mention it.</li>
<li>Sorry, I won’t mention it again.</li>
</ol>
</li>
<li>mind 介意；注意<ol>
<li>Would you mind my smoking here?</li>
<li>Mind your head!</li>
</ol>
</li>
<li>miss 想念；错过<ol>
<li>I miss you.</li>
<li>Did you miss me?</li>
<li>You can’t miss it.</li>
<li>What did I miss?</li>
</ol>
</li>
<li>move 移动；搬家<ol>
<li>Don’t move.</li>
<li><strong>Move on</strong>.</li>
<li>We are <strong>moving to</strong> Melbourne soon.</li>
</ol>
</li>
<li>must 必须<ol>
<li>I must go now.</li>
<li>Must you go so soon?</li>
</ol>
</li>
<li>need 需要<ol>
<li>What do you need?</li>
<li>I need your help.</li>
<li>You needn’t know it.</li>
</ol>
</li>
<li>nod 点头<ol>
<li>I aksed him if he would help me and he nodded.</li>
<li>She nodded to me as she walked by.</li>
</ol>
</li>
<li>notice 注意到<ol>
<li>I noticed that he left early.</li>
<li>I noticed them come in.</li>
</ol>
</li>
<li>pass 走过；通过；传递；不要<ol>
<li>She passed me without even saying hello.</li>
<li>Did you pass the exam?</li>
<li>Pass me the salt, please.</li>
<li>I’ll pass.</li>
</ol>
</li>
<li>pay 付款<ol>
<li>I’ll <strong>pay for</strong> the tickets.</li>
<li>How would you like to pay?</li>
</ol>
</li>
<li>permit 允许<ol>
<li>Dogs are not permitted in the building.</li>
<li>I’ll come tomorrwo, <strong>weather permitting</strong>.</li>
</ol>
</li>
<li>phone 打电话<ol>
<li>Did anybody phone?</li>
<li>I’ll phone you this evening.</li>
</ol>
</li>
<li>pick 采，摘；挑选<ol>
<li>Don’t pick flowers.</li>
<li>Stop <strong>picking you nose</strong>.</li>
<li>You can pick whichever you like.</li>
</ol>
</li>
<li>place 放置<ol>
<li>He placed his hand on her shoulder.</li>
<li>Here! Place it on the table.</li>
</ol>
</li>
<li>plan 计划；打算<ol>
<li>Everything went as planned.</li>
<li>When do you plan to take your holiday?</li>
</ol>
</li>
<li>plant 种植<ol>
<li>We’ve planted tomatoes and carrots in the garden.</li>
<li>Do you want to help us plant trees?</li>
</ol>
</li>
<li>play 玩耍；参加比赛；演奏<ol>
<li>You’ll have to play inside today.</li>
<li>Do you play football?</li>
<li>He’s learning to play the piano.</li>
</ol>
</li>
<li>point 指出，指向<ol>
<li>It’s rude to point.</li>
<li>She <strong>pointed a</strong>t a photo on the wall and said “That’s my mother”</li>
</ol>
</li>
<li>practice 练习<ol>
<li>You need to practice every day.</li>
<li>I need to practice my English.</li>
</ol>
</li>
<li>praise 称赞，赞赏<ol>
<li>Aaron was praised by his teacher.</li>
<li>He praised her for her courage.</li>
</ol>
</li>
<li>pray 祈祷，祷告<ol>
<li>I’ll pray for you.</li>
<li>Let us <strong>pray for</strong> peace.</li>
<li>Martha prayed to God for help.</li>
</ol>
</li>
<li>prefer 更喜欢<ol>
<li>There’s coffee and tea. Which yould you prefer?</li>
<li>I prefer jazz to rock music.</li>
<li>Would you prefer me to stay?</li>
</ol>
</li>
<li>prepare 准备<ol>
<li>I had no time to prepare.</li>
<li>He was in the kitchen preparing lunch.</li>
<li>The whole class is preparing for the exams.</li>
</ol>
</li>
<li>pretent 假装<ol>
<li>I’m tired of having to pretent all the time.</li>
<li>I pretended to be asleep.</li>
</ol>
</li>
<li>prevent 预防，阻止<ol>
<li>Nobody can prevent us getting married.</li>
<li>The accident could have been prevented.</li>
</ol>
</li>
<li>promise 答应，许诺<ol>
<li>I can’t promise, but I’ll do my best.</li>
<li>‘Promise me you won’t do any thing stupied’.  I promise.’</li>
</ol>
</li>
<li>protect 保护<ol>
<li>You need warm clothes to protect you against the cold.</li>
<li>Are we doing enough to protect the environment?</li>
</ol>
</li>
<li>prove 证明<ol>
<li>You’re wrong, and I can prove it.</li>
<li>Just give me a chance and I’ll prove it to you.</li>
</ol>
</li>
<li>pull 拉，扯<ol>
<li>You push and I’ll pull.</li>
<li>Stop pulling my hair!</li>
<li>She pulled open the door and hurried inside.</li>
</ol>
</li>
<li>punish 惩罚<ol>
<li>He was punished for refusing to answer theri questions.</li>
<li>My parents used to punish my by not letting watch TV.</li>
</ol>
</li>
<li>push 推<ol>
<li>Push hard when I tell you to.</li>
<li>I pushed the door open.</li>
<li>He tried to kiss her but she pushed him away.</li>
</ol>
</li>
<li>put 放<ol>
<li>She put the book on the table.</li>
<li>Did you put sugar in my tea?</li>
<li>It’s time to put the baby to bed.</li>
</ol>
</li>
<li>rain 下雨<ol>
<li>Is it raining?</li>
<li>It started to rain.</li>
<li>It had been raining hard all night.</li>
</ol>
</li>
<li>raise 举起；增加；养育<ol>
<li>Raise your hand if you know the right answer.</li>
<li>They raised their offer to $500.</li>
<li>I was raised in the countryside.</li>
</ol>
</li>
<li>reach 到达；伸手去拿<ol>
<li>We reached London late at night.</li>
<li>He reached for his gun.</li>
</ol>
</li>
<li>read 读<ol>
<li>She’s still learning to read.</li>
<li>She read us a story.</li>
<li>Go on = read it to us.</li>
</ol>
</li>
<li>realize 意识到<ol>
<li>I realized that she had been lying.</li>
<li>Do you realize you’re an hour late?</li>
</ol>
</li>
<li>receive 收到，接到<ol>
<li>Every child will receive a small gift.</li>
<li>We received a warm welcome.</li>
</ol>
</li>
<li>remember 记得，记住，回想起<ol>
<li>Do you remember Rose?</li>
<li>Remember to locak the door.</li>
<li>I’m sorry - I can’t remember your name.</li>
</ol>
</li>
<li>repair 修理，修补<ol>
<li>Dad was repairing the roof.</li>
<li>Where can i get my shoes repaired?</li>
</ol>
</li>
<li>rest 休息<ol>
<li>The doctor told me to rest.</li>
<li>Rest your eyes every half an hour.</li>
</ol>
</li>
<li>return 返回；归还<ol>
<li>I had to return to the store to look for my purse.</li>
<li>I must return some books to the library.</li>
</ol>
</li>
<li>ring 响；按铃；电话<ol>
<li>Just then, the doorbell rang.</li>
<li>I rang the bell but no one answered.</li>
<li>I’ll ring you tonight.</li>
</ol>
</li>
<li>rise 上升；起身，起立<ol>
<li>The sun rises in the east.</li>
<li>He rose to welcome me.</li>
<li>All rise!</li>
</ol>
</li>
<li>rob 抢劫<ol>
<li>to rob a bank</li>
<li>I was robbed.</li>
</ol>
</li>
<li>run 跑，跑步<ol>
<li>I had to run to catch the bus.</li>
<li>I often go running after work.</li>
</ol>
</li>
<li>take 拿，接受<ol>
<li>He took some keys out of his pocket.</li>
<li>Someone has taken my scarf.</li>
<li>Don’t give him money. He won’t take it.</li>
</ol>
</li>
<li>talk 谈话，交谈<ol>
<li>We talked for an hour.</li>
<li>He was talking to a friend.</li>
<li>What are they <strong>talking about</strong>?</li>
</ol>
</li>
<li>taste 尝起来，品尝<ol>
<li>Mmm! This tastes good!</li>
<li>I can’t really taste anything with this cold.</li>
</ol>
</li>
<li>teach 教书，教<ol>
<li>She teaches at out local shcool.</li>
<li>I teach English.</li>
</ol>
</li>
<li>tell 说，告诉<ol>
<li>Did she tell you her name？</li>
<li>He told everybody the news.</li>
<li>Are you telling the truth?</li>
</ol>
</li>
<li>thank 感谢<ol>
<li><strong>Thank you</strong> every much!</li>
<li>Thank God it’s over!</li>
</ol>
</li>
<li>think 想，考虑；认为<ol>
<li>I’ll think about it.</li>
<li>Do you think it’s going to rain? Yes, I think so.</li>
<li>I don’t think so.</li>
</ol>
</li>
<li>throw 扔，投<ol>
<li>Please throw me that towel.</li>
<li>Throw the ball to me.</li>
<li>Stop throwing stones at the dog!</li>
</ol>
</li>
<li>travel 旅行<ol>
<li>I love travelling.</li>
<li>When I finished college I went travelling for six months.</li>
</ol>
</li>
<li>trust 相信，信赖<ol>
<li>I just don’t trust him.</li>
<li>Don’t trust what the newspapers say.</li>
</ol>
</li>
<li>try 努力，尝试<ol>
<li>I don’t know if I can come, but I’ll try.</li>
<li>He tried to control his voice.</li>
<li>John isn’t here. Try phoning his home number.</li>
</ol>
</li>
<li>turn 转动；转身<ol>
<li>He turned the key in the lock.</li>
<li>Ricky turned and walked away.</li>
<li><strong>Trun right</strong> at the second crossing.</li>
</ol>
</li>
<li>understand 理解，明白<ol>
<li>She doesn’t understand English.</li>
<li>I’m sorry, I don’t understand.</li>
<li>I don’t want you to do that again. Do you understand?</li>
</ol>
</li>
<li>use 使用<ol>
<li>May I use your phone?</li>
<li>Have you ever used this software before?</li>
<li>If you don’t use your English you’ll forget it.</li>
</ol>
</li>
<li>visit 访问；探望；参观<ol>
<li>The Prime Minister is visiting Japan at the moment.</li>
<li>She doesn’t visit her parents very often.</li>
<li>Which cities did you visit in Spain?</li>
</ol>
</li>
<li>work 工作<ol>
<li>Where do you work?</li>
<li>She isn’t working now.</li>
<li>I’ve been working all day.<br>4.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>firewall</title>
    <url>/2020/04/22/Work%20Record/CAAS/Firewall/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=25/tcp --permanent</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
  </entry>
  <entry>
    <title>LocalDateTime的BUG</title>
    <url>/2020/04/22/Work%20Record/CAAS/LocalDateTimeBug/</url>
    <content><![CDATA[<p>记录一个BUG</p><p>SpringBoot Version : 2.1.0 Release</p><p>使用ResponseBody返回json时，如果有LocalDateTime等类型，返回会一直是数组类型，不是想要的结果，移除掉@EnableWebMvc就可以了，不知道为啥，等等Google下原因。</p><a id="more"></a>


<p>百度还是不靠谱。</p>
<p>查了下，在2以后的版本中，@EnableWebMvc会产生冲突。。。</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p>
<p>上面是Spring 官方文档的说明。</p>
<p>如果使用了@EnableMvc，会全面接管配置，导致默认配置失效。</p>
<p>最好是自己写个类，实现WebMvcConfig，然后自定义实现相关接口。</p>
<p>默认的Jackson的ObjectMapper，也有自己的AutoConfig，默认不用改，如果自定ObjectMapper的话，需要注意，@Transient注解标识的字段，默认是不会处理的。最好是继承之前的ObjectMapper，然后定义。不然的话，可能会有问题。</p>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
  </entry>
  <entry>
    <title>名词-其他</title>
    <url>/2020/04/12/Language/English/New%20Concept/Word/Noun/Other/</url>
    <content><![CDATA[<p>其他常见的一些名词</p>
<a id="more"></a>
<ul>
<li>meal 餐，饭<ul>
<li>breakfast, the first meal of the day</li>
<li>Why don’t you ask him out for a meal?</li>
<li>We must have a meal together some time.</li>
</ul>
</li>
<li>breakfast 早餐<ul>
<li>a light breakfast</li>
<li>a big breakfast</li>
<li>a working breakfast</li>
<li>I’m having breakfast.</li>
</ul>
</li>
<li>lunch 午餐<ul>
<li>What’s for lunch?</li>
<li>I’ll have soup for lunch.</li>
<li>I’m afraid he’s at lunch</li>
<li>I’ll take you out to lunch next time.</li>
</ul>
</li>
<li>supper 晚餐<ul>
<li>the Last Supper</li>
<li>We had supper in a small Italian place.</li>
<li>Why don’t you come over for supper on sunday?</li>
</ul>
</li>
<li>dinner 晚餐，正餐<ul>
<li>It’s time for dinner.</li>
<li>Have you had dinner yet?</li>
<li>Perhaps we should invite them to dinner.</li>
</ul>
</li>
<li>eye 眼睛<ul>
<li>She opened her eyes.</li>
<li>She closed her eyes.</li>
<li>I’ve got something in my eye!</li>
</ul>
</li>
<li>eyebrow 眉毛<ul>
<li>He’s got thick eyebrows.</li>
<li>eyebrow pencil</li>
<li>She is plucking her eyebrows.</li>
</ul>
</li>
<li>forehead 额头<ul>
<li>She’s got a high forehead.</li>
</ul>
</li>
<li>neck 脖子，颈<ul>
<li>Giraffes have very long necks.</li>
<li>Jean wore a string of pearis around he neck.</li>
</ul>
</li>
<li>shoulder 肩膀<ul>
<li>shrug one’s shoulders</li>
<li>a person with broad shoulders</li>
</ul>
</li>
<li>heart 心，心脏<ul>
<li>His heart stopped beating.</li>
<li>He has a kind heart.</li>
<li>You broke my heart.</li>
</ul>
</li>
<li>stomach 胃<ul>
<li>My stomach is completely full.</li>
</ul>
</li>
<li>stomachache 胃痛<ul>
<li>The baay-sister says she has a stomachache</li>
</ul>
</li>
<li>arm 胳膊<ul>
<li>left arm</li>
<li>right arm</li>
<li>Peter was carrying a box under his arm.</li>
<li>They walked alone the beach arm in arm.</li>
</ul>
</li>
<li>hand 手<ul>
<li>Go wash you hands.</li>
<li>The young couple were holding hands.</li>
<li>The two leaders shook hands.</li>
<li>Could you give me a hand?</li>
</ul>
</li>
<li>finger 手指<ul>
<li>Everyone has ten fingers.</li>
<li>We ate with our fingers.</li>
</ul>
</li>
<li>fingernail 指甲<ul>
<li>She had long red fingernails.</li>
</ul>
</li>
<li>thumb 大拇指<ul>
<li>The baby is sucking his thumb.</li>
</ul>
</li>
<li>forefinger 食指<ul>
<li>index finger</li>
</ul>
</li>
<li>middle finger 中指</li>
<li>ring finger 无名指</li>
<li>little finger 小指</li>
<li>waist 腰，腰部，腰围<ul>
<li>He put his arm around her waist.</li>
<li>She has a 26-inch waist.</li>
</ul>
</li>
<li>his 臀部<ul>
<li>He stood with his hands on his hips.</li>
</ul>
</li>
<li>leg 腿<ul>
<li>She fell and broke her leg.</li>
<li>a young boy with skinny legs</li>
</ul>
</li>
<li>knee 膝盖，膝<ul>
<li>He went down on one kenn and asked her to marry him.</li>
<li>Sit on my knee.</li>
</ul>
</li>
<li>foot 脚<ul>
<li>My foot hurts.</li>
<li>I’ve been on my feet all day.</li>
<li>It takes about 30 minutes on foot.</li>
</ul>
</li>
<li>toe 脚趾<ul>
<li>Can you touch your toes?</li>
</ul>
</li>
<li>bone 骨头<ul>
<li>This fish has a lot of bones in it.</li>
<li>She was all skin and bone.</li>
</ul>
</li>
<li>skin 皮，皮肤<ul>
<li>She has a dark skin.</li>
<li>a skin disease.</li>
</ul>
</li>
<li>hat 帽子<ul>
<li>Put on you hat.</li>
<li>Take off you hat.</li>
<li>Maria was wearing a beautiful new hat.</li>
</ul>
</li>
<li>scarf 围巾<ul>
<li>You need a scarf on such a cold day.</li>
</ul>
</li>
<li>coat 上衣，外套<ul>
<li>Billy! Put on your coat. It’s cold outside!</li>
</ul>
</li>
<li>shirt 衬衣<ul>
<li>a cotton shirt</li>
<li>I wear a shirt and tie at work.</li>
</ul>
</li>
<li>tie 领带<ul>
<li>black tie</li>
<li>white tie</li>
</ul>
</li>
<li>blouse 女衬衫<ul>
<li>She was wearing a skirt and blouse.</li>
</ul>
</li>
<li>sweater 针织套衫，羊毛套衫<ul>
<li>a V-necked sweater</li>
<li>Put a sweater on if you’re cold.</li>
</ul>
</li>
<li>trousers 裤子</li>
<li>pants 裤子<ul>
<li>a pair of pants</li>
</ul>
</li>
<li>jeans 牛仔裤<ul>
<li>a T-shirt and jeans</li>
<li>She was wearing a pair of tight blue jeans</li>
</ul>
</li>
<li>jacket 短上衣，夹克<ul>
<li>a black leather jacket</li>
</ul>
</li>
<li>dress 连衣裙<ul>
<li>Susan is wearing a long red dress.</li>
</ul>
</li>
<li>skirt 裙子<ul>
<li>a short skirt and high heels</li>
</ul>
</li>
<li>miniskrit 超短裙，迷你裙</li>
<li>suit 套装<ul>
<li>a business suit</li>
</ul>
</li>
<li>shoe 鞋<ul>
<li>a pair of shoes</li>
<li>I took off my shoes.</li>
</ul>
</li>
<li>sock 袜子<ul>
<li>a pair of socks</li>
<li>Put on your shoes and socks.</li>
</ul>
</li>
<li>stocking 长筒袜<ul>
<li>a pair of silk stockings</li>
</ul>
</li>
<li>glove 手套<ul>
<li>a paire of gloves</li>
<li>boxing gloves</li>
</ul>
</li>
<li>pajamas 睡衣裤<ul>
<li>pyjamas</li>
<li>Why are you still in your pajamas?</li>
</ul>
</li>
<li>cotton 棉花，棉布<ul>
<li>a white cotton shirt</li>
<li>100% cotton</li>
<li>cotton candy</li>
</ul>
</li>
<li>wool 羊毛<ul>
<li>a pure wool skirt</li>
<li>100% wool</li>
</ul>
</li>
<li>silk 丝<ul>
<li>a silk blouse</li>
<li>silk stockings</li>
<li>Her skin was as smooth as silk.</li>
</ul>
</li>
<li>leather 皮，毛皮<ul>
<li>leather shoes</li>
<li>a leather jacket</li>
</ul>
</li>
<li>family 家庭，家人<ul>
<li>a one-parent family</li>
<li>Do you know the family next door?</li>
</ul>
</li>
<li>mother 母亲，妈妈<ul>
<li>Good night, Mother.</li>
<li>His mother is a doctor.</li>
<li>mother cat</li>
</ul>
</li>
<li>mom 妈妈<ul>
<li>mommy</li>
<li>I miss my mom a lot.</li>
<li>Mom, I’m hungry.</li>
</ul>
</li>
<li>father 父亲，爸爸<ul>
<li>Ben’s a wonderful father.</li>
<li>My boss is a father of three.</li>
</ul>
</li>
<li>dad 爸爸<ul>
<li>daddy</li>
<li>Dad, will you help me?</li>
</ul>
</li>
<li>son 儿子<ul>
<li>He has a son and two daughters.</li>
</ul>
</li>
<li>daughters 女儿<ul>
<li>My daughter is three years old.</li>
</ul>
</li>
<li>grandfather 祖父<ul>
<li>His grandfather was a professor.</li>
</ul>
</li>
<li>grandmother 祖母<ul>
<li>My grandmother passed away two years ago.</li>
</ul>
</li>
<li>uncle 叔叔，伯父，舅父，姑父，姨夫<ul>
<li>Uncle Philip</li>
<li>Uncle sam</li>
</ul>
</li>
<li>aunt 姨妈，姑妈，伯母，舅妈<ul>
<li>auntie</li>
<li>Aunt Mary</li>
</ul>
</li>
<li>brother 兄，弟<ul>
<li>big brother</li>
<li>little brother</li>
</ul>
</li>
<li>sister 姐，妹<ul>
<li>big sister</li>
<li>little sister</li>
<li>Do you have any brothers or sisters?</li>
</ul>
</li>
<li>cousin 堂（表）兄弟姐妹<ul>
<li>She is my cousin.</li>
</ul>
</li>
<li>husband 丈夫<ul>
<li>This is my husband, Steve.</li>
<li>ex-husband 前夫</li>
</ul>
</li>
<li>wife 妻子<ul>
<li>She is a good wife and mother.</li>
<li>ex-wife 前妻</li>
</ul>
</li>
<li>boyfriend 男朋友<ul>
<li>He’s not my boyfriend - we’re just good friends!</li>
</ul>
</li>
<li>girlfriend 女朋友<ul>
<li>Does he have a girlfriend?</li>
</ul>
</li>
<li>friend 朋友<ul>
<li>We are good friends.</li>
</ul>
</li>
<li>plane 飞机<ul>
<li>The plane is aboud to land.</li>
<li>travel by plane</li>
<li>The plane will take off in twenty minutes.</li>
</ul>
</li>
<li>train 火车<ul>
<li>I went to Qingdao by train last year.</li>
<li>get on the train</li>
<li>get off the train</li>
</ul>
</li>
<li>bus 公共汽车<ul>
<li>Shall we walk or go by bus?</li>
<li>Hurry up or we’ll miss the bus!</li>
</ul>
</li>
<li>coach 长途公共汽车<ul>
<li>a coach station</li>
</ul>
</li>
<li>subway 地铁<ul>
<li>a subway train</li>
<li>a subway station</li>
</ul>
</li>
<li>taxi 出租汽车<ul>
<li>I <strong>took a taxi</strong> to the airport.</li>
<li>She arrived by taxi.</li>
</ul>
</li>
<li>bike 自行车<ul>
<li>They’ll come <strong>by bike</strong>.</li>
</ul>
</li>
<li>motorbike 摩托车<ul>
<li>She jumped on her motorbike.</li>
</ul>
</li>
<li>boat 小船<ul>
<li>a fishing boat</li>
<li>row a boat</li>
<li>We crossed the river <strong>by boat</strong>.</li>
</ul>
</li>
<li>ship 轮船<ul>
<li>She travelled to Japan by ship.</li>
</ul>
</li>
<li>ferry 渡船<ul>
<li>The ferry leaves for France at one o’clock.</li>
</ul>
</li>
<li>truck 卡车<ul>
<li>a truck driver</li>
</ul>
</li>
<li>car 小汽车<ul>
<li>I bought a new car.</li>
<li>He always goes to work by car.</li>
</ul>
</li>
<li>jeep 吉普车<ul>
<li>Is this a jeep or a truck?</li>
</ul>
</li>
<li>bus stop 公共汽车站<ul>
<li>She is waiting at the bus stop.</li>
</ul>
</li>
<li>railway station 火车站<ul>
<li>I’ll meet you at the railway statoin.</li>
</ul>
</li>
<li>subway station 地铁站<ul>
<li>Excuse me, how can i get on the subway station.</li>
</ul>
</li>
<li>airport 机场<ul>
<li>Her family went to see her off at the airport.</li>
</ul>
</li>
<li>teacher 教师<ul>
<li>I’m an English teacher.</li>
</ul>
</li>
<li>professor 教授<ul>
<li>Professor Stephen Hawking</li>
</ul>
</li>
<li>writer 作家，作者<ul>
<li>He is a writer of children’s stories.</li>
</ul>
</li>
<li>doctor 医生<ul>
<li>You’d better see a doctor.</li>
</ul>
</li>
<li>dentist 牙医<ul>
<li>I’m going to <strong>the dentist’s</strong> this afternoon.</li>
</ul>
</li>
<li>nurse 护士<ul>
<li>His aunt is a nurse.</li>
</ul>
</li>
<li>singer 歌手<ul>
<li>My favorite <strong>pop singer</strong> is Michael Jackson.</li>
</ul>
</li>
<li>dancer 舞蹈演员，舞者<ul>
<li>His ex-girlfriend was a dancer.</li>
</ul>
</li>
<li>painter 画家<ul>
<li>a famous painter</li>
</ul>
</li>
<li>lawyer 律师<ul>
<li>I want to see my lawyer before i say anything.</li>
</ul>
</li>
<li>engineer 工程师<ul>
<li>They’re sending an engineer to fix the telephone line.</li>
</ul>
</li>
<li>designer 设计师<ul>
<li>I want to be a fashion disigner.</li>
</ul>
</li>
<li>actor 演员<ul>
<li>You have to be a very good actor to play that part.</li>
</ul>
</li>
<li>actress 女演员<ul>
<li>She’s a great dramatic actress.</li>
</ul>
</li>
<li>waiter 服务员<ul>
<li>Waiter, could you bring me some water?</li>
</ul>
</li>
<li>waitress 女服务员<ul>
<li>I’ll ask the waitress for the bill.</li>
</ul>
</li>
<li>businessman 商人<ul>
<li>Her husband is a successful businessman.</li>
</ul>
</li>
<li>taxi driver 出租车司机<ul>
<li>He was once a taxi driver; now he is a college student.</li>
</ul>
</li>
<li>bus driver 公交车司机<ul>
<li>Why don’t you ask the bus driver?</li>
</ul>
</li>
<li>accountant 会计师<ul>
<li>Certified public accountant（CPA）</li>
</ul>
</li>
<li>cashier 出纳员<ul>
<li>She is a cashier in a supermarket.</li>
</ul>
</li>
<li>salesperson 售货员，推销员<ul>
<li>a car salesperson</li>
</ul>
</li>
<li>vet 兽医<ul>
<li>I’m going to take the dog to the vet’s tomorrow.</li>
</ul>
</li>
<li>worker 工人<ul>
<li>part-time workters</li>
<li>blue-collar workers</li>
<li>white-collar workers</li>
</ul>
</li>
<li>clerk 职员<ul>
<li>a bank clerk</li>
<li>an office clerk</li>
</ul>
</li>
<li>boss 老板<ul>
<li>I’ll have to ask my boss for a day off.</li>
<li>I’ll my own boss.</li>
</ul>
</li>
<li>model 模特<ul>
<li>a male model</li>
<li>a fashion model</li>
</ul>
</li>
<li>cook 厨师<ul>
<li>He works as a cook in a local restaurant.</li>
<li>Who was the cook?</li>
</ul>
</li>
<li>chef 大厨，厨师长<ul>
<li>He is one of the top chefs in China.</li>
</ul>
</li>
<li>farmer 农场主，农民<ul>
<li>a pig farmer </li>
</ul>
</li>
<li>pilot 飞机员<ul>
<li>Her husband is very good pilot.</li>
</ul>
</li>
<li>captain 船长，机长，队长<ul>
<li>Captain Cook</li>
<li>Captain American</li>
</ul>
</li>
<li>flight attendant 空中乘务员<ul>
<li>It’s not easy to be a good flight attendant.</li>
</ul>
</li>
<li>policeman 男警察<ul>
<li>That policeman’s waving to you.</li>
<li>policewoman</li>
</ul>
</li>
<li>firefighter 消防队员<ul>
<li>He wants to be a firefighter.</li>
</ul>
</li>
<li>dustman 清洁工<ul>
<li>Alf’s wife has never discovered that she married a dustman.</li>
</ul>
</li>
<li>hairdresser 理发师<ul>
<li>That hairdresser curled my hair.</li>
</ul>
</li>
<li>milkman 送牛奶的人<ul>
<li>Have you paid the milkman this month?</li>
</ul>
</li>
<li>postman 邮递员<ul>
<li>Has the postman come this morning?</li>
</ul>
</li>
<li>scientist 科学家<ul>
<li>When i was a kid, my dream was to be a scientist.</li>
</ul>
</li>
<li>baker 面包师傅<ul>
<li>I’m just going to the baker’s.</li>
</ul>
</li>
<li>mayor 市长<ul>
<li>the mayor of New York</li>
</ul>
</li>
<li>president 总统<ul>
<li>President Obama</li>
<li>Do you have any comment, Mr.President?</li>
</ul>
</li>
<li>priest 牧师，神父<ul>
<li>He had trained to be a Catholic priest.</li>
</ul>
</li>
<li>editor 编辑<ul>
<li>the editor of the Washington Post</li>
</ul>
</li>
<li>real estate agent 房产中介<ul>
<li>I spoke to a real estate agent about mu house.</li>
</ul>
</li>
<li>journalist 新闻记者<ul>
<li>a well-known journalist</li>
</ul>
</li>
<li>tour guide 导游<ul>
<li>A tour guide took us around the city.</li>
</ul>
</li>
<li>manager 经理<ul>
<li>a bank manager</li>
<li>a hotel manager</li>
<li>I’d like to speak to the manager.</li>
</ul>
</li>
<li>secretary 秘书<ul>
<li>My secretary will fax you all the details.</li>
</ul>
</li>
<li>sun 太阳<ul>
<li>The sun rises in the east and sets in the west.</li>
<li>The sun is shining and birds are singing.</li>
</ul>
</li>
<li>earth 地球<ul>
<li>The moon goes round the earth.</li>
<li>I must be the happiest person <strong>on the earch</strong>.</li>
</ul>
</li>
<li>moon 月球<ul>
<li>full moon</li>
<li>the Americans landed on the moon in 1969.</li>
</ul>
</li>
<li>star 星星<ul>
<li>The sky was filled with stars.</li>
<li>Twinkle, twinkle, little star, How i wonder what you are. Up above the world so high, Like a diamond in the sky.</li>
</ul>
</li>
<li>air 空气<ul>
<li>Let’s go outside and get some fresh air.</li>
<li>I’d prefer to travel <strong>by air</strong>.</li>
</ul>
</li>
<li>sky 天空<ul>
<li>a clear blue sky</li>
<li>There isn’t a cloud in the sky.</li>
</ul>
</li>
<li>cloud 云<ul>
<li>dark cloud</li>
<li>The sun went behind a cloud.</li>
</ul>
</li>
<li>tree 树<ul>
<li>As a kid, i loved to climb trees.</li>
<li>We planted a peach tree in the backyard.</li>
</ul>
</li>
<li>leaf 叶子，树叶<ul>
<li>fallen leaves</li>
<li>He was sweeping up leaves in his garden.</li>
</ul>
</li>
<li>branch 树枝<ul>
<li>She climbed the tree and hid in the branch.</li>
</ul>
</li>
<li>trunk 树干<ul>
<li>the trunk of an old oak tree</li>
</ul>
</li>
<li>root 根<ul>
<li>I pulled the plant up by the roots.</li>
<li>root vegetables</li>
</ul>
</li>
<li>grass 草<ul>
<li>Keep off the grass.</li>
<li>The dry grass caught fire.</li>
</ul>
</li>
<li>flower 花<ul>
<li>a flower garden</li>
<li>a flower show</li>
<li>She bent down and picked a flower.</li>
</ul>
</li>
<li>bud 花蕾，芽<ul>
<li>rose bug</li>
</ul>
</li>
<li>rose 玫瑰<ul>
<li>a bunch of red rose</li>
<li>a rose garden</li>
</ul>
</li>
<li>lily 百合花<ul>
<li>The are always fresh lilies on her desk.</li>
</ul>
</li>
<li>tulip 郁金香<ul>
<li>Tulip is the national flower of Holland.</li>
</ul>
</li>
<li>sunflower 向日葵<ul>
<li>sunflower seeds</li>
<li>A bee sits on a sunflower in the garden.</li>
</ul>
</li>
<li>daisy 雏菊<ul>
<li>A daisy is a small wild flower with a yellow center and white petals.</li>
</ul>
</li>
<li>road 路<ul>
<li>road signs</li>
<li>All roads lead to Rome.</li>
</ul>
</li>
<li>street 街道<ul>
<li>I met a friend <strong>in the street</strong>.</li>
<li>The bank is just <strong>across the street</strong>.</li>
</ul>
</li>
<li>way 道路，方法<ul>
<li>This way, please.</li>
<li>No way!</li>
<li>I’m sure he loves you, <strong>in his own way</strong>.</li>
</ul>
</li>
<li>building 建筑物，大楼<ul>
<li>They were on the upper floor of the building.</li>
</ul>
</li>
<li>floor 地板，楼层<ul>
<li>wooden floor</li>
<li>kitchen floor</li>
<li>We live on the eighth floor.</li>
</ul>
</li>
<li>basement 地下室<ul>
<li>Dad is working in the basement.</li>
</ul>
</li>
<li>ground 地面<ul>
<li>He lay on the ground and stared up at sky.</li>
<li>playground 操场</li>
</ul>
</li>
<li>door 门<ul>
<li>Could you <strong>open the door</strong> for me?</li>
<li>He quickly <strong>shut the door</strong>.</li>
<li>Someone is <strong>knocking at the door</strong>.</li>
</ul>
</li>
<li>gate 门<ul>
<li>Please wait <strong>at the gate</strong>.</li>
<li>Two guards are standing <strong>at the gate</strong>.</li>
</ul>
</li>
<li>window 窗户<ul>
<li>a broken window</li>
<li>I saw them through the window.</li>
<li>She looked out of the window.</li>
</ul>
</li>
<li>glass 玻璃<ul>
<li>a glass bowl</li>
<li>a piece of broken glass</li>
</ul>
</li>
<li>metal 金属<ul>
<li>a small black metal box</li>
<li>The gate is made of metal.</li>
</ul>
</li>
<li>rain 雨<ul>
<li>heavy rain</li>
<li>light rain</li>
<li>Don’t go out in the rain.</li>
</ul>
</li>
<li>rainbow 彩虹<ul>
<li>Oh look, a rainbow!</li>
<li>all the clolors of the rainbow</li>
</ul>
</li>
<li>snow 雪<ul>
<li>The snow began to fall.</li>
<li>Children were playing in the snow</li>
<li>snowman</li>
</ul>
</li>
<li>wind 风<ul>
<li>strong/heavy winds</li>
<li>a north wind</li>
<li><strong>A gust of wind</strong> blew my hat off.</li>
</ul>
</li>
<li>lightning 闪电<ul>
<li>a flash of lightning</li>
<li>The poor dog <strong>was struck by lightning</strong>.</li>
</ul>
</li>
<li>thunder 雷<ul>
<li><strong>a peal of thunder</strong></li>
<li>a storm with thunder and lightning</li>
</ul>
</li>
<li>storm 暴风雨，暴风雪<ul>
<li>a dust storm</li>
<li>A storm is coming.</li>
</ul>
</li>
<li>kindergarten 幼儿园<ul>
<li>Susie is in kindergarten now.</li>
</ul>
</li>
<li>school 学校<ul>
<li>a school bus</li>
<li>go to school</li>
<li>It’s <strong>time for school</strong>.</li>
</ul>
</li>
<li>primary school 小学<ul>
<li>elementary school</li>
<li>junior high school</li>
<li>senior high school</li>
</ul>
</li>
<li>college 大学，学院<ul>
<li>a college professor</li>
<li>King’s College, Cambridge</li>
<li>She’s at college.</li>
</ul>
</li>
<li>university 大学<ul>
<li>She hopes to <strong>go to university</strong> next year.</li>
<li>He studied Physics <strong>at university</strong>.</li>
</ul>
</li>
<li>grade 年级<ul>
<li>My son’s in the third grade.</li>
</ul>
</li>
<li>class 班级，课<ul>
<li>We were in the same class at scool.</li>
<li>I have a math class at 9 o’clock.</li>
</ul>
</li>
<li>classroom 教室<ul>
<li>She is in the classroom.</li>
</ul>
</li>
<li>classmate 同班同学<ul>
<li>The gril with long hair is my classmate.</li>
</ul>
</li>
<li>department 系，部门<ul>
<li>the Engligh department</li>
<li>the Educatoin Department</li>
</ul>
</li>
<li>subject 学科，话题<ul>
<li>Physics and math are my favouite subject.</li>
<li>an interesting subject of conversation</li>
<li>Chinese 语文</li>
<li>English 英语</li>
<li>math 数学</li>
<li>physics 物理</li>
<li>chemistry 化学</li>
<li>history 历史</li>
<li>geology 地理</li>
</ul>
</li>
<li>country 国家<ul>
<li>European countries</li>
<li>There will be rain in all parts of the country.</li>
<li>China 中国</li>
<li>America 美国</li>
<li>England 英国</li>
<li>France 法国</li>
<li>Germany 德国</li>
<li>Italy 意大利</li>
<li>Austria 奥地利</li>
<li>Turkey 土耳其</li>
<li>Spain 西班牙</li>
<li>Greece 希腊</li>
<li>Sweden 瑞典</li>
<li>Switzerland 瑞士</li>
<li>Russia 俄罗斯</li>
<li>Canada 加拿大</li>
<li>Australia 澳大利亚</li>
<li>New Zealand 新西兰</li>
<li>Japan 日本</li>
<li>Korea 朝鲜，韩国</li>
<li>India 印度</li>
<li>Vietnam 越难</li>
<li>Malaysia 马来西亚</li>
<li>Philippines 菲律宾</li>
</ul>
</li>
<li>time 时间<ul>
<li><strong>Long time no see.</strong></li>
<li>That will <strong>take time</strong>.</li>
<li><strong>Time heals all wounds.</strong></li>
</ul>
</li>
<li>year 年，年纪<ul>
<li>last year</li>
<li>this year</li>
<li>next year</li>
<li>My son is 4 <strong>years old</strong>.</li>
</ul>
</li>
<li>month 月<ul>
<li>She’ll be thirteen <strong>this month</strong>.</li>
<li>He’ll be away for two months.</li>
<li>I haven’t seen him <strong>for months</strong>.</li>
</ul>
</li>
<li>week 星期<ul>
<li>I can’t see you this weak.</li>
<li>See you next week.</li>
<li>Last week I was very busy.</li>
</ul>
</li>
<li>weekend 周末<ul>
<li>Have a nice weekend!</li>
<li>What are you doing <strong>on the weekend</strong>?</li>
</ul>
</li>
<li>day 一天，白天<ul>
<li>There are seven days in a week.</li>
<li>He has been working all day.</li>
</ul>
</li>
<li>night 夜晚，晚上<ul>
<li>Good night!</li>
<li>These animals only comt out <strong>at night</strong>.</li>
</ul>
</li>
<li>morning 上午，早晨<ul>
<li>Good morning!</li>
<li>I’ll see you <strong>tomorrow morning</strong>.</li>
<li>I prefer coffee <strong>in the morning</strong>.</li>
</ul>
</li>
<li>afternoon 下午<ul>
<li>Good afternoon, ladies and gentlemen!</li>
<li><strong>In the afternoon</strong> they went shopping.</li>
</ul>
</li>
<li>evening 晚上<ul>
<li>Good evening, everyone.</li>
<li>What do you usually do <strong>in the evening</strong>?</li>
</ul>
</li>
<li>tomorrow 明天<ul>
<li>See you tomorrow!</li>
<li>We’re meeting <strong>tomorrow evening</strong>.</li>
<li><strong>the day after tomorrow</strong></li>
</ul>
</li>
<li>yesterday 昨天<ul>
<li>Where were you yesterday morning?</li>
<li><strong>yeserday once more</strong></li>
<li><strong>the day before yesterday</strong></li>
</ul>
</li>
<li>hour 小时<ul>
<li>The movie lasts two hours.</li>
<li>I’ll be back in three hours.</li>
</ul>
</li>
<li>minute 分钟<ul>
<li>Just a minue.</li>
<li>Our guests will be here <strong>in a minute</strong>!</li>
<li>He returned <strong>a few minutes later</strong>.</li>
</ul>
</li>
<li>second 秒<ul>
<li>Hold you breath for six seconds.</li>
<li>I’ll be back in a second.</li>
<li>Just a second, I’ll come and help.</li>
</ul>
</li>
<li>moment 瞬间，片刻，时机<ul>
<li>Could you wait a moment, please?</li>
<li>I’ll be back <strong>in a moment</strong>.</li>
<li>Wait for the right moment.</li>
</ul>
</li>
<li>Monday 星期一<ul>
<li>last Monday</li>
<li>next Monday</li>
<li>They met <strong>on Monday</strong> and got married on Friday.</li>
</ul>
</li>
<li>Tuesday 星期二</li>
<li>Wednesday 星期三</li>
<li>Thursday 星期四</li>
<li>Friday 星期五</li>
<li>Saturday 星期六</li>
<li>Sunday 星期天</li>
<li>January 一月<ul>
<li>She started working there <strong>in January</strong>.</li>
</ul>
</li>
<li>February 二月</li>
<li>March 三月</li>
<li>April 四月</li>
<li>May 五月</li>
<li>June 六月</li>
<li>July 七月</li>
<li>August 八月</li>
<li>September 九月</li>
<li>October 十月</li>
<li>November 十一月</li>
<li>December 十二月</li>
<li>season 季节<ul>
<li>the dry season</li>
<li>the rainy season</li>
<li>Spring is my favorite season.</li>
</ul>
</li>
<li>spring 春季<ul>
<li>He was born <strong>in the spring</strong> of 1944.</li>
<li>There’s a feeling of spring in the air today.</li>
</ul>
</li>
<li>summer 夏天<ul>
<li><strong>In (the) summer</strong>, we often go on holiday,</li>
<li>We’re going to Italy <strong>next summer</strong>.</li>
</ul>
</li>
<li>autumn 秋天<ul>
<li>fall</li>
<li>in the early autumn</li>
<li>in the late autumn</li>
</ul>
</li>
<li>winter 冬天<ul>
<li>It usually snows here <strong>in the winter</strong>.</li>
</ul>
</li>
<li>holiday 假日，节日<ul>
<li>The school holidays start tomorrow.</li>
<li>I’m taking two weeks holiday.</li>
</ul>
</li>
<li>ocean 海洋<ul>
<li>the Pacific Ocean</li>
<li>the Atlantic Ocean</li>
<li>the Indian Ocean</li>
<li>the Arctic Ocean</li>
</ul>
</li>
<li>sea 大海<ul>
<li>travel <strong>by sea</strong></li>
<li>a cottage <strong>by the sea</strong></li>
</ul>
</li>
<li>beach 海滩<ul>
<li>a beautiful <strong>sandy beach</strong></li>
<li>I just want to lie <strong>on the beach</strong> in the sun.</li>
</ul>
</li>
<li>river 河流<ul>
<li>the Mississippi River</li>
<li>We went for a walk <strong>alone the river</strong>.</li>
</ul>
</li>
<li>lake 湖<ul>
<li>Lake geneva</li>
<li>We swam <strong>in the lake</strong>.</li>
</ul>
</li>
<li>mountain 山<ul>
<li>the Rocky Mountains</li>
<li>There is still snow on the mountain tops.</li>
</ul>
</li>
<li>hill 小山<ul>
<li>The house is on the side of a hill.</li>
</ul>
</li>
<li>land 陆地<ul>
<li>travel <strong>by land</strong></li>
<li>It was good to be back <strong>on land</strong>.</li>
</ul>
</li>
<li>island 岛<ul>
<li>a remote island</li>
</ul>
</li>
<li>cinema 电影院<ul>
<li>We dicided to <strong>go to the cinema</strong>.</li>
<li>It’s on <strong>at the</strong> local cinema.</li>
</ul>
</li>
<li>theater 剧场，戏院<ul>
<li>an open-air theatre</li>
</ul>
</li>
<li>library 图书馆<ul>
<li>a public library</li>
<li>Let’s meet outside the library.</li>
</ul>
</li>
<li>museum 博物馆<ul>
<li>the Natural History Museum</li>
<li>Night at the Museum</li>
</ul>
</li>
<li>park 公园<ul>
<li>Let’s go for a walk in the park.</li>
<li>They stopped and sat on a park bench.</li>
</ul>
</li>
<li>garden 花园<ul>
<li>Out house has a small garden.</li>
<li>Children are playing in the garden.</li>
</ul>
</li>
<li>hospital 医院<ul>
<li>He had to <strong>go to hospital.</strong></li>
<li>She spend two weeks <strong>in hospital.</strong></li>
</ul>
</li>
<li>church 教堂<ul>
<li>How often do you <strong>go to church</strong>?</li>
<li>We didn’t see you <strong>at church</strong> this morning.</li>
</ul>
</li>
<li>shopping mall 购物中心<ul>
<li>They are planning to build another <strong>shopping mall</strong> around here.</li>
</ul>
</li>
<li>post office 邮局<ul>
<li>You can buy your stamps at the post office.</li>
</ul>
</li>
<li>bank 银行<ul>
<li>a bank manager</li>
<li>a bank account</li>
</ul>
</li>
<li>market 市场<ul>
<li>I usually buy fruit and vegetables at the market.</li>
</ul>
</li>
<li>supermarket 超市<ul>
<li>Another supermarket opened last week.</li>
</ul>
</li>
<li>restaurant 餐厅<ul>
<li>a Chinese restaurant</li>
<li>We went out to a restaurant to celebrate.</li>
</ul>
</li>
<li>farm 农场<ul>
<li>farm workers</li>
<li>fresh farm produce</li>
</ul>
</li>
<li>castle 城堡<ul>
<li>a medieval castle</li>
</ul>
</li>
<li>place 地方<ul>
<li>public places</li>
<li>The place was full of screaming children.</li>
</ul>
</li>
<li>film 电影<ul>
<li>movie</li>
<li>What’s you favorite film?</li>
<li>Let’s <strong>watch a film</strong>.</li>
</ul>
</li>
<li>play 戏剧<ul>
<li>We are going to see a new play.</li>
</ul>
</li>
<li>game 游戏，比赛<ul>
<li>Game over</li>
<li>Did you see the game on TV last night?</li>
</ul>
</li>
<li>ball 球<ul>
<li>Go fetch the ball!</li>
</ul>
</li>
<li>football 足球，橄榄球</li>
<li>basket 篮子<ul>
<li>a shopping basket</li>
</ul>
</li>
<li>basketball 篮球</li>
<li>baseball 棒球<ul>
<li>a baseball bat</li>
<li>a baseball team</li>
</ul>
</li>
<li>tennis 网球<ul>
<li>a tennis player</li>
<li>a tennis club</li>
</ul>
</li>
<li>table tennis 乒乓球<ul>
<li>I’ve never played <strong>table tennis</strong> before.</li>
</ul>
</li>
<li>piano 钢琴<ul>
<li>a piano teacher</li>
<li>Do you <strong>play the piano</strong>?</li>
</ul>
</li>
<li>violin 小提琴<ul>
<li>I used to <strong>play the violin</strong>.</li>
</ul>
</li>
<li>guitar 吉他<ul>
<li>Her son <strong>plays the guitar</strong> in the rock band.</li>
</ul>
</li>
<li>flute 长笛</li>
<li>drum 鼓</li>
<li>person 人<ul>
<li>You are a very nice person.</li>
<li>I’m not really a city person.</li>
</ul>
</li>
<li>people 人们<ul>
<li>How many people were at the meeting?</li>
<li>I don’t care what people thinks.</li>
</ul>
</li>
<li>man 男人，男子汉<ul>
<li>Carson is a very busy man.</li>
<li>There are two men and a woman in the car.</li>
<li>Come on, be a man now. No more crying.</li>
</ul>
</li>
<li>gentleman 先生，绅士，君子<ul>
<li>Thank you. You’re a real gentleman.</li>
<li>Good morning, ladies and gentleman.</li>
</ul>
</li>
<li>woman 女人<ul>
<li>a single woman</li>
<li>married women</li>
<li>a woman driver</li>
</ul>
</li>
<li>lady 女士，淑女<ul>
<li>Ask that lady to help you.</li>
<li>She’s a real lady. She never loses her temper.</li>
</ul>
</li>
<li>boy 男孩，儿子<ul>
<li>The boys wanted to play football.</li>
<li>How old is your little boy?</li>
</ul>
</li>
<li>girl 女孩，女儿<ul>
<li>Good morning, girls and boys!</li>
<li>They have two girls and a boy.</li>
</ul>
</li>
<li>child 儿童，孩子<ul>
<li>I was very happy as a child.</li>
<li>She is married with three children.</li>
</ul>
</li>
<li>kid 小孩<ul>
<li>She’s alwasy loved animals since she was a little kid.</li>
<li>How are your wife and kids?</li>
</ul>
</li>
<li>baby 婴儿，宝贝<ul>
<li>The baby is crying.</li>
<li>Come here, baby.</li>
</ul>
</li>
<li>nieighbor 邻居<ul>
<li>my next-door neighbor</li>
<li>I’m you new neighbor.</li>
</ul>
</li>
<li>Mr. 先生<ul>
<li>Mr. and Mrs. Smith</li>
<li>Mr. President</li>
</ul>
</li>
<li>Mrs 夫人，太太<ul>
<li>Mrs. Brown</li>
</ul>
</li>
<li>Miss 小姐，女士<ul>
<li>That’s all, thank you, Miss Lipman.</li>
<li>Miss America</li>
<li>I know the answer, Miss.</li>
</ul>
</li>
<li>Ms. 女士</li>
<li>sir 先生<ul>
<li>Can i help you, sir?</li>
<li>Are you ready to order, sir?</li>
<li>Dear Sir</li>
</ul>
</li>
<li>madam 女士，夫人<ul>
<li>ma’am</li>
</ul>
</li>
<li>city 城市<ul>
<li>New York City</li>
<li>Beijing is China’s capital city.</li>
</ul>
</li>
<li>town 城镇<ul>
<li>The village where I was born is a town now.</li>
</ul>
</li>
<li>village 村子<ul>
<li>a fishing village</li>
<li>a mountain village</li>
</ul>
</li>
<li>color 颜色<ul>
<li>colour</li>
<li>What color are his eyes?</li>
<li>I love wearing bright colors.</li>
</ul>
</li>
<li>white 白色</li>
<li>black 黑色</li>
<li>red 红色</li>
<li>pink 粉色</li>
<li>purple 紫色</li>
<li>green 绿色</li>
<li>yellow 黄色</li>
<li>blue 蓝色</li>
<li>orange 橘色</li>
<li>brown 棕色</li>
<li>gray grey 灰色</li>
<li>silver 银色</li>
<li>question 问题<ul>
<li>Can I ask you a question?</li>
<li>I’m afraid I can’t answer that questoin.</li>
<li>Does anyone have any questions?</li>
</ul>
</li>
<li>answer 回答，答复，答案<ul>
<li>You don’t have to give them an answer now.</li>
<li>What is the <strong>answer to</strong> question 4?</li>
</ul>
</li>
<li>problem 问题<ul>
<li>No problem.</li>
<li>What is you problem?</li>
<li>That’s not my problem.</li>
<li>Do you have a problem with that?</li>
</ul>
</li>
<li>letter 字母，信<ul>
<li>Fill you answers in <strong>capital letters</strong>, not <strong>small letters</strong>.</li>
<li>I got a long <strong>letter from</strong> Melanie today.</li>
</ul>
</li>
<li>word 单词<ul>
<li>Write an essay of about five hundred words.</li>
</ul>
</li>
<li>sentence 句子<ul>
<li>It’s difficult to sum it up in one sentence.</li>
</ul>
</li>
<li>art 艺术，艺术品<ul>
<li>modern art</li>
<li>an art lover</li>
<li>an art exhibition</li>
</ul>
</li>
<li>beauty 美，美人儿<ul>
<li>the beauty of the sunset</li>
<li>She was a famous beauty in her youth.</li>
</ul>
</li>
<li>bell 铃，钟<ul>
<li>church bells</li>
<li>a bicycle bell</li>
<li>He rang the bell and waited for someone to answer the door.</li>
</ul>
</li>
<li>bridge 桥<ul>
<li>We walked across a wooden bridge.</li>
</ul>
</li>
<li>blood 血<ul>
<li>He lost a lot of blood in the accident.</li>
<li>I’m going to <strong>give blood</strong> this afternoon.</li>
</ul>
</li>
<li>business 生意<ul>
<li>He wants to be a doctor or <strong>go into business.</strong></li>
<li>We <strong>do business with</strong> a number of local companies.</li>
</ul>
</li>
<li>case 事例，实情，案例<ul>
<li>It’s a clear case of blackmail!</li>
<li>This is not alwasy <strong>the case</strong>.</li>
<li>a case of murder</li>
</ul>
</li>
<li>center 中心<ul>
<li>a shopping center</li>
<li>There was a large table <strong>in the center of</strong> the room.</li>
</ul>
</li>
<li>change 机会，可能性<ul>
<li>Give me a change.</li>
<li>There is no change that he will change his mind.</li>
</ul>
</li>
<li>Christmas 圣诞节<ul>
<li>a Christmas present</li>
<li>We’ll se you <strong>at Christmas</strong>.</li>
</ul>
</li>
<li>company 公司<ul>
<li>Which company do you work for?</li>
</ul>
</li>
<li>date 日期，约会<ul>
<li>What’s the date today?</li>
<li>I’ve got a date with David tomorrow night.</li>
</ul>
</li>
<li>death 死亡<ul>
<li>Her death was a shock to him.</li>
<li>Two men were burnt to death in the fire.</li>
</ul>
</li>
<li>dream 梦，梦想<ul>
<li>Good night, Sweet dreams!</li>
<li>I have a dream.</li>
</ul>
</li>
<li>duty 职责，义务，职责<ul>
<li>I feel it is my duty to help her.</li>
<li>I promise I will do my duty.</li>
</ul>
</li>
<li>exercise 练习，运动<ul>
<li>an exercise book</li>
<li>The doctor advised him to take more exercise.</li>
</ul>
</li>
<li>experience 经历，经验<ul>
<li>We all learn by experience.</li>
<li>It was her first experience of living alone.</li>
</ul>
</li>
<li>excuse 借口<ul>
<li>What’s your excuse for being late this time?</li>
<li>I’m tired of listening to his excuses.</li>
</ul>
</li>
<li>enemy 敌人<ul>
<li>Cats ant dogs have always been <strong>natural enemies</strong>.</li>
</ul>
</li>
<li>fact 事实<ul>
<li>I can’t believe the fact that he is married.</li>
<li><strong>In fact</strong>, i had dinner with her last week.</li>
</ul>
</li>
<li>field 田地，领域<ul>
<li>a field of wheat</li>
<li>Peter’s an expert in his field.</li>
</ul>
</li>
<li>forest 森林<ul>
<li>a forest fire</li>
<li>The children got lost in the forest.</li>
</ul>
</li>
<li>wood 木头<ul>
<li>Tables are usually made of wood.</li>
<li>You’d better <strong>knock on wood</strong>.</li>
</ul>
</li>
<li>factory 工厂<ul>
<li>a car factory</li>
<li>She works in a factory.</li>
</ul>
</li>
<li>future 未来，前途<ul>
<li>Who knows what will happen in the future?</li>
<li>Does this school have a future?</li>
</ul>
</li>
<li>fire 火<ul>
<li>The house is <strong>on fire</strong>!</li>
<li>It took firefighters serveral hours to <strong>put out the fire</strong>.</li>
</ul>
</li>
<li>gift 礼物<ul>
<li>present</li>
<li>a birthday gift</li>
<li>a wedding gift</li>
</ul>
</li>
<li>habit 习惯<ul>
<li>Jeff is <strong>in the habit of</strong> taking a walk after dinner.</li>
<li>Old habits die hard.</li>
</ul>
</li>
<li>hobby 业余爱好<ul>
<li>What are you hobbies?</li>
<li>My hobbies include swimming and travelling.</li>
</ul>
</li>
<li>health 健康<ul>
<li>Exercise is good for the health.</li>
<li>Smoking can seriously damage you health.</li>
</ul>
</li>
<li>home 家<ul>
<li>He left home at sixteen.</li>
<li>Last night we stayed <strong>at home</strong> and wathed TV.</li>
</ul>
</li>
<li>homework 家庭作业<ul>
<li>How much homework do you get?</li>
<li>I still haven’t <strong>done my homework</strong>.</li>
</ul>
</li>
<li>house 房子<ul>
<li>I bought a four-bedroom house with a beautiful garden.</li>
</ul>
</li>
<li>housework 家务活<ul>
<li>I spend all morning <strong>doing the housework.</strong></li>
</ul>
</li>
<li>hope 希望<ul>
<li>There is now hope of a cure.</li>
<li>Don’t raise your hopes too high, or you may be disappointed.</li>
</ul>
</li>
<li>help 帮助<ul>
<li>I need you help.</li>
<li>Thank you for your kind help.</li>
</ul>
</li>
<li>ice 冰<ul>
<li>Is the ice thick enough for skating?</li>
<li>Her hands were <strong>as cold as ice</strong>.</li>
</ul>
</li>
<li>idea 主意，想法<ul>
<li>I have an idea.</li>
<li>That’s a good idea.</li>
</ul>
</li>
<li>lesson 功课<ul>
<li>The first lesson in driving is how to start the car.</li>
<li>She geives piano lessons.</li>
</ul>
</li>
<li>job 工作<ul>
<li>Good job!</li>
<li>I’m looking for a new job.</li>
</ul>
</li>
<li>work<ul>
<li>He’s been <strong>out of work</strong> for two years.</li>
<li>My father <strong>started work</strong> when he was just 14.</li>
</ul>
</li>
<li>joy 喜悦，高兴<ul>
<li>the look of joy on her face</li>
<li>She wept <strong>for joy</strong>.</li>
</ul>
</li>
<li>king 国王<ul>
<li>King Edward VII</li>
<li>The lion is the king of the jungle.</li>
</ul>
</li>
<li>queue 女王，往后<ul>
<li>Queue Elizabeth II</li>
<li>At eighteen, Victoria <strong>was crown queen</strong>.</li>
</ul>
</li>
<li>prince 王子<ul>
<li>Prince William</li>
<li>the Prince of Wales</li>
</ul>
</li>
<li>princess 公主，王妃<ul>
<li>Lady Diana Spencer became Princess Diana when she married Prince Charles.</li>
</ul>
</li>
<li>kiss 吻<ul>
<li>Give me a kiss.</li>
<li>Do you remember your first kiss?</li>
</ul>
</li>
<li>kite 风筝<ul>
<li>Let’s go <strong>fly a kite.</strong></li>
</ul>
</li>
<li>knowledge 知识<ul>
<li>I have only limited knowledge of computers.</li>
</ul>
</li>
<li>language 语言<ul>
<li>How many languages do you speak?</li>
<li>Andrea’s <strong>native language</strong> is German.</li>
</ul>
</li>
<li>life 生命<ul>
<li>I’ve never been so embarrassed <strong>in my life</strong>.</li>
<li>I’ve known John <strong>all my life.</strong></li>
</ul>
</li>
<li>love 爱<ul>
<li>What these kids need is love and support.</li>
<li>Their love for each other grew deeper every day.</li>
</ul>
</li>
<li>machine 机器<ul>
<li>Is the <strong>washing machine</strong> working now?</li>
<li>The <strong>fax machine </strong> is broken.</li>
</ul>
</li>
<li>map 地图<ul>
<li>a street map of Beijing</li>
<li>According to the map we should turn left.</li>
</ul>
</li>
<li>matter 事情<ul>
<li>We have more important matters to discuss.</li>
<li>What’s the matter?</li>
</ul>
</li>
<li>medicine 药<ul>
<li>Don’t take too much medicine.</li>
</ul>
</li>
<li>meeting 会议<ul>
<li>We’re having a meeting next week.</li>
<li>Mr.Black is <strong>in a meeting</strong> at the moment.</li>
</ul>
</li>
<li>menu 菜单<ul>
<li>Could I have the menu, please?</li>
<li>Is there any fish <strong>on the menu</strong>?</li>
</ul>
</li>
<li>mile 海里<ul>
<li>We walked about half a mile.</li>
<li>He was driving at 70 <strong>miles per hour</strong>.</li>
</ul>
</li>
<li>mistake 错误<ul>
<li>I <strong>made a</strong> huge mistake.</li>
<li>Sorry, I took you bag <strong>by mistake.</strong></li>
</ul>
</li>
<li>money 钱<ul>
<li>Don’t spend all your money on the first day of you holiday!</li>
<li>Could you lend me some money?</li>
</ul>
</li>
<li>member 会员，成员<ul>
<li>He is a member of the local tennis club.</li>
<li>The other members of his family were against this marriage.</li>
</ul>
</li>
<li>coin 硬币<ul>
<li>two gold coins</li>
<li>Let’s <strong>toss a coin</strong> to see who goes first.</li>
</ul>
</li>
<li>dollar 美元<ul>
<li>It cost three dollars.</li>
</ul>
</li>
<li>pound 英镑，磅<ul>
<li>a pound of apples</li>
<li>a five-pound note</li>
</ul>
</li>
<li>music 音乐<ul>
<li>I often listen to music when I’m in the car.</li>
<li>What’s you favorite kind of music?</li>
</ul>
</li>
<li>name 名字<ul>
<li>What’s you name?</li>
<li>Can I have you name?</li>
</ul>
</li>
<li>nature 自然，天性<ul>
<li>I love the beauties of nature.</li>
<li>She is a very kind person <strong>by nature</strong>.</li>
</ul>
</li>
<li>news 消息，新闻<ul>
<li>What’s the latest news?</li>
<li>Have you heard the news? Mary has got a baby.</li>
</ul>
</li>
<li>notice 布告，通知<ul>
<li>I’ll <strong>put up a notice</strong> about the meeting.</li>
</ul>
</li>
<li>number 数字，号码<ul>
<li>Five was her lucky number.</li>
<li>Can I have you phone number?</li>
</ul>
</li>
<li>peace 和平，安静<ul>
<li>After years of war the people longed for peace.</li>
<li>May he <strong>rest in peace</strong>.</li>
</ul>
</li>
<li>path 小路<ul>
<li>We took the path across the fields.</li>
</ul>
</li>
<li>page 书页<ul>
<li>The answer is on <strong>page 15</strong>.</li>
<li>I <strong>turned the pages</strong> of a magazine impatiently.</li>
</ul>
</li>
<li>paint 油漆，颜料<ul>
<li>Wet paint.</li>
<li>He brought his paints with him.</li>
</ul>
</li>
<li>pleasure 快乐，乐事<ul>
<li>He smiled <strong>with pleasure.</strong></li>
<li>It’s a pleasure to meet you.</li>
<li>It’s my pleasure.</li>
</ul>
</li>
<li>power 能力，影响力<ul>
<li>It is beyond my power.</li>
<li>You have no power here.</li>
</ul>
</li>
<li>pair 一双，一对<ul>
<li>a pair of shoes</li>
<li>the happy pair</li>
</ul>
</li>
<li>couple 夫妻，情侣<ul>
<li>the couple next door</li>
<li>a newly married couple</li>
</ul>
</li>
<li>part 部分<ul>
<li>The front part of the car was damaged.</li>
<li>The best part of the holiday was the food.</li>
</ul>
</li>
<li>party 聚会<ul>
<li>a birthday party</li>
<li>I’m giving a party next Saturday night.</li>
</ul>
</li>
<li>pet 宠物<ul>
<li>pet food</li>
<li>He was bitten by his pet dog.</li>
</ul>
</li>
<li>pirce 价格<ul>
<li>What is the price of this table?</li>
<li>House prices in this area are falling.</li>
</ul>
</li>
<li>program 节目，程序<ul>
<li>What’s you favorite television program?</li>
<li>a computer program</li>
</ul>
</li>
<li>right 右边，权利<ul>
<li>The school is <strong>on you right.</strong></li>
<li>Who gives you the right to do that?</li>
</ul>
</li>
<li>seat 座位<ul>
<li>Please <strong>take a seat</strong>.</li>
<li>You can book seats online.</li>
</ul>
</li>
<li>sand 沙子<ul>
<li>I have sand in my shoe.</li>
</ul>
</li>
<li>seed 种子<ul>
<li>sunflower seeds</li>
<li>grass seed</li>
</ul>
</li>
<li>shape 形状<ul>
<li>What shape is the table?</li>
<li>The dining room was <strong>square in shape</strong>.</li>
</ul>
</li>
<li>smile 微笑<ul>
<li>Come on, <strong>give me a smile</strong>.</li>
<li>‘Oh, I’m fine’, Anna replied <strong>with a smile</strong>.</li>
</ul>
</li>
<li>side 边，面<ul>
<li>A man was watching me from <strong>the other side</strong> of the road.</li>
<li>There is a scar <strong>on the right side</strong> of his face.</li>
</ul>
</li>
<li>size 尺寸，大小<ul>
<li>Jason’s house is about the same size as ours.</li>
<li>The jacket was the wrong size.</li>
</ul>
</li>
<li>smell 气味<ul>
<li>The air was filled with the smell of flowers.</li>
<li>There’s a delicious smell coming from the kitchen.</li>
</ul>
</li>
<li>song 歌曲<ul>
<li>a love song</li>
<li>a pop song</li>
<li>We <strong>sang a song</strong> together.</li>
</ul>
</li>
<li>sound 声音<ul>
<li>the sound of the wind</li>
<li>the sound of the sea</li>
<li><strong>The Sound of Music</strong></li>
<li>I could hear the sound of voices.</li>
</ul>
</li>
<li>voice 声音，嗓音<ul>
<li>She has a sweet voice.</li>
<li>Keep your voice down.</li>
</ul>
</li>
<li>noise 噪音<ul>
<li>What’s that noise?</li>
<li>Don’t make so much noise.</li>
</ul>
</li>
<li>stream 小溪<ul>
<li>A small stream runs through the woods.</li>
</ul>
</li>
<li>stranger 陌生人，外地人<ul>
<li>Our dog barks at strangers.</li>
<li>‘Excuse me, where’s the railway statoins?’ ‘ Sorry, I’m a stranger here myself’</li>
</ul>
</li>
<li>space 空间<ul>
<li>The fridge takes up too much space.</li>
<li>There isn’t much space left for your luggage.</li>
</ul>
</li>
<li>south 南方，南部<ul>
<li>Which way is south?</li>
<li>The town is to <strong>the south of</strong> London.</li>
</ul>
</li>
<li>north 北方，北部</li>
<li>east 东方，东部</li>
<li>west 西方，西部</li>
<li>sport 运动<ul>
<li>Which sport do you like best?</li>
<li>My favorite sport is swimming.</li>
</ul>
</li>
<li>store 商店<ul>
<li>shop</li>
<li>a big department store</li>
<li>At Christmas the stores stay open late.</li>
</ul>
</li>
<li>story 故事<ul>
<li>a ture story</li>
<li>a fairy story</li>
<li>a ghost story</li>
<li>Mommy, will you <strong>read me a story?</strong></li>
</ul>
</li>
<li>surprise 惊讶，惊喜<ul>
<li>What a surprise to find you here!</li>
<li>Bill looked at him <strong>in surprise</strong>.</li>
</ul>
</li>
<li>team 队，小组<ul>
<li>Which team do you play for?</li>
<li>You need to choose a team leader.</li>
</ul>
</li>
<li>test 考试<ul>
<li>She passed her driving test when she was 17.</li>
<li>Did you get a good mark <strong>in the test</strong>?</li>
</ul>
</li>
<li>thing 事情<ul>
<li>You are doing the right thing.</li>
<li>First things first.</li>
</ul>
</li>
<li>truth 真相<ul>
<li>How do I know you’re <strong>telling the truth</strong>?</li>
<li>The truth is, I forgot about it.</li>
</ul>
</li>
<li>ticket 入场券，票<ul>
<li>I’d like to book two tickets to Berlin.</li>
<li>A <strong>return ticket</strong> to London, please.</li>
</ul>
</li>
<li>traffic 交通，路上的车辆<ul>
<li>a traffic accident</li>
<li>traffic lights</li>
<li>There’s usually a lot of traffic at this time of day.</li>
</ul>
</li>
<li>trip 旅行<ul>
<li>Have a nice trip!</li>
<li>Did you enjoy your trip?</li>
<li>We’re thinking of <strong>taking a trip</strong> to Taiwan.</li>
</ul>
</li>
<li>trouble 麻烦<ul>
<li>We’re having trouble with our new car.</li>
<li>You are in big trouble.</li>
</ul>
</li>
<li>unit 单元<ul>
<li>The book has twenty units.</li>
</ul>
</li>
<li>weather 天气<ul>
<li>What’s the weather like today?</li>
<li>The <strong>weather forecase</strong> said it would be fine all day.</li>
</ul>
</li>
<li>world 世界<ul>
<li>I want to travel around the world.</li>
<li>Students from <strong>all over the world</strong> come to study Oxford.</li>
</ul>
</li>
<li>wall 墙<ul>
<li>the Great Wall</li>
<li>I put up some pictures on the walls.</li>
</ul>
</li>
<li>wing 翅膀<ul>
<li>The brid flapped its wings excitedly.<br>-</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>名词-日用品</title>
    <url>/2020/04/04/Language/English/New%20Concept/Word/Noun/DailyNecessities/</url>
    <content><![CDATA[<p>日用品的一些名词</p>
<a id="more"></a>
<ul>
<li>refrigerator 冰箱<ul>
<li>fridge 简称</li>
<li>Don’t forget to put the milk back in the fridge.</li>
</ul>
</li>
<li>cooker 炉灶<ul>
<li>a gas cooker</li>
<li>an electric cooker</li>
<li>rice cooker 电饭锅</li>
<li>Damn! I forgot to turn on the rice cooker.</li>
</ul>
</li>
<li>oven 烤箱，烤炉<ul>
<li>a microwave oven</li>
<li>I took the cake out of the oven.</li>
<li>Perth in summer is like an oven.</li>
</ul>
</li>
<li>cupboard 柜橱，碗柜<ul>
<li>It’s in the kichen cupboard.</li>
<li>The cupboard doors are open.</li>
<li>a skeleton in the cupboard</li>
</ul>
</li>
<li>dish 盘子，碟子<ul>
<li>a glass dish</li>
<li>a large dish of pasta</li>
<li>I’ll do the dishes.</li>
</ul>
</li>
<li>plate 盘子，碟子<ul>
<li>paper plates</li>
<li>plastic plates</li>
<li>I ate a whole plate of French fries.</li>
</ul>
</li>
<li>bowl 碗<ul>
<li>I filled the bowl with water.</li>
<li>a bowl of soup</li>
<li>a bowl of rice</li>
</ul>
</li>
<li>spoon 匙，勺子<ul>
<li>a soup spoon</li>
<li>He stirred his coffee with spoon.</li>
<li>Two spoons of sugar, please.</li>
</ul>
</li>
<li>knife 刀<ul>
<li>a kitchen knife</li>
<li>a bread knife</li>
<li>You need a shark knife to cut the steak.</li>
</ul>
</li>
<li>fork 叉<ul>
<li>a knife and fork</li>
<li>Mark prefers to eat with a knife and fork.</li>
<li>Put the knives and forks on the table.</li>
</ul>
</li>
<li>chopstick 筷子<ul>
<li>bamboo chopsticks</li>
<li>We Chinese use chopsticks instead of knives and forks.</li>
</ul>
</li>
<li>pan 锅<ul>
<li>a frying pan</li>
<li>pots and pans</li>
<li>I cooked the dish in a large pan.</li>
</ul>
</li>
<li>wok 炒菜锅<ul>
<li>A wok is a metal pan shaped like a large bowl which is used for cooking Chinese food.</li>
</ul>
</li>
<li>pot 锅，罐，壶<ul>
<li>pots and pans</li>
<li>They’ve eaten a whole pot a of jam</li>
<li>Bring me another pot of coffee.</li>
</ul>
</li>
<li>teapot 茶壶<ul>
<li>Can you make the tea?<br>Sure. Where is the teapot.</li>
</ul>
</li>
<li>coffee pot 咖啡壶<ul>
<li>Is there any coffee in the coffee pot?</li>
</ul>
</li>
<li>flower pot 花盆<ul>
<li>You’ve poured too much water in the flower pot.</li>
</ul>
</li>
<li>steamer 蒸锅<ul>
<li>My mom makers steamed bread in a steamer.</li>
</ul>
</li>
<li>egg beater 打蛋器<ul>
<li>Do you have an egg beater at home?<br>Yes, in the drawer on you left.</li>
</ul>
</li>
<li>apron 围裙<ul>
<li>She doesn’t have an apron, because she doesn’t cook at all.</li>
</ul>
</li>
<li>cup 杯子<ul>
<li>a cup of tea</li>
<li>a cup of coffee</li>
<li>a paper cup</li>
<li>a cup and saucer</li>
</ul>
</li>
<li>glass 玻璃杯<ul>
<li>a glass of water</li>
<li>a glass of beer</li>
<li>a glass of wine</li>
<li>a glass of milk</li>
</ul>
</li>
<li>bottle 瓶子<ul>
<li>an empty bottle</li>
<li>a bottle of champagne</li>
<li>I drank a whole bottle of wine last night.</li>
</ul>
</li>
<li>chopping board 案板<ul>
<li>I bought a new wooden chopping board.</li>
</ul>
</li>
<li>dish washer 洗碗机<ul>
<li>I have a dish washer in the kitchen, bu i never use it.</li>
</ul>
</li>
<li>detergent 洗涤剂<ul>
<li>Rinse the detergent from the dishes.</li>
</ul>
</li>
<li>trash can 垃圾桶<ul>
<li>Always put the trash in the trash can.</li>
</ul>
</li>
<li>broom 扫帚<ul>
<li>Bill is sweeping the floor with a broom.</li>
</ul>
</li>
<li>table 桌子<ul>
<li>a dinling table</li>
<li>Robbie, would you set the table?</li>
<li>I’ve booked a table for two for six o’clock.</li>
</ul>
</li>
<li>tea table 茶几<ul>
<li>There is a tea table and two chairs on my balcony.</li>
</ul>
</li>
<li>drawer 抽屉<ul>
<li>She took a file from her dest drawer.</li>
<li>I opened the drawer and took out a brown envelope.</li>
</ul>
</li>
<li>chair 椅子<ul>
<li>a table and chairs</li>
<li>a garden chair</li>
<li>I had to sit on a hard wooden chair all day.</li>
</ul>
</li>
<li>rocking chair 摇椅<ul>
<li>He was rocking himself in a rocking chair.</li>
</ul>
</li>
<li>couch 沙发<ul>
<li>I can sleep on the couch.</li>
<li>Annie was lying on the couch, eating candy.</li>
</ul>
</li>
<li>telephone 电话<ul>
<li>phone</li>
<li>The telephone rang just as  i was leaving.</li>
<li>Sally is <u>on the phone.</u></li>
<li><u>Answer the phone</u> </li>
</ul>
</li>
<li>cushion 垫子<ul>
<li>I like the cushions on you couch.</li>
</ul>
</li>
<li>ashtray 烟灰缸<ul>
<li>Drop you cigarette ashes into the ashtray.</li>
<li>The ashtray is full of cigarette ends.</li>
</ul>
</li>
<li>TV 电视<ul>
<li>television </li>
<li>What’s on TV tonight?</li>
<li>I watched the movie on TV.</li>
<li>I’m watching TV.</li>
<li>a TV show</li>
<li>a TV actor</li>
<li>a TV <strong>commercial</strong></li>
</ul>
</li>
<li>lamp 灯<ul>
<li>a streep lamp</li>
<li>a desk lamp</li>
<li>a bedside lamp</li>
</ul>
</li>
<li>light 灯<ul>
<li>The room was dark, so i <u>turned on the light</u>.</li>
<li>Don’t forget to <u>turn off the lights</u> before you go to bed.</li>
</ul>
</li>
<li>tissue 纸巾<ul>
<li>a box of tissues.</li>
<li>Pass me a tissue.</li>
</ul>
</li>
<li>vase 花瓶<ul>
<li>a china vase</li>
<li>a vase of roses</li>
</ul>
</li>
<li>air conditioner 空调<ul>
<li>I can’t sleep without an air conditioner in summer.</li>
</ul>
</li>
<li>remote control 遥控器<ul>
<li>Give me the remote control.</li>
</ul>
</li>
<li>fan 扇子，风扇<ul>
<li>a ceiling fan</li>
<li>It’s so hot. Please turn on the fan.</li>
</ul>
</li>
<li>computer 计算机，电脑<ul>
<li>computer games</li>
<li>the latest computer software</li>
<li>The information is stored <u>on computer.</u></li>
</ul>
</li>
<li>laptop 笔记本电脑<ul>
<li>He won’t let anyone touch his laptop.</li>
</ul>
</li>
<li>desktop 台式电脑<ul>
<li>I’m thinking about what to do with my desktop when i’m moving.</li>
</ul>
</li>
<li>keyboard 键盘<ul>
<li>Suan is a <u>keyboard operator</u>.</li>
</ul>
</li>
<li>mouse 鼠标<ul>
<li>a wireless mouse</li>
<li>a mouse mat</li>
<li>Click the right mouse button.</li>
</ul>
</li>
<li>desk 书桌<ul>
<li>an office desk</li>
<li>a school desk</li>
<li>Marie is sitting at her desk.</li>
</ul>
</li>
<li>clock 时钟<ul>
<li>My clock stopped.</li>
<li>I hreard the clock strike six.</li>
<li>Mary set her alarm clock for 6:30 am.</li>
</ul>
</li>
<li>bookcase 书柜<ul>
<li>Please put the books back into the bookcase.</li>
<li>My three large bookcases are full of books.</li>
</ul>
</li>
<li>book 书<ul>
<li>children’s books</li>
<li>paperback books</li>
<li>hardback books</li>
</ul>
</li>
<li>dictionary 字典<ul>
<li>an English-Chinese dictionary</li>
<li>a Chinese-English dictionary</li>
</ul>
</li>
<li>washing machine 洗衣机<ul>
<li>It’s easy to <u>do the laundry</u> these days. Just put the clothes in the washing machine.</li>
</ul>
</li>
<li>mirror 镜子<ul>
<li>Mirror mirrror on the wall, who is the fairest of them all.</li>
<li>He spends hours in front of the mirror!</li>
</ul>
</li>
<li>toothpaste 牙膏<ul>
<li>a tube of toothpase</li>
</ul>
</li>
<li>tooehbrush 牙刷<ul>
<li>Little Aaron can’t use a toothbrush yet.</li>
</ul>
</li>
<li>soap 肥皂<ul>
<li>a bar of soap</li>
<li>There’s no soap in the bathroom!</li>
</ul>
</li>
<li>cleanser 洗面奶<ul>
<li>I use cleanser every night.</li>
</ul>
</li>
<li>lotion 乳液<ul>
<li>body lotion</li>
<li>suntan lotion</li>
</ul>
</li>
<li>cream 乳，霜<ul>
<li>face cream</li>
<li>hand cream</li>
</ul>
</li>
<li>toner 爽肤水<ul>
<li>This kind of toner can make your skin very soft and smooth.</li>
</ul>
</li>
<li>facial mask 面膜<ul>
<li>After cleaning, unpack the facial mask and apply it gently on your face, remove it 2 minutes late.</li>
</ul>
</li>
<li>foundation 粉底<ul>
<li>Make sure your foundation is the same color as you skin.</li>
</ul>
</li>
<li>blusher 腮红<ul>
<li>Put on some blusher.</li>
</ul>
</li>
<li>eye shadow 眼影<ul>
<li>You shouldn’t use eye shadow at you age.</li>
</ul>
</li>
<li>lipstick 口红<ul>
<li>She is wearing red lipstick.</li>
<li>Check out my new lipstick.</li>
</ul>
</li>
<li>perfume 香水<ul>
<li>a bottle of perfume</li>
<li>French perfume</li>
<li>What perfume are you wearing?</li>
</ul>
</li>
<li>shampoo 洗发水<ul>
<li>a bottle of shampoo</li>
<li>Don’t use too much shampoo.</li>
<li>What kind of shampoo do you use?</li>
</ul>
</li>
<li>conditioner 护发素<ul>
<li>I always use conditioner after washing my hair.</li>
</ul>
</li>
<li>comb 梳子<ul>
<li>I need a <u>comb</u> to <u>comb</u> my hair.</li>
<li>I carry a comb with me whereever i go.</li>
</ul>
</li>
<li>bathtub 浴缸，澡盆<ul>
<li>Clean up the bathtub when  you are done.</li>
</ul>
</li>
<li>shower cap 浴帽<ul>
<li>I always wear a shower cap to keep my hair dry in the shower.</li>
</ul>
</li>
<li>shower curtain 浴帘<ul>
<li>I’m cleaning the shower curtain.</li>
</ul>
</li>
<li>bath mat 浴室防滑垫<ul>
<li>There is a bath mat beside the bathtub on floor.</li>
</ul>
</li>
<li>towel 毛巾<ul>
<li>Have you got a clean towel?</li>
<li>Give me a towel.</li>
</ul>
</li>
<li>toilet 马桶，卫生间<ul>
<li>He <u>flushed the toilet</u>.</li>
<li>Excuse me, where is the toilet?</li>
</ul>
</li>
<li>toilet paper 卫生纸，手纸<ul>
<li>a roll of toilet paper</li>
</ul>
</li>
<li>sheet 床单<ul>
<li>white sheet</li>
<li>I’ll go find you a clean sheet.</li>
<li>I’m going to change the sheets.</li>
</ul>
</li>
<li>blanket 毯子<ul>
<li>It’s too cold. I need another blanket.</li>
</ul>
</li>
<li>quilt 被子<ul>
<li>A blanket is not warm enough. You need quilt.</li>
</ul>
</li>
<li>pillow 枕头<ul>
<li>a pillow <u>fight</u></li>
<li>I fell asleep as soon as my head hit the pillow.</li>
</ul>
</li>
<li>mattress 床垫<ul>
<li>I don’t like the hotel. Last time i got a <u>lumpu mattress</u>.</li>
</ul>
</li>
<li>mat 垫子<ul>
<li>a door mat</li>
<li>a bath mat</li>
<li>a yoga mat</li>
<li>Wipe your feet on the mat.</li>
</ul>
</li>
<li>carpet 地毯<ul>
<li>red carpet</li>
<li>lay a carpet</li>
<li>My bedroom carpet is dark green.</li>
</ul>
</li>
<li>rug 小块地毯<ul>
<li>I like sitting on the rug in front of the fireplace.</li>
</ul>
</li>
<li>vacuum cleaner 吸尘器<ul>
<li>I could hear the whirr of a vacuum cleaner.</li>
</ul>
</li>
<li>string 细绳，线<ul>
<li>He wrapped the package in brown paeer and tied with string.</li>
<li>a puppet on strings.</li>
</ul>
</li>
<li>tape 胶带<ul>
<li>a roll of tape</li>
<li>I stuck the note to the door with tape.</li>
</ul>
</li>
<li>iron 熨斗<ul>
<li>a steam iron</li>
<li>I need an iron to iron my dress.</li>
</ul>
</li>
<li>needle 针<ul>
<li>a needle and thread</li>
<li>Could you thread this needle for me.</li>
</ul>
</li>
<li>thread 线<ul>
<li>I’m looking for a needle and thread.</li>
<li>gold thread</li>
<li>sliver thread</li>
</ul>
</li>
<li>button 纽扣，按钮<ul>
<li>A button was missing from his shirt.</li>
<li>Press the ‘play’ button.</li>
</ul>
</li>
<li>zipper 拉链<ul>
<li>The zipper doesn’t look good.</li>
<li>I can’t open my bag - the zipper has stuck</li>
</ul>
</li>
<li>lighter 打火机<ul>
<li>Do you have a lighter?</li>
</ul>
</li>
<li>torch 手电筒，火炬<ul>
<li>flashlight 手电筒</li>
<li>Take a torch.  It’s dark outside.</li>
<li>the Olympic torch</li>
</ul>
</li>
<li>bulb 电灯泡<ul>
<li>I’ve never changed a buld.</li>
<li>a 60-watt bulb</li>
</ul>
</li>
<li>battery 电池<ul>
<li>The torch needs two batteries.</li>
<li>When the red light is on, you should chage batteries.</li>
</ul>
</li>
<li>lock 锁<ul>
<li>There isn’t a lock on the bathroom door.</li>
<li>He slowly turned the key in the lock.</li>
</ul>
</li>
<li>key 钥匙<ul>
<li>the car keys</li>
<li>a bunch of keys</li>
<li>the key to the front door</li>
<li>the spare key to the front door</li>
</ul>
</li>
<li>watch 表<ul>
<li>a pocket watch</li>
<li>a wrist watch</li>
<li>My watch is five minutes fast.</li>
<li>My watch is five minutes slow.</li>
</ul>
</li>
<li>backpack 背包<ul>
<li>I want to take my backpack and go on a trip alone.</li>
</ul>
</li>
<li>handbag 手提包<ul>
<li>purse</li>
<li>She carried a green leather hadnbag.</li>
<li>I bought a new handbag.</li>
</ul>
</li>
<li>suitcase 衣箱<ul>
<li>Have you packed you suitcase yet?</li>
<li>Could you keep an eye on my suitcase for a moment, please.</li>
</ul>
</li>
<li>jewel 珠宝<ul>
<li>precious jewels</li>
<li>She loves wearing priceless jewels.</li>
</ul>
</li>
<li>jewel case 珠宝盒<ul>
<li>There are many beautiful jewels in her jewel case.</li>
<li>She opened her jewel case and said: ‘Pick one’.</li>
</ul>
</li>
<li>ring 戒指<ul>
<li>a diamond ring</li>
<li>an engagement ring</li>
<li>a wedding ring</li>
</ul>
</li>
<li>earring 耳环<ul>
<li>gold errring</li>
<li>She was wearing a pair of beautiful diamond earrings.</li>
</ul>
</li>
<li>necklace 项链<ul>
<li>a peral necklace</li>
<li>a gold necklace</li>
<li>That necklace you borrowed from me wasn’t diamond necklace.</li>
</ul>
</li>
<li>bracelet 手镯，手链<ul>
<li>a gold bracelet</li>
<li>He bought her a new bracelet.</li>
</ul>
</li>
<li>brooch 胸针<ul>
<li>Excuse me, could you tell me how much this brooch costs?</li>
<li>She is wearing a gold brooch.</li>
</ul>
</li>
<li>pearl 珍珠<ul>
<li>a string of pearls</li>
<li>a peral necklace</li>
<li>Pearl Harbor</li>
</ul>
</li>
<li>diamond 钻石<ul>
<li>a diamond ring</li>
<li>a diamond necklace</li>
</ul>
</li>
<li>jade 玉，翡翠<ul>
<li>a jade vase</li>
<li>a jade necklace</li>
</ul>
</li>
<li>crib 婴儿床<ul>
<li>The baby is sleeping quietly in his crib.</li>
</ul>
</li>
<li>cradle 摇篮，发源地<ul>
<li>The mother rocked the baby to sleep in its cradle.</li>
<li>Greece, the cradle of Western culture.</li>
</ul>
</li>
<li>diaper 纸尿裤<ul>
<li>She was changing the baby’s diaper.</li>
<li>I knew William when he was still in diaper.</li>
</ul>
</li>
<li>stroller 婴儿车<ul>
<li>I saw her pushing a stroller down the street.</li>
<li>The baby was trying to get out of the stroller.</li>
</ul>
</li>
<li>razor 剃须刀<ul>
<li>an electric razor</li>
<li>a disposable razor</li>
</ul>
</li>
<li>umbrella 伞，雨伞<ul>
<li>a folding umbrella</li>
<li>put up an umbrella</li>
<li>take down an umbrella</li>
<li>Take an umbrella with you, in case it rains.</li>
<li>It started to rain, so i put up my umbrella.</li>
<li>The rain stopped, so i took down my umbrella.</li>
</ul>
</li>
<li>sun umbrella 太阳伞<ul>
<li>Chinese girls usually carry sun umbrellas in summer.</li>
</ul>
</li>
<li>stationery 文具<ul>
<li>I must go to the stationer’s to get some stationary.</li>
</ul>
</li>
<li>paper 纸，报纸<ul>
<li>a piece of paper</li>
<li>a sheet of paper</li>
<li>writing paper</li>
</ul>
</li>
<li>a paper bag<ul>
<li>I wrote down her phone number on a piece of apper.</li>
<li>Have you seen today’s paper?</li>
</ul>
</li>
<li>pen 笔，钢笔<ul>
<li>Do you have a pen and paper?</li>
<li>Please fill out the form in pen.</li>
<li>pen name</li>
<li>pen pal</li>
</ul>
</li>
<li>pencil 铅笔<ul>
<li>a sharp pencil</li>
<li>a box of coloured pencils</li>
<li>a note written in pencil</li>
</ul>
</li>
<li>ruler 尺子<ul>
<li>Do you have a ruler?</li>
</ul>
</li>
<li>eraser 橡皮，板擦<ul>
<li>May i borrow your erase?</li>
<li>If you write in pencil, you can always rub out your mistakes with an earser?</li>
</ul>
</li>
<li>glue 胶水<ul>
<li>a tube of glue</li>
<li>He sticks to her like glue.</li>
</ul>
</li>
<li>toy 玩具<ul>
<li>Annice was playing happily with her toys.</li>
<li>Put your toys away now - it’s time for bed.</li>
<li>Leave daddy’s camera alone - it isn’t a toy!</li>
</ul>
</li>
<li>bag 袋，包<ul>
<li>a paper bag</li>
<li>a plastic bag</li>
<li>a garbage bag</li>
<li>a shoppng bag</li>
</ul>
</li>
<li>box 盒子，箱子<ul>
<li>a tool box</li>
<li>a cardboard box</li>
<li>a box of chocolates</li>
<li>black box</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>名词-食物</title>
    <url>/2020/04/03/Language/English/New%20Concept/Word/Noun/Foods/</url>
    <content><![CDATA[<p>食物的一些名词</p>
<a id="more"></a>
<ul>
<li>food 食物<ul>
<li>Everyone needs food.</li>
<li>Fast food.</li>
<li>Junk food.</li>
</ul>
</li>
<li>fruit 水果<ul>
<li>Try to eat plenty of fresh furit.</li>
<li>Fruit and vegetables.</li>
<li>Fruit juice.</li>
</ul>
</li>
<li>apple 苹果<ul>
<li>apple pie.</li>
<li>an apple tree.</li>
<li>An apple a day keeps the doctor away.</li>
</ul>
</li>
<li>pear 梨<ul>
<li>I like apples , but not pears.</li>
</ul>
</li>
<li>peach 桃子<ul>
<li>I like fresh juicy peaches.</li>
</ul>
</li>
<li>banana 香蕉<ul>
<li>a bunch of bananas.</li>
<li>Look! The monkey is eating a banana.</li>
</ul>
</li>
<li>orange 柑橘，橙子<ul>
<li>orange juice</li>
<li>Peel the oranges.</li>
</ul>
</li>
<li>cherry 樱桃<ul>
<li>a cherry tree.</li>
<li>There is a cherry on the cake.</li>
</ul>
</li>
<li>strawberry 草莓<ul>
<li>The strawberry is my favorite fruit.</li>
</ul>
</li>
<li>blueberry 蓝莓<ul>
<li>blueberry pie</li>
<li>The blueberry is good for your eyes.</li>
</ul>
</li>
<li>lemon 柠檬<ul>
<li>a lemon tree</li>
<li>a slice of lemon</li>
</ul>
</li>
<li>lemonage 柠檬水</li>
<li>mango 芒果<ul>
<li>Some people are allergic（过敏） to mango.</li>
</ul>
</li>
<li>pineapple 菠萝<ul>
<li>pineapple juice</li>
</ul>
</li>
<li>grape 葡萄<ul>
<li>a bunch of grapes.</li>
<li>seedless grapes.</li>
</ul>
</li>
<li>plum 李子<ul>
<li>juicy ripe plums</li>
<li>a plum tree</li>
</ul>
</li>
<li>kiwi fruit 猕猴桃<ul>
<li>Kiwi fruit is rich in vitamin C.</li>
</ul>
</li>
<li>druian 榴莲<ul>
<li>I can’t bear the smell of a durain.</li>
</ul>
</li>
<li>coconut 椰子<ul>
<li>coconut mile 椰奶</li>
<li>I was hit by a coconut when i was sitting under a coconut palm.</li>
</ul>
</li>
<li>papaya 木瓜</li>
<li>pawpaw 木瓜<ul>
<li>pawpaw ointment 木瓜粥</li>
</ul>
</li>
<li>pomegranate 石榴<ul>
<li>pomegranate juice</li>
<li>pomegranate seeds</li>
</ul>
</li>
<li>persimmon 柿子<ul>
<li>A persimmon is a soft sweet fruit that looks like a large orange-colored tomata and grows on a persimmon tree.</li>
</ul>
</li>
<li>watermelon 西瓜<ul>
<li>In summer, out main fruit is watermelon.</li>
<li>Of all the fruits, I like watermelon most.</li>
</ul>
</li>
<li>lychee 荔枝<ul>
<li>We all know that Princess Yang Kwei-fei liked lychees.</li>
</ul>
</li>
<li>vegetable 蔬菜<ul>
<li>green vegetables</li>
<li>organic（有机） vegetables</li>
<li>You should eat more fruit and vegetables.</li>
</ul>
</li>
<li>tomato 西红柿<ul>
<li>tomato soup</li>
<li>Is the tomato a fruit or vegetables?</li>
<li>The tomato is a round soft read fruit <strong>eaten raw</strong>（生吃） or cooked as a vegetable.</li>
</ul>
</li>
<li>ketchup 番茄酱<ul>
<li>a bottle of ketchup</li>
<li>Do you want some ketchup with you hamburger?</li>
</ul>
</li>
<li>potato 土豆<ul>
<li>potato soup</li>
<li>Marie is pelling potatoes.</li>
<li>mashed potatoes.</li>
</ul>
</li>
<li>sweet potato 红薯<ul>
<li>A sweet potato is sweeter than a potato.</li>
</ul>
</li>
<li>cabbage 卷心菜<ul>
<li>Do you like cabbage?</li>
<li>Chinese cabbage.</li>
</ul>
</li>
<li>cucumber 黄瓜<ul>
<li>Have some cucumber.</li>
<li>cucumber salad.</li>
<li>sea cucumber 海参</li>
</ul>
</li>
<li>celery 芹菜<ul>
<li>a stick of celery.</li>
<li>I dont’t like eating celery. It’s like eating grass.</li>
</ul>
</li>
<li>leek 韭菜<ul>
<li>A leek tastes like an onion.</li>
</ul>
</li>
<li>carrot 胡萝卜<ul>
<li>carrot juice</li>
<li>Have some carrot.</li>
<li>We are like peas and carrots.</li>
</ul>
</li>
<li>pea 豌豆<ul>
<li>The twins are like two peas in a pod.</li>
<li>The Princess and the Pea.</li>
</ul>
</li>
<li>radish 萝卜<ul>
<li>I don’t like radished. Most of them are spicy.</li>
</ul>
</li>
<li>spinach 菠菜<ul>
<li>Popeye loves spinach.</li>
<li>spinach soup.</li>
</ul>
</li>
<li>mushroom 蘑菇<ul>
<li>wild mushroom</li>
<li>Some types of mushrooms are poisonous.</li>
</ul>
</li>
<li>eggplant 茄子<ul>
<li>My husband likes eggplant no matter how it cooked.</li>
</ul>
</li>
<li>bean 豆子<ul>
<li>soya beans.</li>
<li>bean curd.</li>
<li>Jack and the Beanstalk.</li>
</ul>
</li>
<li>pumpkin 南瓜<ul>
<li>pumpkin pie</li>
<li>pumpkin lanterns</li>
</ul>
</li>
<li>green pepper 青椒<ul>
<li>sharedded beef with green pepper.</li>
</ul>
</li>
<li>lettuce 生菜<ul>
<li>a lettuce and tomato salad.</li>
</ul>
</li>
<li>onion 洋葱<ul>
<li>I alaways cry when I’m chopping oinions.</li>
<li>There is too much onion is the salad.</li>
</ul>
</li>
<li>lotus root 莲藕<ul>
<li>Sister lotus</li>
</ul>
</li>
<li>noodle 面条<ul>
<li>egg noodles</li>
<li>instant noodles</li>
</ul>
</li>
<li>pasta 意大利面<ul>
<li>Every time i eat pasta, i eat a lot.</li>
</ul>
</li>
<li>rice 米，米饭<ul>
<li>rice fields</li>
<li>I like noodles more than rice.</li>
</ul>
</li>
<li>corn 玉米，谷物<ul>
<li>All their chickens are fed on corn.</li>
</ul>
</li>
<li>popcorn 爆米花<ul>
<li>It doesn’t feel like a moive without popcorn.</li>
</ul>
</li>
<li>sandwich 三明治<ul>
<li>a ham sandwich</li>
<li>He usually just has a sandwich for lunch.</li>
</ul>
</li>
<li>ham 火腿<ul>
<li>a slice of ham.</li>
</ul>
</li>
<li>sauasge 香肠<ul>
<li>garlic sausage.</li>
<li>pork sausage.</li>
</ul>
</li>
<li>bread 面包<ul>
<li>a slice of bread.</li>
<li>a loaf of bread.</li>
<li>bread and butter.</li>
</ul>
</li>
<li>steamed bread 馒头<ul>
<li>My dad eats steamed bread every day.</li>
</ul>
</li>
<li>biscuit 饼干<ul>
<li>chocolate biscuits.</li>
<li>a packet of biscuits.</li>
<li>We had tea and biscuits.</li>
</ul>
</li>
<li>cookie 曲奇，饼干<ul>
<li>I had a glass of mile and a cookie for breakfasf.</li>
<li>Don’t eat my cookie.</li>
</ul>
</li>
<li>dessert 餐后甜点<ul>
<li>Shall we move on to dessert?</li>
<li>I forgot to prepare dessert, so we had ice-cream.</li>
</ul>
</li>
<li>candy 糖果<ul>
<li>a candy shop</li>
<li>a box of candy</li>
<li>You had too much candy today.</li>
</ul>
</li>
<li>cake 蛋糕<ul>
<li>birthday cake</li>
<li>chocolate cake</li>
<li>fruit cake</li>
</ul>
</li>
<li>pizza 比萨饼<ul>
<li>Would you like some more pizza?</li>
<li>a slice of pizza.</li>
</ul>
</li>
<li>hamburger 汉堡包<ul>
<li>I hate eating hamburgers. I’d rather be hungry.</li>
</ul>
</li>
<li>French fries 炸薯条<ul>
<li>I usually have French fries with ketchup.</li>
</ul>
</li>
<li>potato chips 薯片<ul>
<li>When i feel blue, i like eating a lot of potato chips.</li>
</ul>
</li>
<li>flour 面粉<ul>
<li>I was busy mixing water and flour.</li>
</ul>
</li>
<li>oat 燕麦<ul>
<li>oat biscuits.</li>
<li>oatmeal</li>
</ul>
</li>
<li>butter 黄油<ul>
<li>bread and butter</li>
<li>Should i use oil or butter for frying the onions.</li>
</ul>
</li>
<li>cheese 奶酪<ul>
<li>a piece of cheese</li>
<li>a cheese sandwich</li>
<li>Say ‘cheese’!</li>
</ul>
</li>
<li>soup 汤<ul>
<li>vegetable soup</li>
<li>Chicken Soup for the Soul.</li>
<li>Would you like a bowl of soup?</li>
</ul>
</li>
<li>dumpling 饺子<ul>
<li>I miss the dumplings that my mom makes.</li>
</ul>
</li>
<li>salad 沙拉<ul>
<li>fruit salad</li>
<li>potato salad</li>
<li>Would you like some salad with you paste?</li>
</ul>
</li>
<li>egg 鸡蛋<ul>
<li>fresh eggs</li>
<li>fried eggs</li>
<li>I don’t like boiled eggs.</li>
</ul>
</li>
<li>meat 肉<ul>
<li>fresh meat</li>
<li>frozen meat</li>
<li>I gave up eating meat a few months ago.</li>
</ul>
</li>
<li>pork 猪肉<ul>
<li>portk sausages</li>
<li>pork chops</li>
</ul>
</li>
<li>beef 牛肉<ul>
<li>a beef sandwich</li>
<li>roast beef</li>
</ul>
</li>
<li>steak 牛排<ul>
<li>How would you like you steak cooked?</li>
<li>I’d like my steak rare.</li>
</ul>
</li>
<li>rare 三分熟</li>
<li>medium rare 四分熟</li>
<li>medium 五分熟</li>
<li>medium well 七八分熟</li>
<li>well-done 全熟</li>
<li>mutton 羊肉<ul>
<li>I perfer mutton to beef.</li>
</ul>
</li>
<li>lamb 羔羊肉<ul>
<li>lamb chops</li>
</ul>
</li>
<li>chicken 鸡肉<ul>
<li>chicken soup</li>
<li>fried chicken</li>
</ul>
</li>
<li>fish 鱼肉<ul>
<li>fresh fish</li>
<li>frozen fish</li>
<li>smoked fish</li>
</ul>
</li>
<li>vinegar 醋<ul>
<li>Would you like some vinegar with you dumplings?</li>
</ul>
</li>
<li>soy sauce 酱油<ul>
<li>Would you pass me the soy sauce?</li>
</ul>
</li>
<li>jam 果酱<ul>
<li>strawberry jam</li>
<li>a jar of jam</li>
</ul>
</li>
<li>salt 盐<ul>
<li>table salt</li>
<li>There is too much salt in the soup.</li>
</ul>
</li>
<li>sugar 糖<ul>
<li>white sugar</li>
<li>brown sugar</li>
<li>Dont’t eat too much sugar.</li>
</ul>
</li>
<li>oil 油<ul>
<li>cooking oil</li>
<li>olive oil</li>
<li>sunflower oil</li>
</ul>
</li>
<li>pepper 胡椒粉<ul>
<li>You can put some salt and papper in you soup if you like.</li>
</ul>
</li>
<li>ginger 姜<ul>
<li>ginger ale</li>
</ul>
</li>
<li>garlic 大蒜<ul>
<li>a clove of garlic</li>
</ul>
</li>
<li>spring onion 大葱<ul>
<li>I just hate the smell of spring onion and garlic.</li>
</ul>
</li>
<li>nut 坚果<ul>
<li>a pine nut</li>
<li>We were sitting around the fireplace cracking nuts.</li>
</ul>
</li>
<li>peanut 花生<ul>
<li>peanut oil</li>
<li>peanut butter</li>
</ul>
</li>
<li>chestnut 栗子<ul>
<li>A man in the street is selling roast chestnuts.</li>
<li>chestnut cake</li>
</ul>
</li>
<li>sesame 芝麻<ul>
<li>sesame seeds</li>
<li>sesame oil</li>
<li>open sesame</li>
</ul>
</li>
<li>chocolate 巧克力<ul>
<li>a bar of chocolate</li>
<li>a box of chocolate</li>
<li>Life is like a box of chocolate</li>
<li>dark chocolate</li>
<li>chocolate mousse</li>
<li>Would you like a chocolate?</li>
<li>I’ll have a hot chocolate, please.</li>
</ul>
</li>
<li>beverage 饮料<ul>
<li>foods and beverages</li>
<li>Hot beberages include tea, coffee and hot chocolate.</li>
</ul>
</li>
<li>milk 牛奶<ul>
<li>a bottle of mile</li>
<li>Would you like some milk in you tea?</li>
<li>breast milk.</li>
</ul>
</li>
<li>yoghurt 酸奶<ul>
<li>plain yoghurt</li>
<li>strawberry yoghurt</li>
<li>low-fat yoghurt</li>
</ul>
</li>
<li>wine 葡萄酒，果酒<ul>
<li>red wine</li>
<li>white wine</li>
<li>I love Australian wines.</li>
<li>Would you like to see the wine list, sir?</li>
</ul>
</li>
<li>champagne 香槟酒<ul>
<li>a glass of champagne</li>
<li>They celebrated their wedding anniversary with a bottle of champagne.</li>
</ul>
</li>
<li>beer 啤酒<ul>
<li>My brother has every dinner with beer.</li>
<li>Two beers, please.</li>
</ul>
</li>
<li>juice 果汁<ul>
<li>tomato juice</li>
<li>orange juice</li>
<li>apple juice</li>
</ul>
</li>
<li>tea 茶<ul>
<li>lemon tea</li>
<li>iced tea</li>
<li>Shall i make tea?</li>
<li>Would you like some tea?</li>
<li>I’d love a cup of tea, please.</li>
<li>How about a nice cup of tea? That’ll make you feel better.</li>
<li>afternoon tea</li>
</ul>
</li>
<li>coffee 咖啡<ul>
<li>coffee bean</li>
<li>coffee house</li>
<li>instant coffee</li>
<li>I’ll make some coffee.</li>
<li>Do you like your coffee white or black?</li>
<li>Two coffees, to go, please.</li>
</ul>
</li>
<li>water 水<ul>
<li>running water</li>
<li>drinking water</li>
<li>Fish live in water.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>名词-动物</title>
    <url>/2020/04/01/Language/English/New%20Concept/Word/Noun/Animals/</url>
    <content><![CDATA[<p>动物的一些名词</p>
<a id="more"></a>
<ul>
<li>dog 狗<ul>
<li>I love dogs;</li>
<li>Dogs are man’s best friends;</li>
<li>The dog is very cude;</li>
</ul>
</li>
<li>cat 猫<ul>
<li>I have a cat , the cat is white.</li>
<li>The cat likes sleeping.</li>
</ul>
</li>
<li>puppy 小狗</li>
<li>doggie 小狗</li>
<li>kitty 小猫</li>
<li>rooster 公鸡<ul>
<li>It’s hard to see a rooster in bi cities.</li>
<li>I saw a rooster this morning.</li>
<li>The rooaster is dead.</li>
</ul>
</li>
<li>hen 母鸡<ul>
<li>My sister keeps a few hens.</li>
<li>The hens lay eggs every day.</li>
<li>The eggs laid by these haes taste yummy.</li>
</ul>
</li>
<li>chicken 小鸡，鸡肉<ul>
<li>The chickens are very cute.</li>
<li>My son likes the chickens very much.</li>
<li>My friends gave me three chickens last week.</li>
</ul>
</li>
<li>duck 鸭子<ul>
<li>Peking Roast Duck</li>
</ul>
</li>
<li>duckling 小鸭子<ul>
<li>The ugly duckling.</li>
</ul>
</li>
<li>goose 鹅  复数：geese<ul>
<li>a goose is bigge than a duck.</li>
</ul>
</li>
<li>pig 猪<ul>
<li>He keeps pigs.I don’t like pigs.</li>
<li>You a such a pi.</li>
</ul>
</li>
<li>piggy 小猪</li>
<li>piggy bank 储蓄罐</li>
<li>cow 奶牛，母牛<ul>
<li>She is milking the cow.</li>
</ul>
</li>
<li>cowboy 西部牛仔，牧童</li>
<li>bull 公牛</li>
<li>horse 马<ul>
<li>I have never ridden a horse before.</li>
<li>I’s so hangry! I could eat a horse.</li>
<li>A horse race.</li>
</ul>
</li>
<li>donkey 驴<ul>
<li>I’ve never seen a donkey before.</li>
<li>you stupid a donkey.</li>
</ul>
</li>
<li>sheep 绵羊<ul>
<li>He is a sheep farmer.</li>
<li>A black sheep.</li>
</ul>
</li>
<li>goat 山羊<ul>
<li>Goat’s milk</li>
<li>Let me go ! You old goat.</li>
</ul>
</li>
<li>lamb 羊羔</li>
<li>lion 狮子<ul>
<li>Mark is as brave as a lion.</li>
</ul>
</li>
<li>lioness 母狮子</li>
<li>tiger 老虎<ul>
<li>I saw two tigers in the zoo today.</li>
<li>A paper tiger.</li>
</ul>
</li>
<li>tigress 母老虎</li>
<li>leopard 豹<ul>
<li>A leopard can’t change its spots.</li>
<li>Wanna see me be leopard.</li>
</ul>
</li>
<li>wolf 狼<ul>
<li>He is a wolf in sheeps clothiing.</li>
</ul>
</li>
<li>Wolf Totem 狼图腾</li>
<li>zebra 斑马<ul>
<li>Looking! There is a zebre .</li>
<li>Zebra crossing.</li>
</ul>
</li>
<li>bear 熊<ul>
<li>bear marker.</li>
<li>He gave me a bear-hug.</li>
</ul>
</li>
<li>polar bear 北极熊</li>
<li>panda</li>
<li>giant panda<ul>
<li>The panda is a national treasure of China.</li>
</ul>
</li>
<li>camel 骆驼<ul>
<li>Camels live in desserts.</li>
</ul>
</li>
<li>deer 鹿  复数 deer<ul>
<li>The deer eating grass.</li>
</ul>
</li>
<li>giraffe 长颈鹿<ul>
<li>A giraffe has a very long neck</li>
</ul>
</li>
<li>elephant 大象<ul>
<li>You can see many elephant in Thailand.</li>
<li>A white elephant.</li>
</ul>
</li>
<li>fox 狐狸<ul>
<li>Julie is as sly as a fox.</li>
<li>I don’t like that sly old fox.</li>
</ul>
</li>
<li>kangraoo 蜥蜴<ul>
<li>Kangraoo are found in Australia.</li>
</ul>
</li>
<li>koala 考拉<ul>
<li>I love koalas! They are just so cute!.</li>
</ul>
</li>
<li>ostrich 鸵鸟<ul>
<li>An ostrich can’t fly. but it can run vary fast.</li>
</ul>
</li>
<li>rabbit 兔子<ul>
<li>Bob keeps a rabbit as a pet.</li>
</ul>
</li>
<li>snake  蛇<ul>
<li>I am scared of snakes.</li>
<li>Steve wa bitten by a snake.</li>
<li>Stay awar from him. He is a snake.</li>
</ul>
</li>
<li>mouse 老鼠 鼠标  复数:mice<ul>
<li>Mickey Mouse</li>
<li>a mouse mat</li>
</ul>
</li>
<li>squirrel 松鼠<ul>
<li>Squirrels like eating nuts.</li>
<li>The squirrel in the movie <strong>Ice Age</strong> is very funny;</li>
</ul>
</li>
<li>monkey 猴子，顽皮的儿童<ul>
<li>Look at the monkey! It’s climbing up the tree so fast!</li>
<li>Stop that, you little monkey!</li>
</ul>
</li>
<li>turkey 火鸡，火鸡肉<ul>
<li>roast turkey</li>
<li>People eat turkey on Thanks-giving Day.</li>
</ul>
</li>
<li>lizard 蜥蜴<ul>
<li>A lizard is a reptile with shor legs and a long tail.</li>
</ul>
</li>
<li>penguin 企鹅<ul>
<li>A penguin is a type of sea bird. It can not fly but it can swim.</li>
</ul>
</li>
<li>swan 天鹅<ul>
<li>She is as graceful as a swan.</li>
<li>Swan Lake.</li>
</ul>
</li>
<li>frog 青蛙<ul>
<li>The Frog Prince</li>
</ul>
</li>
<li>frogman 蛙人，潜水员</li>
<li>crocodile 鳄鱼，鳄鱼皮<ul>
<li>A crocodile handbag</li>
<li>Crocodile tears</li>
</ul>
</li>
<li>rhinoceros(rhino) 犀牛</li>
<li>hippopotamus(hippo) 河马</li>
<li>gorilla 大猩猩<ul>
<li>A gorilla is very large ape(猿)</li>
</ul>
</li>
<li>peacock 孔雀<ul>
<li>Peter is as proud as a peacock.</li>
<li>Peacoke is blue.</li>
</ul>
</li>
<li>dinosaur 恐龙<ul>
<li>Boys usually like dinosaurs.</li>
<li>If you want to see dinosayrs, go to Beijing Museum of Natural History.</li>
</ul>
</li>
<li>ant 蚂蚁<ul>
<li>Ants live in large groups.</li>
<li>I hate to see ants in my house.</li>
</ul>
</li>
<li>spider 蜘蛛<ul>
<li>Many grils are afraid of spiders.</li>
</ul>
</li>
<li>Sipder-Man 蜘蛛侠</li>
<li>snail 蜗牛<ul>
<li>The snail came out of its shell.</li>
<li>The old woman crossed the street at a snail’s pace.</li>
</ul>
</li>
<li>cockroach 蟑螂<ul>
<li>I hate cockroaches. They are so disgusting.</li>
</ul>
</li>
<li>brid 鸟<ul>
<li>The early bird catches the worm.</li>
<li>You are an eraly bird.</li>
<li><strong>A little bird told me</strong> that you’ve got engaged（订婚）.</li>
</ul>
</li>
<li>parrot 鹦鹉<ul>
<li>I have a parrot named Henry.</li>
<li>The parrot can say ‘good morning’ and ‘Good night’.</li>
</ul>
</li>
<li>magpie 喜鹊，爱收集或贮藏东西的人<ul>
<li>Magpies are common birds in China.</li>
<li>She is quite a magpie.</li>
</ul>
</li>
<li>sparrow 麻雀<ul>
<li>There are serveral sparrows twittering outside my window.</li>
</ul>
</li>
<li>swallow 燕子<ul>
<li>One swallow does not make a summer.</li>
</ul>
</li>
<li>dove 鸽子</li>
<li>crow 乌鸦<ul>
<li>She thinks something bad is going to happen bacause she saw a crow this morning.</li>
</ul>
</li>
<li>owl 猫头鹰<ul>
<li>An owl ususlly sleeps with on eye open and the other closed.</li>
<li>A night owl.</li>
</ul>
</li>
<li>eagle 鹰<ul>
<li>An eagle is flying in the sky.</li>
<li>The teacher’s egale eye was always on us.</li>
<li>Hotel California  — Eagles</li>
</ul>
</li>
<li>bee 蜜蜂<ul>
<li>John is as busy as a bee.</li>
<li>I was stung（叮咬） by a bee.</li>
</ul>
</li>
<li>bumblebee 大黄蜂</li>
<li>dragonfly 蜻蜓</li>
<li>dragon 龙</li>
<li>butterfly 蝴蝶<ul>
<li>I saw many beautiful butterflies in Melbon Zoo.</li>
<li>The Butterfly Effect</li>
</ul>
</li>
<li>fly 苍蝇<ul>
<li>Is summer you can see many flies near the river.</li>
<li>My dog wouldn’t hurt a fly.</li>
</ul>
</li>
<li>mosquito 蚊子<ul>
<li>I was bitten by a mosquito.</li>
<li>There is one thing i don’t like about summer too many mosquitoes.</li>
</ul>
</li>
<li>bat 蝙蝠<ul>
<li>A bat can fly around at night.</li>
</ul>
</li>
<li>Batman</li>
<li>seagull 海鸥</li>
<li>fish 鱼 复数：fish<ul>
<li>fish and chips</li>
<li>A big fish in a little pond.</li>
<li>A cold fish.</li>
</ul>
</li>
<li>tuna 金枪鱼<ul>
<li>tuna fish sandwich</li>
</ul>
</li>
<li>dolphin 海豚<ul>
<li>a dolphin show</li>
<li>The dolphin is a smart animal.</li>
</ul>
</li>
<li>whale 鲸<ul>
<li>The whale is not a fish.</li>
<li>The whale is a kind of mamal.</li>
</ul>
</li>
<li>seal 海豹<ul>
<li>Do you know a sea lion is a large type of seal?</li>
</ul>
</li>
<li>sea lion 海狮<ul>
<li>There are sea lions and dolphins in Beijing Oceanarium.</li>
</ul>
</li>
<li>sea horse 海马<ul>
<li>A sea horse has a head that looks like the head of a horse.</li>
</ul>
</li>
<li>turtle 海龟</li>
<li>tortoise 陆龟<ul>
<li>That tortoise is fifty years old , but it looks small.</li>
</ul>
</li>
<li>shrimp 小虾<ul>
<li>Do you know a shrimp has ten legs?</li>
</ul>
</li>
<li>lobster 龙虾<ul>
<li>I bought several live lobsters. They are so expensive.</li>
</ul>
</li>
<li>crab 蟹<ul>
<li>Don’t touch the crab! It has two powerful claws.</li>
</ul>
</li>
<li>jellyfish 水母<ul>
<li>A jellyfish is swimming after you.</li>
<li>I can see thougn the jellyfish . It’s so funny.</li>
</ul>
</li>
<li>startfish 海星 复数 starfish<ul>
<li>I found a starfish on the beach.</li>
</ul>
</li>
<li>squid 鱿鱼，乌贼<ul>
<li>I’ve never seen a live squid before.</li>
</ul>
</li>
<li>walrus 海象<ul>
<li>A walrus also has two long teeth called tusks.</li>
</ul>
</li>
<li>shark 鲨鱼<ul>
<li>a great white shark.</li>
<li>The move <strong>Jaws</strong> is about a man-eating shark.</li>
</ul>
</li>
<li>octopus 章鱼<ul>
<li>There was an amazing octopus during the World Cup in 2010.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>docker部署jar包</title>
    <url>/2020/03/11/Work%20Record/CAAS/JDK8withDocker/</url>
    <content><![CDATA[<p>首先先docker search openjdk8，寻找到要使用的image。我使用的是adoptopenjdk/openjdk8这个。</p><a id="more"></a>
<p>然后基于该镜像构建容器。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -dit --name XXX -w /root  -v /etc/timezone:/etc/timezone:ro -v /etc/localtime:/etc/localtime -v /XXX:/root  -p 8888:8080 adoptopenjdk/openjdk8 sh -c "java -jar api.jar"</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus打包碰到的问题</title>
    <url>/2019/11/01/Work%20Record/CAAS/Nexus/</url>
    <content><![CDATA[<p>打包如果打的是snapshot的包的话，包里只包含当前project下的文件，其他的依赖获取不到。</p><p>比如说，A依赖B，B依赖C，B打的是snapshot包，但是A想使用C的东西，获取不到，查看依赖，也看不到C。</p><a id="more"></a>

<p>两个解决办法：</p>
<ol>
<li>打release包，这样A依赖B的release版本，就能够获取到想要的东西</li>
<li>打fat-jar，但是这样，包的体积会非常大</li>
</ol>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>农科院</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-JVM篇章</title>
    <url>/2019/10/22/Interview/JVM/</url>
    <content><![CDATA[<p>JVM相关面试题</p>
<p>基于《深入理解JVM》这本书，如果说可能问的话，会问什么样的问题，又该如何去解答，如果连环炮的形势问的话，又该怎么去解答。如果没有足够理解的话，估计很难面对连环炮的形势。JVM实际工作中主要定位排查问题，性能优化，节省资源，但是一些理论还是要知道的，不然的话就成了高级技工了。有人说月薪3W以下的都不叫程序员，还是有点道理的，不过每个</p>
<p>码畜，总归是有点理想的吧。</p>
<a id="more"></a>
<ol>
<li><h4><span id="jvm运行时数据区分为哪几个部分分别是什么作用">JVM运行时数据区分为哪几个部分？分别是什么作用？</span></h4><p>分为程序计数器，<strong>Java虚拟机栈</strong>，本地方法栈，<strong>Java堆</strong>，方法区</p>
<p>程序计数器：</p>
<p>程序计数器的工作就是通过改变计数器的值来选取吓一跳需要执行的字节码指令，分支、循环、跳转、异常处理、县城回复等基础功能都依赖程序计数器来完成。Java虚拟机的多线程是<strong>通过线程轮流切换并分配处理器执行时间的方式来实现的</strong>，在任何一个确定的时刻，<strong>一个处理器（一个内核）都只会执行一条线程中的指令</strong>。因此为了线程切换后能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，<strong>互不影响，独立存储，线程私有</strong>，而且是唯一一个没有<strong>OutOfMemoryError</strong>情况的区域。</p>
<p>Java虚拟机栈：</p>
<p>线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型：<strong>每个方法在执行的同事都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程</strong>。局部变量表<strong>存放了编译期可知的各种基本数据类型（boolean,byte,char,short,int,float,long,double）、对象引用（reference类型，不是对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）</strong>。如果线程请求的栈深度大于虚拟机允许的深度，那么会StackOverflowError，如果扩展时无法申请到足够的内存，则会OutOfMemoryError。</p>
<p>本地方法栈：</p>
<p>为虚拟机使用的Native方法服务。</p>
<p>Java堆：</p>
<p>是Java虚拟机所管理的内存中最大的一块。被所有线程共享，存放对象实例，<strong>所有的对象实例以及数组都在堆上分配</strong>。是是垃圾收集器管理的主要区域，细分可分为<strong>新生代和老年代</strong>，再细分可以有：<strong>Eden空间、From Survivor空间、To Survivor空间。线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）</strong>。可以用-Xmx和-Xms来控制大小。无法扩展的时候，会抛出OutOfMemotyError。</p>
<p>方法区：</p>
<p>各个线程共享，存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。也叫做永久代。</p>
<p>运行时常量池：</p>
<p>是方法取得一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内存在类加载后进入方法区的运行时常量池存放。</p>
<p>直接内存：</p>
<p>独立于Java堆和Native堆，收到本机总内存的影响。</p>
<blockquote>
<p>可能延伸出的问题</p>
</blockquote>
<ul>
<li>既然说程序计数器是唯一一个没有OutOfMemory的区域，那么说说有哪些区域会有OutOfMemory？</li>
</ul>
<p>答：Java虚拟机栈，Java堆，本地方法栈，方法区。虚拟机栈的内存是可以动态扩展的，但是如果动态扩展时，申请不到足够的内存的话，那么会抛出OutOfMemory；Java堆如果达到了最大使用内存，那么再次开辟内存的时候，同样也会抛出OutOfMemory；本地方法栈如果调用Native方法没有足够内存或者没有释放的时候，那么也会抛出OutOfMemory；方法区中由于有运行时常量池的存在，这部分是最占内存的，如果没有足够内存的时候，同样会OutOfMemory。</p>
<ul>
<li><h5><span id="来说一下线程的生命周期">来说一下线程的生命周期</span></h5></li>
<li><h5><span id="局部变量表里存放是有哪些">局部变量表里存放是有哪些？</span></h5></li>
<li><h5><span id="说一下一个栈帧在虚拟机栈中入栈出栈的过程">说一下一个栈帧在虚拟机栈中入栈出栈的过程</span></h5></li>
<li><h5><span id="什么情况下会stackoverflowerror栈深度怎么算栈和堆所占内存比是多少">什么情况下会StackOverflowError？栈深度怎么算？栈和堆所占内存比是多少？</span></h5></li>
<li><h5><span id="eden空间-from-survivor空间-to-survivor空间内存占比怎么算">Eden空间、From Survivor空间、To Survivor空间内存占比怎么算？</span></h5></li>
<li><h5><span id="虚拟机加载类的过程是什么样的">虚拟机加载类的过程是什么样的？</span></h5></li>
<li><h5><span id="直接内存什么情况下会抛出outofmemoryerror">直接内存什么情况下会抛出<strong>OutOfMemoryError</strong>？</span></h5></li>
</ul>
</li>
<li><h4><span id="当new一个对象的时候对象的创建是怎么样一个过程">当new一个对象的时候，对象的创建是怎么样一个过程？</span></h4><p>虚拟机遇到一条new执行时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p>
<p>类加载检查通过后，虚拟机就会为对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。如果Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的放在一边，中间放着一个指针作为分界点的指示器，那分配内存就是仅仅把那个指针向空闲空间挪动一段与对象大小相等的距离，这种分配方式叫做指针碰撞（Bump the Pointer）。如果内存并不是规整的，已经使用内存和未使用的内存相互交错，这种情况下就没办法使用指针碰撞。那么Java虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式叫做空闲列表（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial，ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>但是在对象的创建是一个非常频繁的行为，并发情况下并不是线程安全的，有可能指针指向A，来没来得及修改，B就使用了原来的指针进行分配内存。为了避免这种情况，有两种处理方式，一种是对分配内存空间的操作进行同步处理，JVM采用CAS+失败重试的方式保证更新操作的原子性；另一种就是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并且分配新的TLAB时，才需要进行同步锁定。虚拟机是否使用TLAB，通过-XX:+/-UseTLAB。</p>
<p>内存分配完毕后，虚拟机就需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。<strong>这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对的零值</strong>。</p>
<p>然后对对象进行必要设置，如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息。<strong>这些信息存放在对象的对象头（Object Header）中</strong>。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>然后对象就已经产生了，但是知道虚拟机执行了init方法之后，把对象按照意愿进行初始化，这才算完成产生。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="来说一下类加载的过程是什么样">来说一下类加载的过程是什么样。</span></h5></li>
<li><h5><span id="如何确定一个对象所需内存大小">如何确定一个对象所需内存大小？</span></h5></li>
<li><h5><span id="内存是如何进行分配的">内存是如何进行分配的？</span></h5></li>
<li><h5><span id="如何确定内存分配方式">如何确定内存分配方式？</span></h5></li>
<li><h5><span id="哪种垃圾收集器带有压缩整理功能">哪种垃圾收集器带有压缩整理功能？</span></h5></li>
<li><h5><span id="有哪几种垃圾收集器分别有哪些特点采用的垃圾回收算法有哪几种分别是什么">有哪几种垃圾收集器？分别有哪些特点？采用的垃圾回收算法有哪几种？分别是什么？</span></h5></li>
<li><h5><span id="对象的创建过程是线程安全的么不是如何解决的">对象的创建过程是线程安全的么？不是？如何解决的？</span></h5></li>
<li><h5><span id="开启tlab的参数是什么默认是否使用tlab">开启TLAB的参数是什么？默认是否使用TLAB？</span></h5></li>
<li><h5><span id="对象头什么时候进行初始化包含哪些信息">对象头什么时候进行初始化？包含哪些信息</span></h5></li>
<li><h5><span id="对象头有哪几种不同的设置方式">对象头有哪几种不同的设置方式？</span></h5></li>
</ul>
</li>
</ol>
<ol>
<li><h4><span id="说一下对象的内存布局">说一下对象的内存布局</span></h4><p>在HotSpot虚拟机中，对象在内存中存储的的布局可以分为三个区域：<strong>对象头（Object Header），实例数据（Instance Data），对象填充（Padding）</strong>。</p>
<p>对象头包括两部分信息，<strong>第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。另一部分是类型指针，既对象指向它的的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</strong>。但是不是所有的虚拟机实现都必须在对象数据上保留类型指针。另外如果对象是一个Java数组，那在对象头中必须还有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p>
<p>实例数据存放的是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认），那么子类中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充不是必然存在，仅仅起到占位符的作用。因为HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。而对象头正好是8字节的整数倍，也就是实例部分没有对齐时，就需要用对齐填充来补全。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="哪个虚拟机实现不保留类型指针">哪个虚拟机实现不保留类型指针？</span></h5></li>
<li><h5><span id="虚拟机分配策略参数有哪些分配策略有哪些">虚拟机分配策略参数有哪些？分配策略有哪些？</span></h5></li>
<li><h5><span id="有没有可能子类的变量出现在父类变量之前">有没有可能子类的变量出现在父类变量之前？</span></h5></li>
</ul>
</li>
<li><h4><span id="说一下对象访问的时候是如何进行定位的">说一下对象访问的时候是如何进行定位的？</span></h4><p>访问对象是通过栈上的reference数据来操作具体对象，两种办法，直接指针和句柄访问。</p>
<p>句柄访问的话，会在Java堆中划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的地址信息。</p>
<p>直接指针的话，reference中存储的直接就是对象地址。</p>
<p>使用句柄访问的好处是，reference中存储的是句柄地址，在对象被于东的时候只会改变句柄中的实例数据地址，而reference本身则不需要修改。</p>
<p>直接指针的最好好处就是速度更快，节省了一次指针定位的时间开销。HotSpot主要使用直接指针。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li>直接指针和句柄访问各自有什么优缺点，哪个使用的比较多？</li>
</ul>
</li>
<li><h4><span id="什么情况下回oom写个代码使其抛出outofmemoryerror">什么情况下回OOM？写个代码，使其抛出OutOfMemoryError</span></h4><p>堆的话，可能会有内存泄露和内存溢出两种情况。如果一直新建对象，但是GC无法回收，超过了GC所允许的最大内存，那么就会产生OOM。</p>
<p>如果内存泄漏，那么就检查泄露对象到GC Roots的引用链是通过怎样的路径关联并导致垃圾收集器无法自动回收它们的。如果是内存溢出，那么就调大内存，然后检查代码中是否有某些对象生命周期过长，持有时间过长等情况。</p>
<p>栈的话，如果说请求栈的深度超过了允许的深度，会抛出StackoverFlow异常，但是如果栈无法申请到足够的内存的话，则会抛出OOM异常。</p>
<p>运行时常量池的话，一直添加字符串，将其固化到常量池填满，应该就会OOM。</p>
<p>方法区，由于方法区存放的是类的信息，那么构造足够多的类，将其撑爆就会OOM。</p>
<p>本机直接内存。直接或者间接使用NIO，总内存不够，则会抛出OOM。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="什么是内存泄漏什么是内存溢出">什么是内存泄漏，什么是内存溢出？</span></h5></li>
<li><h5><span id="控制内存大小的参数是什么">控制内存大小的参数是什么？</span></h5></li>
</ul>
</li>
<li><h4><span id="判断对象是否存活的算法有哪几种各有什么特点">判断对象是否存活的算法有哪几种？各有什么特点？</span></h4><p>引用计数算法和可达性分析算法。</p>
</li>
</ol>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="可作为gc-roots的对象包括哪几种">可作为GC Roots的对象包括哪几种？</span></h5></li>
</ul>
<ol>
<li><h4><span id="说一说java的引用">说一说Java的引用</span></h4></li>
<li><h4><span id="如何判断一个常量是否为废弃常量如何判断一个类是无用的类">如何判断一个常量是否为废弃常量？如何判断一个类是无用的类？</span></h4></li>
<li><h4><span id="说一下常用的垃圾收集算法">说一下常用的垃圾收集算法</span></h4></li>
<li><h4><span id="说一下有哪些垃圾收集器分别有什么用途各自用的什么算法">说一下有哪些垃圾收集器，分别有什么用途，各自用的什么算法？</span></h4></li>
<li><h4><span id="既然你说到了g1收集器那你说说g1收集器">既然你说到了G1收集器，那你说说G1收集器</span></h4></li>
<li><h4><span id="g1和cms有哪些区别">G1和CMS有哪些区别？</span></h4><p>​    </p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题收集-前言</title>
    <url>/2019/10/21/Interview/Perface/</url>
    <content><![CDATA[<p>工作如果能带来提升的话，那当然是最好不过的一件事情，但是如果不能呢？那就很尴尬了，当待得时间越来越长，<strong>自己的价值和竞争力就会越来越低</strong>。最后可能就会被抛弃，虽然应该也不至于和中兴程序员一样跳楼，然是忧患意识还是要有，日常学习不能少，但是，有些地方可能自己意识不到从而忽略，然后错失一次机会。因此，如果是我去面试的话，我会问的问题和我自己的答案，会放在这里。</p><a id="more"></a>
<p>采用连环炮的方式。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>中文数据中筛选出英文数据</title>
    <url>/2019/10/19/Work%20Record/CAAS/StringLength/</url>
    <content><![CDATA[<p>数据库表中，有字段为<strong><em>title</em></strong>，只存中文，但是英文数据混入，需要筛选出来将其放到英文库中。如何找出来，就成为了一个问题。</p><a id="more"></a>
<p>其实很简单，<strong>select id from xxx x where length(x.title) != char_length(title)</strong></p>
<p>因为说，MySQL在UTF-8的编码下，一个汉字字符占据三个字节，但是英文是一个字符一个字节，这就会导致说，如果title为英文，那么他的字符数和字节数是肯定能对上的，中文反之。</p>
<p>延伸一下，MySQL的varchar类型，并不是按照字节来算，而是字符，比如说，定义了一个varchar(10)，存“西门吹雪”是没有任何问题的，占用会是4，存”Jobs”也一样。MySQL对此作了优化。</p>
<p>再延伸一下，UTF-8一个汉字占据两三个字节，GBK一个汉字两个字节，部分汉字占据四个字节</p>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>农科院</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码</title>
    <url>/2019/08/25/Source%20code%20reading/JDK/Collection/ConcurrentHashMap/</url>
    <content><![CDATA[<blockquote>
<p>ConcurrentHashMap，可以进行并发读，写操作互斥。HashMap是线程不安全的。</p>
</blockquote>
<p>先翻译一下重点注释</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Overview:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The primary design goal of this hash table is to maintain</span></span><br><span class="line"><span class="comment"> * concurrent readability (typically method get(), but also</span></span><br><span class="line"><span class="comment"> * iterators and related methods) while minimizing update</span></span><br><span class="line"><span class="comment"> * contention. Secondary goals are to keep space consumption about</span></span><br><span class="line"><span class="comment"> * the same or better than java.util.HashMap, and to support high</span></span><br><span class="line"><span class="comment"> * initial insertion rates on an empty table by many threads.</span></span><br><span class="line"><span class="comment"> 这个主要设计目标是为了保证并发读的最小竞争性(主要是get方法，但是也支持迭代器相关方法)，第二个目标是为了和hashMap一致或者更好的空间消耗，并且支持多线程下的空表的高并发初始化插入速度。</span></span><br><span class="line"><span class="comment"> * The table is lazily initialized to a power-of-two size upon the</span></span><br><span class="line"><span class="comment"> * first insertion.  Each bin in the table normally contains a</span></span><br><span class="line"><span class="comment"> * list of Nodes (most often, the list has only zero or one Node).</span></span><br><span class="line"><span class="comment"> * Table accesses require volatile/atomic reads, writes, and</span></span><br><span class="line"><span class="comment"> * CASes.  Because there is no other way to arrange this without</span></span><br><span class="line"><span class="comment"> * adding further indirections, we use intrinsics</span></span><br><span class="line"><span class="comment"> * (jdk.internal.misc.Unsafe) operations.</span></span><br><span class="line"><span class="comment"> 这个table是在首次插入之后进行延迟初始化的，大小为2的次方数，每个table中的子节点通常都包含一个node的list(大多数情况下，这个list仅仅只有一个Node或者没有Node)。访问tabe需要volatile/atomic 读，写和CAS操作。因为这里没有其他方法可以再不使用间接指令的情况下安排table，所以我们使用内在函数(Unsafe)操作。</span></span><br><span class="line"><span class="comment"> * We use the top (sign) bit of Node hash fields for control</span></span><br><span class="line"><span class="comment"> * purposes -- it is available anyway because of addressing</span></span><br><span class="line"><span class="comment"> * constraints.  Nodes with negative hash fields are specially</span></span><br><span class="line"><span class="comment"> * handled or ignored in map methods.</span></span><br><span class="line"><span class="comment"> //我们使用Node参与hash的字段的top位来达到控制的目的，由于地址约束的存在，它无论如何都是欧东可用的，Node的辣鸡hash 字段会被在map的方法里面特殊处理或者直接丢弃</span></span><br><span class="line"><span class="comment"> * Insertion (via put or its variants) of the first node in an</span></span><br><span class="line"><span class="comment"> * empty bin is performed by just CASing it to the bin.  This is</span></span><br><span class="line"><span class="comment"> * by far the most common case for put operations under most</span></span><br><span class="line"><span class="comment"> * key/hash distributions.  Other update operations (insert,</span></span><br><span class="line"><span class="comment"> * delete, and replace) require locks.  We do not want to waste</span></span><br><span class="line"><span class="comment"> * the space required to associate a distinct lock object with</span></span><br><span class="line"><span class="comment"> * each bin, so instead use the first node of a bin list itself as</span></span><br><span class="line"><span class="comment"> * a lock. Locking support for these locks relies on builtin</span></span><br><span class="line"><span class="comment"> * "synchronized" monitors.</span></span><br><span class="line"><span class="comment"> 在一个空桶中的首个node的插入操作(通过put或者它的变种方法)中，是通过CAS操作进行的。对于大多数的key/value分布情况下，这是最普通最常见的情况。其他修改操作需要锁(insert,delete,replace)，我们不去浪费空间在每个桶中挂上不同独立的锁，所以使用桶中第一个节点来作为锁，这些锁的锁定支持，依赖于内置的“同步”监视器。</span></span><br><span class="line"><span class="comment"> * Using the first node of a list as a lock does not by itself</span></span><br><span class="line"><span class="comment"> * suffice though: When a node is locked, any update must first</span></span><br><span class="line"><span class="comment"> * validate that it is still the first node after locking it, and</span></span><br><span class="line"><span class="comment"> * retry if not. Because new nodes are always appended to lists,</span></span><br><span class="line"><span class="comment"> * once a node is first in a bin, it remains first until deleted</span></span><br><span class="line"><span class="comment"> * or the bin becomes invalidated (upon resizing).</span></span><br><span class="line"><span class="comment"> 使用list中的首个节点来作为锁并不能够满足条件：当一个node被锁的时候，任何修改都必须在锁定之后进行首节点验证，验证它仍然是首节点。而且如果不是首节点就重新验证。因为时新的node通常都是添加到list里，第一次的时候node是桶里的第一个元素，它会保持第一知道删除或者桶变成不可用的状态（调整大小后）。</span></span><br><span class="line"><span class="comment"> * The main disadvantage of per-bin locks is that other update</span></span><br><span class="line"><span class="comment"> * operations on other nodes in a bin list protected by the same</span></span><br><span class="line"><span class="comment"> * lock can stall, for example when user equals() or mapping</span></span><br><span class="line"><span class="comment"> * functions take a long time.  However, statistically, under</span></span><br><span class="line"><span class="comment"> * random hash codes, this is not a common problem.  Ideally, the</span></span><br><span class="line"><span class="comment"> * frequency of nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment"> * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment"> * parameter of about 0.5 on average, given the resizing threshold</span></span><br><span class="line"><span class="comment"> * of 0.75, although with a large variance because of resizing</span></span><br><span class="line"><span class="comment"> * granularity. Ignoring variance, the expected occurrences of</span></span><br><span class="line"><span class="comment"> * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The</span></span><br><span class="line"><span class="comment"> * first values are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0:    0.60653066</span></span><br><span class="line"><span class="comment"> * 1:    0.30326533</span></span><br><span class="line"><span class="comment"> * 2:    0.07581633</span></span><br><span class="line"><span class="comment"> * 3:    0.01263606</span></span><br><span class="line"><span class="comment"> * 4:    0.00157952</span></span><br><span class="line"><span class="comment"> * 5:    0.00015795</span></span><br><span class="line"><span class="comment"> * 6:    0.00001316</span></span><br><span class="line"><span class="comment"> * 7:    0.00000094</span></span><br><span class="line"><span class="comment"> * 8:    0.00000006</span></span><br><span class="line"><span class="comment"> * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lock contention probability for two threads accessing distinct</span></span><br><span class="line"><span class="comment"> * elements is roughly 1 / (8 * #elements) under random hashes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 当桶上锁时，桶中其他节点的其他操作会中止，比如使用equals或者mapping的方法将会执行很长时间。然后在统计中，在随机hash值的情况下，这不是一个常见的问题。理想情况下，在给定阈值给0.75的时候，桶中节点的分布遵循平均值约为0.5的泊松分布，尽管会因为resizing粒度具有较大方差，忽略方差，list的期望大小k为(exp(-0.5) * pow(0.5, k) / factorial(k))</span></span><br><span class="line"><span class="comment"> 两个线程访问不同的元素，锁竞争的概率大约为 1 / (* elements)</span></span><br><span class="line"><span class="comment"> * Actual hash code distributions encountered in practice</span></span><br><span class="line"><span class="comment"> * sometimes deviate significantly from uniform randomness.  This</span></span><br><span class="line"><span class="comment"> * includes the case when N &gt; (1&lt;&lt;30), so some keys MUST collide.</span></span><br><span class="line"><span class="comment"> * Similarly for dumb or hostile usages in which multiple keys are</span></span><br><span class="line"><span class="comment"> * designed to have identical hash codes or ones that differs only</span></span><br><span class="line"><span class="comment"> * in masked-out high bits. So we use a secondary strategy that</span></span><br><span class="line"><span class="comment"> * applies when the number of nodes in a bin exceeds a</span></span><br><span class="line"><span class="comment"> * threshold. These TreeBins use a balanced tree to hold nodes (a</span></span><br><span class="line"><span class="comment"> * specialized form of red-black trees), bounding search time to</span></span><br><span class="line"><span class="comment"> * O(log N).  Each search step in a TreeBin is at least twice as</span></span><br><span class="line"><span class="comment"> * slow as in a regular list, but given that N cannot exceed</span></span><br><span class="line"><span class="comment"> * (1&lt;&lt;64) (before running out of addresses) this bounds search</span></span><br><span class="line"><span class="comment"> * steps, lock hold times, etc, to reasonable constants (roughly</span></span><br><span class="line"><span class="comment"> * 100 nodes inspected per operation worst case) so long as keys</span></span><br><span class="line"><span class="comment"> * are Comparable (which is very common -- String, Long, etc).</span></span><br><span class="line"><span class="comment"> * TreeBin nodes (TreeNodes) also maintain the same "next"</span></span><br><span class="line"><span class="comment"> * traversal pointers as regular nodes, so can be traversed in</span></span><br><span class="line"><span class="comment"> * iterators in the same way.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">   * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">   * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">   * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">   * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">   * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">   * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">   * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">   * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>
<p>这里就发现，所有的变量都是volatile的，而volatile这个关键字的作用，就是首先保证可见性，然后禁止指令重排序，单次读写的原子性</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap源码</title>
    <url>/2019/08/19/Source%20code%20reading/JDK/Collection/TreeMap/</url>
    <content><![CDATA[<blockquote>
<p>Map的另一种有序实现，上一种是LinkedHashMap</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Red-Black tree based &#123;<span class="doctag">@link</span> NavigableMap&#125; implementation.</span></span><br><span class="line"><span class="comment"> * The map is sorted according to the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment"> * ordering&#125; of its keys, or by a &#123;<span class="doctag">@link</span> Comparator&#125; provided at map</span></span><br><span class="line"><span class="comment"> * creation time, depending on which constructor is used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation provides guaranteed log(n) time cost for the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> containsKey&#125;, &#123;<span class="doctag">@code</span> get&#125;, &#123;<span class="doctag">@code</span> put&#125; and &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment"> * operations.  Algorithms are adaptations of those in Cormen, Leiserson, and</span></span><br><span class="line"><span class="comment"> * Rivest's &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//简单翻译一下，摘录主要的东西，基于红黑树的实现，这个map的key是自然有序的，或者自定义实现在使用构造方法创建的时候使用Comparator</span></span><br><span class="line"><span class="comment">//这个实现支持log(n)级别的时间复杂度，包裹containsKey,get,put,remove等操作。后面是算法改编自XXX。</span></span><br><span class="line"><span class="comment">//这个map是不同步的，如果想多线程使用，需要使用Collections.syschronizedSortedMap包装</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty tree map, ordered according to the given</span></span><br><span class="line"><span class="comment">     * comparator.  All keys inserted into the map must be &lt;em&gt;mutually</span></span><br><span class="line"><span class="comment">     * comparable&lt;/em&gt; by the given comparator: &#123;<span class="doctag">@code</span> comparator.compare(k1,</span></span><br><span class="line"><span class="comment">     * k2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k1&#125; and &#123;<span class="doctag">@code</span> k2&#125; in the map.  If the user attempts to put</span></span><br><span class="line"><span class="comment">     * a key into the map that violates this constraint, the &#123;<span class="doctag">@code</span> put(Object</span></span><br><span class="line"><span class="comment">     * key, Object value)&#125; call will throw a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comparator the comparator that will be used to order this map.</span></span><br><span class="line"><span class="comment">     *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment">     *        ordering&#125; of the keys will be used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//比较关键的一个代码，创建的时候，指定排序方式，再插入的时候进行排序，如果为null，那就会使用默认的排序方式</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new tree map containing the same mappings and</span></span><br><span class="line"><span class="comment">     * using the same ordering as the specified sorted map.  This</span></span><br><span class="line"><span class="comment">     * method runs in linear time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  m the sorted map whose mappings are to be placed in this map,</span></span><br><span class="line"><span class="comment">     *         and whose comparator is to be used to sort this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException | ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个代码交待我们，如果构造方法传入的另一个TreeMap的话，那么排序方式会继承之前的map</span></span><br><span class="line"><span class="comment">//containsKey，containsValue,get,put这些全部是基于红黑树，没必要说，懂了红黑树的数据结构，就自然明白了</span></span><br><span class="line"><span class="comment">//非HashMap，不是基于hash算法</span></span><br><span class="line"><span class="comment">//感觉没啥写的了。。。红黑树现在感觉也不难。。。简直了</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap源码</title>
    <url>/2019/07/18/Source%20code%20reading/JDK/Collection/LinkedHashMap/</url>
    <content><![CDATA[<p>写在前面</p>
<p>HashMap是无序的，那么说，Map接口有没有说有序的实现？有，两种，一种LinkedHashMap，一种就是TreeMap，先来看看LinkedHashMap。</p>
<a id="more"></a>
<p>照旧，先来翻译一下LinkedHashMap的注释。好长啊，Map的注释怎么就这么长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Hash table and linked list implementation of the &#123;<span class="doctag">@code</span> Map&#125; interface,</span></span><br><span class="line"><span class="comment"> * with predictable iteration order.  This implementation differs from</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> HashMap&#125; in that it maintains a doubly-linked list running through</span></span><br><span class="line"><span class="comment"> * all of its entries.  This linked list defines the iteration ordering,</span></span><br><span class="line"><span class="comment"> * which is normally the order in which keys were inserted into the map</span></span><br><span class="line"><span class="comment"> * (&lt;i&gt;insertion-order&lt;/i&gt;).  Note that insertion order is not affected</span></span><br><span class="line"><span class="comment"> * if a key is &lt;i&gt;re-inserted&lt;/i&gt; into the map.  (A key &#123;<span class="doctag">@code</span> k&#125; is</span></span><br><span class="line"><span class="comment"> * reinserted into a map &#123;<span class="doctag">@code</span> m&#125; if &#123;<span class="doctag">@code</span> m.put(k, v)&#125; is invoked when</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> m.containsKey(k)&#125; would return &#123;<span class="doctag">@code</span> true&#125; immediately prior to</span></span><br><span class="line"><span class="comment"> * the invocation.)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * Map散列表和链表的实现，具有可预测的特性。这个实现和HashMap不同的地方在于它维护了一个贯穿所有实体的双向链表，这个链表定义了其迭代顺序，每个key再插入map之后都是有序的。如果一个key已经插入到了map中，再次插入的时候，是不影响其在map中的顺序的。（当一个key重新插入map的时候，如果在m.containsKey(k) 在调用之前将要return true的时候调用m.put(k,v)。）</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation spares its clients from the unspecified, generally</span></span><br><span class="line"><span class="comment"> * chaotic ordering provided by &#123;<span class="doctag">@link</span> HashMap&#125; (and &#123;<span class="doctag">@link</span> Hashtable&#125;),</span></span><br><span class="line"><span class="comment"> * without incurring the increased cost associated with &#123;<span class="doctag">@link</span> TreeMap&#125;.  It</span></span><br><span class="line"><span class="comment"> * can be used to produce a copy of a map that has the same order as the</span></span><br><span class="line"><span class="comment"> * original, regardless of the original map's implementation: </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  这个实现避免了像HashMap和HashTable的实现一样不确定，难以预测。并且不需要像TreeMap一样一直增加的消耗。它可以复制一个map来使用，它会和原先的map一样有同样的顺序，而不用管之前源map的实现。就像下面这样</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     void foo(Map m) &#123;</span></span><br><span class="line"><span class="comment"> *         Map copy = new LinkedHashMap(m);</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * This technique is particularly useful if a module takes a map on input,</span></span><br><span class="line"><span class="comment"> * copies it, and later returns results whose order is determined by that of</span></span><br><span class="line"><span class="comment"> * the copy.  (Clients generally appreciate having things returned in the same</span></span><br><span class="line"><span class="comment"> * order they were presented.)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 这个技巧是非常有用的，如果一个模块获得了个map，然后复制它，过一会就回返回一个顺序已经被定义的副本(用户通常中意一件事像原先那样发展)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A special &#123;<span class="doctag">@link</span> #LinkedHashMap(int,float,boolean) constructor&#125; is</span></span><br><span class="line"><span class="comment"> * provided to create a linked hash map whose order of iteration is the order</span></span><br><span class="line"><span class="comment"> * in which its entries were last accessed, from least-recently accessed to</span></span><br><span class="line"><span class="comment"> * most-recently (&lt;i&gt;access-order&lt;/i&gt;).  </span></span><br><span class="line"><span class="comment"> 	一个特殊的构造方法被提供来创建一个Linked hash map，其迭代顺序是其entry上次访问的顺序，从最近的访问到最多的访问(访问排序)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> This kind of map is well-suited to</span></span><br><span class="line"><span class="comment"> * building LRU caches.  Invoking the &#123;<span class="doctag">@code</span> put&#125;, &#123;<span class="doctag">@code</span> putIfAbsent&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get&#125;, &#123;<span class="doctag">@code</span> getOrDefault&#125;, &#123;<span class="doctag">@code</span> compute&#125;, &#123;<span class="doctag">@code</span> computeIfAbsent&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> computeIfPresent&#125;, or &#123;<span class="doctag">@code</span> merge&#125; methods results</span></span><br><span class="line"><span class="comment"> * in an access to the corresponding entry (assuming it exists after the</span></span><br><span class="line"><span class="comment"> * invocation completes). The &#123;<span class="doctag">@code</span> replace&#125; methods only result in an access</span></span><br><span class="line"><span class="comment"> * of the entry if the value is replaced.  The &#123;<span class="doctag">@code</span> putAll&#125; method generates one</span></span><br><span class="line"><span class="comment"> * entry access for each mapping in the specified map, in the order that</span></span><br><span class="line"><span class="comment"> * key-value mappings are provided by the specified map's entry set iterator.</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;No other methods generate entry accesses.&lt;/i&gt;  In particular, operations</span></span><br><span class="line"><span class="comment"> * on collection-views do &lt;i&gt;not&lt;/i&gt; affect the order of iteration of the</span></span><br><span class="line"><span class="comment"> * backing map.</span></span><br><span class="line"><span class="comment"> * 这种类型的map非常适合于构建一个LRU缓存(Least Recently Used),使用put,putIfAbsent,get,getOrDefault,apmpute,aomputeIfAbsent,aomputeInfPresent</span></span><br><span class="line"><span class="comment"> merge等方法来记录访问缓存(在调用完成之后记录)。如果value被替换的话，replace方法仅仅返回entry中被访问过的对象，putAll方法生成一个访问记录给每个在这个map里的entry，在这种情况下，这个key-value映射将会被支持于map的set iterator，没有其他方法生成entry 访问记录。通常情况下，集合视图的操作不会修改map的iterator的顺序。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@link</span> #removeEldestEntry(Map.Entry)&#125; method may be overridden to</span></span><br><span class="line"><span class="comment"> * impose a policy for removing stale mappings automatically when new mappings</span></span><br><span class="line"><span class="comment"> * are added to the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> removeEldestEntry这个方法可能被重载来在remove的时候或者在新的映射添加到map的时候。安全自动的使用</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class provides all of the optional &#123;<span class="doctag">@code</span> Map&#125; operations, and</span></span><br><span class="line"><span class="comment"> * permits null elements.  Like &#123;<span class="doctag">@code</span> HashMap&#125;, it provides constant-time performance for the basic operations (&#123;<span class="doctag">@code</span> add&#125;, &#123;<span class="doctag">@code</span> contains&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove&#125;), assuming the hash function disperses elements</span></span><br><span class="line"><span class="comment"> * properly among the buckets. </span></span><br><span class="line"><span class="comment"> LinkedHashMap支持Map的所有操作，并且允许null元素。像HashMap，假设这个hash方法均匀分布key的话，它的add，contains，remove等基础操作拥有稳定的性能。</span></span><br><span class="line"><span class="comment"> * Performance is likely to be just slightly</span></span><br><span class="line"><span class="comment"> * below that of &#123;<span class="doctag">@code</span> HashMap&#125;, due to the added expense of maintaining the</span></span><br><span class="line"><span class="comment"> * linked list, with one exception: Iteration over the collection-views</span></span><br><span class="line"><span class="comment"> * of a &#123;<span class="doctag">@code</span> LinkedHashMap&#125; requires time proportional to the &lt;i&gt;size&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * of the map, regardless of its capacity.  Iteration over a &#123;<span class="doctag">@code</span> HashMap&#125;</span></span><br><span class="line"><span class="comment"> * is likely to be more expensive, requiring time proportional to its</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;capacity&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> 	LinkedHashMap的性能仅仅稍微比HashMap低一点，由于添加操作使用的是Linked list，所以性能消耗全在这里，除了一个情况，迭代LinkedHashMap的集合试图需要O(map.size)，不管他的capacity多大。而迭代HashMap的时候与它很像，但是需要更多的花费，需要O(map.capacity)的花费。</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A linked hash map has two parameters that affect its performance:</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  They are defined precisely</span></span><br><span class="line"><span class="comment"> * as for &#123;<span class="doctag">@code</span> HashMap&#125;.  Note, however, that the penalty for choosing an</span></span><br><span class="line"><span class="comment"> * excessively high value for initial capacity is less severe for this class</span></span><br><span class="line"><span class="comment"> * than for &#123;<span class="doctag">@code</span> HashMap&#125;, as iteration times for this class are unaffected</span></span><br><span class="line"><span class="comment"> * by capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	一个LinkedHashMap有连个参数影响他的性能(initial capacity , load factor),他们在HashMap中被精确定义。但是需要注意的是，相对于HashMap来说，选择一个非常大的initial capacity的值产生的影响是非常小的，LinkedHashMap的迭代时间并不受capacity的影响。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * If multiple threads access a linked hash map concurrently, and at least</span></span><br><span class="line"><span class="comment"> * one of the threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be</span></span><br><span class="line"><span class="comment"> * synchronized externally.  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	注意：这个实现并不是线程安全的，如果两个以上的线程并发访问LinkedHashMap，同时至少有一个线程修改了map的结构，外部操作必须是线程安全的，这通常使用某个对象的同步操作来包装这个map。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * If no such object exists, the map should be "wrapped" using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span></span><br><span class="line"><span class="comment"> * method.  This is best done at creation time, to prevent accidental</span></span><br><span class="line"><span class="comment"> * unsynchronized access to the map:&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *   Map m = Collections.synchronizedMap(new LinkedHashMap(...));&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 如果没有对象存在的话，那么这个map应该使用Collections.synchronizedMap来包装。它最好在创建的时候使用，来防止线程不安全的访问。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * A structural modification is any operation that adds or deletes one or more</span></span><br><span class="line"><span class="comment"> * mappings or, in the case of access-ordered linked hash maps, affects</span></span><br><span class="line"><span class="comment"> * iteration order.  In insertion-ordered linked hash maps, merely changing</span></span><br><span class="line"><span class="comment"> * the value associated with a key that is already contained in the map is not</span></span><br><span class="line"><span class="comment"> * a structural modification.  &lt;strong&gt;In access-ordered linked hash maps,</span></span><br><span class="line"><span class="comment"> * merely querying the map with &#123;<span class="doctag">@code</span> get&#125; is a structural modification.</span></span><br><span class="line"><span class="comment"> * &lt;/strong&gt;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	添加，删除一个或者多个元素都会修改结构，并且在这些情况中都会影响LinkdHashMap的迭代顺序。如果只是修改一个存在的key-value的映射关系的话并不会修改结构。在LinkedHashMap中，仅仅使用get是一种结构修改。</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The iterators returned by the &#123;<span class="doctag">@code</span> iterator&#125; method of the collections</span></span><br><span class="line"><span class="comment"> * returned by all of this class's collection view methods are</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after</span></span><br><span class="line"><span class="comment"> * the iterator is created, in any way except through the iterator's own</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove&#125; method, the iterator will throw a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span></span><br><span class="line"><span class="comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span></span><br><span class="line"><span class="comment"> * arbitrary, non-deterministic behavior at an undetermined time in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	由该类的所有集合视图中返回的iterator都会有fail-fast：如果map创建之后，结构被除了iterator的remove外的方法修改，这个iterator将会抛出ConcurrentModificationException。因此，当面对并发修改的时候，iterator会快速失败并清空，而不会在未来不确定的时间内进行不确定的有风险的行为。</span></span><br><span class="line"><span class="comment"> 	下面的不翻译了</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The spliterators returned by the spliterator method of the collections</span></span><br><span class="line"><span class="comment"> * returned by all of this class's collection view methods are</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally report &#123;<span class="doctag">@link</span> Spliterator#ORDERED&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href="&#123;<span class="doctag">@docRoot</span>&#125;/java.base/java/util/package-summary.html#CollectionsFramework"&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment"> * The spliterators returned by the spliterator method of the collections</span></span><br><span class="line"><span class="comment"> * returned by all of this class's collection view methods are created from</span></span><br><span class="line"><span class="comment"> * the iterators of the corresponding collections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     HashMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     TreeMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Hashtable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Implementation note.  A previous version of this class was</span></span><br><span class="line"><span class="comment">     * internally structured a little differently. Because superclass</span></span><br><span class="line"><span class="comment">     * HashMap now uses trees for some of its nodes, class</span></span><br><span class="line"><span class="comment">     * LinkedHashMap.Entry is now treated as intermediary node class</span></span><br><span class="line"><span class="comment">     * that can also be converted to tree form. The name of this</span></span><br><span class="line"><span class="comment">     * class, LinkedHashMap.Entry, is confusing in several ways in its</span></span><br><span class="line"><span class="comment">     * current context, but cannot be changed.  Otherwise, even though</span></span><br><span class="line"><span class="comment">     * it is not exported outside this package, some existing source</span></span><br><span class="line"><span class="comment">     * code is known to have relied on a symbol resolution corner case</span></span><br><span class="line"><span class="comment">     * rule in calls to removeEldestEntry that suppressed compilation</span></span><br><span class="line"><span class="comment">     * errors due to ambiguous usages. So, we keep the name to</span></span><br><span class="line"><span class="comment">     * preserve unmodified compilability.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The changes in node classes also require using two fields</span></span><br><span class="line"><span class="comment">     * (head, tail) rather than a pointer to a header node to maintain</span></span><br><span class="line"><span class="comment">     * the doubly-linked before/after list. This class also</span></span><br><span class="line"><span class="comment">     * previously used a different style of callback methods upon</span></span><br><span class="line"><span class="comment">     * access, insertion, and removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//继承自HashMap的node，区别就是多了个前驱节点和后继节点，也就是从单链表变成了双向链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//双向链表的头结点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//为节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The iteration ordering method for this linked hash map: &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * for access-order, &#123;<span class="doctag">@code</span> false&#125; for insertion-order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//true为访问排序，false为插入排序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal utilities</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// link at the end of list</span></span><br><span class="line">    <span class="comment">//将entry放入到链表最后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply src's links to dst</span></span><br><span class="line">    <span class="comment">//两个链表合并为一个</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = dst;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overrides of HashMap hook methods</span></span><br><span class="line">		<span class="comment">//重新初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.reinitialize();</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的node，并且放入链表最后</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将next放到p的后面</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap.Entry&lt;&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//treenode entry 在这里其实一样</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//同上</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//下面三个方法，在HashMap中只是一个钩子，实现在LinkedHashMap，元素删除后的回调方法，删除e节点的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//插入元素后的回调，evict为true的话，会删除链表最老的元素，但是，这个removeEldestEntry方法，里面永久返回的是false，因此，如果想删除老的元素的话，需要重写这个方法。删除老的元素，有两种策略，按照访问，按照插入，上面又说。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            K key = first.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//元素访问后的回调，如果在构造方法中设置了按照访问排序的话，那么这里会执行。其实也就是将当前元素e，将其在链表中的位置后移一下而已</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">            s.writeObject(e.key);</span><br><span class="line">            s.writeObject(e.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance</span></span><br><span class="line"><span class="comment">     * with the specified initial capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//构造方法，默认accessOrder为false，也就是插入排序，下面都一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance</span></span><br><span class="line"><span class="comment">     * with the specified initial capacity and a default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance</span></span><br><span class="line"><span class="comment">     * with the default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance with</span></span><br><span class="line"><span class="comment">     * the same mappings as the specified map.  The &#123;<span class="doctag">@code</span> LinkedHashMap&#125;</span></span><br><span class="line"><span class="comment">     * instance is created with a default load factor (0.75) and an initial</span></span><br><span class="line"><span class="comment">     * capacity sufficient to hold the mappings in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance with the</span></span><br><span class="line"><span class="comment">     * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  accessOrder     the ordering mode - &#123;<span class="doctag">@code</span> true&#125; for</span></span><br><span class="line"><span class="comment">     *         access-order, &#123;<span class="doctag">@code</span> false&#125; for insertion-order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     * specified value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//从此看出，LinkedHashMap的containsValue速度并不会很快，数据量大的话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">            V v = e.value;</span><br><span class="line">            <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//和HashMap的区别就是，当accessOrder为true的话，会执行afterNodeAccess的回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//这个没啥写的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> defaultValue;</span><br><span class="line">       <span class="keyword">if</span> (accessOrder)</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">       <span class="keyword">return</span> e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this map should remove its eldest entry.</span></span><br><span class="line"><span class="comment">     * This method is invoked by &#123;<span class="doctag">@code</span> put&#125; and &#123;<span class="doctag">@code</span> putAll&#125; after</span></span><br><span class="line"><span class="comment">     * inserting a new entry into the map.  It provides the implementor</span></span><br><span class="line"><span class="comment">     * with the opportunity to remove the eldest entry each time a new one</span></span><br><span class="line"><span class="comment">     * is added.  This is useful if the map represents a cache: it allows</span></span><br><span class="line"><span class="comment">     * the map to reduce memory consumption by deleting stale entries.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Sample use: this override will allow the map to grow up to 100</span></span><br><span class="line"><span class="comment">     * entries and then delete the eldest entry each time a new entry is</span></span><br><span class="line"><span class="comment">     * added, maintaining a steady state of 100 entries.</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *     private static final int MAX_ENTRIES = 100;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span></span><br><span class="line"><span class="comment">     *        return size() &amp;gt; MAX_ENTRIES;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method typically does not modify the map in any way,</span></span><br><span class="line"><span class="comment">     * instead allowing the map to modify itself as directed by its</span></span><br><span class="line"><span class="comment">     * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify</span></span><br><span class="line"><span class="comment">     * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> false&#125; (indicating that the map should not attempt any</span></span><br><span class="line"><span class="comment">     * further modification).  The effects of returning &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * after modifying the map from within this method are unspecified.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation merely returns &#123;<span class="doctag">@code</span> false&#125; (so that this</span></span><br><span class="line"><span class="comment">     * map acts like a normal map - the eldest element is never removed).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>    eldest The least recently inserted entry in the map, or if</span></span><br><span class="line"><span class="comment">     *           this is an access-ordered map, the least recently accessed</span></span><br><span class="line"><span class="comment">     *           entry.  This is the entry that will be removed it this</span></span><br><span class="line"><span class="comment">     *           method returns &#123;<span class="doctag">@code</span> true&#125;.  If the map was empty prior</span></span><br><span class="line"><span class="comment">     *           to the &#123;<span class="doctag">@code</span> put&#125; or &#123;<span class="doctag">@code</span> putAll&#125; invocation resulting</span></span><br><span class="line"><span class="comment">     *           in this invocation, this will be the entry that was just</span></span><br><span class="line"><span class="comment">     *           inserted; in other words, if the map contains a single</span></span><br><span class="line"><span class="comment">     *           entry, the eldest entry is also the newest.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>   &#123;<span class="doctag">@code</span> true&#125; if the eldest entry should be removed</span></span><br><span class="line"><span class="comment">     *           from the map; &#123;<span class="doctag">@code</span> false&#125; if it should be retained.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//注释比较简单，不翻译了，就是想删除比较老的元素，就重写它，put和putAll的时候回调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &#123;<span class="doctag">@code</span> remove&#125; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Iterator.remove&#125;, &#123;<span class="doctag">@code</span> Set.remove&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> removeAll&#125;, &#123;<span class="doctag">@code</span> retainAll&#125;, and &#123;<span class="doctag">@code</span> clear&#125;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &#123;<span class="doctag">@code</span> add&#125; or &#123;<span class="doctag">@code</span> addAll&#125;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     * Its &#123;<span class="doctag">@link</span> Spliterator&#125; typically provides faster sequential</span></span><br><span class="line"><span class="comment">     * performance but much poorer parallel performance than that of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> HashMap&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the keys contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//获取map中所有key的驶入，支持Iterator的操作，不支持add和addAll，顺序执行的性能更快，但是，并发执行不如hashmap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> LinkedKeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                            Spliterator.ORDERED |</span><br><span class="line">                                            Spliterator.DISTINCT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">                action.accept(e.key);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator's own &#123;<span class="doctag">@code</span> remove&#125; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &#123;<span class="doctag">@code</span> Iterator.remove&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Collection.remove&#125;, &#123;<span class="doctag">@code</span> removeAll&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> retainAll&#125; and &#123;<span class="doctag">@code</span> clear&#125; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &#123;<span class="doctag">@code</span> add&#125; or &#123;<span class="doctag">@code</span> addAll&#125; operations.</span></span><br><span class="line"><span class="comment">     * Its &#123;<span class="doctag">@link</span> Spliterator&#125; typically provides faster sequential</span></span><br><span class="line"><span class="comment">     * performance but much poorer parallel performance than that of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> HashMap&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//同上，不翻译了，也没啥可问的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> LinkedValues();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValues</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                            Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">                action.accept(e.value);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &#123;<span class="doctag">@code</span> remove&#125; operation, or through the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> setValue&#125; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &#123;<span class="doctag">@code</span> Iterator.remove&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Set.remove&#125;, &#123;<span class="doctag">@code</span> removeAll&#125;, &#123;<span class="doctag">@code</span> retainAll&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> clear&#125; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> add&#125; or &#123;<span class="doctag">@code</span> addAll&#125; operations.</span></span><br><span class="line"><span class="comment">     * Its &#123;<span class="doctag">@link</span> Spliterator&#125; typically provides faster sequential</span></span><br><span class="line"><span class="comment">     * performance but much poorer parallel performance than that of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> HashMap&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> LinkedEntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                Object key = e.getKey();</span><br><span class="line">                Object value = e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                            Spliterator.ORDERED |</span><br><span class="line">                                            Spliterator.DISTINCT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">                action.accept(e);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map overrides</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.key, e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            e.value = function.apply(e.key, e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">        <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">        LinkedHashIterator() &#123;</span><br><span class="line">            next = head;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            current = e;</span><br><span class="line">            next = e.after;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            removeNode(p.hash, p.key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeyIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().getKey(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较简单啊，除了双向链表和访问排序以外，好像没什么可以问的。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码</title>
    <url>/2019/07/17/Source%20code%20reading/JDK/Collection/HashSet/</url>
    <content><![CDATA[<p>Set和List的区别就是，List是有序的，可重复的，而Set是无序的，不可重复的，但是为什呢，从来没有看过，这次来看下源码，看源码中是怎么来实现的</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &#123;<span class="doctag">@code</span> HashMap&#125; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真简单。。。本来还想得说不定也得和HashMap一样写那么多，弄了半天就这么一句话就解释了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment">     * More formally, adds the specified element &#123;<span class="doctag">@code</span> e&#125; to this set if</span></span><br><span class="line"><span class="comment">     * this set contains no element &#123;<span class="doctag">@code</span> e2&#125; such that</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Objects.equals(e, e2)&#125;.</span></span><br><span class="line"><span class="comment">     * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment">     * unchanged and returns &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment">     * element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用的是HashMap，key实际上就是set里存的值，value就是一个object。而键值对是一一对应的，也就解释了为什么Set的值是不可重复的。</p>
<p>而由于说Set继承于Collection，而Collection接口又继承了Iterator接口，所以说，Set也是支持迭代器操作的，也就支持Foreach操作。</p>
<p>至于说为什么无序，因为HashMap的key并不能保证有序。hashmap按照散列值进行存储，读取的顺序还真不一定是插入的顺序。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2019/07/14/Data%20Struct/RBT/</url>
    <content><![CDATA[<p>红黑树操作图示<img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/RBT/02.png" alt="红黑树操作图示">：</p><p>红黑树插入操作详细图示：</p><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/RBT/01.png" alt="插入操作"></p><p>红黑树删除操作图示</p><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/RBT/03.png" alt="删除操作"></p>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码问题解读</title>
    <url>/2019/06/30/Source%20code%20reading/JDK/Collection/HashMap_Question/</url>
    <content><![CDATA[<blockquote>
<p>HashMap相关问题放这里，带着问题看，自己的思路解答也会放这里</p>
</blockquote>
<a id="more"></a>
<p>问题记录：</p>
<ol>
<li><p>DEFAULT_INITIAL_CAPACITY为啥默认是16，为什么必须是2的倍数？</p>
<p>解答：</p>
<p>16可能是一个折中的选项，来避免说设置太小，稍微放一点数据，就进行扩容了，产生不必要的空间浪费。至于说2的倍数，因为底层计算的时候，都是通过cpu移位来进行计算，而2的倍数的话，只需要进行左移一位即可，不然的话，如果是什么加减乘除取模，全部都是cpu进行的加法运算，浪费效率。</p>
</li>
<li><p>最大容量能否进行更改？达到最大容量的时候会浪费多少的容量？</p>
<p>解答：</p>
<p>不能通过构造方法更改，如果手动将其更改为比1&lt;&lt;30（1&lt;&lt;31的话，会超出整型的最大值，也就是Integer.MAX_VALUE）更大的数字的话，tableSizeFor()这个方法会重新将值设置为16。如果经过resize()方法扩容了很多次，那么，它的最大容量，实际上汇编成为Integer.MAX_VALUE。如果达到了最大容量，由于说hashmap的阈值范围是threshold * loadFactor，所以首先说，会有1/4的容量，是完全被浪费掉了的。</p>
</li>
<li><p>默认加载因子是0.75，如果是其他的值会有什么影响？为什么是0.75？</p>
<p>解答：</p>
<p>threshold = capacity * 0.75，初始默认情况下，这个值为12，也就是说，刚开始map的capacity是16，threshold为12，而当容量达到12的时候就会进行扩容。如果loadFactor为0.5的话，那么容量到了8的时候就会扩容，如果等于1的话，那map里的用完之后才会进行扩容。</p>
<p>由API注释可知，桶的分布满足于泊松分布，参数在在默认阈值0.75的条件下，平均数为0.5，会产生比较良好的分布。再问泊松分布的话，就不会了。。。。MLGJ</p>
</li>
<li><p>树化的阈值为什么是8？树退化为链表的阈值为什么是6？达到阈值6和8的时候分别会产生什么效果？</p>
<p>解答：</p>
<p>因为hashmap是数组+链表，达到阈值后，会变成数组+红黑树。链表的复杂度为O(n)，红黑树的复杂度为O(logn)。假设长度为8的话，那么，红黑树的复杂度就是O(log8) = 3，链表的复杂度是O(8)，红黑树&gt;链表。假设长度为6的话，那么，红黑树的复杂度就是O(log6) = 2.585，链表的复杂度是O(6)，但是红黑树对应的需要有平衡的操作，相对来说，这些操作没有链表来的复杂性小点，没有必要使用红黑树。所以说，树化阈值为8的时候，是最合适的一个值。</p>
</li>
<li><p>最小树化容量不是64么，为什么源码注释里写的是4*8=32？如果是32会怎么样？</p>
<p>解答：</p>
<p>不知道</p>
</li>
<li><p>hashcode的集合仅仅在当前掩码变化的时候将会一直碰撞冲突？如果不异或呢。会怎么个冲突法？这个需要自己实现来验证。</p>
</li>
<li><p>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，为什么要这么做？hashcode为何要与code无符号右移16位后的数字做异或？</p>
<p>解答：</p>
<p>先不关注hashCode的实现方式，这个东西，后面再说吧。先看看为什么要这么做，好处在哪。</p>
<p>hashcode右移16位，然后进行和原值进行异或。然后，由于是整型(int)，int的取值范围为0x00000000-0xFFFFFFFF，也就是说，是32位的二进制数据，如果这时候hashcode进行右移16位，那就是说，hashCode的高16位和低16位进行异或。至于为什么这么做，hashCode的值，用到高16位的情况，太少了，可能是为了减少hash碰撞吧，因为如果hashcode值比较小的话，那么产生相同的hashcode的可能性相对来说是比较高的一个情况，所以用高位和低位来异或，加快速度，减少hash碰撞。</p>
</li>
<li><p>tableSizeFor方法的作用是什么，为什么要这么写？</p>
<p>解答：</p>
<p>Returns a power of two size for the given target capacity。</p>
<p>意思为：返回给定目标容量的2次方幂的数字。实际上，是返回一个比指定整数大，且是接近2次方幂的一个整数。</p>
<p>因为移位的速度是最快的，能够以很高的效率来获取。看到是看明白了，这个是怎么推出来的？百思不得其解啊。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//capacity默认值为16，以默认情况来看</span></span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认情况，i==2^4-1;</span></span><br><span class="line">  <span class="comment">// HD, Count leading 0's    HD是啥意思？应该是计算前导数的0有多少了吧</span></span><br><span class="line">  <span class="comment">//由此可见，i的最小值为0。</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">31</span>;</span><br><span class="line">  <span class="comment">//i &gt;= 2^16</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">  <span class="comment">//i &gt;= 2^8</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">  <span class="comment">//i &gt;= 2^4</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">  <span class="comment">//i &gt;= 2^2</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况（initial_capacity = 16）会进入下面的判断(i == 2^4 - 1)，此时，n=29，而i无符号右移两位之后，会从15(1111)-&gt;3(0011)，在return语句中，i再次进行无符号右移，变为(0001)，这时，n-i的值就为28。然后再看tableSizeFor，使用-1无符号右移28位。而-1的二进制表示为11111111111111111111111111111111(因为负数的二进制表示为：1的二进制表示，取反码，然后补码)，移位之后结果就变成了00000000000000000000000000001111，如果没有大于MAXIMUM_CAPACITY，则+1，变为了16，2^4</li>
<li>换种情况，68983，当它进入numberOfLeadingZeros的时候，便成为68982。首先会进入i &gt;= 1&lt;<16，此时n-=16=15。i>&gt;&gt;16之后，会变为(0001)，下面三个判断都进不去，这时候return语句再次右移，就成0了，然后，n=15-0=15，最后，-1无符号右移15位，过程不进行叙述，最后结果为2^17，而68983是大于2^16的。</16，此时n-=16=15。i></li>
</ul>
</li>
<li><p>初始容量和负载因子如果在构造方法中改变的话，会有什么影响？</p>
<ul>
<li>和上面的tableSizeFor方法相关，上面已经说了一部分了，如果修改了initial_capacity的话，会将这个值赋值给threshold，因为hashmap的扩容方法是触发threshold才会进行，也就是达到了capacity<em>loadFactor。如果赋值的是20，根据tableSizeFor方法，容量会变成为2^5(32)，当容量到了32之后，才会进行扩容，而不是说32\</em>0.75之后才扩容。</li>
<li>如果loadFactor修改为1，那么，首先来说，当所有容量用完了，才会进行扩容；如果修改的太小了，那么数据刚扩容相对来说就会非常快（假设为0.1，到了十分之一就扩容和到了四分之三扩容，这个不言而喻）；还有个问题，hashmap是基于hash分布，如果说loadFactor设置太高的话，那么所有bucket都会被利用，不利于良好的hash分布，hash冲突就会增大，hashmap查询性能就会降低，如果太小，bucket空间又浪费太多。0.75是比较合适的一个值。结合上面的一起。</li>
</ul>
</li>
<li><p>Float.isNaN = return v != v ，为什么这么写？</p>
<p>isNaN接收的参数是一个float，而该方法判断这个值是否是一个数字，NaN(Not a Number)，而查看float的源码，里面有个常量，float NaN = 0.0f/0.0f。而hashmap源码里，会先进行判断，loadFactor&lt;=0，如果这里满足的话，因该是不会进行后面的操作的，可能是因为hashmap不是线程安全的，虽然刚开始loadFactor是正确的值，然后被其他线程修改之后，就变成了0.0f/0.0f，就会变成一个not a number的数。</p>
</li>
<li><p>tab[(n - 1) &amp; hash]，这个操作是什么意思？</p>
<p>是用来定位数组位置的，上面说了这个hash值是自身的hashcode的高16位与低16位进行异或产生的结果，而n-1是当前hashmap的长度，通过(length-1) &amp; hash的话，就能够得到所需要查找的下标，然后就可以通过index来获取到需要get或者说需要put的数据。</p>
<p>hash算法最主要的就是说让元素均匀分布，而很多hash算法都是使用的取模运算，但是hashmap用的是(n-1) &amp; hash，首先，&amp;的运算速度是大于%的，然后length是2的倍数，x%length == (length-1) &amp; x，求x。</p>
<ul>
<li>假设length=8,x=5，(8-1) &amp; 5 == 0111 &amp; 0101 ==5，结果正确</li>
<li>假设length=4,x=21，(4-1) &amp; 21 == 0011 &amp; 10101 == 1，结果正确</li>
<li>假设length=3,x=20，(3-1) &amp; 20 == 1000 &amp; 10100 == 0，结果错误</li>
</ul>
<p>由此可知，x%length == (length-1) &amp; x这个公式是正确的，然后看下这个公式怎么推出来。</p>
<p>一个十进制数用二进制方法表示：$X<em>nX</em>{n-1}X<em>{n-2}…X_1X_0$ == $X_n*2^n + X</em>{n-1}<em>2^{n-1} + X_{n-2}</em>2^{n-2} … +X_1<em>2^1 + X_0</em>2^0 $</p>
<p>由于分配率的规定，由上面的公式可知，length为2的倍数，$X/2^k$的余数就为取模的值，那就看怎么取这个余数：$X/2^k ==  X<em>n*2^n/2^k + X</em>{n-1}<em>2^{n-1}/2^k + X_{n-2}/2^k</em>2^{n-2}/2^k … +X_1<em>2^1/2^k + X_0</em>2^0/2^k  $</p>
<ul>
<li>如果k&gt;n的话，余数就是整个十进制数</li>
<li>如果0&lt;=k&lt;=n，因为比k大的，都能被k整除，所以说，余数就为$X<em>k*2^k + X</em>{k-1} <em> 2^{k-1} + … X_k </em> 2^1 + X_k * 2^0 $</li>
<li>特么的，这个公式《数据结构与算法》这本书上有</li>
</ul>
<p>一个十进制数对$2^n$的数进行取余，就是说，十进制数转换为二进制数后，向右进行移位，移掉的这n位数，就为余数，比如说，10 % 8  ==  2。1000 向右移位2位的话是 0010 == 2，结果正确。然后是怎么获取这个n位数：$2^0…2^n$ 用二进制表示为0001,0010,0100,1000…如果我们将$2^n-1$的话，就会变成为0000，0001，0011，0111，1111…然后用十进制数和该数字进行&amp;操作，得到的数字，就是需要移位的数字。</p>
<p>嗯。就是这些。</p>
</li>
<li><p>resize()这个方法初次执行的时候大小是多少？后续执行的时候，大小会如何变化？</p>
<p>resize初次执行的时候大小为默认值1 &lt;&lt; 4，后续执行的时候，大小会翻倍。</p>
</li>
<li><p>hashmap扩容的话，会怎么进行变化？</p>
<p>扩容的话，桶里的链表或者红黑树没什么变化，但是说，数组里的元素的位置会发生改变，会重新计算元素在数组中的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码</title>
    <url>/2019/05/10/Source%20code%20reading/JDK/Collection/HashMap/</url>
    <content><![CDATA[<blockquote>
<p>阅读源码之前还是应该阅读注释</p>
</blockquote><p>API文档：</p><p>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><a id="more"></a>


<p>HashTable是Map的基础实现，这个实现支持map的所有操作，而且允许null的value和key（HashMap除了它支持null且线程不安全外和Hashtable差不多），HashMap不保证map里的有序性，在一些情况，它不保证一段时间内的有序性。</p>
<p>This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.</p>
<p>HashMap的get和put拥有常数时间的性能，假定hash函数将元素均匀分散于桶(bucket)之间，迭代集合需要有和HashMap实例的capacity(容量，桶的容量)+map的大小（key-&gt;value映射的数量）成比例的时间。因此，如果性能是非常重要的话，将初始容量(initial capacity)设置的不要太高是非常重要的一件事，</p>
<p>An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p>
<p>HashMap的示例有两个参数影响它的性能：初始容量和加载因子（initial capacity and load factor），这个容量是hash table里桶（bucket）的数量。然后这个初始容量（initial capacity）仅仅是在hash table创建的时候的容量。这个加载因子(load factor)是hash table在它的容量自动增加之前测量增加量的一个关键参数。当hash table中的entry的数量超过(load factor * current capacity)的时候，hash table 会进行重新hash(意思是，内部的数据结构会重新构建)，构建之后这个hash table 的桶的数量差不多有之前桶的数量的两倍</p>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
<p>在一般的条件下，默认的加载因子在时间和空间消耗之间做了很好的权衡。负载因子的值变高了之后会减少空间的消耗，但是会增加查找的开销(表现在HashMap中的大部分操作，包括get和set)。map里entries的数量和加载因子在初始容量被设置的时候就应该被考虑到。所以减少rehash的次数。如果初始化容量大于entries的数量除以负载因子，那么不会发生rehash操作。</p>
<p>If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. </p>
<p>如果很多映射被存储于HashMap实例。那么创建一个有足够大的容量的实例将会比让它自动去执行rehash来扩大表来进行映射存储来的的更高效（efficientily 有效，有效率，效率高）。</p>
<p>Note that using many keys with the same hashCode() is a sure way to slow down performance of any hash table. </p>
<p>注意：任何HashTable如果很多key有了相同的hashCode的话将会降低其性能。</p>
<p>To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties.</p>
<p>如果改善其影响的话，当key是可比较的时候，这个类也许可以使用key之间的比较关系来帮助打破关系</p>
<p>Note that this implementation is not synchronized. If multiple threads access a hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) </p>
<p>注意：这个实现是线程不安全的，如果很多线程同时访问一个hash map的话，并且至少有一个线程修改了该map 的结构，那么它在外部必须是线程安全的操作。(结构改变是指任何添加或删除一个或者多个映射的操作。仅仅修改一个实例里key相关的value的话，已经包含的并不是结构修改)</p>
<p>This is typically accomplished by synchronizing on some object that naturally encapsulates the map.</p>
<p>这通常由一些对象的同步操作来完成自然封装的的map。</p>
<p> If no such object exists, the map should be “wrapped” using the Collections.synchronizedMap method. </p>
<p>如果没有任何对象存在，这个map应该使用Collections.synchronizedMap来进行包装。</p>
<p>This is best done at creation time, to prevent accidental unsynchronized access to the map:</p>
<p>​     Map m = Collections.synchronizedMap(new HashMap(…));</p>
<p>最好是在创建的时候完成这个操作，以防止意外线程不安全的访问该map</p>
<p>The iterators returned by all of this class’s “collection view methods” are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove method, the iterator will throw a ConcurrentModificationException. </p>
<p>这个迭代器范回的是collection的映射元素，会抛出fail-fast异常。如果这个map结构被修改于任何时间在迭代器被创建之后，用任何方式除了迭代器自己的remove方法，这个迭代器都会抛出 快速失败异常</p>
<p>Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</p>
<p>因此。面对并发修改的时候，迭代器会快速而清晰的失败，而不是顶着是任意的风向和不确定的的行为在未知的时间</p>
<p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. </p>
<p>注意：迭代器的fail-fast行为不能像这样得到保障，一般来说，不可能硬性保证其一定出现在线程不安全的并发修改下</p>
<p>Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.</p>
<p>迭代器的Fail-fast尽最大努力在抛出ConcurrentModificationException，因此，为了正确性，需要编写一个程序，依赖于这个异常，来检验其错误。迭代器的fail-fast行为应该仅仅用于发现bug</p>
<p>This class is a member of the Java Collections Framework.</p>
<p>HashMap是Java集合框架下的成员。</p>
<p>————————————————————————————————————————————————————</p>
<p>分割线</p>
<p>Implementation notes.</p>
<p>This map usually acts as a binned (bucketed) hash table, but when bins get too large, they are transformed into bins of<br>TreeNodes, each structured similarly to those in java.util.TreeMap. </p>
<p>这个map通常为用桶（bucketed）实现的hash table，但是当桶的数量太大的时候，它们会转换成TreeNode，每个数据结构都与TreeMap类似。</p>
<p>Most methods try to use normal bins, but relay to TreeNode methods when applicable (simply by checking<br>instanceof a node).  Bins of TreeNodes may be traversed and used like any others, but additionally support faster lookup when overpopulated. </p>
<p>大多数方法都尽量使用普通的桶，但是当可以的时候（仅仅检查bin是否能够 instaneof node），就会转变成为TreeNode。桶或TreeNodes应该可以遍历而且用起来和其他的一致，但是进一步的支持快速的循环当数据过多的时候。</p>
<p>However, since the vast majority of bins in normal use are not overpopulated, checking for existence of<br>tree bins may be delayed in the course of table methods.</p>
<p>然后，通常桶的大多数使用都是在数据不多的时候。在使用table的方法的时候可能延迟检查桶是否存在</p>
<p>Tree bins (i.e., bins whose elements are all TreeNodes) are ordered primarily by hashCode, but in the case of ties, if two<br>elements are of the same “class C implements Comparable<c>“, type then their compareTo method is used for ordering. (We conservatively check generic types via reflection to validate this — see method comparableClassFor).  </c></p>
<p>树桶(桶里所有的元素都是TreeNodes)主要是根据hashCode排序的，但是在关联的情况下，如果两个元素是同样的类，都实现了Comparable接口，然后他们进行排序(我们保守检查类的类型通过反射来验证—see method comparableClassF-or)。</p>
<p>The added complexity of tree bins is worthwhile in providing worst-case O(log n) operations when keys either have distinct hashes or are orderable, Thus, performance degrades gracefully under accidental or malicious usages in which hashCode() methods return values that are poorly distributed, as well as those in which many keys share a hashCode, so long as they are also Comparable. (If neither of these apply, we may waste about a factor of two in time and space compared to taking no precautions. But the only known cases stem from poor user programming practices that are already so slow that this makes little difference.)</p>
<p>当key有不同的hashCode或者说是已排序的话，树桶（翻译很别扭，有时间看看别人怎么翻译的）的添加操作的最坏时间复杂度是O(log n)。然后，在hashCode()的意外或异常执行，产生不均匀的分布的话，性能将会平缓降级，除此之外，许多key共享一个hashCode，只要是可比较的。(如果两种情况都无法匹配的话，我们将会浪费factor两倍的时间和空间性能相对于不采取预防措施。但是这种仅知的情况来源于糟糕的用户代码实践，它们已经非常缓慢了，所以基本没有什么去呗)</p>
<p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). </p>
<p>因为TreeNodes的大小事普通节点的两倍，我们仅仅在桶里包含足够的节点的时候去保证使用它(参见 树化阈值—TREEIFY_THRESHOLD)</p>
<p>And when they become too small (due to removal or resizing) they are converted back to plain bins.</p>
<p>然后当它是比较小的时候(由于删除或者大小改变)，它将退化为普通箱。</p>
<p>  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a<br>parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of<br>resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The first values are:</p>
<p>0:    0.60653066<br>1:    0.30326533<br>2:    0.07581633<br>3:    0.01263606<br>4:    0.00157952<br>5:    0.00015795<br>6:    0.00001316<br>7:    0.00000094<br>8:    0.00000006<br>more: less than 1 in ten million</p>
<p>在拥有良好分布的hashCode的时候，树桶很少被使用。通常情况，在随机的hashCode情况中，树桶的节点分布遵循于Poisson distribution 分布方式（泊松分布），参数在在默认阈值0.75的条件下，平均数为0.5，尽管因为重新调整粒度有很大的方差变化。预计list的大小k公式是：<script type="math/tex">10^{-0.5} 0.5^k/k!</script></p>
<p>概率小于千万分之一</p>
<p>The root of a tree bin is normally its first node.  However, sometimes (currently only upon Iterator.remove), the root might be elsewhere, but can be recovered following parent links (method TreeNode.root()).</p>
<p>树桶的root节点通常都是它的第一个节点。然而，有些时候(当前已知的情况就是Interator的remove)，root可能会不是第一个节点，但是可以被父链接节点所恢复(TreeNode.root())</p>
<p>All applicable internal methods accept a hash code as an argument (as normally supplied from a public method), allowing them to call each other without recomputing user hashCodes. Most internal methods also accept a “tab” argument, that is normally the current table, but may be a new or old one when resizing or converting.</p>
<p>所有可使用的内部方法接受hash code作为参数(还有被支持的公开方法)，允许他们互相调用，且不进行重新计算hashCode。大多数内部方法通常接受tab这个参数，通常代表当前table，但是也可能是新的或者旧的当大小改变或者被覆盖的时候。</p>
<p>When bin lists are treeified, split, or untreeified, we keep them in the same relative access/traversal order (i.e., field<br>Node.next) to better preserve locality, and to slightly simplify handling of splits and traversals that invoke iterator.remove. When using comparators on insertion, to keep a total ordering (or as close as is required here) across<br>rebalancings, we compare classes and identityHashCodes as tie-breakers.</p>
<p>当桶的列表为树，分隔，或者非树的时候，我们保证他们在相同的访问/遍历顺序时能更好的保留位置。并且简单的处理split和遍历在调用iterator.remove的时候。当在插入的时候使用比较器，来在重新平衡的过程中保证总体是有序的(或者按要求关闭？)，我们使用类和hashcode作为连接断开器。</p>
<p>The use and transitions among plain vs tree modes is complicated by the existence of subclass LinkedHashMap. See<br>below for hook methods defined to be invoked upon insertion,removal and access that allow LinkedHashMap internals to otherwise remain independent of these mechanics. (This also requires that a map instance be passed to some utility methods that may create new nodes.)</p>
<p>由于存在子类LinkedHashMap，普通模式和树模式之间的使用和转变会变得复杂。参考钩子方法定义在了调用插入，删除和访问的时候，来允许LinkedHashMap使用其他方式来保证独立性(也同样需要这一个映射实例来传递一些有用的可能创建新节点的方法)。</p>
<p>The concurrent-programming-like SSA-based coding style helps avoid aliasing errors amid all of the twisty pointer operations.</p>
<p>这个并行编码方式用于SSA的编码风格的话有助于避免混乱错误在一些指针操作上面。</p>
<p>————————————————————————————————————————————————————</p>
<p>分割线。最长的注释就在上面，现在开始代码的阅读，产生的问题，会收集在另一篇文章里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//默认初始化大小必须为1左移4位，也就是2^4，也就是16，必须是2的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//最大容量，如果需要更大的容量，需要在构造方法中通过参数定义，必须是2的倍数，并且&lt;= 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//当构造方法不进行指定的时候，默认加载因子为0.75f</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用树而不是使用桶的数量的阈值。当在有很多元素的桶里最后添加一个元素的时候，桶会转换为树。这个值必须大于2而且应该最少有8个，以符合树移除元素后压缩转换为普通箱的假定</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//再重新设定大小操作的时候，何时进行树的分割退化操作的阈值。应该小于TREEIFY_THRESHOLD，然后最多6个匹配的在删除操作之后的收缩检测</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//每个可能被树化的桶的最小的链表的容量（或者说桶里的表的重新分配大小并且有太多节点的时候）</span></span><br><span class="line"><span class="comment">//应该至少有32的空间阈值来避免在重新分配大小和树化的时候产生的hash冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//基本hash桶节点，被大多数实体使用。看下面的TreeNode子类和LinkedHashMap都是Entry的子类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    V oldValue = value;</span><br><span class="line">    value = newValue;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">      Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">      <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">          Objects.equals(value, e.getValue()))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">   * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">   * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">   * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">   * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">   * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">   * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">   * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">   * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">   * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">   * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">   * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">   * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">   * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//又是一大段注释，真不想翻译这些，不想翻译吧，有些代码又看不懂，妈的还是自己太菜了。专八在乎这？</span></span><br><span class="line">  <span class="comment">//计算key的hashcode，然后高位和低位进行异或。因为链表使用了两倍的掩码，hashcode的集合仅仅在当前掩码变化的时候将会一直碰撞冲突。(已知的例子,一组浮点数会在小点的表里保持连续整数。)所以我们使用异或来将高位的冲撞向下传播。这是比特扩展在速度，功能和质量之间的折中。因为许多内容hash的集合是已经合理分布了的（所以不会从扩散中受益），而且因为我们使用树来处理桶中的大量元素，我们用一个比较便宜的方法来降低系统性能损耗，就是使用异或来转换一些bit。除此之外，包含最高位的bit位，因为表边界的原因，将不会使用计算过的下标，来归并高位的碰撞。</span></span><br><span class="line">  <span class="comment">//也不知道翻译对不对，哪里来个大佬带带我~~~</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//卧槽嘞，这个就更尼玛看不懂了啊，注释倒是很简单，返回两倍目标容量的大小，最大值是MAXIMUM_CAPACITY，最小值是1，这个numberOfLeadingZeros留岛问题里解答吧</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">   * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">   * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">   * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">//这个table在第一次使用的时候初始化，然后大小一定会改变。当进行分配空间的时候，大小通常都会是2的倍数(我们也会允许启动执行的机器上当前非必须的一些操作，它大小为0)</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">   * for keySet() and values().</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//entrySet的缓存，记录AbstractMap字段里keySet和values方法的使用</span></span><br><span class="line">  <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//key-value映射在map里的大小</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//modCount是HashMap发生变化或者修改了内部结构的时候（rehash），会改变这个数字，这个字段在iterator的集合视图操作的时候会产生 快速失败</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//下一个值当大小改变的时候(容量 * 负载因子)</span></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//hashtable 的负载因子</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//注释没什么翻译的，从这里能看出来，初始化的时候，容量最大为MAXIMUM_CAPACITY，不过话说Float.isNaN这个方法没看懂啊，先记下来，等等再看</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">      initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//也没什么翻译的，就是修改默认初始容量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//更加没什么翻译的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &#123;<span class="doctag">@code</span> HashMap&#125; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &#123;<span class="doctag">@code</span> Map&#125;.  The &#123;<span class="doctag">@code</span> HashMap&#125; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &#123;<span class="doctag">@code</span> Map&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//也没啥翻译的，下面的方法看起来比较重要</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">     * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//实现了Map的putAll方法和构造器，由此可见，map的putAll方法也是用的这个putMapEntries方法，等等到下面的时候验证下</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">        <span class="comment">//size/loadFactor + 1，他为什么要ft命名啊，特么的。先解释一下，因为所hashmap的capacity = threshold * loadFactor  ，所以用 size/loadFactor+1 就能得到threshold</span></span><br><span class="line">        <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">        <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">        <span class="comment">//这里会判断capacity是否大于threshold，大于的话，毫无一人，threshold扩容吧。。。</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">          threshold = tableSizeFor(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//和上面一样，不重复写了</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">      <span class="comment">//capacity和threshold确定之后，通过put方法进行设置</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">        K key = e.getKey();</span><br><span class="line">        V value = e.getValue();</span><br><span class="line">        putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//map的重头方法，get和put，这里到了get了，来翻一下。</span></span><br><span class="line">  <span class="comment">//返回value当key被映射的时候，如果不包含则返回null。通常情况下，map的key可以为null，有则返回value，没有则返回null，这里最多返回一个映射(value)。</span></span><br><span class="line">  <span class="comment">//当这个map不包含这个key的时候，返回null并不是必须的情况，这个key通常有可能就是为null，然后containsKey操作可能在使用的时候返回两种情况。distinguish是啥意思。。。擦泪</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//重头戏就是这个getNode了，下面解释</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//实现了map接口的get方法和relate方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//hashmap是数组加链表的实现方式，所以说，现根据hashcode获取到第一个链表的节点，等于null的话说明没有呗，[(n - 1) &amp; hash]得专门解读一下。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//每次都检测第一个链表节点，为了下面的递归或者说while循环做准备</span></span><br><span class="line">      <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">          ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="comment">//循环链表进行查找，找到到的话，就返回去，不然null呗</span></span><br><span class="line">      <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//链表在达到阈值(8)之后会转换为树节点，这个树是红黑树，树是怎么获取的，下面再写吧。</span></span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">     * specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">     * key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//不解释</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//重头戏之二，put方法。</span></span><br><span class="line">  <span class="comment">//将key和value的关联放到这个map，如果key之前已经有值，将会被替换。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//难怪叫hashmap啊，都是需要根据hash进行操作的，所以，重写hashcode方法是多么的重要，对不对</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//实现了Map的put方法和related方法，related是啥意思，重新延迟？</span></span><br><span class="line">  <span class="comment">//onlyIfAbsent是ture的话，不改变已经存在的value，应该是会被某些包装方法使用</span></span><br><span class="line"> <span class="comment">//evict如果是false，这个table将会是创建模式</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n是用来记录hashmap大小的，tab是内部table，p是当前节点。i是当前hash对应数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//如果这个hashmap初始化后还从未使用过，那么就用resize进行初始化操作</span></span><br><span class="line">      n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//先根据hash看数组是否有值，没有值得话，直接将新节点放进去。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">      tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如若不然，就开始链表(红黑树)的遍历，</span></span><br><span class="line">      Node&lt;K,V&gt; e; K k;</span><br><span class="line">      <span class="comment">//会先看当前链表首个元素的key和即将放入的key是否相等，相等的话，就不进行后面的遍历了。直接对它进行处理。不然的话，需要整体遍历去看hash是否有对应的节点存储。</span></span><br><span class="line">      <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">          ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">      <span class="comment">//当链表的元素的个数大于一定阈值的话，会转换为红黑树，所以，这里看节点是否已经变为了红黑树，如果已经变了，那么久按照红黑树的标准进行元素的插入，putTreeVal，后面看的时候在进行解释。</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非红黑树，那就普通链表遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">          <span class="comment">//因为说第一个元素已经进行过判断，所以直接next就可以。然后到了链表的最后一个位置，将val放到最后</span></span><br><span class="line">          <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//这里会看链表中的值是否已经到了树化的阈值，到了之后，会将链表转换为红黑树。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">              <span class="comment">//treeifyBin放到下边说</span></span><br><span class="line">              treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果key已经存在的话，那就直接break返回去。</span></span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          p = e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//不为null的话，说明key已经存在，那么进行覆盖，新值覆盖，旧值返回。</span></span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        <span class="comment">//onlyIfAbsent猜测是为了某些工具类的方便而使用的，后面验证</span></span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">          e.value = value;</span><br><span class="line">        <span class="comment">//linkedHashMap的回调，到时候再看吧</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//put会触发modCount的变化。</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//size变化，如果超过阈值的话，那么hashmap进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">      resize();</span><br><span class="line">    <span class="comment">//linkedHashMap's callback ，后面说</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//用于初始化或者表空间扩张(双倍)，如果是null的话，分配的空间是initial capactiy * threshold，另外，因为我们使用的是两倍膨胀，table里的每个元素都必须待在同样的下表下，或者两倍位移在新的table中。</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果table不为null</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果容量已经达到了最大的话，那么，不进行扩容，直接return</span></span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果newCapactiy &lt; oldCap/2 &amp;&amp; &lt; max_cap &amp;&amp; &gt;= inital_cap，那么，表进行双倍扩充</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">               oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">//double</span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//threshold不为0的话，那么，capacity = threshold</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">      newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">      <span class="comment">//都没初始化，那就取默认值，capacity == 1 &lt;&lt; 4 == 16，</span></span><br><span class="line">      <span class="comment">//threshold == 0.75f * 16 == 12</span></span><br><span class="line">      <span class="comment">//也就是说，阈值是总容量的3/4，也就是说，hashmap中，有至少四分之一的容量是被浪费了的</span></span><br><span class="line">      newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">      newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有capacity设置了，但是threshold没设置的话，会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//这里其实结果还是12，ft的意思应该是float_threshold</span></span><br><span class="line">      <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">      <span class="comment">//判断是否超出了最大值，然后阈值设置</span></span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// threshold setting</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//设置新的node数组大小</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//然后将table指向新的table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果hashmap没值得话，那就直接return，大小为初始化的值，如果不然，就进行数据迁移</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//循环数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">//如果数组的内容不为null的话，进行处理</span></span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//将oldTab数组对应的值设置为null，方便GC回收</span></span><br><span class="line">          oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//进行链表首个节点的判断</span></span><br><span class="line">          <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是treeNode的话，需要进行红黑树的扩容，至于这个split，后面碰到的话，再进行解释吧。</span></span><br><span class="line">            ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">          <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            <span class="comment">//还是挺反感这种命名方式的。写全点还是来的更直观一点。lo=low,hi=high。</span></span><br><span class="line">            <span class="comment">//low,high头尾节点，将单向链表变为双向链表。</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">//do-while进行链表的遍历操作</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              next = e.next;</span><br><span class="line">              <span class="comment">//这个e.hash &amp; oldCap是什么操作。。。</span></span><br><span class="line">              <span class="comment">//因为前面的hash方法没看，这里往下的东西，就看不懂了。。。</span></span><br><span class="line">              <span class="comment">//把hash方法看完回来了。e.hash是通过hash()方法获取到的值，在put的时候存放进去得，并不是说这个node本身的hashcode，这个还是得注意下。在另一篇文章里说了：hash &amp; (length-1)得到的是该元素对应的数字下标值，至于为什么(length-1)，是因为length是2的倍数，转换为二进制的话就是0010,0100,1000,10000等，所以需要-1变成为0001,0011,0111,1111来方便进行&amp;的操作。但是如果不-1的话，那么就是用最高位的1进行&amp;的操作（oldCap就是tableLength），也就是说，e.hash &amp; oldCap得到的值，如果hash是小于oldCap的话，那么一定是0，也就是说，随着oldCap的变化（2的倍数增长），e.hash &amp; oldCap的值就不一定一直为0了，比如说，14 &amp; 16，为0，17 &amp; 16 为1，但是随着oldCap变化为32的时候，再次到了这里，14 &amp; 31 == 0 ，但是17 &amp; 31 就也等于0了。</span></span><br><span class="line">              <span class="comment">//如果等于0的话，那么该hash是值比较小的，那么用lowTail来存储</span></span><br><span class="line">              <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                  loHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  loTail.next = e;</span><br><span class="line">                loTail = e;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//否则的话，说明hash&gt;=oldCap，值相对来说大一点，所以用highTail来存储</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                  hiHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  hiTail.next = e;</span><br><span class="line">                hiTail = e;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//hash值相对来说小点的node节点，用lowTail链表来存储，而大于oldCap的，用highTail存储，而且由于 hash &amp; oldCap != 0 ，因此，在扩容之后，该节点并不在原先数组的下标中存放。而是进行等量平移</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">              loTail.next = <span class="keyword">null</span>;</span><br><span class="line">              newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">              hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">              newTab[j + oldCap] = hiHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面这一段前移节点的代码，意思理解，但是为啥这么写，为啥用这种写法，还是不太理解。等自己实现一遍hashmap，应该说就能懂了吧。</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//根据得到的hash替换桶里的所有link node，除非表非常小，这种情况的话，用resize操作来代替</span></span><br><span class="line">  <span class="comment">//试一下windows是不是比较卡，好想确实比较卡啊</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果说tab的长度小于最小树化阈值的话，那么只改变大小，否则，进行树化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//首先根据hash获取到当前下边的元素</span></span><br><span class="line">      <span class="comment">//这个hd是Head ...的意思，tl 是tail ..的意思，能不用简写嘛</span></span><br><span class="line">      TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//返回一个tree node ，也就是将链表的节点换为红黑树的节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//然后进行关系的连接，虽然是tree node，但是这里，只是将单向链表转换为了双向链表</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">          hd = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          p.prev = tl;</span><br><span class="line">          tl.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tl = p;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//根据index获取到数组的元素，且设置为头结点，如果不为null的话，那么从头结点开始进行树化</span></span><br><span class="line">      <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//转换为红黑树</span></span><br><span class="line">        hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">      next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">      x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//如果root节点尚未设置的话，那么先指向root节点</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        x.parent = <span class="keyword">null</span>;</span><br><span class="line">        x.red = <span class="keyword">false</span>;</span><br><span class="line">        root = x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//然后根据hash值，进行左右节点的设置，然后进行红黑树的平衡</span></span><br><span class="line">        K k = x.key;</span><br><span class="line">        <span class="keyword">int</span> h = x.hash;</span><br><span class="line">        Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">          <span class="keyword">int</span> dir, ph;</span><br><span class="line">          K pk = p.key;</span><br><span class="line">          <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                   (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">          TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">          <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = xp;</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">              xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              xp.right = x;</span><br><span class="line">            root = balanceInsertion(root, x);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>英语短语</title>
    <url>/2019/04/29/Language/English/Phrase/</url>
    <content><![CDATA[<p>is simply ：不过，仅仅，根本，简直</p><p>take into account：考虑到；把…..计算在内</p><a id="more"></a>

<p>so as to：= in order to 以便；为使</p>
<p>be divided by：除以</p>
<p>ever occur：发生</p>
<p>in the face of：面对</p>
<p>rather than：而不是</p>
<p>generally speaking：一般来说</p>
<p>vast majority：绝大多数</p>
<p><a href="https://fanyi.baidu.com/#en/zh/as well as" target="_blank" rel="noopener">as well as</a>：既…又…; 除…之外; 此外</p>
<p>so long as：只要。“as/so long as”的变体</p>
<p>little difference：相差不大，没什么区别</p>
<p>due to ：由于</p>
<p>rather than：而不；与其…倒不如…</p>
<p>conflicts：冲突</p>
<p><a href="https://fanyi.baidu.com/#en/zh/in accord with" target="_blank" rel="noopener">in accord with</a>：一致; 相符</p>
<p>performed by：由……执行</p>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语短语</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList源码</title>
    <url>/2019/04/27/Source%20code%20reading/JDK/Collection/LinkedList/</url>
    <content><![CDATA[<blockquote>
<p>LinkedList是基于链表，是Java中线性表的链表实现。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>LinkedList实现了Deque接口，而Deque又继承自Queue，说明Linked是支持双/单向队列相关操作。</li>
</ul>
<p>问题：</p>
<ul>
<li>ArrayList继承于AbstractList，而LinkedList继承于AbstractSequentialList，这两个类区别在哪？(<strong>问题1</strong>)</li>
<li>ArrayList实现了RandomAccess接口，这个接口作用是什么？为什么实现？LinkedList为什么没有实现？(<strong>问题2</strong>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">      <span class="keyword">this</span>.item = element;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">      <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>由上可知，Node不仅指向了它的下一个节点，也有其上一个节点的指针。由此说明，LinkedList是双向循环链表，而非单向。</li>
<li>由于有first和last的引用，所以，使用queue相关操作会很方便。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>由于是链表，没有ArrayList的数组扩容和数组移动相关操作。数据多的情况下，add的性能优于ArrayList</li>
<li>指定位置add的话，如果是非最后一个位置添加元素，则需要根据下标先找到原先元素，在其之前进行操作。真是想方设法优化速度。。。</li>
<li>node()并不是完全从头开始遍历获取。而是根据index是否小于size的一半，来决前序遍历还是后序遍历。这里应该还能继续优化一次，用二分的话，一次次缩小区间，这样岂不是更小了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">  <span class="comment">//node方法在上面有</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>get需要循环遍历list的1/2。性能肯定比不上数组（ArrayList）的直接获取。</li>
<li>set方法并没有增加modCount。那么，循环中可以放肆的set….</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>remove方法可以看出，移除的是从头开始遍历里第一个匹配的元素。</li>
<li>indexOf也是如此，不贴代码了</li>
<li>lastIndexOf还是是从尾到头进行遍历，其他一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &#123;<span class="doctag">@code</span> null&#125; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &#123;<span class="doctag">@code</span> null&#125; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the last element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null last node l.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>Deque相关操作，peek,element,poll都是获取头部元素，区别在于：peek()如果没有的话，返回的是null，不进行删除；element如果没有，则是抛出NoSuchElementException，不进行删除；poll则是弹出，会移除头部元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>remove删除的是第一个元素，因为队列是FIFO。删除不掉，则抛出noSuchException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element as the tail (last element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque operations</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerFirst&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerLast&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>于队头或者队尾添加元素，没啥解释的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops an element from the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, removes and returns the first element of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #removeFirst()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the front of this list (which is the top</span></span><br><span class="line"><span class="comment"> *         of the stack represented by this list)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>LinkedList惊现Stack的操作，看了下源码这两个操作是在Deque接口定义的。</li>
</ul>
<p>问题解读：</p>
<ol>
<li>Sequentia意思为：顺序，连续。AbstractSequentialList继承于AbstractList，主要看AbstractSequentiaList实现了什么方法。图就不上了，实现的方法，都是通过Iterator来进行的实现（大量用到了策略模式），而AbstractList中，使用for循环来实现的。<strong>迭代器模式是为了提供方法访问聚合对象的元素，但是不暴露对象的内部表示</strong>。由注释可知<strong>This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a “sequential access” data store (such as a linked list). For random access data (such as an array), AbstractList should be used in preference to this class.</strong>  LinkedList使用该类会有更好的性能，而如果是支持随机访问的数据，比如ArrayList，应该优先使用AbstractList，会有更好的性能。</li>
<li>LinkedList不实现RandomAccess的原因有：使用AbstractSequentialList会有更好的性能。RandomAccess对于支持随机访问的(如ArrayList)有更好的性能。与Collections的indexedBinarySearch可以看到。对于实现了RandomAccess的接口，可以用二分方法进行更好的排序，拥有更好的性能。</li>
<li>总之，实现了RandomAccess 的接口，使用for i 循环会有更好的性能。而没有实现的，链表操作的，使用interator会有更好的性能。</li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读-前言</title>
    <url>/2019/04/26/Source%20code%20reading/Preface/</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><p>以前倒是也看过源码，但是看了就忘，很尴尬，用博客记录一下，加深一下印象。</p><p>源码版本为JDK12。</p><p>先进行集合类相关源码阅读。</p>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>前言</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码</title>
    <url>/2019/04/26/Source%20code%20reading/JDK/Collection/ArrayList/</url>
    <content><![CDATA[<blockquote>
<p> ArrayList是基于数组，是Java中线性表的顺序实现。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default initial capacity.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">   * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">   * first element is added.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">   * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">   * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">   * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>ArrayList的默认初始容量是10</li>
<li>内部数据是由一个Object[]来进行存储的，默认则是一个空数组</li>
</ul>
<p>问题：</p>
<ul>
<li>elementData是声明为transient的。这就意味着，它是不参与序列化的，但是用的时候并没有感觉，先往下看源码，等等找出来这个问题的答案。（<strong>问题1</strong>）</li>
<li>空数组是如何进行扩容？（<strong>问题2</strong>）</li>
<li>Object类型的数组是如何根据<em>泛型</em>来返回自定的数据格式？如果数据元素不一致会有什么情况？（<strong>问题3</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// defend against c.toArray (incorrectly) not returning Object[]</span></span><br><span class="line">        <span class="comment">// (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>为啥有两个Object[]？注释里说的很清楚：We distingush this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added。主要是区别于EMPTY_ELEMENTDATA以方便于知道第一个元素添加进去后数组是如何膨胀的。</li>
<li>如果说传入了一个collection，那么会将其转为Object[]</li>
</ul>
<p>问题：</p>
<ul>
<li>第一个元素添加后数组是如何膨胀的？（<strong>问题5</strong>）</li>
<li>看源码，是可以传入自定义初始大小的，那么自定义初始容量和默认容量如果不同的话，区别在哪里？（<strong>问题6</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum size of array to allocate (unless necessary).</span></span><br><span class="line"><span class="comment"> * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment"> * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment"> * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>list数组最大容量，如果超过了虚拟机允许的范围，那么会抛出<strong>OutOfMemoryError</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError if minCapacity is less than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a capacity at least as large as the given minimum capacity.</span></span><br><span class="line"><span class="comment"> * Returns the current capacity increased by 50% if that suffices.</span></span><br><span class="line"><span class="comment"> * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span></span><br><span class="line"><span class="comment"> * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError if minCapacity is less than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>grow是数组扩容的方法，扩容大小通过newCapacity来保证，其确保其至少能保存minimum capacity容量的元素。默认的扩容会在当前size的基础上加1后进行。</li>
<li>newCapacity保证返回的元素至少与minCapacity相等，每次在允许范围内扩容50%，但是不会大于MAX_ARRAY_SZE，除非给定的值已经大于它了。如果溢出的话，就返回最小值回去。</li>
<li>扩容的公式为 new = old + old &gt;&gt; 1，也就是上述的扩容50%的由来</li>
<li>如果new&lt;Int.max_size - 8的话，就看是否移除，否，直接返回int.max作为数组最大值，从此也能得知，list最大值就是int最大值，而Java中int无符号，也就是21亿。如果溢出，直接OutOfMemory。</li>
</ul>
<p>问题：</p>
<ul>
<li>minimum capacity是怎么定义的？每次是如何变化的？（<strong>问题7</strong>）</li>
<li>是什么时候触发的扩容？（<strong>问题8</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this list contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns &#123;<span class="doctag">@code</span> true&#125; if and only if this list contains</span></span><br><span class="line"><span class="comment"> * at least one element &#123;<span class="doctag">@code</span> e&#125; such that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Objects.equals(o, e)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this list is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Objects.equals(o, get(i))&#125;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOfRange(o, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>contains只能判断是否知道有一个元素在当前list中，多了不行。indexOf同样，只会返回第一个相等的元素的index。</li>
<li>contains需要循环整个list</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the highest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Objects.equals(o, get(i))&#125;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOfRange(o, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfRange</span><span class="params">(Object o, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>和indexOf相反</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns a shallow copy of this &#123;<span class="doctag">@code</span> ArrayList&#125; instance.  (The</span></span><br><span class="line"><span class="comment">  * elements themselves are not copied.)</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a clone of this &#123;<span class="doctag">@code</span> ArrayList&#125; instance</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">         v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">         v.modCount = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">return</span> v;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns an array containing all of the elements in this list</span></span><br><span class="line"><span class="comment">  * in proper sequence (from first to last element).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The returned array will be "safe" in that no references to it are</span></span><br><span class="line"><span class="comment">  * maintained by this list.  (In other words, this method must allocate</span></span><br><span class="line"><span class="comment">  * a new array).  The caller is thus free to modify the returned array.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This method acts as bridge between array-based and collection-based</span></span><br><span class="line"><span class="comment">  * APIs.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> an array containing all of the elements in this list in</span></span><br><span class="line"><span class="comment">  *         proper sequence</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>ArrayList的克隆为浅克隆，toArray也是浅克隆。所以可以放心大胆的删除，但是修改会导致有问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] es, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) es[index];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     Objects.checkIndex(index, size);</span><br><span class="line">     <span class="keyword">return</span> elementData(index);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Replaces the element at the specified position in this list with</span></span><br><span class="line"><span class="comment">  * the specified element.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">     Objects.checkIndex(index, size);</span><br><span class="line">     E oldValue = elementData(index);</span><br><span class="line">     elementData[index] = element;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>因为是基于数组实现，所以说，get和set一个元素速度极快。越界的话则会OutOfBounds。</li>
<li>由于是JDK12，checkIndex的方法放入到Objects下了。</li>
<li>由于get 和 set方法并没有修改modCount，所以，这两个方法可以放心大胆的于循环中使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This helper method split out from add(E) to keep method</span></span><br><span class="line"><span class="comment"> * bytecode size under 35 (the -XX:MaxInlineSize default value),</span></span><br><span class="line"><span class="comment"> * which helps when add(E) is called in a C1-compiled loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>直接添加的话，会添加到数组最后面，开销很小，如果容量不足，会进行扩容</li>
<li>指定下标添加的话，会进行数组间的元素复制，如果复制的元素很多，开销会比较大。如果指定的index&gt;size，不会进行扩容，而是抛出OutOfBounds。</li>
</ul>
<p>问题：</p>
<ul>
<li>modCount是干嘛的？有什么用？为什么要用？（<strong>问题9</strong>）</li>
<li>add方法里的s为什么是final的？（<strong>问题10</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E oldValue = (E) es[index];</span><br><span class="line">    fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = size = <span class="number">0</span>; i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>删除同样会导致modCount++。</li>
<li>如果删除的是最后一个元素，那么不会进行数组之前的复制操作。</li>
<li>clear会将数组里每个元素设置为0，但是数组并没有进行缩容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's Iterator.  The behavior of this operation is</span></span><br><span class="line"><span class="comment"> * undefined if the specified collection is modified while the operation</span></span><br><span class="line"><span class="comment"> * is in progress.  (This implies that the behavior of this call is</span></span><br><span class="line"><span class="comment"> * undefined if the specified collection is this list, and this</span></span><br><span class="line"><span class="comment"> * list is nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element from the</span></span><br><span class="line"><span class="comment"> *              specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = s - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index,</span><br><span class="line">                         elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>addAll如果在数组容量不够的情况下，才会进行扩容。</li>
<li>指定位置addAll的话，需要先将元素后移之后，在进行添加</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes from this list all of the elements whose index is between</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive.</span></span><br><span class="line"><span class="comment"> * Shifts any succeeding elements to the left (reduces their index).</span></span><br><span class="line"><span class="comment"> * This call shortens the list by &#123;<span class="doctag">@code</span> (toIndex - fromIndex)&#125; elements.</span></span><br><span class="line"><span class="comment"> * (If &#123;<span class="doctag">@code</span> toIndex==fromIndex&#125;, this operation has no effect.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if &#123;<span class="doctag">@code</span> fromIndex&#125; or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> toIndex&#125; is out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> fromIndex &lt; 0 ||</span></span><br><span class="line"><span class="comment"> *          toIndex &gt; size() ||</span></span><br><span class="line"><span class="comment"> *          toIndex &lt; fromIndex&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                outOfBoundsMsg(fromIndex, toIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    shiftTailOverGap(elementData, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Erases the gap from lo to hi, by sliding down following elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftTailOverGap</span><span class="params">(Object[] es, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(es, hi, es, lo, size - hi);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = (size -= hi - lo); i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>区间删除的操作会触发modCount++，以及，会锁容，这是和单纯的remove不同的地方。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Saves the state of the &#123;<span class="doctag">@code</span> ArrayList&#125; instance to a stream</span></span><br><span class="line"><span class="comment"> * (that is, serializes it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.io.IOException if an I/O error occurs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &#123;<span class="doctag">@code</span> ArrayList&#125;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &#123;<span class="doctag">@code</span> Object&#125;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioral compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitutes the &#123;<span class="doctag">@code</span> ArrayList&#125; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserializes it).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException if the class of a serialized object</span></span><br><span class="line"><span class="comment"> *         could not be found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.io.IOException if an I/O error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elementData = elements;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Invalid size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>其实通过这两个方法，来控制序列化。而为什么不适用transient，是因为trainsien会让elementData整个都进行序列化，而如果正好扩容的话，那岂不是尴尬了。50%的空间都被浪费掉了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">      subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;E&gt; root;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> SubList&lt;E&gt; parent;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>list的sublist方法，返回的是一个内部类，相当于一个视图。但是这里有个惊天大坑，特么的SubList没有实现序列化的接口，这意味着他是不可序列化的。<strong>大坑！！！</strong></li>
</ul>
<p>问题解答：</p>
<ol>
<li>elementData虽然声明为transient，不参与序列化，但是实际上是为了性能考虑，ArrayList实现了writeObejct和readObject这两个方法，而Stream会通过这两个方法来进行对象的序列化。</li>
<li>当添加一个元素发现容量不足以添加，且没有超过最大值-8的时候，则进行扩容。最大值为Int.max</li>
<li>get的时候，通过强转来进行类型转换。如果不加泛型的话，那么get到的，都是Object类型的数据，需要自己手动强转，可控性会变弱，出错概率会很高。</li>
<li>忘记啥问题了</li>
<li>不膨胀，只有达到了elementData的容量之后才会进行扩容</li>
<li>默认容量是10，自定义容量就随意了。自定义容量适合于情况限制死的条件，比如说天上只有一个太阳一个月亮，那么capacity设置为2是合理的。但是如果说天上多少颗星星，还是默认的合适。如果说定义的过大，玩意有雾霾了，就会导致空间的浪费。</li>
<li>如果说使用add方法，那么minCapacity每次是size+1，但是如果使用的addAll，那么minCapacity的值就会加上collection的size之后在进行变化</li>
<li>容量达到了elementData的上限的时候，触发扩容</li>
<li>modCount会在iterator循环迭代的时候被拿去判断，如果使用了涉及到修改了modCount的方法，那么modCount的值会变化，而iterator会记录循环开始之前的值，一旦对比不通过，则会抛出ConcurrentModificationException。</li>
<li>final修饰的对象，是线程安全的。</li>
</ol>
<p>ArrayList还是比较简单的一个类，不过其中涉及到iterator的源码并没有看，还是需要抽时间看一下，然后进行补充。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2019/04/18/Data%20Struct/Sorting/</url>
    <content><![CDATA[<p>插入排序：</p><ul>
<li>直接插入</li>
<li>折半插入</li>
<li>2路插入</li>
<li>表插入</li>
<li>上面其实就是查找方式不同而已，操作还是一致的</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/InsertSort01.png" alt="插入排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/InsertSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/InsertSorting.java</a></li>
</ul><a id="more"></a>

<p>冒泡排序：</p>
<ul>
<li>类似于冒泡泡，每次将最大值浮到表面，浮动完毕之后，排序结束</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/BumbleSort01.png" alt="冒泡排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BumbleSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BumbleSorting.java</a></li>
</ul>
<p>快速排序：</p>
<ol>
<li>寻找一个基准点（pointer），进行循环，将比它小的放其左边，将比其大的放右边</li>
<li>然后对左右两个数组重复1的过程，最终结果就为排序后的结果</li>
<li>数组越大，速度越快。因为最快情况：基准点左侧只有一个元素，而剩下的元素全在基准点右侧，而去随机数的话，假设10W个元素，最坏情况的可能性为十万分之一。</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/QuickSort01.png" alt="算法图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/QuicklySorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/QuicklySorting.java</a></li>
</ol>
<p>希尔排序：</p>
<ul>
<li>缩小增量排序</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/ShellSorting01.png" alt="希尔排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/ShellSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/ShellSorting.java</a></li>
</ul>
<p>选择排序：</p>
<ul>
<li>类似于冒泡排序，不过每次讲最小值放入已排序的数组</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/SelectSort01.png" alt="选择排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/SelectSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/SelectSorting.java</a></li>
</ul>
<p>堆排序：</p>
<ul>
<li><p>构建一个堆，然后首尾互换，除了尾节点之外，再次构建堆，这就是堆排序的过程</p>
</li>
<li><p>堆排序，最主要的就是构建一个堆，而构建堆，需要知道最后一个非叶节点的位置。</p>
<ul>
<li>假设节点数目为n，最后一个非叶节点为i。</li>
<li>分两种情况<ul>
<li>由完全二叉树的性质可知：i的左子节点为2i+1，i的右子节点为2i+2</li>
<li>只有左子节点，那么该节点下标为n-1，那么，2i+1=n-1，可以推出i=n/2 -1 </li>
<li>有左/右子节点，那么左子节点下标则为n-2，右子节点下标为n-1，2i+2=n-1，i= (n-3)/2=n/2-3/2。由于二叉树最后一个节点为左孩子，那么该二叉树的节点数为偶数，反之，则为奇数。再因为java中，除不尽则向下取整，因此，i=n/2-1</li>
</ul>
</li>
<li>i=n/2-1得证</li>
</ul>
</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/HeapSort01.png" alt="堆排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/HeapSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/HeapSorting.java</a></li>
</ul>
<p>归并排序：</p>
<ul>
<li>采用分而治之的思想（divide-and-conquer），拆分成最小单元进行排序后，一步一步进行合并</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/MergeSort01.png" alt="归并排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/MergeSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/MergeSorting.java</a></li>
</ul>
<p>基数排序：</p>
<ul>
<li>也比较简单，个位开始，依次开始对比，放入对应的bucket中</li>
<li>然后十位，百位，以此类推，到了某一位，所有数字都没有的话，排序结束，输出结果则为排序后的内容</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/RadixSort01.png" alt="基数排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/RadixSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/RadixSorting.java</a></li>
</ul>
<p>桶排序：</p>
<ul>
<li>和上面基数排序很像，不过桶排序的<strong>映射函数</strong>为<script type="math/tex">f=array[i]/k，k^2=n</script>。n为所有元素个数</li>
<li>然后设置一个定量的桶，将元素放到对应的桶里，然后对每个非空的桶进行排序（插入，选择等）</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/BucketSort01.png" alt="桶排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BucketSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BucketSorting.java</a></li>
</ul>
<p>计数排序：</p>
<ul>
<li>最快的排序，类似于桶排序和基数排序。</li>
<li>给每个元素一个桶</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/CountingSort01.png" alt="计数排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/CountSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/CountSorting.java</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2019/04/16/Data%20Struct/Graph/</url>
    <content><![CDATA[<ol>
<li>图的概念<ul>
<li>基本概念：图结构中，任意两个节点之间的关系是任意的，途中任意两个数据元素之间都可能相关。</li>
<li>ADT：<ul>
<li>数据对象V：数据元素集合，顶点集；</li>
<li>数据关系R：<ul>
<li>R={VR}</li>
<li>VR={<v,w>| <script type="math/tex">v,w \in V</script> 且P(v,w)，<v,w>表示从v到w的弧，P(v,w)定义了弧<v,w>的意义或者信息}</v,w></v,w></v,w></li>
</ul>
</li>
</ul>
</li>
<li>顶点：图中的数据元素</li>
<li>弧：<v,w>表示从v到w的一条弧;v是顶点的集合；vr是两个顶点之间关系的集合<ul>
<li>有向图<ul>
<li><script type="math/tex"><v,w> \in VR</script>，v为弧尾，w为弧头</li>
</ul>
</li>
<li>无向图<ul>
<li>若<script type="math/tex"><v,w> \in VR</script>，必有<script type="math/tex"><w,v> \in VR</script>，用(v,w)表示一条边</li>
</ul>
</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Graph/01.png" alt="有向图和无向图图例"></li>
</ul>
</v,w></li>
<li>定点数n和弧的数目e：<ul>
<li>无向图：<script type="math/tex">0 \le e \le {\frac 1 2} n(n-1)</script></li>
<li>有向图：<script type="math/tex">0 \le e \le  n(n-1)</script></li>
</ul>
</li>
<li>完全图：有n(n-1)/2条边的无向图</li>
<li>有向完全图：有n(n-1)条弧的有向图</li>
<li>稀疏图：边或弧很少的图</li>
<li>稠密图：边或弧较多的图</li>
<li>子图：<script type="math/tex">G=(V,{E})，G1=(V1,{E1})</script>，若<script type="math/tex">V1 \subseteq V</script>，且<script type="math/tex">E1 \subseteq E</script>，则称G1为G的子图</li>
<li>邻接点：无向图中，<script type="math/tex">(V,V1) \in E</script>，则v,v1互为邻接点</li>
<li>顶点v的度：与v相关联的边的数目，TD(v)</li>
<li>有向图中，若<v,v1> \in A，则顶点v邻接到顶点v1，而顶点v1邻接自v<ul>
<li>出度：以v为尾的弧的数目，OD(v)</li>
<li>入度：以v为头的弧的数目，ID(v)</li>
<li>TD(v) = OD(v) + ID(v)</li>
</ul>
</v,v1></li>
<li>路径<ul>
<li>无向图中顶点v到v1的路径：一个顶点序列</li>
<li>有向图中，路径也是有向的</li>
<li>回路</li>
<li>简单路径：顶点序列中顶点不重复的路径</li>
</ul>
</li>
<li>连通图、连通分量、强连通图、强连通分量<ul>
<li>无向图中：顶点v到顶点v1有路径，则v和v1是连通的</li>
<li>如果图G中任意两个点都是连通的，则图G就是连通图</li>
<li>连通分量：无向图中的极大连通子图</li>
<li>有向图中：若任意的顶点vi到vj都有路径，则为强连通图</li>
<li>强连通分量：有向图中的极大连通子图</li>
</ul>
</li>
<li>一个连通图的生成树：一个极小连通子图，含有途中全部节点，但只有足以构成一棵树的n-1条边。<ul>
<li>一棵有n个顶点的生成树有且仅有n-1条边</li>
<li>但有n-1条变得图不一定是生成树</li>
</ul>
</li>
<li>有向图<ul>
<li>如果有一个顶点的入度为0，其余顶点的入度都为1，则是一个有向树。</li>
</ul>
</li>
</ul>
</li>
<li>图的存储结构<ul>
<li>数组表示：两个数组分别存放顶点信息和弧信息<ul>
<li>代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/graph/ArrayGraph.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/graph/ArrayGraph.java</a></li>
</ul>
</li>
<li>链式结构：为途中没一个顶点创建一个单链表，其中的节点表示与依附于顶点的边<ul>
<li>链表存储</li>
<li>十字链表——有向图</li>
<li>邻接多重表——无向图</li>
</ul>
</li>
<li>遍历方式<ul>
<li>深度优先</li>
<li>广度优先</li>
<li>比较简单，类似于树的先序遍历和中序遍历</li>
</ul>
</li>
</ul>
</li>
</ol>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2019/04/12/Data%20Struct/Tree/</url>
    <content><![CDATA[<p><strong>树的定义</strong>：</p><ul>
<li>一棵树是一些节点的集合。这个集合可以是空集；若的不是空集，则树由称作<strong>根（root）</strong>的节点<script type="math/tex">r</script>以及0个或者多个非空的(子)树<script type="math/tex">T_0，T_1…..，T_k</script>组成，这些子树中每一棵的根都被来自根<script type="math/tex">r</script>的一条有向的<strong>边（edge）</strong>所连结。</li>
<li>一棵树是<script type="math/tex">N</script>个结点和<script type="math/tex">N-1</script>条边的集合，其中的一个节点叫做根。</li>
<li>没有儿子的结点成为<strong>树叶（leaf）</strong>，叶节点。</li>
<li>具有相同父亲的节点为<strong>兄弟（siblings）</strong>节点</li>
<li>从节点<script type="math/tex">n_1</script>到<script type="math/tex">n_k</script>的<strong>路径（path）</strong>定义为节点<script type="math/tex">n_1，n_2，……，n_k</script>的一个序列，使得对于<script type="math/tex">1\le i \lt k</script>的节点<script type="math/tex">n_i</script>是<script type="math/tex">n_i+1</script>的父亲。这条路径的<strong>长（length）</strong>是位该路径上的边的条数，即<script type="math/tex">k-1</script>。从每一个节点到它自己都有一条边长为0的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。</li>
<li>对任一节点<script type="math/tex">n_i，n_i</script>的<strong>深度（depth）</strong>为从根到<script type="math/tex">n_i</script>的唯一的路径的长。因此，根的深度为0。<script type="math/tex">n_i</script>的<strong>高（height）</strong>是从<script type="math/tex">n_i</script>到一片树叶的最长路径的长。因此所有的树叶的高都是0。一棵树的高等于它的根的高。一棵树的深度等于它的最深的树叶的深度；该深度总是等于这棵树的高。</li>
<li>如果存在从<script type="math/tex">n_1</script>到<script type="math/tex">n_2</script>的一条路径，那么<script type="math/tex">n_1</script>是<script type="math/tex">n_2</script>的一位<strong>祖先（ancestor）</strong>而<script type="math/tex">n_2</script>是<script type="math/tex">n_1</script>的一个<strong>后裔（descendant）</strong>。如果<script type="math/tex">n_1 \neq n_2</script>，那么<script type="math/tex">n_1</script>是<script type="math/tex">n_2</script>的<strong>真祖先（proper ancestor）</strong>而<script type="math/tex">n_2</script>是<script type="math/tex">n_1</script>的<strong>真后裔（proper descendant）</strong>。</li>
</ul><a id="more"></a>

<p><strong>满二叉树</strong>：一棵深度为k且有2^k-1个节点的二叉树</p>
<p><strong>完全二叉树</strong>：深度为k有n个节点的二叉树，并且仅当其每一个节点都与深度为k的满二叉树中编号从1至n的节点一一对应时，成为完全二叉树。</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/01.png" alt="树图"></p>
<p><strong>二叉树的性质</strong>：</p>
<ul>
<li>在二叉树的第i层上至多有<script type="math/tex">2^i+1 个</script>结点(<script type="math/tex">i>=1</script>)</li>
<li>深度为k的二叉树至多有<script type="math/tex">2^k -1</script>个结点(<script type="math/tex">k>=1</script>)</li>
<li>对任何一棵二叉树T，如果其终端节点数为<script type="math/tex">n_0</script>，度为2的结点数为<script type="math/tex">n_2</script>，则<script type="math/tex">n_0=n_2+1</script></li>
<li>具有n个结点的完全二叉树的深度为<script type="math/tex">(log_2n) + 1</script></li>
<li>如果有一棵有n个结点的完全二叉树(其深度为<script type="math/tex">(log_2n)+1</script>层，每层从左到右)，则对任一结点i(<script type="math/tex">1 \le i \le n</script>)，有：<ul>
<li>如果i=1，则节点i是二叉树的根，无双亲；若i&gt;1，则其parent(i)是节点 i/2</li>
<li>如果2i&gt;n，则节点i无左孩子(节点i为叶子节点)；否则其做孩子leftChild(i)是节点2i</li>
<li>如果2i+1&gt;n，则节点i无右孩子；否则其有孩子rightChild(i)是节点2i+1</li>
</ul>
</li>
</ul>
<p>二叉树的<strong>顺序存储</strong>：</p>
<ul>
<li>就是将完全二叉树上编号为i的节点元素存储在数组对应的下标中。</li>
<li>利用二叉树的最后一条性质，可以快速定位到二叉树的左右子节点和父节点。</li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/ArrayBinTree.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/ArrayBinTree.java</a></li>
</ul>
<p>树的<strong>遍历方式</strong>（模板为上图的完全二叉树）：</p>
<ul>
<li>先序（根）遍历<ul>
<li>对节点的处理工作是在它的诸儿子节点被处理之前进行的</li>
<li>遍历结果为 1   2   4   8   9   2   10   11   3   6   12   13   7   14   15 </li>
</ul>
</li>
<li>中序（根）遍历<ul>
<li>中序遍历左子树，然后访问根节点，然后中序遍历右子树</li>
<li>遍历结果为 8   4   9   2   10   2   11   1   12   6   13   3   14   7   15</li>
</ul>
</li>
<li>后序（根）遍历<ul>
<li>一个结点初的工作是在它的诸儿子节点被计算后进行的</li>
<li>遍历结果为  8   9   4   10   11   2   2   12   13   6   14   15   7   3   1 </li>
</ul>
</li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/LinkedBinTree.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/LinkedBinTree.java</a></li>
</ul>
<p><strong>线索二叉树</strong>：</p>
<ul>
<li><p>对二叉树进行中序排序，将所有的节点右子节点为空的指针指向它的后继节点，将所有的节点左子节点为空的指针指向它的前驱节点。如下图所示</p>
</li>
<li><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/02.png" alt="线索二叉树"></p>
</li>
</ul>
<p>树的<strong>存储结构</strong>：</p>
<ul>
<li>双亲表示法：除了根节点之外，每个节点都会指向其双亲</li>
<li>孩子表示法：每个节点，如果有子节点，则都会指向其子节点</li>
<li><strong>孩子兄弟表示法：两个链域，左链域指向其第一个子节点，右链域指向其第一个兄弟节点</strong></li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/03.png" alt="树表示法图例"></li>
</ul>
<p>森林：就是好多棵树</p>
<p>森林/树与二叉树的互相转换：</p>
<ul>
<li><p>森林转换为二叉树</p>
<ul>
<li><script type="math/tex; mode=display">F={T_1,T_2……T_m}$$是森林，转为二叉树$$B=(root,LB,RB)</script></li>
<li>若<script type="math/tex">F</script>为空，则m=0，B为空</li>
<li>若<script type="math/tex">F</script>非空，则B的根root是森林中的第一棵树的根<script type="math/tex">ROOT(T_1)</script>；B的左子树LB是从<script type="math/tex">T_1</script>中根节点的子树森林<script type="math/tex">F1={T_1,T_2……T_m}</script>转换而成的二叉树；B的右子树RB是从森林<script type="math/tex">F2={T_1,T_2……T_m}</script>转换而成的二叉树 </li>
</ul>
</li>
<li><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/04.png" alt="森林，树，二叉树相互转换图"></p>
</li>
</ul>
<p>最优二叉树(哈弗曼树)：</p>
<ul>
<li><strong>概念：带权路径长度最短的树</strong></li>
<li><strong>路径长度：结点之间的树枝的总数</strong></li>
<li><strong>树的路径长度：从根到每一结点的路径长度之和</strong></li>
<li><strong>树的带权路径长度：叶子结点的带权路径长度之和。设有</strong> <strong>n</strong> <strong>片叶子，它们的权值分别为<script type="math/tex">w_1,w_2,…w_n</script>相应的路径长度分别为<script type="math/tex">l_1,l_2,…,l_n</script></strong>，则树的带权路径长度（Weight Path Length）可记为：<script type="math/tex">WPL=\sum_{k-1}^n w_k l_k</script></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>串的模式匹配算法</title>
    <url>/2019/04/09/Data%20Struct/StringMatcher/</url>
    <content><![CDATA[<blockquote>
<p>面试常见题</p>
</blockquote><p>&emsp;&emsp;给定一个串，然后给其一个子串，获取<strong>子串在串中的下标</strong>，LeetCode也收录了这个问题。</p><a id="more"></a>

<p>&emsp;&emsp;解法一：贪婪法</p>
<p>&emsp;&emsp;假设有两个串，主串A，子串B。首先说循环A，然后循环B，判断子串中的值和主串中的是否完全一致，如果不一致的话，A开始下一次循环，继续这个过程。最欢情况的话，就是O(m*n)。这个是最容易想到的，也是最简单的一个，同时也是最慢的一个。</p>
<p>&emsp;&emsp;解法二：KMP算法</p>
<p>&emsp;&emsp;如下图所示，如果T[2] != P[2]，按照贪婪法，应该是T移动到1，P移动到0，然后重新开始匹配。而KMP算法的目的，就是说跳过无用的匹配，使其无用操作变少。</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/01.jpg" alt="KMP示例"></p>
<p>&emsp;&emsp;KMP算法的核心，就是next数组，需要通过next数组，来获取其移位的长度。<strong><em>next[i]，i从1开始计算，则表示，除去第i个数，在一个字符串里面从第一个数到第(i-1)字符串前缀和后缀最长重复的个数</em></strong>。而这个个数，就是子串移位的长度。</p>
<p>&emsp;&emsp;公式(图片来源于网络)如下</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/02.png" alt="next函数公式"></p>
<p>&emsp;&emsp;举例说明前缀和后缀，在”abcd”中，前缀为”abc”，后缀为”bcd”。</p>
<p>&emsp;&emsp;举例模式串为：<strong>ABAAAABC</strong>，用大写看起来舒服点。</p>
<p>&emsp;&emsp;子串说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>各个子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最大公共元素长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>无</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>AB</td>
<td>A</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>ABA</td>
<td><font color="red">A</font>；AB</td>
<td><font color="red">A</font>；BA</td>
<td>1</td>
</tr>
<tr>
<td>ABAA</td>
<td><font color="red">A</font>；AB；ABA</td>
<td><font color="red">A</font>；AA；BAA</td>
<td>1</td>
</tr>
<tr>
<td>ABAAA</td>
<td><font color="red">A</font>；AB；ABA；<br>ABAA</td>
<td><font color="red">A</font>；AA；AAA；<br>BAAA</td>
<td>1</td>
</tr>
<tr>
<td>ABAAAA</td>
<td><font color="red">A</font>；AB；ABA；<br>ABAA；ABAAA</td>
<td><font color="red">A</font>；AA；AAA；<br>AAAA；BAAAA</td>
<td>1</td>
</tr>
<tr>
<td>ABAAAAB</td>
<td>A；<font color="red">AB</font>；ABA；<br>ABAA；ABAAA；ABAAAA</td>
<td>B；<font color="red">AB</font>；AAB；<br>AAAB；AAAAB；<br>BAAAAB</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;用一张图来表示next函数的执行过程：</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/03.png" alt="next函数执行过程"></p>
<p>接下来简述一下next函数的执行过程，我们用P来代表上面的子串。</p>
<ol>
<li><p>第一步，i=j=0，第一步没有可比较对象，所以<strong>next[0]=0，i++</strong>。</p>
</li>
<li><p>第二步，i=1，j=0。P[i]!=P[j]。next[1]=0，i++**。</p>
</li>
<li>第三步，i=2，j=0。P[i]==P[j]。next[2]=next[j]+1=1，i++，j++**。</li>
<li><p>第四步，i=3，j=1。P[i]!=P[j]。j = next[j-1]，再次进行对比，P[i]==P[j-1]，j = j-1+1，i++。</p>
</li>
<li><p>第五步，同上</p>
</li>
<li>第六步，同上</li>
<li>第七步，同上</li>
<li>第八步，同上</li>
</ol>
<p>next函数的代码如下，写的并不严谨，只表示主要思路，仅供参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取滑动位的算法，这个算法思路很简单。就是对比前缀和后缀，看其中重复的子串的长度，则就是next[]函数的值</span></span><br><span class="line"><span class="comment">  * 但是要注意的是，前缀必须从头开始算，后缀必须从最后一个数开始算</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(String expression, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//第一个已经固定死为0了。</span></span><br><span class="line">     <span class="keyword">while</span> (i &lt; expression.length()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">             next[i] = <span class="number">0</span>;</span><br><span class="line">             i++;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果相等的话</span></span><br><span class="line">         <span class="keyword">if</span> (Objects.equals(expression.charAt(i), expression.charAt(j))) &#123;</span><br><span class="line">             System.out.println(<span class="string">"expression.charAt(i) is "</span> + expression.charAt(i) + <span class="string">"  expression.charAt(j) is "</span> + expression.charAt(j));</span><br><span class="line">             next[i] = j + <span class="number">1</span>;</span><br><span class="line">             j++;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                 j = next[j - <span class="number">1</span>];</span><br><span class="line">                 System.out.println(<span class="string">"expression.charAt(i) is "</span> + expression.charAt(i) + <span class="string">"  expression.charAt(j) is "</span> + expression.charAt(j));</span><br><span class="line">                 <span class="keyword">if</span> (Objects.equals(expression.charAt(i), expression.charAt(j))) &#123;</span><br><span class="line">                     next[i] = j + <span class="number">1</span>;</span><br><span class="line">                     j++;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">"i --------&gt; "</span> + i + <span class="string">" j-------------&gt;"</span> + j + <span class="string">"  next["</span> + i + <span class="string">"] = "</span> + next[i]);</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; next.length; k++) &#123;</span><br><span class="line">         System.out.print(next[k] + <span class="string">"  "</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;至此，next数组就已经全部获取到了。接下来就是，利用这个next数组，来查询子串是否存在并且返回下标。如下图所示：</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/04.png" alt="next数组使用"></p>
<p>执行过程描述：</p>
<ol>
<li><p>第一次执行，匹配到S[i] != P[j]的时候，从next数组中获取其前一位的值（next[j-1] = 0）</p>
<p>于是能够知道，下一次对比，是从P[0]开始，OK。j=0，i++。</p>
</li>
<li><p>第二次执行，匹配到S[i] != P[j]的时候，从next数组中获取其前一位的值（next[j-1] = 2）</p>
<p>于是能够知道，下一次对比，是从P[2]开始，OK。j=2，i=i+k。</p>
</li>
<li><p>第三次执行。全部匹配，OK，退出，返回下标。</p>
</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(String common, String expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] commonCharArray = common.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] expressionCharArray = expression.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[expression.length()];</span><br><span class="line">        next(expression, next);</span><br><span class="line">        <span class="keyword">int</span> commonLength = common.length();</span><br><span class="line">        <span class="keyword">int</span> patternLength = expression.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; commonLength) &#123;</span><br><span class="line">            <span class="keyword">int</span> incrementValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; patternLength) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(commonCharArray[i + incrementValue], expressionCharArray[k])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k == patternLength - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i - (k - incrementValue);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                        incrementValue++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = k + i;</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">                        k = next[k - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用栈实现中缀转后缀</title>
    <url>/2019/04/08/Data%20Struct/StackAlgorithm1/</url>
    <content><![CDATA[<p>&emsp;&emsp;代码比较长，就不写了，写一写思路。举例：2+1-5+(5-8)*2</p><ol>
<li>常规数字，直接输出，碰到符号的话，对比优先级，然后判断是否出栈，优先级高的话，入栈，否则，出栈，小括号()优先级最高</li>
<li>输出2 +入栈</li>
<li>输出1，由于+和-的优先级相同，+出栈，-入栈 21+</li>
<li>输出5，由于+和-的优先级相同，-出栈，+入栈 21+5-</li>
<li>输出5 碰到小括号，优先级最大，(入栈，21+5-5</li>
<li>输出8，栈里已经有了小括号，所以说，-直接输出 21+5-58-</li>
<li>碰到小括号，优先级最大。所以小括号出栈，碰到<em>号，优先级大于栈里的+，所以</em>入栈，输出2，21+5-58-2</li>
<li>已经没东西了，栈里的依次出栈输出，结果为21+5-58-2*+</li>
</ol><a id="more"></a>

<p>&emsp;&emsp;其实应该说配几张图的。。。但是hexo图片还没想好到底要不要存阿里或者腾讯。好了再补，估计是不补了，写的应该足够</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈和队列</title>
    <url>/2019/04/07/Data%20Struct/StackQueue/</url>
    <content><![CDATA[<p>&emsp;&emsp;<strong>栈（Last In First Out）</strong>和<strong>队列（First In First Out）</strong></p><a id="more"></a>
<p>&emsp;&emsp;细分的话，可以分为<strong>顺序栈</strong>，<strong>链栈</strong>，<strong>顺序队列</strong>，<strong>链队</strong>。也就是一个用<strong>数组</strong>实现，一个用<strong>链表</strong>实现，区别的话，也就是顺序存储和链式存储的区别。而JDK中util下的Stack，<strong>实现是顺序栈</strong>。</p>
<p>&emsp;&emsp;栈一般有两个指针，<strong>top和base</strong>，top指向栈顶，base指向栈底。这样的话，<strong>top==base</strong>，说明栈空，<strong>top-base&gt;=stacksize</strong>的话，则说明栈满。</p>
<p>&emsp;&emsp;JDK的Stack的pop实现，是先进行peek()，然后remove()。这就说明了pop和peek的区别，pop是<strong>弹出栈顶元素</strong>，peek，顾名思义，偷看，<strong>只查看栈顶元素</strong>。JDK中是<strong>并没有</strong>提供链栈的实现的，没有说和List一样，提供一个接口，然后提供ArrayList和LinkedList两种实现。只有一个Stack的类，继承与Vector。但是看源码能够知道，util的LinkedList包含有peek，pop，push这些方法。也就是说<strong><em>LinkedList完全可以将其当成是链栈来用</em></strong>！LinkedList支持栈的操作，那么同理，ArrayList应该也支持栈的操作。毕竟都是线性表么。因此，区别的话就能知道：<strong>ArrayList和LinkedList不是线程安全，而Stack是线程安全的</strong>。</p>
<p>&emsp;&emsp;补充一下，ArrayList和LinkedList都实现的栈和队列的方法。</p>
<p>&emsp;&emsp;现代化的计算机将栈作为它的指令系统的一部分，也就是说，<strong>栈很可能是计算机科学中除了数组之后的最基本的数据结构</strong>。</p>
<p>&emsp;&emsp;用栈来实现进制转换很容易，除以n，然后余数压入栈中，依次进行，最后依次出栈。</p>
<p>&emsp;&emsp;<strong>递归</strong>实际上就是利用栈来实现的，自调用，层层入栈，层层出栈。</p>
<p>&emsp;&emsp;队列一般<strong>长度固定</strong>，然后实现是<strong>循环队列</strong>。这样的话，能够合理利用空间。用front指向队头，用tail指向队尾。front==tail的时候，就说明队列为空。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2019/04/06/Data%20Struct/List/</url>
    <content><![CDATA[<p>&emsp;&emsp;线性表分大致两种实现：<strong>顺序实现</strong>，<strong>链表实现</strong>。</p><p>&emsp;&emsp;对于顺序实现来说，特点有这么几个：1、<strong>基于数组</strong>，2、<strong>Locate是常数时间O(1)</strong>，3、<strong>插入和删除要移动大量元素，最坏情况为O(N)，平均情况为线性时间，最好情况是O(1)</strong></p><a id="more"></a>

<p>&emsp;&emsp;对于链表实现来说，特点是这么几个：1、<strong>元素不连续存储</strong>，2、<strong>Locate是线性时间</strong>，3、<strong>插入、删除开销小</strong>。</p>
<p>&emsp;&emsp;链表分类有：<strong>单向链表</strong>，<strong>循环链表</strong>，<strong>双向链表</strong>，<strong>双向循环链表</strong>。单向链表的话，只有一个next指针指向下一个元素；循环链表的话，tail.next-&gt;head；双向链表的话，一个next指针，一个prev指针；双向循环链表的话，head-&gt;tail，tail-&gt;head;</p>
<p>&emsp;&emsp;对于顺序实现的插入和删除，实现步骤如下：<strong>插入的时候</strong>，需要看其原先的位置有没有元素，如果没有，则直接赋值即可。但是如果有值的话，则需要将该位置之后的元素通通向后后移一位。<strong>删除的时候</strong>同理，删除了元素之后，该元素之后的数据，需要通通向前移动一位。</p>
<p>&emsp;&emsp;对于链式存储的插入和删除，实现步骤如下：<strong>插入的时候</strong>，看位置有没有元素，没有，直接赋值进去，同时看有没有上一个元素，有的话，prev指向上一个元素，否则，自己作为头结点。如果有元素，麻烦一点，首先得看这个元素是不是头节点，是头结点，那插入之后，自己的next需要指向之前的头结点。不是头结点的话，自己的next指到上一个元素的next，那上一个元素的next指向自己，自己的prev指到上一个元素。<strong>删除的时候</strong>，和插入的判断差不多，不想写了，意思差求不多。</p>
<p>&emsp;&emsp;用list实现多项式的相加，也就是<strong>合并多项式</strong>，写一下思路吧，代码不写了，和归并差不太多，多了一层判断，也就是比较大小的时候，需要对比多项式<strong>指数部分</strong>是否相等，相等的话，合并多项式，就完了。多项式相减也是同理。</p>
<p>&emsp;&emsp;写LinkedList的时候，参考了一下jdk的源码，发现个有意思的事情。在jdk中，getElement的时候，做了一层优化，<strong>根据下标，判断是否小于size/2，小于的话，则从前开始遍历，否则，从后往前开始遍历。</strong>这样的话，减少了不必要的遍历。而且，获取node的时候，这通常第一就会想到递归。但是，jdk并不是用递归进行的处理，而是用的循环，这样性能上相对于递归来说更好。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;又发现个有意思的事情，jdk的LinkedList，是<strong>双链表</strong>，记录有头尾节点，因此，添加元素直接对尾节点进行操作就可以，速度很快。而C语言描述中，是<strong>单链表</strong>，则添加为O(n)。先往后看看，可能刚开始只是用单链表演示而已。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-前言</title>
    <url>/2019/04/05/Data%20Struct/Preface/</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><blockquote>
<p> 程序=数据机构+算法</p>
</blockquote><p>&emsp;&emsp;如果主要是写企业级应用的话，其实绝大多数都是JAVA，算法的作用，相对来说不是那么大。因为说，C，C++这种的更加偏重于算法。而JAVA这种，难就难在生态的庞大。但是说，不能说数据结构和算法都不用学了，那和码农有什么区别？没有哪个程序员说是想一辈子写业务性的CURD的吧？面试，如果有算法的话，能刷掉至少百分之九十的人，我们为何不成为那百分之十的人？</p><a id="more"></a>

<p>&emsp;&emsp;之前这写一点笔记，那写一点笔记，三天打鱼两天晒网，完了之后自己还是啥也不会，其实不太好。这样并不是一个持续性成长的过程，可能过了一年之后，发现自己啥也不会。也有可能发现自己啥都会，哈哈，然后随随便便往深了一问，得，扑街。</p>
<p>&emsp;&emsp;其实应该用C来写的，但是C写起来着实是麻烦。先用Java写吧，等完了之后，看《深入理解计算机系统》这本书的时候，再用C搞搞，理解还能更深刻一点。</p>
<p>&emsp;&emsp;Here we go!</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>前言</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL查询性能的优化</title>
    <url>/2020/12/18/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/4-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>查询的生命周期大致可以按照顺序来看：<strong>客户端，服务器，在服务器上进行解析，生成执行计划，执行，返回结果给客户端，执行可以认为是整个生性周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组</strong>。在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的IO操作上消耗时间，根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。</p><a id="more"></a>
<p>| 慢查询基础：优化数据访问</p>
<p>查询性能低下最根本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。两个步骤：<strong>1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的航，但有时候也可能是访问了太多的列。2.确认MySQL服务器层是否在分析大量超过需要的数据行。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL创建高性能索引</title>
    <url>/2020/12/17/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/3-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>| 1.1 索引的类型</p><p>索引是在存储引擎层实现，非服务器层实现，所以，不同的存储引擎之间，索引的工作方式不一样，也不是所有的存储引擎都实现了某一个索引，即使实现了，工作方式也很有可能不一样。</p><a id="more"></a>

<p>一般常说的索引指的是<strong>B-Tree索引</strong>，但是实际上一般是B+tree，因为B+tree每一个叶子节点都指向下一个叶子节点，有助于范围区间的查询遍历。</p>
<p>示例图如下</p>
<p>B-tree能提高数据访问速度，不再需要全表扫描，而是通过索引，从root节点开始搜索，树的深度和表的大小直接相关，因为b-tree是顺序存储，因此很适合范围查找数据，比如，整数的顺序，字母的顺序，非常高效。</p>
<p>B-tree适合于<strong>全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引</strong>等查询。而且，索引树种的节点是有序的，因此，能用于查询，也就能用于order by 排序。</p>
<p>B-tree索引的限制（最左匹配原则）：</p>
<ol>
<li>如果不是按照索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，那么右边的所有列都无法使用索引优化查找</li>
</ol>
<p><strong>Hash索引</strong>的话，必须是精确匹配所有的查询列才会生效，只有Memery引擎显示支持hash索引。hash找数据非常快，但是也有其自身的一些限制</p>
<ol>
<li>hash索引只包含hash值和指针，无法避免回表</li>
<li>hash索引并不是按照索引值顺序排列的，也就无法用于排序</li>
<li>不支持部分匹配查找</li>
<li>只支持等值匹配查找</li>
<li>hash碰撞（冲突）很多的话，极端情况，会变化为链表</li>
</ol>
<p>同时，InnoDB有一个功能叫”自适应hash索引“，当某些索引值使用的非常频繁的时候，会在内存中，基于B-Tree索引之上再创建一个hash索引，用户无法控制，但是这个功能可以关闭。</p>
<p>同时，如果想在InnoDB中使用hash索引的话，可以手动实现一个，其实就是插入前使用hash函数，但是需要注意，使用CRC32()函数比较合适，推荐使用整数，并不推荐使用SHA1和MD5，这种函数是为了最大化避免hash冲突，实际过程中，并不是那么的有必要。同时，由于生日悖论，hash冲突的出现会比想象中快很多，最好手动维护一个64位的hash函数使用。</p>
<p><strong>R-Tree 空间索引</strong></p>
<p>用作地理数据存储，但是必须使用GIS相关函数来维护数据</p>
<p><strong>全文索引</strong></p>
<p>MySQL不常用，更适合用搜索引擎来做</p>
<p>| 1.2 索引的优点</p>
<ol>
<li>大大减少了服务器需要扫描的数据量</li>
<li>可以帮助服务器避免排序和临时表</li>
<li>可以将随机I/O变为顺序IO</li>
</ol>
<p>| 1.3 高性能索引策略</p>
<ol>
<li><p>独立的列</p>
<p> 如果查询的列不是独立的，那么无法使用索引，也就是说，索引列不能是表达式的一部分，也不能是函数的参数，比如：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> to_day(<span class="keyword">current_date</span>) - to_day(<span class="keyword">current_date</span>) &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p> But，与MySQL8 测试，这个查询正常走了索引，估计是优化器进行了优化吧</p>
</li>
<li><p>前缀所以和索引的选择性</p>
<p> 先说很重要的一点：<strong>MySQL无法使用前缀索引进行order by和group by，也无法使用前缀索引做覆盖扫描</strong>。</p>
<p> 有时候需要索引很长的字符列，这样的话，索引会变的又大又慢，一个策略是使用伪hash索引，但是通常情况下，可以索引开始的部分字符，这样可以大大节省索引空间，提升索引效率。但是同时也会降低索引的选择性。索引的选择性是指：<strong>不重复的索引值和数据表的记录总数的比值，范围从1/T - 1 之间</strong>，索引的选择性越高，则查询效率越高，因为选择性越高的索引在查询时能过滤掉更多的行，唯一索引的选择性为1，是性能最好的索引选择性。</p>
<p> 对于很长的text，varchar，blob，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p> 诀窍在于选择足够长的前缀以保证较高的选择性，同时不能太长（节约空间），前缀应该足够长，使得选择性接近与索引整个列。  </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算完成列的选择性</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> city)/<span class="keyword">count</span>(*) <span class="keyword">from</span> city_demo;</span><br><span class="line"><span class="comment"># 如何在一个查询中计算不同前缀长度的选择性</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">3</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel3,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">4</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel4,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">5</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel5,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">6</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel6,</span><br><span class="line">   <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">7</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel7</span><br><span class="line"><span class="keyword">from</span> city_demo</span><br></pre></td></tr></table></figure>
<p> 这样的话，有助于帮助找到最合适的前缀索引长度。然后开始创建前缀索引。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> city_demo <span class="keyword">add</span> <span class="keyword">key</span>(city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>多列索引</p>
<p> 一个常见错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<p> MySQL引入了一种叫<strong>索引合并（index merge）</strong>的策略，一定程度上可以利用表上的多个单列索引来定位指定的行。比如下面代码所示</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> film_id =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p> 在某些语句的extra列中，还能看到嵌套操作。索引合并是一种优化的结果，但是也说明，索引实际上建的非常糟糕。</p>
<ul>
<li>当服务器对多个索引做相交操作时（多个AND条件），通常意味着需要一个包含相关列的多列索引，而不是多个独立的单列索引。</li>
<li>当服务器需要对多个索引做联合操作时（多个OR条件），通常需要消耗大量的CPU和内存资源在算法的缓存，排序和合并操作上，特别是其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。</li>
<li>更重要的是，优化器不会把这些计算算到”查询成本（cost）“中，优化器只关心随机页面读取。这样会使得查询的成本被低估，导致该执行计划还不如全表扫描。这样不仅可能会消耗更多的CPU和内存资源，还可能会影响查询的并发性。还不如改写成union。</li>
</ul>
</li>
<li><p>选择合适的索引列顺序</p>
<p> 说明：<strong><em>只适用于b-tree索引</em></strong></p>
<p> 在一个多列b-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的order by, group by 和 distinct等子句的查询需求。</p>
<p> 有的建议是：将选择性最高的列放到索引最前列。但是这个建议，<strong>通常不如避免随机IO和排序那么重要</strong>。</p>
<p> 当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好地。这时候索引的作用只适用于优化where条件的查找。这种情况下，这样索引能最快地过滤出所需要的行，对于在where子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。示例如下</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> payment <span class="keyword">where</span> staff_id = <span class="number">2</span> <span class="keyword">and</span> customer_id = <span class="number">584</span>;</span><br><span class="line"><span class="comment"># 应该创建一个(staff_id,customer_id)还是应该颠倒以下顺序？可以跑一些查询来确定在这个表中的分布情况，并确定哪个列的选择性更高。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(staff_id=<span class="number">2</span>),<span class="keyword">sum</span>(customer_id=<span class="number">584</span>) <span class="keyword">from</span> payment;</span><br><span class="line"><span class="comment"># sum(staff_id=2)：7992</span></span><br><span class="line"><span class="comment"># sum(customer_id=584)：30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(staff_id=<span class="number">2</span>) <span class="keyword">from</span> payment <span class="keyword">where</span> customer_id = <span class="number">584</span>;</span><br><span class="line"><span class="comment"># sum(staff_id=2)：17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是，查询的结果非常依赖与选定的具体值，如果这样来，服务器的整体性能可能会更糟，或者不如预期</span></span><br><span class="line"><span class="comment"># 最好还是按照经验法则来，考虑全局技术和选择性，而不是某个具体查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> staff_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> staff_id_selectivity,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> customer_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> customer_id_selectivity,</span><br><span class="line">    <span class="keyword">count</span>(*) <span class="keyword">from</span> payment;</span><br><span class="line"><span class="comment"># 由结果可知，customer_id的选择性更高，所以它是索引列的第一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> payment <span class="keyword">add</span> <span class="keyword">key</span> (customer_id,staff_id)</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚簇索引</p>
<p> InnoDB的聚簇索引实际上在同一个结构中保存了B-tree索引和数据行。当表有局促索引时，它的数据行实际上存放在索引的叶子页中。因为无法同时把数据航存放在两个不同的地方，所以一个表只能有一个聚簇索引（覆盖索引可以模拟多个局促索引的情况）。</p>
<p> 图例在这</p>
<p> 如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p>
<p> 聚簇索引的一些优点：</p>
<ul>
<li>可以把相关数据保存在一起。避免每一次都是磁盘IO</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-tree中，从聚簇索引中获取数据通常比在非聚簇索引中查找要快</li>
<li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</p>
<p>聚簇索引的一些缺点：</p>
</li>
<li><p>最大限度的提高了I/O密集型应用的性能，但是数据如果全部都放在内存中，则反问的顺序就没有那么重要，聚簇索引也就没有什么优势</p>
</li>
<li>插入速度严重依赖与插入顺序，按照主键的顺序插入是加载数据到InnoDB表中速度最快的，但是如果不是按照主键顺序加载，那么加载完成后，需要使用optimize table重新组织一下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临”页分裂（page split）“的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将改页分裂成两个页面来运行，页分裂会导致表占用更多的磁盘空间</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂，导致的数据存储不连续的时候</li>
<li>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li><p>二级索引访问需要两次索引查找，而不是一次</p>
<p>因为二级索引中保存的不是指向行的物理位置的指针，而是行的主键值。意味着通过二级索引查找行，存储引擎需要到二级索引的叶子节点获得对应的主键，然后根据这个值，去聚簇索引中查找到对应的行。自适应hash索引能减少这样的重复操作。</p>
<p>Innodb和myisam的数据分布对比：</p>
<p>myisam按照数据插入的顺序存储在磁盘上，每一行有个行号，因为行是定长的，所以myisam可以从表的开头跳过所需的字节找到需要的行。</p>
<p>myisam的图在这里</p>
<p>要注意的是，在innodb中，聚簇索引“就是表”，所以不想myisam那样需要独立的行存储。</p>
<p>聚簇索引的每一个叶子节点都包含了主键值，事务ID，用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，innodb也会包含完整的主键列和剩下的其他列。</p>
<p>innodb的二级索引和聚簇索引很不相同。innodb的二级索引的叶子节点中，存的不是行指针，而是主键值，以此作为行的指针。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键值当指针会让二级索引占用更多的空间，但是好处是，innodb在移动行的时候无需更新行指针</p>
<p>聚簇索引，非聚簇索引，myisam保存数据和索引的区别，看这个图。</p>
<p>从性能角度考虑，使用UUID作为聚簇索引会很糟糕，会使得聚簇索引的插入变得完全随机，最坏情况会导致数据没有任何聚集特性，而且插入不仅花费的时间更长，索引占用的空间也更大，页分裂和碎片化也更多。</p>
</li>
</ul>
</li>
<li><p>覆盖索引</p>
<p> 如果一个索引包含（或者是覆盖）所有需要查询的字段的值，不需要再次回表查询，称之为覆盖索引。覆盖索引的好处有这些</p>
<ul>
<li>避免回表</li>
<li>索引数目远小于数据行大小，因此如果只需要读取索引，就能够极大的减少数据访问量对于IO密集的应用友好，索引也容易全部放到内存里面，有利于myisam的索引压缩</li>
<li>在单个页内，索引是按照顺序存储的，对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO少得多</li>
<li>一些存储引擎如myisam在内存中之缓存索引，数据则依赖于操作系统来缓存，因此，访问数据需要一次系统调用。可能会导致严重的性能问题，尤其是系统调用占了数据访问中的最大开销的场景。</li>
<li><p>由于InnoDB的聚簇索引，覆盖索引对InnoDB很有用。二级索引在叶子节点中保存了行的主键值，所以如果二级索引能覆盖查询，可以避免对主键索引的二次查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,store_id <span class="keyword">from</span> inventory;</span><br></pre></td></tr></table></figure>
<p>当执行这条sql的时候，extra列显示为Using index，这表示，索引覆盖了查询。但是覆盖索引有很多坑可能会导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了where条件中的字段，但不是整个查询涉及的字段。如果条件为false，MySQL5.5也总是会回表获取数据行，尽管并不需要这一行而且最终会被过滤掉。如果需要解决这个问题的话，需要使用<strong>延迟关联</strong>。</p>
</li>
</ul>
</li>
<li><p>使用索引扫描来做排序</p>
<p> MySQL有两种方式可以生成有序的结果：<strong>通过排序操作；或者按照搜因顺序扫描；</strong>。如果explain出来的type列的值为index，说明MySQL使用了索引扫描来做排序。</p>
<p> 索引的扫描是很快的，从一条移动到下一条即可，但是，如果说索引没有覆盖扫描行的话，每一条索引记录都需要回表查询一次对应的行，基本都是随机IO，因此按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是IO密集型的工作负载时。</p>
<p> 因此，应该尽可能，既满足排序，又满足查找行，这样最好。<strong>只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能使用索引对结果做排序。如果查询需要关联多张表，则只有当order by 子句引用的字段全部为第一个表时，才能使用索引做排序。order by 子句和查找型查询的限制是一样的：需要满足最左前缀的要求；否则；MySQL都需要执行排序操作，而无法利用索引排序。</strong></p>
<p> 有一种情况下order by 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果where子句或者join子句中对这些列制定了常量，就可以弥补索引的不足。</p>
</li>
</ol>
<ol>
<li><p>索引压缩</p>
<p> 不太重要，myisam使用场景不多，不予考虑</p>
</li>
<li><p>冗余和重复索引</p>
<p> 重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应当避免，发现后应当立即删除</p>
<p> 冗余索引大多数情况下都不需要，应当尽量扩展已有的索引而不是创建新索引。但是有时候，扩展已有的索引会导致其变的太多，从而影响其他使用该索引的查询的性能。同时，表中的索引越多插入的速度越慢。</p>
</li>
<li><p>未使用的索引</p>
<p>赶紧删了，可以通过information_schema.index_statistics表，获取到每个索引的使用频率</p>
</li>
<li><p>索引和锁</p>
<p>索引可以让查询锁定更少的行。如果查询从不访问那些不需要的行，那么就会锁定更少的行，从这方面来看对性能是有好处的。因为innodb虽然行锁效率高，内存使用少，当时锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>
<p>InnoDB只有在访问行的时候才对其枷锁，而索引能减少Innodb访问的行数，从而减少锁的数量。但是只有当innodb在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤无效的行，那么在innodb检索到数据并返回给服务器层以后，MySQL服务器才能应用where子句。这时候已经无法避免锁定行了：innodb已经锁住了这些行，适当的时候才会释放。</p>
<p>示例：</p>
<p><strong>explain出现了using where，这表示MySQL服务器将存储引擎返回行以后再应用过滤条件</strong>。Innodb在二级索引上使用共享锁（读），但访问主键索引需要排他锁（写）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的Schema和数据类型优化</title>
    <url>/2020/12/16/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/2-Schema%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>| 1. 选择数据类型时候的基本原则</p><ol>
<li><strong>更小的通常更好</strong>，占用更少的磁盘，内存和CPU缓存，处理时需要的CPU时钟周期也少，但是不建议项目初期就弄，不然改起来也太费劲了，超级痛苦。</li>
<li><strong>简单的更好</strong>，比如能使用整形就不适用字符，能用date就不用字符串，因为字符集和排序规则使得字符串相比整形复杂。</li>
<li><strong>避免为null</strong>，滴滴的数据表，全都是not null的，因为有null的列更难优化，耗费的成本更高，索引，统计更麻烦，浪费更多的存储空间，</li>
</ol><a id="more"></a>

<p>| 1.1 整数类型</p>
<p>分为两种，整数（real number）和实数（real number），整数有这么几种：<strong>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT</strong>，分别使用8，16，24，32，64位存储空间，存储的值为 -2^n-1 到 2^(n-1)-1，同时有可选的<strong>UNSIGNED</strong>属性，不允许负值，可以将正数上限提高一倍。<strong>INT(11)</strong>不会限制值的合法范围，只是规定了一些交互工具显示字符的个数。</p>
<p>| 1.2 实数类型</p>
<p>DECIMAL可以存比BIGINT更大的整数，也可以存储精确的小数，<strong>CPU原生支持浮点运算，但是DECIMAL需要MySQL实现，因此浮点比DECIMAL运算更快。decimal计算中，会转换为double，因此，虽然DECIAML支持65个数字，但是实际上并不支持</strong>。同时，建议选择数据类型，不建议选择decimal的精度。可以使用BIGINT取代decimal，避免运算代价过高。</p>
<p>| 1.3 varchar和char类型</p>
<p>varchar比定长更节省空间，因为它只使用必要的空间，除非使用row_format=fixed，但是varchar需要1-2个字节记录字符串长度。虽然varchar对于性能有好处，但是，由于行是变长的，因此update操作可能使得行比原先变的更长，这时候，innodb就会进行分裂页，是数据能够放入页内。</p>
<p>下面这几种情况使用varchar更合适：<strong>字符串列的最大长度比平均长度长很多；列的更新很少，碎片不是问题；使用了复杂字符集，比如utf-8，每个字符都是用不同的字节数进行存储</strong>。</p>
<p>char会删除末尾空格，由于定长，也不容易产生碎片，而且在存储空间上也更有效率，没有存储长度的多余字节。</p>
<p>| 1.3.1 Blob和Text类型</p>
<p>分别属于两组：<strong>TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT  和 TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB</strong>。区别是，blob存储的是二进制数据，没有排序规则和字符集，而text有排序规则和字符集。如果数据过大的话，MySQL会在外部存储区域进行存储实际的值，每个值在行内用1-4个字节存储一个指针。</p>
<p>| 1.4 时间和日期类型</p>
<p>MySQL能存储的最小时间单位粒度为秒，datetime可以存储1001-9999的数据，<strong>使用8个字节的存储空间</strong>。而timestamp，<strong>保存的是标准时间，只能从1970-2038，使用4个字节进行存储，依赖于时区，默认为NOT NULL，效率也比datetime更高</strong>。</p>
<p>如果想存储微秒级别的时间戳，可以使用bigint，或者使用MariaDB。</p>
<p>| 1.5 位数据类型</p>
<p>bit列的最大长度是64个位，MySQL把bit当成字符串类型使用，同时和上下文环境有关系，比如直接查询，可能是显示的这个二进制对应的ASCII码表的内容，但是如果与数字一起运算，得到的就是数字结果，谨慎使用。</p>
<p>如果需要很多true/false值，可以使用set，在MySQL内部是以一系列打包的位的集合表示的，能够有效利用存储空间，但是该变列的话，需要alter table.</p>
<p>总的来说不太推荐这种方式，并不如redis的位图来的直观好用。</p>
<p>| 1.6 选择标识符（identifier）</p>
<p>要确保所有关联表中都使用同样的类型，要精确匹配。<strong>最好使用整数，快，而且可以使用AUTO_INCREMENT，要避免使用uuid，会有6倍左右的性能下降，会导致insert和select语句很慢</strong>。</p>
<p><strong><em>因为插入的时候，会随机写到索引的不同位置，使得insert语句很慢，会导致页分裂，磁盘随机访问，以及聚簇索引碎片；select语句也会很慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方；随机值导致缓存对所有类型的查询语句效果都很差，会使得缓存赖以工作的访问局部性原理失效，如果数据都是热数据，那么缓存哪一部分到内存都没好处，如果工作集比内存大，缓存将会有很多刷新和不命中</em></strong></p>
<p>如果使用UUID，应当移除“-”符号，更好的做法应该是使用unhex函数转换uuid为16字节的数字，并且存在binary(16)的列中。检索时，通过hex()函数来格式化为十六进制。UUID虽然分布也不均匀，但还是有一点顺序，但是还是不如递增的整数好用。</p>
<p>| 2. schema设计中的陷阱（应当避免）</p>
<ol>
<li><p>太多的列</p>
<p> MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，单然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。</p>
</li>
<li><p>太多的关联</p>
<p> MySQL限制了每个关联操作最多只能有61张表，同时，最好在12个表以内做关联。</p>
</li>
<li><p>全能的枚举</p>
</li>
<li>变相的枚举</li>
<li>用魔法数字代替null</li>
</ol>
<p>| 3. 数据库范式和反范式</p>
<p>三范式如下：</p>
<p>1．第一范式(确保每列保持原子性)</p>
<p>2．第二范式(确保表中的每列都和主键相关)</p>
<p>3．第三范式(确保每列都和主键列直接相关,而不是间接相关)</p>
<p>范式化的优点很明显：</p>
<ol>
<li>范式化的更新操作通常比反范式化更快</li>
<li>很少或者没有重复数据，只需要修改更少的数据</li>
<li>表更小，能更好的放内存里，执行起来会更快</li>
<li>更好的distinct和group by语句</li>
</ol>
<p>缺点也很明显：</p>
<ol>
<li>干个啥都得关联查询</li>
<li>稍微复杂一点的语句在schema上都可能至少需要一次关联</li>
</ol>
<p>反范式化的优点</p>
<ol>
<li>避免关联，对查询来说是极大的优化</li>
<li>能使用更有效的缓存策略</li>
</ol>
<p>| 缓存表和汇总表</p>
<p>| 物化视图</p>
<p>| 计数器表</p>
<p>更新的时候核能会碰到并发问题，记录会有一个全局的互斥锁，使得一些事务只能穿行执行，可以将数据保存为多行，随机选择一行进行更新，获得更高的并发更新性能。</p>
<p>| 5. 加快 alter table 操作的速度</p>
<p>使用alter column改变列，防止表重建，会直接修改.frm文件</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询性能剖析</title>
    <url>/2020/12/16/Book%20Nodes/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/1-MySQL%E6%9F%A5%E8%AF%A2%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>首先，也是最重要的一点，需要记录慢查询日志，然后针对日志，进行分析。假设已经定位到问题是查询语句的问题，如果不是，需要自顶而下进行考虑，外部接口慢？文件解析慢？正则滥用？还是暴力搜索算法等。</p><a id="more"></a>
<p>剖析工具</p>
<p>| Profile分析</p>
<p>profile分析最重要的还是在语句执行期间剖析服务器的具体操作，当一条查询到了数据库后，会记录信息到一张临时表，并且给一个整数的id作为标识符，方便查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nicer_but_slower_film_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span> ;</span><br><span class="line"><span class="comment"># show prifiles 会显示出刚刚那条查询语句的查询id，获取到后</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="comment"># 会打印出这条查询的详细信息，由于打印出来的信息不太直观，可以优化一下，如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @query_id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> state,</span><br><span class="line">       <span class="keyword">sum</span>(<span class="keyword">duration</span>)            <span class="keyword">as</span> total_r,</span><br><span class="line">       <span class="keyword">round</span>(<span class="number">100</span> * <span class="keyword">sum</span>(<span class="keyword">duration</span>) /</span><br><span class="line">             (<span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">duration</span>) <span class="keyword">from</span> information_schema.PROFILING <span class="keyword">where</span> QUERY_ID = @query_id), <span class="number">2</span></span><br><span class="line">           )                    <span class="keyword">as</span> pct_r,</span><br><span class="line">       <span class="keyword">count</span>(*)                 <span class="keyword">as</span> calls,</span><br><span class="line">       <span class="keyword">sum</span>(<span class="keyword">duration</span>) / <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="string">"r/call"</span></span><br><span class="line"><span class="keyword">from</span> information_schema.PROFILING</span><br><span class="line"><span class="keyword">where</span> QUERY_ID = @query_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> state</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total_r <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>这个工具能告诉我们哪些活动花费了很长时间，但是并不会告诉我们为什么，还是需要我们具体情况具体分析。</p>
<p>| show status  || show global status</p>
<p>这个工具只是一个计数器，但是并不是剖析工具，用来显示一些活动的频繁程度，但是无法给出消耗了多少时间。只有一条信息显示的是操作时间(Innodb_row_lock_time)，而且是全局的，无法测量会话级别。</p>
<p>虽然无法知道哪些操作耗时最长，但是可以猜测。最有用的句柄计数器(handle counter)，临时文件和表计数器。示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">status</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nicer_but_slower_film_list;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">where</span> Variable_name <span class="keyword">like</span> <span class="string">'Handler%'</span> <span class="keyword">or</span> Variable_name <span class="keyword">like</span> <span class="string">'Created%'</span>;</span><br></pre></td></tr></table></figure>
<p>从执行结果中可以看到，使用了三张临时表，其中两个磁盘临时表，而且有很多没有用到索引的读操作(Handler_read_rnd_next)，这个查询有可能是使用了join多表关联查询，但是没有合适的索引，或者是一个子查询创建了临时表，并且和其他表做联合查询，而用于保存子查询结果的临时表没有索引等。</p>
<p>show status 可以类比为explain，它们两者可以得到相似的结果，但是explain是预估的结果，而show status是精确测量的结果，比如explain无法告诉你临时表是否是磁盘表还是内存临时表。</p>
<p>| performance_schema</p>
<p>performance_schema无法提供查询阶段的细节和计时信息，但是，能够知道其他很多有意思的信息，比如：user_variables_by_thread, global status,global_variables,session_variables等，可以用排错或者定位问题使用</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-RabbitMQ</title>
    <url>/2020/12/16/Interview/RabbitMQ/</url>
    <content><![CDATA[<ol>
<li><p>知道MQ么，MQ是什么，MQ的作用是什么？</p>
<p> Message Queue，顾名思义，消息队列，基于生产者-消费者模式。作用可分为下面几点，但是MQ在单机环境下并不适用，更加适用于多系统，多服务的环境。</p>
<ul>
<li>异步处理，提高系统吞吐量</li>
<li>应用解耦，不用关系其他系统怎么处理</li>
<li>流量削峰，缓解短时间内的高并发请求，可通过控制mq长度来处理</li>
<li>消息通讯，聊天室，点对点传输等</li>
<li>日志处理，解决大量日志传输 </li>
<li>详细回答……</li>
</ul>
</li>
<li><p>MQ的缺点是什么？</p>
<ul>
<li>增加系统复杂性</li>
<li>降低系统可用性</li>
<li>数据一致性</li>
<li>详细回答</li>
</ul>
</li>
<li><p>RabbitMQ 和 其他MQ之间的区别有哪些？为什么选择RabbitMQ？</p>
<ul>
<li>虽然是Erlang开发，但是有很高的社区活跃度，可以保证可用性以及bug修复的及时性，国内外已经有很多公司使用rabbitMQ，并且有了很好的工程实践</li>
<li>有良好的的web管理界面</li>
<li>对于MQ没有特别强烈的定制需求，已有功能足以满足业务需求</li>
</ul>
</li>
<li><p>RabbitMQ有哪些常见问题？如何避免这些问题？</p>
<ul>
<li>消息的乱序问题</li>
<li>消息的重复发送问题</li>
</ul>
</li>
<li><p>Rabbit的工作模式</p>
<ol>
<li>simple模式，最简单的收发模式</li>
<li>消费者监听模式（customer）</li>
<li>work工作模式，信息被消费者竞争</li>
<li>publish/subscribe 发布/订阅模式，每个消费者监听自己的队列</li>
<li>routing 路由模式</li>
<li>topic 模式</li>
</ol>
</li>
<li><p>如何保证信息消费时的幂等性？</p>
</li>
<li><p>如何保证消息的可靠传输？</p>
</li>
<li><p>消息队列满了怎么处理？过期失效怎么办？有消息积压怎么办？</p>
</li>
</ol>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity 负载均衡</title>
    <url>/2020/12/15/Spring%20Security/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>想弄一下SpringSecurity的负载均衡是怎么实现的，就找了找资料，在此记录一下。</p><p>首先，需要两个依赖：</p><a id="more"></a>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation(<span class="keyword">group</span> = <span class="string">"org.springframework.boot"</span>, name = <span class="string">"spring-boot-starter-data-redis"</span>)</span><br><span class="line">implementation(<span class="keyword">group</span> = <span class="string">"org.springframework.session"</span>, name = <span class="string">"spring-session-data-redis"</span>, version = <span class="string">"2.4.1"</span>)</span><br></pre></td></tr></table></figure>
<p>引入这两个依赖之后，需要在properties或者yaml里配置一下redis的路径和端口，默认为127.0.0.1和6379，但是由<code>RedisAutoConfiguration</code>可知，需要配置spring.redis的相关属性后，才会生效，因此虽然有默认值，还是写一下吧。。。</p>
<p>然后配置nginx的upstream：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcat &#123;</span><br><span class="line">		<span class="attribute">server</span> localhost:<span class="number">8080</span>;</span><br><span class="line">		<span class="attribute">server</span> localhost:<span class="number">8081</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://tomcat;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了之后，先生成个jar包，然后使用<code>--server.port=8080</code>的方法，启动两个实例。这时，我们请求接口的话，就能看到打印的sessionId是一致的，且两个实例轮流打印日志，说明负载均衡配置成功。同时查看redis，session信息已经保存了进去。</p>
<p>图在这里。</p>
<p>| tips</p>
<p>还是有点地方需要注意</p>
<ol>
<li>如果项目中有缓存，不要使用直接基于内存的，比如静态的hashmap等，最好使用第三方的分布式缓存工具，比如memcached，redis等，否则，原有的缓存会失效，一致性也会无法得到保证</li>
<li><p>有个地方很坑，如果想获取所有在线用户的话，注册<code>sessionRegistry</code>获取，<code>spring-sessoin</code>的实现类是<code>SpringSessionBackedSessionRegistry</code>，然后点进去源码一看</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getAllPrincipals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"SpringSessionBackedSessionRegistry does not support retrieving all principals, "</span> +</span><br><span class="line">            <span class="string">"since Spring Session provides no way to obtain that information"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 大爷的，咋就不能用了，从redis查一下不就好了，如果有使用在线用户方法的，需要避免这个问题。。。同样，使用第三方来管理session吧，或者重写它的方法，手动从redis中查询也可以。</p>
</li>
<li>获取当前登录用户是没问题的</li>
<li>登录的时候，会把当前实现了UserDetais的实体序列化到redis中，一定要实现Serializable接口，不然会报错，或者可以手动修改序列化的方式，改为json，但是如果是json的话，需要避免循环依赖导致OOM的问题.</li>
</ol>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-Redis篇章</title>
    <url>/2020/12/06/Interview/Redis/</url>
    <content><![CDATA[<ol>
<li><p>Redis常见的数据类型有哪些？</p>
<p>String,List,hash,set,zset</p>
</li>
<li><p>解释一下redis的二进制安全</p>
<p>需要客户端给它字节数组</p>
</li>
</ol>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-MySQL篇</title>
    <url>/2020/11/16/Interview/MySQL/</url>
    <content><![CDATA[<h3><span id="想提升还是得连环炮方式的提问">想提升，还是得连环炮方式的提问</span></h3><ol>
<li><p>你们对线上的数据有没有做一些优化？怎么优化的？</p>
<ol>
<li><p>如果回答的是索引</p>
<ol>
<li><p>来说一说什么是索引？有哪几种索引？索引有什么优点？</p>
<p>用于存储引擎快速找到记录的一种数据结构，存储引擎会先在索引中找到对应值，然后根据匹配的索引记录找到对应的记录行，索引可以包含一个或者多个列的值</p>
<p>B-Tree索引，（准确的说是B+Tree，B-Tree和B+Tree有什么区别？）哈希索引，空间数据索引，全文索引，分行树索引</p>
<p>优点：1.大大减少服务器需要扫描的数据量，2.可以帮助服务器避免排序和临时变，3.索引可以将随机IO变为顺序IO。</p>
</li>
<li><p>这些索引采取的是哪种数据结构？</p>
<p>B-Tree索引用的B+Tree，哈希索引用的哈希表</p>
</li>
<li><p>为什么采取B+Tree？这种数据结构有什么好处么？</p>
<p>B+Tree对索引列是按照顺序组织存储的，适用于<strong>全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引的查询</strong>。因为节点有序，还可用于查询中的order by操作。</p>
<p>但是，如果<strong>不是按照索引的最左列开始查找，则无法使用索引；不能跳过索引中的列；如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</strong>。</p>
</li>
<li><p>和哈希表相比，有什么优点或者有什么不同？</p>
<p>Hash索引基于哈希表，会在哈希表中保存指向每个数据行的指针，<strong>只有精确匹配索引所有列的查询才有效</strong>。但是Hash并不是就一定会很快，因为hash值重复的话，会以链表的方式存放多个记录指针到一个条目中，所以说，极端情况下，会变成为链表。</p>
<p>B+ Tree索引和Hash索引区别 哈希索引适合等值查询，但是无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
</li>
<li><p>MySQL中B+Tree的叶子节点能存什么东西？</p>
<p>首先，叶子节点会有索引列的数据，其次，B+Tree的叶子节点会保存数据行，MySQL中会保存数据库表的聚簇索引，主键（如果没有，首先会选择一个唯一的非空索引来代替，如果还没有，会隐式定义一个主键作为聚簇索引），然后会根据主键，进行回表，获取所需数据。</p>
</li>
<li><p>什么是聚簇索引和非聚簇索引？</p>
<p>聚簇索引将<strong>索引和数据放在同一行</strong>，非聚簇索引将<strong>索引和数据分开存放</strong>。</p>
<p>一个表仅有一个聚簇索引</p>
<p>聚簇索引的插入速度依赖于插入顺序，如果使用UUID，可能导致插入页分裂降低速度。</p>
<p>更新主键（聚簇索引）的时候，会导致被更新的行移动</p>
<p><strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>
</li>
<li><p>查询的时候有什么区别？</p>
<p>当取一定范围内的数据时，聚簇索引相比较非聚簇索引也会更快</p>
<p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>
<p>因为非聚簇索引查询时，会先扫描一遍B+Tree，获取到叶子节点的主键ID，然后根据ID进行回表，而聚簇索引，会包含整行数据，每次会把共同一个页的数据都加载到内存里，读取同一页的数据，避免了磁盘查找，速度会更快。同时，使用ID获取数据时，会更快。少了一次根据ID回表的过程。但是，比如有一个code，普通索引，查询这个code的时候，应为不需要获取其他数据，少了回表的过程，应该也算是聚簇索引。</p>
<blockquote>
<p>覆盖索引 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol><a id="more"></a>
<pre><code>  8. 联合索引是怎么使用的？为什么使用联合索引？说一说最左前缀匹配

     给需要查询的列，或者是需要排序的列，添加联合索引，比如说(k1,k2,k3)这么一个联合索引，会相当于(k1),(k1,k2),(k1,k2,k3)三个索引，这就是最左前缀匹配。

  9. 各个MySQL版本中，对索引有哪些方面的优化？

     5.6版本的MySQL做了索引下推。

     people表中（zipcode，lastname，firstname）构成一个索引

     SELECT * FROM people WHERE zipcode=&#39;95054&#39; AND lastname LIKE &#39;%etrunia%&#39; AND address LIKE &#39;%Main Street%&#39;;

     如果没有使用索引下推技术，则MySQL会通过zipcode=&#39;95054&#39;从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE &#39;%etrunia%&#39;和address LIKE &#39;%Main Street%&#39;来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=&#39;95054&#39;的索引，然后根据lastname LIKE &#39;%etrunia%&#39;和address LIKE &#39;%Main Street%&#39;来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

  10. 通过什么情况，能知道是否走了索引？

     使用explain语句进行分析

  11. 什么情况下会发生创建了索引，但是没有走索引的情况？

      查询发生隐式转换，比如数据库定义的是string，但是查询的时候使用的是int

      对索引列进行运算，导致索引失效

      使用&lt;&gt;，not in , not exist 等会导致索引失效

      如果变量为空，使用 = null ，会导致索引失效

      查询优化器 一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个，可能会优化器认为全表扫描的代价小于使用索引

  12. 不同类型的值，比如说varchar，int，等，使用索引会有什么变化？

      如果column定义的为是varchar，但是查询使用的是int，会走索引

      如果column定义的是int，查询用的是string，存在隐式转换，不会走索引
</code></pre><ol>
<li><p>加缓存，memcache，redis等</p>
<p>memcache，redis等问题放到其他章节</p>
</li>
<li><p>主从复制，或者主主复制，读写分离</p>
<ol>
<li>MySQL复制的方法有哪几种？分别有什么优缺点？</li>
<li>主从的延迟问题你们怎么解决？</li>
<li>解释一下半同步复制和并行复制</li>
<li>MySQL能否一主多从？或者多主多从？</li>
</ol>
</li>
<li><p>分区表</p>
<ol>
<li>解释一下分区表，有哪几种类型？</li>
<li>分区表的优缺点？</li>
</ol>
</li>
<li><p>分库分表</p>
<ol>
<li>分库分表有哪几种类型？你们平时都是怎么处理的？</li>
<li>水平分表和垂直分表的优缺点？</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>React中碰到的生命周期问题</title>
    <url>/2020/11/09/Frontend/React/01/</url>
    <content><![CDATA[<p>先上代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  componentWillMount() &#123;</span><br><span class="line">    const &#123; params &#125; = this.props.location;</span><br><span class="line">    const &#123; dispatch &#125; = this.props;</span><br><span class="line">    if (params?.id) &#123;</span><br><span class="line">      roleDetail(params.id).then((role) =&gt; &#123;</span><br><span class="line">        if (dispatch) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: &apos;roleForm/saveRoleBasic&apos;,</span><br><span class="line">            payload: role,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">getCurrentStepAndComponent = (current?: string) =&gt; &#123;</span><br><span class="line">    switch (current) &#123;</span><br><span class="line">      case &apos;permission&apos;:</span><br><span class="line">        return &#123; step: 1, component: &lt;RolePermission/&gt; &#125;;</span><br><span class="line">      case &apos;complete&apos;:</span><br><span class="line">        return &#123; step: 2, component: &lt;RoleComplete/&gt; &#125;;</span><br><span class="line">      case &apos;basic&apos;:</span><br><span class="line">        return &#123; step: 0, component: &lt;RoleBasic/&gt; &#125;;</span><br><span class="line">      default:</span><br><span class="line">        return &#123; step: 3, component: &lt;RoleBasic/&gt; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; step, component &#125; = this.getCurrentStepAndComponent(this.props.current);</span><br><span class="line">    return &lt;&gt;</span><br><span class="line">      &lt;Card bordered=&#123;false&#125; bodyStyle=&#123;&#123; padding: 73 &#125;&#125;&gt;</span><br><span class="line">        &lt;Steps current=&#123;step&#125; style=&#123;&#123; marginBottom: 60 &#125;&#125;&gt;</span><br><span class="line">          &lt;Step title=&quot;角色基本信息&quot;/&gt;</span><br><span class="line">          &lt;Step title=&quot;角色权限信息&quot;/&gt;</span><br><span class="line">          &lt;Step title=&quot;完成&quot;/&gt;</span><br><span class="line">        &lt;/Steps&gt;</span><br><span class="line">        &#123;component&#125;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    &lt;/&gt;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>如代码所见，一个tab，角色保存的三个步骤，当进入Form的时候，会去获取角色ID，然后保存到saveRoleBasic里，以供第一个tab来进行角色信息的回显。代码类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  const &#123; data &#125; = this.props;</span><br><span class="line">  this.formRef.current!!.setFieldsValue(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，使用的时候发现问题，form请求了后台数据，但是页面的数据并没有如期正确回显。</p>
<p>首先能肯定的时候，后台的数据肯定是正确的，经过日志的验证，数据也确实返回去了，但是为何没有触发回显？</p>
<p>随后又加了几条日志，发现，data使用的仍然是之前的数据，除非再来一次，它才会进行刷新，这就表示，先执行的RoleBasic的componentDidMount，后执行的父类的componentWillMount，也就是说，子组件优先于父组件初始化，不过，本当如此。</p>
<p>为了解决这个问题，需要做的就是，子组件修改为在componentDidUpdate进行数据的初始化，这样的话，父类组件修改props的数据时，子类组件的componentWillMount会进行执行，数据回显就正常了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>CMS的一些记录</title>
    <url>/2020/09/22/Essay/2020/CMS%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>想要的一些功能点记录：</p><ol>
<li><p>WebSite站点配置，主要用来进行静态资源判断定位（完成）</p>
</li>
<li><p>使Organization绑定WebSite，一个机构可以绑定多个站点（完成）</p>
</li>
<li><p>使User绑定Organization，一个用户可绑定多个机构（完成）</p>
</li>
<li><p>Channel和WebSite进行绑定，Content和WebSite进行绑定（完成）</p>
</li>
<li><p>数据隔离，数据权限（完成）</p>
</li>
<li><p>前端必须得手写一个list页面（完成）</p>
</li>
<li><p>子账户进行分配权限，只能分配自己所拥有的权限（完成）</p>
</li>
<li><p>Hibernate validator 添加（完成）</p>
</li>
</ol>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2020/06/30/Language/English/New%20Concept/Chapter1/lesson67/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>greengrocer 蔬菜水果零售商<ol>
<li>grocer 零售商</li>
<li>at <strong>the</strong> greengrocer’s 在蔬菜水果零售店</li>
<li>at the butcher’s 在肉店</li>
<li>at the doctor’s 在诊所</li>
<li>at the grocer’s 在零售店</li>
</ol>
</li>
<li>absent adj. 缺席的<ol>
<li>He is absent today.</li>
<li>He is absent from school today.</li>
<li><strong>be absent from …</strong>   <strong>school / work / class…</strong></li>
<li>She is not absent from work.</li>
</ol>
</li>
<li>keep v. 保持，保留，（身体健康）处于（装填）<ol>
<li>keep healthy</li>
</ol>
</li>
<li>spend v. 度过<ol>
<li><strong>spend + 时间 + 地点</strong><ol>
<li>He spends two days in Beijing.</li>
<li>He stays in Beijing for two days.</li>
</ol>
</li>
<li><strong>spend + 时间 + with sb.</strong><ol>
<li>He spends two weeks with his girlfriend.</li>
</ol>
</li>
</ol>
</li>
<li>weekend 周末</li>
<li>country 乡村<ol>
<li>in the country 在乡下</li>
<li>in the city  在城里</li>
<li>in the village 在村里</li>
<li>国家，in my country</li>
</ol>
</li>
<li>lucky  adj. 幸运的<ol>
<li>You are so lucky!</li>
<li>You are a lucky dog.</li>
</ol>
</li>
<li>Sunday（SUN） 周日  </li>
<li>Monday（MON） 周一  </li>
<li>Tuesday（TUE） 周二 </li>
<li>Wednesday（WED） 周三 </li>
<li>Thursday（THUR） 周四 </li>
<li>Friday（FRI） 周五 </li>
<li>Saturay（SAT） 周六 </li>
<li><strong>首字母大写</strong></li>
<li><strong>on + 天</strong></li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>at <strong>the</strong> butcher<strong>‘s</strong>  在肉店<ol>
<li>Were you at the butcher’s？ 你刚刚在肉店么？</li>
<li>Were 过去式</li>
<li>Are you at the butcher’s</li>
</ol>
</li>
<li>How<strong>‘s</strong> Jimmy today?<ol>
<li>How is …?</li>
<li>How was …?</li>
<li>How has …?</li>
</ol>
</li>
<li>Was he absent from school last week?<ol>
<li>be absent from …</li>
</ol>
</li>
<li>How are you (all keeping)?</li>
<li>We’re going to spend three days in the country.<ol>
<li><strong>spend + 时间 +地点</strong></li>
</ol>
</li>
<li>at my mother’s 在我妈妈家<ol>
<li>at the butcher’s</li>
</ol>
</li>
<li>Aren’t you lucky! 你们可真幸运啊</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h5><span id="一般现在时态">一般现在时态</span></h5><ol>
<li>经常的状态<ol>
<li>主语 + is / am /are </li>
</ol>
</li>
<li>习惯的动作<ol>
<li>主语 + v.</li>
</ol>
</li>
<li>真理<ol>
<li>主语 + is / am /are</li>
<li>主语 + v</li>
</ol>
</li>
</ol>
<h5><span id="一般过去时态">一般过去时态</span></h5><ol>
<li><strong>过去</strong>的状态：<ol>
<li>主语 + was / were</li>
</ol>
</li>
<li><strong>过去的</strong>动作：<ol>
<li>主语 + v.（动词过去式）</li>
</ol>
</li>
</ol>
<p>My boyfriend is 27, he is a little fat. He is a clerk. He is in Beijing too.</p>
<p>My boyfriend was 27  last year, he was a little fat. He wes a clerk. He was in Beijing too two years ago.</p>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>church 教堂<ol>
<li>at church</li>
</ol>
</li>
<li>dairy 乳品店<ol>
<li>at the dairy</li>
</ol>
</li>
<li>baker 面包师傅<ol>
<li>at the baker’s</li>
</ol>
</li>
<li>grocer 食品杂货商<ol>
<li>at the grocer’s </li>
</ol>
</li>
<li>Where were you on Sunday, Jan. 1st?</li>
<li>I was at church.</li>
<li>When were you at the bucher’s?</li>
<li>I was at the butcher’s on Wed, Apr, 4th.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/06/29/Language/English/New%20Concept/Chapter1/lesson65/</url>
    <content><![CDATA[<a id="more"></a><ol>
<li>Dad  爸爸（口语）</li>
<li>key 钥匙<ol>
<li>门的钥匙：the key <strong>to</strong> the door</li>
<li>车的钥匙：the key <strong>to</strong> the car</li>
<li>书的颜色：the color of the book</li>
<li>张艺谋的电影：ZhangYimou’s movie</li>
</ol>
</li>
<li>baby 婴儿，宝贝<ol>
<li>baby - kid(child) - teenager</li>
<li>baby, honey, sweetheart….</li>
</ol>
</li>
<li>hear 听见<ol>
<li>Listen! Can you hear it.</li>
<li>Look! Can you see it?</li>
<li>Look for it! Can your find it?</li>
</ol>
</li>
<li>enjoy 玩的开心<ol>
<li>en- 使得</li>
<li>enlarge, endanger, enslave, enjoy…</li>
<li>过得愉快，玩的开心<ol>
<li>I enjoy my holiday.</li>
</ol>
</li>
<li>喜欢<ol>
<li>I enjoy the song very much.</li>
</ol>
</li>
<li>mum 妈妈</li>
</ol>
</li>
</ol><a id="more"></a>

<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You must be home at half past ten.<ol>
<li><strong>must / can + be + 非动词</strong></li>
<li>他能够在这呆很久。</li>
<li>He can be here for a long time.</li>
<li>他们必须9点到这。</li>
<li>They must be here at 9:90.</li>
</ol>
</li>
<li>回家<ol>
<li>be home / get home / come home / arrive home…</li>
</ol>
</li>
<li>… the key to the front door.<ol>
<li>the front door &amp; the back door</li>
<li>the key to …</li>
<li>the answer to the question</li>
<li>the exit to the building</li>
<li>the ticket to the movie</li>
</ol>
</li>
<li>年龄的表达<ol>
<li>… years old</li>
<li>…year -old</li>
<li>19岁：nineteen years old / nineteen-year-old</li>
</ol>
</li>
<li>Enjoy yourself. 玩的开心<ol>
<li>Enjoy your holiday.</li>
<li>Enjoy your class.</li>
<li>Enjoy your dinner party.</li>
<li>Have a nice day.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="反身代词">反身代词</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>我（们）自己</th>
<th>你（们）自己</th>
<th>他自己</th>
<th>她自己</th>
<th>它自己</th>
</tr>
</thead>
<tbody>
<tr>
<td>单数</td>
<td>myself</td>
<td>yourself</td>
<td>himself</td>
<td>herself</td>
<td>itself</td>
</tr>
<tr>
<td>复数</td>
<td>ourselves</td>
<td>yourselves</td>
<td>themselves</td>
<td>themselves</td>
<td>themselves</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>英语中为什么有反身代词</li>
<li>何时用？<ol>
<li>强调主语 &amp; 宾语<ol>
<li>He <u>himself</u> sent me a gift.他亲自送我一件礼物</li>
<li>I see JayChou himself.</li>
</ol>
</li>
<li>不言而喻的宾语<ol>
<li>Take good care of <u>yourself</u>.</li>
<li>Enjoy <strong>yourself</strong>.</li>
</ol>
</li>
<li>用法？<ol>
<li>介词+反身代词<ol>
<li><strong>by oneself 独自</strong></li>
<li>I’m going to swim by myself.</li>
<li>He’s going to learn English by himself.</li>
<li><strong>between oneself  私下</strong></li>
<li>It’s just between ourselves.</li>
</ol>
</li>
<li>动词 + 反身代词<ol>
<li><strong>enjoy oneself 玩的开心，过得愉快</strong></li>
<li>They enjoy themselves.</li>
<li><strong>help oneself 随意</strong></li>
<li>Help yourselves, please.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><p>What’s the time?</p>
<ol>
<li><p><strong>past 过</strong></p>
</li>
<li><p><strong>to 差</strong></p>
</li>
<li><p><strong>a quarter 15分钟</strong>  </p>
</li>
<li><p>时间的读法</p>
<ol>
<li>3:00 three o’clock</li>
<li>7:30 seven thirty</li>
<li>half past seven</li>
<li>half to eight</li>
<li>4:20 four twenty</li>
<li>twenty past four</li>
<li>forty to five</li>
<li>10:15 ten fifteen</li>
<li>fifteen past ten</li>
<li>a quarter past ten</li>
<li>2:45 two forty five</li>
<li>forty five past two</li>
<li>three quarters past two</li>
<li>fifteen to three</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 63</title>
    <url>/2020/06/29/Language/English/New%20Concept/Chapter1/lesson63/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>better adj. 形容词well的比较级<ol>
<li>good-better-well</li>
<li>I’m well.   I’m better.</li>
</ol>
</li>
<li>certainly  adv.当然</li>
<li>get up 起床<ol>
<li>go to bed /  go to sleep</li>
<li>三单形式：</li>
<li><strong>gets up / goes to bed / goes to sleep</strong></li>
</ol>
</li>
<li>yet adv. 还，仍<ol>
<li>否定，疑问句末</li>
<li>你还不能去上班呢</li>
<li>You can’t go to work yet.</li>
<li>He can’t drive yet.</li>
</ol>
</li>
<li>rich adj. 油腻的<ol>
<li>rich food 油腻的食物</li>
<li>a rich man  一个富有的人</li>
<li>rich silk  华丽的丝绸</li>
<li>rich land 肥沃的</li>
</ol>
</li>
<li>food 食物<ol>
<li>rich food. 油腻的食物</li>
<li>mild food.  清淡的食物</li>
<li>spicy food. 辛辣的食物</li>
<li>green food 绿色食品</li>
<li>fast food 快餐</li>
<li>sea food 海鲜</li>
</ol>
</li>
<li>remain v. 保持，继续<ol>
<li>remain in bed.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You <u>look</u> very <u>well</u>.<ol>
<li>感官动词 - adj.</li>
<li>你看起来很开心啊。</li>
<li>You look very happy.</li>
<li>He looks very busy.</li>
</ol>
</li>
<li>你现在好多了，但你还不能去上学呢。<ol>
<li>You are better now, but you mustn’t go to school yet.</li>
<li><strong>yet，否定疑问句末</strong></li>
<li><strong>mustn’t，绝对不可以</strong></li>
</ol>
</li>
<li>你必须再卧床两天。<ol>
<li>You must stay in bed two days again.    Wrong.</li>
<li>again 再一次地<ol>
<li>Try again.  Say it again.</li>
<li>another two days</li>
</ol>
</li>
<li>two days</li>
<li><strong>for + two days</strong>    <strong>for + 时间段，长达</strong></li>
<li><strong>at + 点</strong></li>
<li><strong>on + 天</strong></li>
<li><strong>in + 月，季，年</strong></li>
<li>You must stay in bed for another two days.  Right</li>
<li>我必须在北京再戴两周</li>
<li>我们必须再学两年英语</li>
</ol>
</li>
<li>have a temperature<ol>
<li>have a fever</li>
<li><strong>三单：has</strong><ol>
<li>He has a fever.</li>
<li>Do you have a fever.</li>
<li>Does he have a fever.</li>
<li>I don’t have a fever.</li>
<li>He doesn’t have a fever.</li>
</ol>
</li>
</ol>
</li>
<li>卧床<ol>
<li>stay in bed</li>
<li>remain in bed</li>
</ol>
</li>
<li>他每天可以起床大约两小时<ol>
<li>He every day can get up abour two hours.   Wrong.</li>
<li><strong>谁？干什么？</strong></li>
<li><strong>for +时间段，长达</strong></li>
<li>He can get up for about two hours every day.</li>
<li>every day &amp; each day</li>
<li><strong>every 整体</strong></li>
<li><strong>each 个体</strong></li>
<li>Hi, every one!</li>
<li>Each man has his own name.</li>
</ol>
</li>
<li>You must keep the room warm.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="must">must</span></h4><ol>
<li>疑问：<ol>
<li>我必须清扫屋子么？</li>
<li>Must I clean the room?</li>
</ol>
</li>
<li>否定：<ol>
<li>I mustn’t clean the room.     Wrong.</li>
<li><strong>mustn’t 绝对不可以，禁止</strong></li>
<li>你绝对不可以在这里大吵</li>
<li>You mustn’t make noise here.</li>
<li>你绝对不可以在这吸烟</li>
<li>You mustn’t smoke here.</li>
<li>I <strong>don’t neet to</strong> clean the room.</li>
<li><strong>dont’t neet to… 不必，不需要</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>play v. 完<ol>
<li>play games  玩游戏</li>
<li>play the violin 弹奏，拉琴</li>
<li>play football / basketball 打球，踢球</li>
</ol>
</li>
<li>match 火柴<ol>
<li>matches </li>
</ol>
</li>
<li>talk 谈话<ol>
<li>talk to sb. 与…谈话</li>
<li>Don’t talk to me like that!</li>
<li>Don’t talk to strangers.</li>
</ol>
</li>
<li>library 图书馆<ol>
<li>in the library</li>
</ol>
</li>
<li>drive<ol>
<li>drive the car</li>
</ol>
</li>
<li>so adv. 如此的<ol>
<li>so beautiful / so much</li>
</ol>
</li>
<li>quickly adv. 快的<ol>
<li>He drives so quickly.</li>
</ol>
</li>
<li>lean out of 身体探出<ol>
<li>lean  倾斜，偏向，弯斜</li>
<li>lean out of the window</li>
</ol>
</li>
<li>break v.打破</li>
<li>noise n. 喧闹声<ol>
<li>发出噪音</li>
<li><strong>make the noise</strong></li>
<li><strong>have make take get</strong></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 61</title>
    <url>/2020/06/28/Language/English/New%20Concept/Chapter1/lesson61/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>feel 感觉</li>
<li>look 看起来</li>
<li>must 必须</li>
<li>call 叫、请</li>
<li>doctor  医生</li>
<li>telephone 电话<ol>
<li>call sb.</li>
<li>phone sb.</li>
<li>give sb. a call</li>
<li>give sb. a phone</li>
</ol>
</li>
<li>remember 记得，记住，想起来了<ol>
<li>Do you remember?</li>
<li>oh, yeah, I remember.</li>
</ol>
</li>
<li>mouth 嘴巴</li>
<li>tongue 舌头<ol>
<li>Tongue twister 绕口令</li>
</ol>
</li>
<li>bad 严重的<ol>
<li>a bad cold：严重的感冒</li>
</ol>
</li>
<li>cold 感冒<ol>
<li>a cold day  寒冷的一天</li>
<li>a cold handshake 冷淡的，不热情</li>
<li>the cold color 冷色调</li>
</ol>
</li>
<li>news 消息<ol>
<li>a piece of news</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>in bed （生病卧床）<ol>
<li>He is in bed.</li>
<li>He is in the bed.</li>
<li>in hospital,  in the hospital</li>
</ol>
</li>
<li>What’s the matter with him?<ol>
<li>What’s the matter <strong>with</strong> sb.?</li>
<li>What’s wrong with sb.?</li>
<li>What’s up?</li>
</ol>
</li>
<li>所以他必须在床上待一周<ol>
<li>So he must stay in bed for a week.</li>
<li><strong>for +段时间，表示长达</strong></li>
<li>I have classes for eight hours today.</li>
<li>He must stay in Beijing for ten years.</li>
</ol>
</li>
<li>That’s good news for Jimmy.<ol>
<li>for ， 对于某人来说</li>
<li>English is very easy for him.</li>
<li>It is to dry for her to stay in Beijing.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="感官动词">感官动词</span></h4><ol>
<li>sound</li>
<li>look</li>
<li>smell</li>
<li>feel</li>
<li>taste</li>
</ol>
<h5><span id="感官动词-半系动词">感官动词 - 半系动词</span></h5><ol>
<li>一半实义动词<ol>
<li>do - does, drink - drinks</li>
<li>look - looks , sound - sounds, feel - feelds, smell - smells, taste - tastes</li>
</ol>
</li>
<li>一半系动词<ol>
<li>She is <u>listening</u> to music <strong>carefully</strong>.</li>
<li>I <u>eat</u> my breakfast <strong>quickly</strong>.</li>
<li><strong><u>实义动词=&gt;副词   感官动词=&gt;形容词</u></strong></li>
<li>You <u>look</u> <strong>young</strong>.</li>
<li>It <u>tastes</u> <strong>good</strong>.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>headache 头疼</li>
<li>earache 耳朵疼</li>
<li>toothache 牙疼</li>
<li>stomach ache 胃疼<ol>
<li><strong>ache - 表示疼痛，长时间的疼痛</strong></li>
</ol>
</li>
<li>backache 背疼<ol>
<li>v.  My head aches. 我头疼</li>
<li>have a headache</li>
<li>have a toothache</li>
<li>have a cold</li>
</ol>
</li>
<li>flu 流感</li>
<li>bird flu  禽流感</li>
<li>swine flu 猪流感<ol>
<li>Have flu / have bird flu…</li>
</ol>
</li>
<li>measles 麻疹<ol>
<li>have measles</li>
</ol>
</li>
<li>mumps 腮腺炎<ol>
<li>have mumps</li>
</ol>
</li>
<li>dentist 牙医<ol>
<li>scientist 科学家</li>
<li>tourist 旅行的人</li>
<li>typist 打字员</li>
</ol>
</li>
<li>medicine 药（不可数）</li>
<li>temperature 温度<ol>
<li>have a temperature / fever 发烧</li>
</ol>
</li>
</ol>
<h5><span id="生病amp解决办法">生病&amp;解决办法</span></h5><ol>
<li>He has a headache. What must he do?<ol>
<li>He must <strong>take</strong> an aspirin.</li>
</ol>
</li>
<li>The baby has a temperature. What must we do?<ol>
<li>He must see the doctor.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 59</title>
    <url>/2020/06/28/Language/English/New%20Concept/Chapter1/lesson59/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>envolope 信封</li>
<li>writing paper 信纸<ol>
<li>a piece of writing paper</li>
<li>two pieces of writing paper</li>
</ol>
</li>
<li>shop assistant 售货员</li>
<li>size  尺寸，尺码，大小<ol>
<li>S/M/L</li>
<li>S - small</li>
<li>M - medium </li>
<li>L - large</li>
<li>XS - extra small</li>
<li>XL - extra large</li>
<li>small / medium / large size</li>
<li>size 6 / 7…</li>
</ol>
</li>
<li>Pad  信笺薄</li>
<li>glue 胶水<ol>
<li>a bottle of ~</li>
</ol>
</li>
<li>chalk 粉笔</li>
<li>change 零钱，找给的钱<ol>
<li>small change,   keep the change </li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>买东西时用来询问的句型：<ol>
<li>I want some …</li>
<li>Do you have any … ?</li>
<li>n. + please</li>
</ol>
</li>
<li>一盒粉笔    a box of chalk<ol>
<li>一大盒粉笔：a large box of chalk</li>
<li>一瓶可乐：a bottle of cola</li>
<li>一大瓶可乐：a large bottle of cola</li>
</ol>
</li>
<li>only   adv.  仅仅，只有<ol>
<li>I have two watches.</li>
<li>I <strong>only</strong> have two watches.</li>
<li>I have <strong>only</strong> two watches.</li>
</ol>
</li>
<li>I only have large ones.<ol>
<li>ones - large pads</li>
</ol>
</li>
<li>That’s all, thank you.<ol>
<li>就这些了，谢谢！</li>
<li>That’s all, thank you for your listening.</li>
<li>使用时机<ol>
<li>发言完毕时；</li>
<li>讲课结束时；</li>
<li>购物时…</li>
</ol>
</li>
</ol>
</li>
<li>What else?<ol>
<li>Who else?</li>
<li>Which else?</li>
<li>Where else?</li>
<li>What else do you want?</li>
<li>Who else do you like?</li>
<li>Which else is your favorite?</li>
<li>Where else do you want to go?</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="数词">数词</span></h4><h5><span id="整十">整十</span></h5><p>one, two , three, four , five , six, seven , eight, nine, ten , eleven , twelve</p>
<p>thir<strong>teen</strong>, four<strong>teen</strong> , fif<strong>teen</strong>,  six<strong>teen</strong>, seven<strong>teen</strong>, eigh<strong>teen</strong>, nine<strong>teen</strong></p>
<p>twen<strong>ty</strong> thir<strong>ty</strong>  for<strong>ty</strong>  fif<strong>ty</strong>   fix<strong>ty</strong>  secen<strong>ty</strong> eigh<strong>ty</strong>  nine<strong>ty</strong></p>
<h5><span id="非整十">非整十</span></h5><p>23: twenty - three    36: thirty-six   42:fouth-two   57:fifty-seven</p>
<p>64:sixty-four  78:seventy-eight   85:eight-five   91:ninety-one</p>
<h5><span id="点钟的读法">点钟的读法</span></h5><p>3:10  three ten </p>
<p>10:20 ten twenty</p>
<p>6:15 six fifteen</p>
<p>8:30 eight thirty</p>
<p>4:53 four fifty-three</p>
<p>12:49 tweleve forty-nine</p>
<h5><span id="日期的读法">日期的读法</span></h5><p>第一：first，第二：second，第三：third，第四：forth，第五：fifth，第六：sixth</p>
<p>第七：seventh，第八：eighth，第九：ninth，第十：tenth，第十一：eleventh，第十二：twelfth</p>
<p>第十三：thirteenth  第二十：twentieth  第二十一：twenty-first  第二十二：twenty-second </p>
<p>第二十三：thenty - third  第二十四：twenty-forth  第二十五：twenty-fifth</p>
<p>第三十：thirtieth   第三十一：thirty-first  第三十二：thirty-second  第三十三：thirth-third</p>
<p>8月2日：Aug.2nd.    </p>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>Do you have any …?<ol>
<li>+可数名词复数<ol>
<li>friends / envelopes / bananas…</li>
</ol>
</li>
<li>+不可数名词<ol>
<li>coffee /  tea / time…</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 57</title>
    <url>/2020/06/27/Language/English/New%20Concept/Chapter1/lesson57/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>o’clock 点钟，整点<ol>
<li>8点整 eight o’clock</li>
</ol>
</li>
<li>shop 商店（规模较小，出售同一类商品）<ol>
<li>department store （美） store （英） 百货商店</li>
</ol>
</li>
<li>moment 片刻，瞬间<ol>
<li>at the moment 此刻</li>
<li>She is learning English at the moment.</li>
<li>Wait a moment = Wait a minute.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>It is …<ol>
<li>天气</li>
<li>点钟</li>
<li>电话</li>
<li>示例<ol>
<li>春天天气很糟糕。It is terrible in spring.</li>
<li>现在是八点整。It is eight o’clock now.</li>
<li>是我，Venus。 It’s me, Venus.</li>
</ol>
</li>
</ol>
</li>
<li>The children go to school <strong>by car</strong> every day.<ol>
<li>on foot </li>
<li>by bike</li>
<li>by bus</li>
<li>by car</li>
<li>By train</li>
<li>by air</li>
<li>你是怎么去学校的？</li>
<li>How do you go to school?</li>
</ol>
</li>
<li>But today, they <u>are going to</u> school on foot.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="一般现在时-amp-现在进行时">一般现在时 &amp; 现在进行时</span></h4><ol>
<li>使用情况不同<ol>
<li>一般现在：习惯的状态，经常的动作，真理</li>
<li>现在进行：此时此刻正在做，一段时间内一直</li>
</ol>
</li>
<li>结构不同<ol>
<li>一般现在：主语 + is / am / are ，主语+v</li>
<li>现在进行：主语 + is / am / are + doing</li>
</ol>
</li>
<li>时间状语不同<ol>
<li>一般现在：every … always, usually, often , sometimes…</li>
<li>现在进行：now, at the moment…</li>
</ol>
</li>
<li>示例<ol>
<li>我通常12点吃饭，但今天都这会了，2点才吃呢</li>
<li>I usually have lunch at 12.AM. But I am having lunch now at 2.PM</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>What’s the time?<ol>
<li>What’s time is it?<br>2.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 55</title>
    <url>/2020/06/26/Language/English/New%20Concept/Chapter1/lesson55/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>live v. 住，生活<ol>
<li>长期居住</li>
<li>live + at   小</li>
<li>live + in   大</li>
<li>She lives at 23 Haidian Street.</li>
<li>I live in Beijing.</li>
<li>live - evil adj.  邪恶的</li>
</ol>
</li>
<li>stay v. 待在，停留<ol>
<li>短暂停留</li>
<li>stay + at 小</li>
<li>stay + in 大</li>
<li>stay at home</li>
<li>stay at the hotel</li>
<li>stay in New York</li>
</ol>
</li>
<li>arrive 到达<ol>
<li>arrive + at 小</li>
<li>arrive + in  大</li>
<li>He arrives at the classroom early.</li>
<li>I arrive in Shanghai late.</li>
</ol>
</li>
<li>home <ol>
<li>n. 家</li>
<li>adv. 在家，到家</li>
</ol>
</li>
<li>housework 家务<ol>
<li>homework 家庭作业</li>
<li>不可数</li>
<li>do some housework / homework</li>
<li>She never does the housework.</li>
</ol>
</li>
<li>lunch n. 午饭<ol>
<li>breakfast 早饭</li>
<li>dinner / supper 晚饭</li>
<li>eat / have breakfast / lunch / dinner / supper</li>
</ol>
</li>
<li>afternoon 下午<ol>
<li>after 之后</li>
<li>noon 正午</li>
<li>morning 早晨</li>
<li>evening 傍晚</li>
<li>night 夜晚</li>
<li>in the morning  / afternoon / evening</li>
<li>at night</li>
<li>an evening dress 晚礼服</li>
</ol>
</li>
<li>usually  adv. 通常<ol>
<li>usual adj. 平常的</li>
</ol>
</li>
<li>together adv. 一起<ol>
<li>他们通常一起喝咖啡。</li>
<li>They usually drink coffee together.</li>
<li>咱一块干吧！</li>
<li>Let’s do it together.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>the Sawyer family<ol>
<li>the Sawyers </li>
<li>姓…一家人</li>
<li>the  + 姓氏 + family /  the 姓氏+s</li>
<li>the Lee family</li>
<li>the Lees</li>
<li>the Smith family</li>
<li>the Smiths</li>
</ol>
</li>
<li>… live at 87 King Street<ol>
<li>海淀路9号：9 Haidian Road</li>
<li>海淀区海淀路9号：9 Haidian Road, Haidain District</li>
<li>district  行政区域</li>
<li>Chaoyang District</li>
<li>北京市海淀区海淀路9号：9 Haidian Roat, Haidian District, Beijing.</li>
<li>小 - 大</li>
<li>北京市朝阳区幸福街4号</li>
<li>4 Xingfu Stree, Chaoyang District, Beijing.</li>
</ol>
</li>
<li>动词短语<ol>
<li>go to work 去上班</li>
<li>go to school 去上学</li>
<li>take sb. to … 送…去</li>
<li>stay at home 待在家里</li>
<li>see her friends 去见朋友</li>
<li>come home from work 下班回家</li>
<li>come home from school 放学回家</li>
<li>go to bed 去睡觉</li>
<li>read newspaper 读报纸</li>
<li>watch television 看电视</li>
<li><strong>谁？干什么？</strong></li>
<li>我送妹妹去火车站。</li>
<li>I take my sister to the train station.</li>
<li>他每天都上班</li>
<li>He goes to wrod every day.</li>
<li>她经常下班回家很早</li>
<li>She often comes home from work early.</li>
<li>我通常晚上11点睡觉</li>
<li>I usually go to bed at 11:00 at night.</li>
<li>我老爸有时早上看报纸。</li>
<li>My father sometimes reads newspapers in the morning.</li>
<li>我老妈周一都呆在家里</li>
<li>My mother usually stays at home on Monday.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>home<ol>
<li>go to school</li>
<li>go to work</li>
<li>go to beg</li>
<li>go to Shanghai</li>
<li>回家<ol>
<li>go home</li>
<li>arrive home</li>
<li>come home</li>
<li><strong>没啥没to?</strong></li>
<li>adv. - v.</li>
<li>home - n.家  adv. 在家，到家</li>
<li>这是我的家</li>
<li>This is my home.</li>
</ol>
</li>
<li>表示地点的副词：<ol>
<li><strong>home / there / here / upstairs / downstairs…</strong></li>
<li>stay here</li>
<li>go there</li>
<li>come upstairs</li>
<li>go downstairs</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><strong>名词的复数</strong><ol>
<li><strong>+s</strong><ol>
<li><strong>a book - book</strong></li>
<li><strong>a cat - cats</strong></li>
<li><strong>a bottle - bottles</strong></li>
</ol>
</li>
<li><strong>辅音 + y + ies</strong><ol>
<li><strong>a lady - ladies</strong></li>
<li><strong>a baby - a babies</strong></li>
</ol>
</li>
<li><strong>s / sh / ch / x + es</strong><ol>
<li><strong>a watch - watches</strong></li>
<li><strong>a bus - buses</strong></li>
<li><strong>a dish - dished</strong></li>
</ol>
</li>
<li><strong>o + es</strong><ol>
<li><strong>a potato - potatoes</strong></li>
<li><strong>a hero - heroes</strong></li>
</ol>
</li>
</ol>
</li>
<li><strong>动词的第三人称单数</strong><ol>
<li><strong>+s</strong><ol>
<li><strong>come - comes</strong></li>
<li><strong>dust - dusts</strong></li>
<li><strong>make - makes</strong></li>
</ol>
</li>
<li><strong>辅音+ y + ies</strong><ol>
<li><strong>study - studies</strong></li>
<li><strong>try - tries</strong></li>
</ol>
</li>
<li><strong>s / sh / ch / x + es</strong><ol>
<li><strong>watch - watches</strong></li>
<li><strong>pass - passes</strong></li>
<li><strong>wish - wishes</strong></li>
</ol>
</li>
<li><strong>o + es</strong><ol>
<li><strong>go - goes</strong></li>
<li><strong>do - does</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 53</title>
    <url>/2020/06/26/Language/English/New%20Concept/Chapter1/lesson53/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>mild 温和的，温暖的<ol>
<li>It is mild in fall. 秋天天气很温和。</li>
<li>mild food 清淡的食物</li>
<li>spicy food 辛辣的食物</li>
<li>hot food 辣的食物</li>
</ol>
</li>
<li>always 总是，一直，永远</li>
<li>north 北方</li>
<li>east 东方</li>
<li>west 西方</li>
<li>south 南方<ol>
<li>in the north …</li>
<li>in the north of …</li>
</ol>
</li>
<li>news  新闻、消息<ol>
<li>East, west, home is best.</li>
</ol>
</li>
<li>wet 潮湿的<ol>
<li>water - wash - wine - wave - well - weep - woman</li>
</ol>
</li>
<li>season 季节<ol>
<li>There are four seasons in a year.</li>
<li>There are spring, summer, autumn / fall and winter.</li>
</ol>
</li>
<li>best 最  adv. 最好的 adj.<ol>
<li>Green is my favorite color.</li>
<li>I like green best.（行前动后）</li>
<li>Beijing is my favorite city.</li>
<li>I like Beijing best.</li>
<li>Spring is his favorite seasion.</li>
<li>He likes spring best.</li>
<li>Chinese is her favorite langue.</li>
<li>She likes Chinese best.</li>
</ol>
</li>
<li>night 夜晚，深夜<ol>
<li>evening 傍晚</li>
</ol>
</li>
<li>rise 升起</li>
<li>set 落下<ol>
<li>太阳每天6点升起，7点落下</li>
<li>The sun rises at 6:00 in the morning and sets at 7:00 in the evennig.</li>
</ol>
</li>
<li>early 早的 adj.  adv.</li>
<li>late 晚的 adj. adv.<ol>
<li>I am late today.  adj.</li>
<li>I come late today.</li>
</ol>
</li>
<li>interesting 有趣的</li>
<li>subject 话题、科目<ol>
<li>What’s the subject we are going to talk about today?</li>
<li>We have nine subjects this term.</li>
</ol>
</li>
<li>conversation 谈话</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>An interestion climate</li>
<li>What’s the climate / weather like in … + （月份、季节、地点）？</li>
<li>描述天气的句型结构：<ol>
<li>It is … in …</li>
<li>春天天气很糟糕。  It is terrible in spring.</li>
<li>西边气候很干燥。 It is dry in the west.</li>
<li>厦门天气很宜人。It is pleasant in Xiamen.</li>
</ol>
</li>
<li>Which seasons do you like best?<ol>
<li>Which is your favorite season?  不等价</li>
<li>Which are your favorite seasons. 等价</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>频率副词：<ol>
<li>never</li>
<li>seldom</li>
<li>sometimes</li>
<li>often</li>
<li>usually</li>
<li>always</li>
</ol>
</li>
<li>频率副词的位置：<ol>
<li>情、系后，实义前<ol>
<li>She is seldom ill.</li>
<li>He can never sleep.</li>
<li>He always loves her.</li>
<li>他老是迟到。</li>
<li>He is always late.</li>
<li>他经常给女孩写情书。</li>
<li>He often writes love letters to girls.</li>
</ol>
</li>
<li>表达强调时，可调整位置。<ol>
<li>我永远也记不住</li>
<li>I can never remember.</li>
<li>I never can remember.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>Australia - Australian 澳大利亚，澳大利亚人</li>
<li>Austria - Austrain</li>
<li>Canada - Canadian</li>
<li>China - Chinese </li>
<li>Finland - Finnish</li>
<li>India - Indian</li>
<li>Japan - Japanese</li>
<li>Nigeria - Nigerian</li>
<li>Turkey - Turkish</li>
<li>Korea - Korean</li>
<li>Poland - Polish</li>
<li>Thai - Thailand</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 51</title>
    <url>/2020/06/25/Language/English/New%20Concept/Chapter1/lesson51/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>Greece 希腊</li>
<li>Greek  希腊人</li>
<li>Athens 雅典</li>
<li>climate  气候<ol>
<li>宜人的气候：a pleasant climate</li>
</ol>
</li>
<li>country 国家<ol>
<li>in my/your country</li>
</ol>
</li>
<li>pleasant   adj. 宜人的<ol>
<li>The weather is very pleasant.</li>
<li>令人开心的、愉快的</li>
<li>a pleasant dream 美梦</li>
<li>a pleasant manner 随和的态度</li>
</ol>
</li>
<li>weather 天气<ol>
<li>How is the weather today?</li>
<li>The weather is fine / pleasant / terrible.</li>
</ol>
</li>
<li>spring 春季</li>
<li>summer 夏天</li>
<li>autumn / fall 秋天</li>
<li>winter 冬天</li>
<li>春节，the Spring Festival</li>
<li>windy adj. 有风的<ol>
<li>It’s windy today.</li>
</ol>
</li>
<li>warm adj. 温暖的<ol>
<li>It’s warm today</li>
</ol>
</li>
<li>hot 炎热的</li>
<li>cold 寒冷的</li>
<li>cool 凉爽的</li>
<li>rain v.下雨<ol>
<li>It is often rain here</li>
<li>It often rain here.</li>
<li>It often rains here.     对的</li>
</ol>
</li>
<li>snow 下雪<ol>
<li>It often snows here.</li>
</ol>
</li>
<li>sometimes adv. 有时</li>
<li>Jan. 1月</li>
<li>Feb. 2月</li>
<li>Mar.  3月</li>
<li>Apr. 4月</li>
<li>May. 5月</li>
<li>June. 6月</li>
<li>July. 7月</li>
<li>Aug. 8月</li>
<li>Sept.  9月</li>
<li>Otc. 10月</li>
<li>Nov. 11月</li>
<li>Dec. 12月</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>你来自哪里？<ol>
<li>Where do you come from?</li>
<li>不能用 are </li>
<li>come v.</li>
<li>from  prep.</li>
<li>do  -   动词</li>
<li>are   -  非动词</li>
<li>回答：I come from …</li>
<li>Where are you from?  I am from…</li>
</ol>
</li>
<li>What’s the climate like?<ol>
<li>like   像</li>
<li>例句：What’s her boyfriend like?</li>
<li>How’s the cliamte?</li>
<li>How’s the weather?</li>
<li>How’s her boyfriend?</li>
<li><strong>What’s sth. / sb. like ?  &lt;=&gt;  How’s sth. / sb. ?</strong></li>
<li>What’s the climate like <strong>in … + 国家、城市、季节、月份？</strong> </li>
</ol>
</li>
<li>三月经常是风天<ol>
<li>It’s often windy in March.</li>
<li>主语~</li>
<li>介词~</li>
<li><strong>It’s + 天气形容词 + in _.</strong></li>
<li>练习<ol>
<li>四月和五月经常很暖和。</li>
<li>It’s often warm in April and May.</li>
<li>六七八月经常狠炎热。</li>
<li>It’s often hot in June, July and August.</li>
<li>四月和五月有时会下雨。</li>
<li><strong>rain - rainy    snow - snowy     v. - adj.</strong></li>
<li>It’s sometimes rainy in April and May.</li>
<li>It sometimes rains in April and May.</li>
</ol>
</li>
<li><strong>It + 天气动词 + in _.</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般现在时态<ol>
<li>经常的状态：主语 + is / am / are.</li>
<li>习惯的动作：主语 + v.</li>
<li>真理</li>
<li>示例<ol>
<li>这里冬天经常是雪天</li>
<li>It’s often snowy in winter here.</li>
<li>这里冬天经常下雪</li>
<li>It often snows in winter here.</li>
<li>这工作很简单</li>
<li>The work is easy.</li>
<li>他在北京工作</li>
<li>He works at Beijing.</li>
</ol>
</li>
</ol>
</li>
<li>介词<ol>
<li>可翻译出意思的介词<ol>
<li>on </li>
<li>behind</li>
<li>under</li>
</ol>
</li>
<li>翻译为汉语时不需要， 介词 + 时间</li>
<li>示例<ol>
<li>冬天非常冷</li>
<li>It’s cold in winter.</li>
</ol>
</li>
<li><strong>at / on / in + 时间</strong><ol>
<li><strong>at + 点</strong></li>
<li><strong>on + 天</strong></li>
<li><strong>in + 月、季、年</strong></li>
</ol>
</li>
<li>示例<ol>
<li>我经常8点起床</li>
<li>I often get up at 8:00.</li>
<li>他周一很忙</li>
<li>He is busy on Monday.</li>
<li>他们计划5月4号回来</li>
<li>They are going to come back on May 4th.</li>
<li>三月很暖和</li>
<li>It’s very warm in March.</li>
<li>夏天经常是雨天</li>
<li>It’s often rainy in summer.</li>
<li>我打算2017年去旅行</li>
<li>I am going to travel in 2017.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>the U.S  美国</li>
<li>the United States Of America</li>
<li>American 美国人</li>
<li>Brazil 巴西</li>
<li>Brazilian 巴西人</li>
<li>Holland 荷兰</li>
<li>Dutch 荷兰人</li>
<li>England 英国</li>
<li>English 英国人</li>
<li>France 法国</li>
<li>French 法国人</li>
<li>Germany 德国</li>
<li>German 德国人</li>
<li>Italy 意大利</li>
<li>Italian 意大利人</li>
<li>Norway 挪威</li>
<li>Norwegian 挪威人</li>
<li>Russia 俄罗斯</li>
<li>Russian  俄罗斯人</li>
<li>Spain 西班牙</li>
<li>Spanish 西班牙人</li>
<li>Sweden 瑞典</li>
<li>Swedish 瑞典人</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 49</title>
    <url>/2020/06/23/Language/English/New%20Concept/Chapter1/lesson49/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>butcher 卖肉的，屠夫<ol>
<li><strong>at the</strong> butcher’s： 在肉店</li>
<li><strong>at the</strong> doctor’s：在诊所</li>
<li><strong>at the</strong> hairdresser’s：在理发店</li>
<li><strong>at the</strong> baker’s：在面包店</li>
</ol>
</li>
<li>meat  肉，不可数名词<ol>
<li>a pound of meat</li>
</ol>
</li>
<li>beef 牛肉</li>
<li>lamb 羔羊肉</li>
<li>mutton 羊肉</li>
<li>steak 牛排</li>
<li>mince 肉馅</li>
<li>chicken 鸡肉</li>
<li>pork 猪肉<ol>
<li>a pound of …</li>
</ol>
</li>
<li>husband 丈夫</li>
<li>tell 告诉<ol>
<li>tell sb. sth. 告诉某人某件事</li>
</ol>
</li>
<li>truth 实情，事实</li>
<li>true adj. 真实的</li>
<li>either 也，否定句</li>
<li>too  也，陈述句，疑问句<ol>
<li>I don’t know either.</li>
<li>Do you love English, too?</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Do you want any meat …?<ol>
<li>Are you …?<ol>
<li>Are you + 非动词？</li>
<li>第三人称  Is she / he / it …?</li>
</ol>
</li>
<li>Do you …?<ol>
<li>Do you + 动词？</li>
<li>第三人称  Does she / he / it …?</li>
</ol>
</li>
<li>先看词性：动词 or 非动词<ol>
<li>Are you …?</li>
<li>Is she / he / it…?</li>
</ol>
</li>
<li>再看人称：三单 or 非三单（第三人称单数）<ol>
<li>Do you …?</li>
<li>Does she /he / it…?</li>
</ol>
</li>
</ol>
</li>
<li>Yes, please.<ol>
<li>No, thank you.</li>
</ol>
</li>
<li>But my husband doesn’t.<ol>
<li>isn’t, aren’t, don’t &amp; doesn’t</li>
<li>isn’t + 非动词， aren’t + 非动词，don’t + 动词，doesn’t + 动词</li>
<li>先看词性：动词 or 非动词   再看人称：三单 or 非三单</li>
</ol>
</li>
<li>To tell you the truth,…</li>
</ol>
<blockquote>
<p>语法讲解</p>
</blockquote>
<p>一般现在时态：</p>
<ol>
<li>何时用？<ol>
<li>经常的状态</li>
<li>习惯的动作</li>
<li>真理</li>
</ol>
</li>
<li>结构？<ol>
<li>经常的状态；主语 + is / am / are</li>
<li>习惯的动作；主语 + v.</li>
<li>真理。主语 + is / am / are， 主语 + v.</li>
<li>举例<ol>
<li>They are very bad.</li>
<li>They often cheat in the exams.</li>
<li>The earth is round.</li>
<li>The sun rises in the east.</li>
</ol>
</li>
</ol>
</li>
<li>动词？<ol>
<li>主语 + v.</li>
<li><strong>主语为非三单 + 动词原形</strong></li>
<li><strong>主语为三单 + 动词s/es</strong><ol>
<li><strong>He loves</strong> his girlfriend very much.</li>
<li>Jim and Lily <strong>walk</strong> to school every day.</li>
<li>They <strong>drink</strong> beer every night.</li>
<li><strong>My dog watches</strong> TV at night.</li>
<li>She <strong>goes</strong> to school on foot.</li>
</ol>
</li>
</ol>
</li>
<li>变疑问句？<ol>
<li>They drink beer every night.</li>
<li>He loves his grilfriend very much.</li>
<li>先看词性，再看人称</li>
</ol>
</li>
<li>否定句？<ol>
<li>They drink beer every night.</li>
<li>They don’t drink beer every night.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>tomato 西红柿</li>
<li>potato 土豆</li>
<li>cabbage 卷心菜</li>
<li>lettuce 莴苣</li>
<li>pea 豌豆</li>
<li>bean 豆角，豆子</li>
<li>pear 梨</li>
<li>grape 葡萄</li>
<li>peach 桃子</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 47</title>
    <url>/2020/06/23/Language/English/New%20Concept/Chapter1/lesson47/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>like v. 喜欢，想要<ol>
<li>I like football.  我喜欢足球</li>
<li>I like football very much.</li>
<li>I like playing football. 我喜欢踢足球</li>
<li>I like going shopping. 我喜欢购物</li>
<li>I like swimming.</li>
</ol>
</li>
<li>want v. 想</li>
<li>think 考虑，认为<ol>
<li>I want a new car.</li>
<li>I want a new car very much.</li>
<li>I want <strong>to buy</strong> a new car.</li>
<li>I want <strong>to go</strong> shopping.</li>
<li>I want <strong>to swim</strong>.</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Do you like coffee?<ol>
<li><strong>Do you like books</strong>?</li>
</ol>
</li>
<li>Do you wan any sugar?<ol>
<li>Yes, please.</li>
<li>Do you want any milk?</li>
<li>No, thank you.</li>
</ol>
</li>
<li>I don’t like milk <strong>in</strong> my coffee.<ol>
<li>I don’t like English in Chinese.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li><p>Are they + 形容词、名词、介词…</p>
<ol>
<li>Are they happy?</li>
<li>Are they students?</li>
<li>Are they on the subway?</li>
</ol>
</li>
<li><p>一般疑问句：</p>
<ol>
<li>be +形容词、名词、介词…</li>
<li>Do + 动词<ol>
<li>Do you speak English？</li>
<li>Do you like coffee?</li>
<li>Do you want any sugar?</li>
<li>Do you often eat breakfast.</li>
</ol>
</li>
<li>现在进行时态：<ol>
<li>主语 + is / am / are + doing</li>
</ol>
</li>
<li>动词否定<ol>
<li>You are eating breakfast.</li>
<li>Are you eating breakfast?</li>
</ol>
</li>
</ol>
</li>
<li>否定句<ol>
<li>They are not + 形容词、名词、介词…</li>
<li>be + not + 形容词、名词、介词…</li>
<li>动词否定<ol>
<li>do not + 动词</li>
</ol>
</li>
<li>I don’t speak English.</li>
<li>You don’t often eat breakfast.</li>
</ol>
</li>
<li>动词<ol>
<li>疑问句：<ol>
<li>Do + 动词</li>
</ol>
</li>
<li>否定句<ol>
<li>do not + 动词</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>fresh adj. 新鲜的<ol>
<li>the fresh air</li>
</ol>
</li>
<li>egg n. 鸡蛋  可数名词</li>
<li>butter 黄油 不可数</li>
<li>pure adj. 纯净的<ol>
<li>the pure water</li>
</ol>
</li>
<li>honey n. 蜂蜜</li>
<li>ripe adj. 成熟的<ol>
<li>mature 成熟的，特之人</li>
</ol>
</li>
<li>banana 香蕉</li>
<li>jam 果酱<ol>
<li>traffic jam 交通堵塞</li>
</ol>
</li>
<li>sweet adj. 甜的<ol>
<li>her sweet voice</li>
</ol>
</li>
<li>orange 橙子</li>
<li>Scotch Whisky </li>
<li>choice  adj. 上等的，精选的<ol>
<li>some choice apples</li>
<li>n. 选择</li>
<li>He can make a wise choice.</li>
</ol>
</li>
<li>apple n. 苹果</li>
<li>wine n. 果酒</li>
<li>beer n. 啤酒</li>
<li>blackboard 黑板<ol>
<li>whiteboard 白板</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 45</title>
    <url>/2020/06/23/Language/English/New%20Concept/Chapter1/lesson45/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>can 能够，可以</li>
<li>boss 老板</li>
<li>manager 经理</li>
<li>minute 分钟，一会儿<ol>
<li>Wait a minute 等一会，等一下</li>
</ol>
</li>
<li>hour 小时</li>
<li>second 秒钟</li>
<li>ask 请求，问<ol>
<li>Can I ask you a question?</li>
<li>aks the way 问路</li>
</ol>
</li>
<li>handwriting 书写<ol>
<li>他的字写得很好</li>
<li>His handwriting is very nice.</li>
</ol>
</li>
<li>terrible 糟糕的</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Can you come here a minute please?<ol>
<li>a minute 一会，一下</li>
</ol>
</li>
<li>next door 在隔壁，与…相邻<ol>
<li>She is next door. 她在隔壁。</li>
<li>She is next door to us. 她与我们相邻。</li>
<li>There is a school next door to the park. 公园的隔壁有一所学校</li>
</ol>
</li>
<li>next-door adj. 隔壁的<ol>
<li>The next-door girl is very beautiful. 隔壁的女孩很漂亮</li>
<li>The old man next-door is going to leave. 隔壁的老人就要离开了。</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="情态动词">情态动词</span></h4><ul>
<li>分类<ul>
<li>连系动词</li>
<li>情态动词</li>
<li>实义动词</li>
<li>助动词</li>
</ul>
</li>
</ul>
<ol>
<li>概念：表示情感，态度<ol>
<li>You must go out!</li>
<li>Can you please stand up?</li>
</ol>
</li>
<li>包括：can, must, may…</li>
<li>用法： + 动词，且原型</li>
<li>没有人称和数的变化<ol>
<li>She is …   I am …</li>
<li>She can… I can …</li>
</ol>
</li>
<li>疑问句：提前</li>
<li>否定句：<ol>
<li>can - can’t , cannot（不可用 can not）</li>
<li>must - mustn’t 禁止</li>
<li>may - may not </li>
</ol>
</li>
<li>示例<ol>
<li>Tom can swim well.<ol>
<li>Can Tom swim well?</li>
</ol>
</li>
<li>The students must finish their homework tonight.<ol>
<li>The student don’t neet to finish their homework tonight.</li>
</ol>
</li>
<li>Can I have a cup of tea? （改写）<ol>
<li>May I have a cup of tea?</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>lift 举起<ol>
<li>Can you lift this heavy case?</li>
<li>电梯（英式直梯，美式：elevator）</li>
<li>There are thirteen people in this lift, it’s overweight.</li>
</ol>
</li>
<li>cake 蛋糕  可数名词</li>
<li>biscuit 饼干，可数名词</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 43</title>
    <url>/2020/06/22/Language/English/New%20Concept/Chapter1/lesson43/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>of course 当然</li>
<li>certainly 一定 更加正式一些</li>
<li>Of course not. 当然没有</li>
<li>kettle 水壶</li>
<li>behind prep. 在…后面</li>
<li>teapot n. 茶壶<ol>
<li>hot pot, 火锅</li>
</ol>
</li>
<li>now 现在，此刻<ol>
<li>What are you doing now?</li>
<li>I am learning English.</li>
<li>What are you going to do now?</li>
<li>I am going to swim.</li>
</ol>
</li>
<li>find v. 找到<ol>
<li><strong>Look</strong>! Can you <strong>see</strong> it?</li>
<li><strong>Listen</strong>! Can you <strong>hear</strong> it?</li>
<li><strong>Look for</strong> it! Can you <strong>find</strong> it?</li>
</ol>
</li>
<li>boil v. 沸腾，开<ol>
<li>The water is boiling.</li>
<li>boiled，已经烧开的</li>
<li>boiled water 开水</li>
<li>boil v. 煮  boil an egg</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Hurry up! 快点<ol>
<li>Be quick!</li>
</ol>
</li>
<li>make the tea 沏茶<ol>
<li>make sone coffee 冲咖啡</li>
<li>make the bed 整理床铺</li>
<li>What make is it? 这个什么牌子的？</li>
</ol>
</li>
<li>It’s over there. 就在那儿。<ol>
<li>right here  就在这儿</li>
</ol>
</li>
<li>Can you see it?<ol>
<li>Can you find it?</li>
<li>look - see</li>
<li>listen - hear</li>
<li>Look for - find</li>
</ol>
</li>
<li>There it is.<ol>
<li>Here they are.</li>
<li>Here I am.</li>
<li>There he is.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="可以吗">可以吗？</span></h4><p>Can you …?   Are you …?</p>
<p>Can she …?   Is she …?</p>
<p>Can he …?   Is he …?</p>
<p>Can we …?  Are we …?</p>
<p>Can they …?  Are they …?</p>
<p><strong>can可以用于任何人称</strong></p>
<p>你可以帮我么？</p>
<p>Can you help me?</p>
<p>你可以做这事么？</p>
<p>Can you do it?</p>
<p>我们可以一起游泳么？</p>
<p>Can we swim together?</p>
<p><strong>can + 动词，必须是原型</strong></p>
<p>Can you make the tea?</p>
<p>Can you see it?</p>
<p>Can you find them?</p>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>只有可数名词才有复数形式</li>
<li>Are there any …?<ol>
<li>Are there any + 复数。</li>
</ol>
</li>
<li>Is there any…?<ol>
<li>Is there any + 不可数。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 41</title>
    <url>/2020/06/22/Language/English/New%20Concept/Chapter1/lesson41/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>cheese 奶酪<ol>
<li>Say cheese!</li>
</ol>
</li>
<li>bread 面包</li>
<li>soap 肥皂</li>
<li>soup 汤</li>
<li>chocolate 巧克力</li>
<li>sugar 糖（白砂糖）</li>
<li>candy 糖果</li>
<li>sugar coat.<ol>
<li>Can you sugar coat a little?  你可以稍微委婉一点么？</li>
</ol>
</li>
<li>coffee 咖啡</li>
<li>tea 茶</li>
<li>tobacco 烟草</li>
<li>cigarette 香烟</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Not very.  不是非常…<ol>
<li>It is not very heavy.</li>
</ol>
</li>
<li>What’s in it?<ol>
<li>What’s <strong>on / under / over / behind</strong> it ?</li>
</ol>
</li>
<li>量词：<ol>
<li>a piece of … 一片，一块的…</li>
<li>a loat of … 一个，一条的…</li>
<li>a bar of… 一条，一块的…</li>
<li>a bottle of…   一瓶的…</li>
<li>a pound of…  一磅的</li>
<li>a tin of…  一罐的</li>
<li>a cup of… 一杯…</li>
<li>a box of…   一箱…</li>
<li>a spoon of…  一勺…</li>
</ol>
</li>
<li>pound:  <ol>
<li>价格<ol>
<li>英镑<ol>
<li>one pound / two pounds</li>
</ol>
</li>
<li>便士<ol>
<li>one penny / two pence</li>
</ol>
</li>
<li>dollar 美元<ol>
<li>one dollar / two dollars</li>
</ol>
</li>
<li>cent 分<ol>
<li>one cent / two cents</li>
</ol>
</li>
</ol>
</li>
<li>重量<ol>
<li>a pound 一磅<ol>
<li>a pound of cheese.</li>
</ol>
</li>
<li>half a pound of  半磅</li>
<li>a quarter of a pound of … 四分之一磅</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="名词">名词</span></h4><ol>
<li>冠词 + 名词</li>
<li>名词所有格： ‘s / of</li>
<li>单&amp;复数</li>
<li>可数&amp;不可数</li>
<li>不可数名词<ol>
<li>概念：不可以数的，不可以计算的名词；</li>
<li>包括<ol>
<li>液体状的东西；water / tea / coffee / milk / beer….</li>
<li>物质名词：soap / bread / chocolate / rice / tobacco …</li>
<li>抽象名词：love / friendship / work / homework …</li>
</ol>
</li>
<li>用法：<ol>
<li>前面不可以加one，two，three…</li>
<li>前面不可以加 a / an</li>
<li>后面不可以加s，永远是单数</li>
</ol>
</li>
<li>与量词的搭配：<ol>
<li>a piece of bread 一片面包</li>
<li>a loaf of bread 一个面包</li>
<li>a bar of soat 一条肥皂</li>
<li>a bottle of cola</li>
<li>a pound of …</li>
<li>a tin of cola</li>
<li>a cup of coffee</li>
<li>a box of tea</li>
<li>a spoon of sugar</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><p>bird 鸟</p>
</li>
<li><p>any 一些</p>
</li>
<li><p>some 一些</p>
<ol>
<li><p>some / any + 复数名词或不可数名词时，”一些”，some用在肯定句中，any用在否定、疑问句中</p>
<ol>
<li>some students / some water / any cups / any money</li>
<li>Is there a + 可数名词单数?</li>
<li>Is there any + 不可数名词?</li>
</ol>
</li>
<li><p>但在表请求，建议的疑问句中用some。</p>
<ol>
<li>Could you lend me some money?</li>
</ol>
</li>
<li><p>some / any + 单数名词，some翻译为 “某一”，any 翻译为“任一”</p>
<ol>
<li>Some day, he can be some one.</li>
<li>You can buy it in any supermarket.</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 39</title>
    <url>/2020/06/22/Language/English/New%20Concept/Chapter1/lesson39/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>front n. 前面</li>
<li>in front of 在…之前<ol>
<li>in the front of </li>
<li>The man is in front of the car.</li>
<li>The man is in the front of the car.</li>
</ol>
</li>
<li>careful 小心的，小心的</li>
<li>vase 花瓶<ol>
<li>vases 复数</li>
</ol>
</li>
<li>drop v. 掉下</li>
<li>flower 花<ol>
<li>flowers 复数</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>What are you going to <strong>do with</strong> …?<ol>
<li>你打算怎么处理…？</li>
</ol>
</li>
<li>Give it to me.<ol>
<li>祈使句<ol>
<li>没有主语</li>
<li>动词打头</li>
<li>Be careful!</li>
<li>Be + adj. / prep. …</li>
</ol>
</li>
<li>Give it to me.<ol>
<li>You give the vase to me.</li>
<li>双宾语</li>
<li>give / show / take / teach  … 可以接双宾语</li>
<li>give sth. to sb. = give sb. sth.</li>
<li>I give some money to him. I give him some money.</li>
<li>I give a flower to my mother.  I give my mother a flower.</li>
<li>我给了他们一些新书。<ol>
<li>I give some new boos to them.</li>
<li>I give them some new books.</li>
</ol>
</li>
<li>我给了她一只猫<ol>
<li>I give a cat to her.</li>
<li>I give her a cat.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>There we are.<ol>
<li>瞧，看~</li>
<li>就这么着吧~</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<h4><span id="说不">说不</span></h4><ol>
<li>构成： is not / am not / are not<ol>
<li>This is my name. This is not my name.</li>
<li>She is pretty.</li>
<li>You are busy.</li>
<li>I am in the front.</li>
</ol>
</li>
<li>Don’t (Do not) + v.<ol>
<li>Do it!  Don’t do it!</li>
<li>Come in!   Don’t come in!</li>
<li>Don’t litter !  Don’t fall !  Don’t enter !</li>
<li>Don’t drop it!</li>
<li>Don’t do that!</li>
<li>Don’t put it there!</li>
<li>Don’t work.</li>
<li>Don’t swim.</li>
<li>Don’t drive.</li>
<li>Don’t eat.</li>
<li>Don’t cook.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>show v. 给…看</li>
<li>send v. 送给</li>
<li>take  v. 带给</li>
<li>I’m going to send my grandma a letter.</li>
<li>I’m going to show my friend my new dress.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 37</title>
    <url>/2020/06/21/Language/English/New%20Concept/Chapter1/lesson37/</url>
    <content><![CDATA[<a id="more"></a><blockquote>
<p>单词</p>
</blockquote><ol>
<li>work 工作<ol>
<li>I workin NO School. v.</li>
</ol>
</li>
<li>hard 努力地  adv(副词)<ol>
<li>副词的功能：用来修饰 adj / v / adv<ol>
<li>修饰adj<ol>
<li>I am tired.  I am <strong>very</strong> tired. I am <strong>so</strong> tired. I am <strong>too</strong> tired. I am <strong>awfully</strong> tired.</li>
</ol>
</li>
<li>修饰 v<ol>
<li>I love you. I love you <strong>very much</strong>. I love you <strong>awfully</strong>.</li>
</ol>
</li>
</ol>
</li>
<li>副词的位置：通常情况，行前动后</li>
<li>例子<ol>
<li>I swim well.</li>
<li>I know him well.</li>
</ol>
</li>
<li>hard 词性讨论：<ol>
<li>努力地  adv</li>
<li>勤奋的，艰苦的  adj</li>
</ol>
</li>
<li>hard word： 艰苦的工作</li>
<li>word hard：努力工作</li>
</ol>
</li>
<li>make 做<ol>
<li>What make is it? 这是什么牌子？</li>
<li>make the bed. 整理床铺</li>
<li>make a bookcase / bookshelf 制作一个书架</li>
</ol>
</li>
<li>bookcase 书架</li>
<li>hammer 锤子</li>
<li>paint 涂色，上色<ol>
<li>painting n 画</li>
<li>Chinese paintings 中国国画</li>
</ol>
</li>
<li>pink 粉色</li>
<li>favourite （favorite） 最喜欢的<ol>
<li>Facorite color / city / school / book / girl</li>
<li>What’s your favorite …?</li>
</ol>
</li>
</ol><a id="more"></a>


<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You are working hard, …  你正忙着呢！</li>
<li>Give me …</li>
<li>I’m going to paint it(the bookcase) pink（宾补）.<ol>
<li>宾补：对宾语的补充和说明，使句子更加简洁。</li>
<li>我发现那屋子是黑的</li>
<li>I find the room <del>is</del> dark.</li>
<li>大家务必保持教室干净。</li>
<li>We must keep the classroom clean.</li>
<li>历史使人明智。Histories make men wise.</li>
<li>诗歌使人灵秀。Poems make men witty.</li>
<li>数学使人缜密。Math make men subtle.</li>
<li>哲学使人深刻。Philosophy make men deep.</li>
</ol>
</li>
<li>It’s for my daughter.<ol>
<li>for<ol>
<li>为了…某人而…  It’s for you.</li>
<li>对于某人来说…   Math is so difficult for me.</li>
<li>表原因…  What are you sorry for?</li>
<li>长达… I study Yoga for two years.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般将来时</li>
<li>be going to 句型<ol>
<li>何时用？ 预先计划和打算要做的事</li>
<li>固定形式：主 + is / am / are + going to</li>
<li>要求： 后面接动词原形</li>
<li>示例<ol>
<li>我打算周末去逛街</li>
<li>I am going to <strong>go shopping</strong> this weekend.</li>
<li>他打算把旧车卖了买新车</li>
<li>He’s going to <strong>sell</strong> his old car, and <strong>buy</strong> a new one.</li>
<li>I am gonna be happy this year. </li>
<li>I’m going to <strong>be</strong> happy this year.</li>
</ol>
</li>
<li>口语中：be going to = be gonna</li>
</ol>
</li>
<li>be going to do / be going to be + adj. n. prep<ol>
<li>示例<ol>
<li>我打算下周开始忙起来。</li>
<li>I am going be busy next week.</li>
<li>他计划这周末呆家里。</li>
<li>He is going to be at home this weekend.</li>
<li>这个孩子打算以后成为医生。</li>
<li>This kid is going to be a doctor.</li>
</ol>
</li>
<li>其他形式：<ol>
<li>疑问： be 提前</li>
<li>否定：be + not</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>homework 家庭作业</li>
<li>housework 家务活</li>
<li>listen 听<ol>
<li>Listen to the music / radio ..</li>
</ol>
</li>
<li>dish 盘子</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-标准化</title>
    <url>/2020/06/21/Network/Step2-StandardAndInsist1.1.2/</url>
    <content><![CDATA[<p>网络标准化分类：</p><ul>
<li>法定标准<ul>
<li>权威机构指定的正式的，合法的标准</li>
</ul>
</li>
<li>事实标准<ul>
<li>某些公司产品竞争中占据了主流，这些协议和技术就成了标准</li>
</ul>
</li>
</ul>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-概述</title>
    <url>/2020/06/21/Network/Step1-concept1.1.1/</url>
    <content><![CDATA[<p>计算机网络：是一个将分散的，具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统。</p><a id="more"></a>
<p>计算机网络是<strong>互联的，自治的</strong>计算机集合。</p>
<p>计算机网络的功能：</p>
<ul>
<li>数据通信(连通性)</li>
<li>资源共享(硬件，软件，数据)</li>
<li><p>分布式处理(多台计算机各自承担统一工作任务的不同部分)</p>
</li>
<li><p>提高可靠性</p>
</li>
<li>负载均衡</li>
<li>等等</li>
</ul>
<p>计算机网络组成：</p>
<ul>
<li>组成部分<ul>
<li>硬件</li>
<li>软件</li>
<li>协议</li>
</ul>
</li>
<li>工作方式<ul>
<li>边缘部分，用户直接使用<ul>
<li>C/S方式</li>
<li>P2P方式</li>
</ul>
</li>
<li>核心部分，为边缘部分服务</li>
</ul>
</li>
<li>功能组成<ul>
<li>通信子网，实现数据通信</li>
<li>资源子网，实现资源共享/数据处理</li>
<li>TODO 这里需要张图</li>
</ul>
</li>
</ul>
<p>计算机网络的分类</p>
<ul>
<li>按分布范围<ul>
<li>广域网WAN</li>
<li>城域网MAN</li>
<li>局域网WAN</li>
<li>个人区域网PAN</li>
</ul>
</li>
<li>按使用者区分<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li>按交换技术分<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
</li>
<li>按拓扑结构分<ul>
<li>总线型</li>
<li>星型</li>
<li>环形</li>
<li>网状型-常用语广域网</li>
</ul>
</li>
<li>按传输技术分<ul>
<li>广播式网络——共享公共通信信道</li>
<li>点对点网络——使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 35</title>
    <url>/2020/06/18/Language/English/New%20Concept/Chapter1/lesson35/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>photograph 照片</li>
<li>village 村庄<ol>
<li>in the village</li>
</ol>
</li>
<li>valley 山谷<ol>
<li>in a valley</li>
</ol>
</li>
<li>between prep 在…之间<ol>
<li>Just between you and me, don’t tell others.</li>
<li>between A and B</li>
<li>The lady is between her daughter and her friend.</li>
</ol>
</li>
<li>hill 小山</li>
<li>mountain 大山</li>
<li>another 另一个</li>
<li>Here is another photo of my school.</li>
<li>wife 妻子<ol>
<li>wives 复数</li>
</ol>
</li>
<li>alone prep  沿着</li>
<li>bank 河岸</li>
<li>water 水</li>
<li>swim 游泳<ol>
<li>swimming 进行时</li>
<li>He is swimming in the water.</li>
</ol>
</li>
<li>building 大楼<ol>
<li>the school building 教学大楼</li>
</ol>
</li>
<li>park 公园<ol>
<li>in the park</li>
<li>park  v  停车</li>
<li>park the car</li>
</ol>
</li>
<li>into prep 进入<ol>
<li>I <strong>come into</strong> the bedroom.</li>
<li>I <strong>jump into</strong> the water.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>a photograph of our village</li>
<li>My wife and I walking along…<ol>
<li>My classmate and I …</li>
<li>My father and I …</li>
</ol>
</li>
<li>Here is another photograph…<ol>
<li>another 另一个（大于等于3）</li>
<li>the other 另一个（等于2）</li>
<li>I have two best friends. One is a teacher, the other is a doctor.</li>
</ol>
</li>
<li>Some children are coming out of…<ol>
<li>out of … 出来</li>
<li>come out of…</li>
<li>walk out of…</li>
<li>run out of…</li>
</ol>
</li>
<li>Some of them <strong>are</strong> going into the park.<ol>
<li>some of them 他们中的一些</li>
<li>some of us 我们中的一些</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<p>谁谁谁“的”</p>
<ol>
<li>物主代词<ol>
<li>我的 my</li>
<li>你的 your</li>
<li>她的 her</li>
<li>他的 his</li>
<li>我们的 our</li>
<li>你们的 your</li>
<li>他们的 their</li>
</ol>
</li>
<li>‘s  必须是有生命的<ol>
<li>Lucy’s friend</li>
<li>Lily’s book</li>
<li>my mother’s bag</li>
<li>the driver’s watch</li>
</ol>
</li>
<li>of   必须是没有生命的<ol>
<li>我学校的照片：the photo of my school</li>
<li>这首歌的名字：the name of the song</li>
<li>那辆车的颜色：the color of the car</li>
<li>这房间的窗户：the window of the room</li>
</ol>
</li>
<li>联系<ol>
<li>那只小狗的名: the dog’s name</li>
<li>那本书的颜色：the color of the book</li>
<li>我妈妈的手提包：my mother’s handbag</li>
<li>那位男士的妻子：the man’s wife</li>
<li>他们的教师：their classroom</li>
<li>世界地图：the map of the world</li>
<li>我们的老师：our teacher</li>
<li>那部电影的名字：the name of the movie</li>
<li>我老板的办公室：my boss’s office</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>beside prep 在…的旁边<ol>
<li>there is a bed table beside the bed.</li>
</ol>
</li>
<li>off prep. 离开<ol>
<li>take off</li>
<li>drive off </li>
<li>jump off </li>
</ol>
</li>
<li>test 测试提交</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 31</title>
    <url>/2020/06/14/Language/English/New%20Concept/Chapter1/lesson33/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>day 日子、天<ol>
<li>today 今天</li>
<li>yesterday 昨天</li>
<li>holiday 假日</li>
</ol>
</li>
<li>cloud 云<ol>
<li>There are some clouds in the sky.</li>
</ol>
</li>
<li>sky 天空<ol>
<li>in the sky</li>
</ol>
</li>
<li>sun 太阳<ol>
<li>sunhat 遮阳帽</li>
<li>sunglass</li>
<li>sunblock</li>
</ol>
</li>
<li>shine 照耀<ol>
<li>The sun is shining. 阳光灿烂</li>
</ol>
</li>
<li>with  和…一起<ol>
<li>He is with his new girlfriend.他和他的新女朋友在一起</li>
<li>I am with my new sunglass. 我待着我的新墨镜</li>
<li>The hourse is with a garden. 这栋房子带着一个花园</li>
<li>人与人，人与物，物与物</li>
</ol>
</li>
<li>family 家庭<ol>
<li>a family meeting 家庭会议</li>
<li>We are a family. 我们是一家人</li>
<li>Are you the family of …? 你们是…的家属么？</li>
</ol>
</li>
<li>walk 走路，步行<ol>
<li>I walk to school</li>
</ol>
</li>
<li>over 跨越，上方<ol>
<li>He is walking over the bridge.他正走着跨过那座桥。</li>
<li>The bird is flying over the river.</li>
</ol>
</li>
<li>bridge 桥<ol>
<li>过桥   over the bridge</li>
<li>他正在过桥   He is overing the bridge. 错误</li>
<li>He is going / walking / running over the bridge.</li>
</ol>
</li>
<li>boat 小船<ol>
<li>dream boat 梦中情人</li>
</ol>
</li>
<li>river 河</li>
<li>ship 轮船</li>
<li>aeroplane 飞机</li>
<li>fly 飞</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>描述天气：it作主语<ol>
<li>今天天气很好。It is fine today.</li>
<li>春天天气很糟糕。It is bad in spring.</li>
<li>夏天天气很好。It is nice in summer.</li>
<li>描述天气的句型结构：it is + adj. + 时间</li>
</ol>
</li>
<li>…is with his family.<ol>
<li>with: 介词，动词 + 介词</li>
<li>The desk <strong>is</strong> near the window.</li>
<li>She <strong>is</strong> with her friends.</li>
</ol>
</li>
<li>仿写<ol>
<li>今天的天气真好。天空飘着几朵白云，但是阳关灿烂，Lucy和她的男朋友在一块。他们正在开车。Lucy正在看一只漂亮的小鸟。小鸟正从天上飞过。一些人从天桥上走过，他们很忙。</li>
<li>It is fine today. There are some clouds in the sky. But sun is shinning. Lucy is with her bodfriends. Her boyfriend is driving. Lucy is looking at a beautiful bird. The bird is flying in the sky. Some people are walking over the bridge. They are busy.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>时态：<ol>
<li>时间</li>
<li>状态</li>
</ol>
</li>
<li>现在进行时态<ol>
<li>主 + is / am / are + doing</li>
<li>The cowl is swiming in water.</li>
<li>He is reading on the grass.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>sleep 睡觉</li>
<li>shave 刮胡子</li>
<li>shaver 刮胡刀</li>
<li>cry 哭<ol>
<li>The baby is cyring.</li>
</ol>
</li>
<li>wash 洗<ol>
<li>wash my face / wash my hads</li>
</ol>
</li>
<li>wait 等待<ol>
<li>look at</li>
<li>listen to</li>
<li>wait for me</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 31</title>
    <url>/2020/06/14/Language/English/New%20Concept/Chapter1/lesson31/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>garden 花园<ol>
<li>in the garden 在花园里 / a gardener 园艺师</li>
</ol>
</li>
<li>under prep 在…之下<ol>
<li>There is a chair under the bed.</li>
</ol>
</li>
<li>tree 树<ol>
<li>under the tree</li>
<li>a family tree 家谱</li>
</ol>
</li>
<li>climb  v.  爬，攀登<ol>
<li>climb the mountain 爬山</li>
</ol>
</li>
<li>who 谁</li>
<li>run v 跑<ol>
<li>run after 追赶</li>
<li>a runner 跑步运动员</li>
<li>Liu xiang is a runner.</li>
</ol>
</li>
<li>grass 草地</li>
<li>after prep 在…之后<ol>
<li>After you! 您先请。</li>
</ol>
</li>
<li>across prep 穿过<ol>
<li>go across the street</li>
<li>walk across the street</li>
<li>run across the street</li>
</ol>
</li>
<li>cat 猫</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>There are two people in the room.</li>
<li>Ther are talking.</li>
<li>There is a boy in the tree.</li>
<li>He is climbing the tree.</li>
<li>There is a gril under the tree.</li>
<li>She is reading.</li>
</ol>
<ol>
<li>She is sitting under the tree.<ol>
<li>sit - sitting</li>
</ol>
</li>
<li>He is climbing the tree.<ol>
<li>climb - climbing</li>
</ol>
</li>
<li>I beg your pardon?<ol>
<li>beg  祈求</li>
<li>Pardon? Excuse me? Sorry? Say it again.</li>
</ol>
</li>
<li>What about …?<ol>
<li>I am a teacher. What about you ?</li>
<li>I am learing English. What about you ?</li>
<li>I like rice. What about you?</li>
</ol>
</li>
<li>他正穿过那片草地<ol>
<li>He is acrossing the grass.  错误，across 是介词，不能加ing</li>
<li>He is going / walking / running across the grass.</li>
</ol>
</li>
<li>It’s running after a cat.<ol>
<li>run after 追赶</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>时态（简单区分）<ol>
<li>时间<ol>
<li>过去</li>
<li>现在</li>
<li>将来</li>
</ol>
</li>
<li>状态<ol>
<li>一般</li>
<li>进行</li>
<li>完成</li>
</ol>
</li>
</ol>
</li>
<li>现在进行时<ol>
<li>时间：现在</li>
<li>状态：进行</li>
<li>此时此刻正在做的动作。</li>
<li>动词中心说</li>
<li>总结<ol>
<li>一般 + ing</li>
<li>以不发音的e结尾，去e + ing</li>
<li>辅元辅，双写辅音字母+ing，除了opening.</li>
</ol>
</li>
</ol>
</li>
<li>现在进行时态的构成：<ol>
<li>主语 + is / am / are + doing</li>
<li>He is eating.   Is he eating?</li>
<li>He is reating.   Is he reading?</li>
<li>She is dringking. Is she dringking?</li>
<li>He is sleeping. Is he sleeping?</li>
<li>He is playing. Is he playing? No, he isn’t. he is running</li>
<li>Ther are singing. Are they singing?</li>
<li>He is swiming. Is he swiming?</li>
<li>He is running.  Is he running?</li>
<li>She is writing. Is she writing?</li>
</ol>
</li>
<li>现在进行时态的一般疑问<ol>
<li>Is / Am / Are + 主语 + doning</li>
<li>What is she doing?<ol>
<li>She is teaching.</li>
</ol>
</li>
<li>Where is she teaching?<ol>
<li>She is teaching in the classroom.</li>
</ol>
</li>
<li>What is she teaching?<ol>
<li>She is teaching math.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>type v 打字<ol>
<li>typeing</li>
</ol>
</li>
<li>letter 信<ol>
<li>a love letter 情书</li>
</ol>
</li>
<li>basket 篮子<ol>
<li>basketball 篮球</li>
</ol>
</li>
<li>eat 吃<ol>
<li>eating </li>
</ol>
</li>
<li>bone 骨头</li>
<li>clean v 清洗<ol>
<li>clean adj  干净的</li>
<li>clean the room</li>
<li>cleaning</li>
</ol>
</li>
<li>tooth 牙齿<ol>
<li>复数  teeth</li>
<li>foot - feet</li>
<li>toothbrush</li>
</ol>
</li>
<li>cook 做饭<ol>
<li>cooking</li>
<li>My mother is cooking.</li>
</ol>
</li>
<li>milk 牛奶</li>
<li>meal 饭，一顿饭<ol>
<li>cook a meal</li>
</ol>
</li>
<li>drink 喝<ol>
<li>drinking</li>
<li>She is drinking some wather.</li>
</ol>
</li>
<li>tap 水龙头<ol>
<li>打开水龙头   open the tap</li>
<li>turn on the tap</li>
<li>turn off the tap</li>
</ol>
</li>
<li>What’s she / he / it doing?<br>14.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 29</title>
    <url>/2020/06/10/Language/English/New%20Concept/Chapter1/lesson29/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>shut 关门<ol>
<li>The door is shut.  门是管着的</li>
<li>Shut the door. 关门。</li>
</ol>
</li>
<li>bedroom 卧室<ol>
<li>in the bedroom</li>
</ol>
</li>
<li>untidy 不干净的<ol>
<li>un-  不，表示否定</li>
<li>clean  unclean</li>
<li>easy uneasy</li>
<li>happy unhappy</li>
</ol>
</li>
<li>must 必须  model verb<ol>
<li>情态动词——情感，态度</li>
<li>You must go out.</li>
<li>Can you got out please?</li>
</ol>
</li>
<li>open 打开<ol>
<li>The window is open. </li>
<li>Open the window.</li>
</ol>
</li>
<li>air 通风，使空气流通<ol>
<li>The air is fresh. 空气清新</li>
<li>Open the windows and air the kitchen.</li>
<li>打开窗户，让厨房通下气</li>
<li>What is the <strong>color</strong>?</li>
<li><strong>Color</strong> the picture.给图片上个色</li>
<li>I like milk.</li>
<li>Milk it. 给奶球挤牛奶</li>
<li>This is my <strong>book</strong>.</li>
<li><strong>Book</strong> a ticket. 预定一张票</li>
<li>There is some water in the glass.</li>
<li><strong>Water</strong> the flower.给花浇水</li>
<li>There is some <strong>dust</strong>.</li>
<li><strong>Dust</strong> the table. 把桌上的灰尘清扫掉</li>
</ol>
</li>
<li>put 放置，搁<ol>
<li>把书放桌上：Put the book on the table.</li>
<li>把手穿兜里  Put your hand in your pocket.</li>
</ol>
</li>
<li>clothes 衣服 （单复数同形）<ol>
<li>people / hair / fish / sheep</li>
</ol>
</li>
<li>wardrobe 大衣柜<ol>
<li>把外套放在大衣柜里</li>
<li>Put your coat in the wardrobe.</li>
</ol>
</li>
<li>sweep 清扫<ol>
<li>Sweep the floor please.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>祈使句<ol>
<li>没有主语</li>
<li>东西开头<ol>
<li>Come in</li>
<li>Go out</li>
<li>Shut the door.</li>
<li>Open the window</li>
<li>Air the room.</li>
</ol>
</li>
</ol>
</li>
<li>What must I do?<ol>
<li>What must I say / read / clean … ?</li>
<li>Where must I go / live / stay…?</li>
<li>Who must I meet / love / care…?</li>
</ol>
</li>
<li>make the bed </li>
<li>sweep the floor</li>
<li>dust the table</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>祈使句：用来表示命令、请求、建议等；<ol>
<li>表示命令：东西原型+…<ol>
<li>Shut the door.</li>
</ol>
</li>
<li>表示请求： please + 动词原型 + …<ol>
<li>Please give me it.</li>
</ol>
</li>
<li>表示建议：Let’s + 动词原型+…<ol>
<li>Let’s go, ok?</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>empty<ol>
<li>My mind is empty. adj</li>
<li>Empty the bottle please. v</li>
</ol>
</li>
<li>read 读，看<ol>
<li>读书，看报，看杂志：read a book / newspaper / a magazine</li>
</ol>
</li>
<li>sharpen 使锋利<ol>
<li>adj + en = v</li>
<li>sharp + en = 使锋利</li>
<li>short + en = 缩短</li>
<li>weak + en = 削弱</li>
</ol>
</li>
<li>put on &amp;&amp; take off<ol>
<li>戴上眼镜，项链，戒指</li>
</ol>
</li>
<li>turn on &amp;&amp; turn off<ol>
<li>打开带电的设备</li>
<li>turn on / off the television</li>
<li>turn on / off the radio</li>
<li>turn on / off the light</li>
<li>turn on / off the tap(水龙头)</li>
</ol>
</li>
<li>句型：What must I do?<ol>
<li>What must I say / read /clean?</li>
<li>Where must I go / live /stay</li>
<li>Who must I meet/love/find.</li>
<li>Which must I like/take/find/</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 27</title>
    <url>/2020/06/10/Language/English/New%20Concept/Chapter1/lesson27/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>living room 客厅</li>
<li>near prep  靠近、旁边<ol>
<li>电视靠近桌子</li>
<li>The television is near  the table</li>
</ol>
</li>
<li>window 窗户</li>
<li>armchair 扶手椅<ol>
<li>arm 胳膊</li>
<li>chair 椅子</li>
</ol>
</li>
<li>door 门</li>
<li>picture 图画，照片</li>
<li>wall 墙<ol>
<li>the great wall 长城</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>There is a television in the room.</li>
<li>There are some magazines on the table.<ol>
<li>There is a + 单数名次</li>
<li>There are some  + 复数名词</li>
</ol>
</li>
<li>There is a sofa in the room.</li>
<li>There is a television in the room.</li>
<li>There are some pictures on the wall.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>介词 prep<ol>
<li>媒婆，连接两个词或句子</li>
<li>on in of near</li>
<li>使用介词时，不能忘记动词！</li>
<li>The television is near the windows.</li>
<li>The money is in the bag.</li>
<li>The picture is on the wall.</li>
<li>The wather is in the glass.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>trousers 长裤</li>
<li>pants 长裤</li>
<li>jeans 牛仔裤</li>
<li>shorts 短裤</li>
<li>shoes 鞋子</li>
<li>socks 袜子</li>
<li>gloves 手套</li>
<li>glasses 眼镜</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 25</title>
    <url>/2020/06/09/Language/English/New%20Concept/Chapter1/lesson25/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>Mrs 夫人</li>
<li>kitchen 厨房<ol>
<li>in the kitchen</li>
</ol>
</li>
<li>refrigerator 电冰箱<ol>
<li>frige</li>
</ol>
</li>
<li>right 右边<ol>
<li>on the right</li>
<li>The desk is on the right.</li>
</ol>
</li>
<li>left 左边</li>
<li>electric 带电的，可通电的<ol>
<li>an electric cooker</li>
<li>an electric shaver</li>
</ol>
</li>
<li>cooker 炉子，炊具</li>
<li>middle 中间<ol>
<li>in the middle of  在…的中间</li>
<li>The table is in the middle of the room.</li>
</ol>
</li>
<li>of （属于）……的</li>
<li>room 房间<ol>
<li>living room</li>
<li>dinning room</li>
<li>bedroom</li>
<li>bathroom</li>
</ol>
</li>
<li>cup 杯子</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Mrs.Smith’s kitchen is small.<ol>
<li>第一句话——总述</li>
</ol>
</li>
<li>描述物体的方式<ol>
<li>There is … in the kitchen.</li>
<li>The … is blue.</li>
<li>It is on the left.</li>
<li>所在位置，颜色，具体位置，状态</li>
<li>卧室里有一张床，是绿色的，在屋子中间，上面很干净</li>
<li>There is a bed in the bedroom.</li>
<li>The bed is green.</li>
<li>It is in the middle of the room.</li>
<li>And it is very clean.</li>
<li>所在位置： there be 句型</li>
<li>颜色： it is + 颜色</li>
<li>具体位置：on the right/left, in the middle of…</li>
<li>状态： it is clean / empty / large / small</li>
</ol>
</li>
<li>冠词用法复习<ol>
<li>初次出现，不了解，不确定，用不定冠词a /an</li>
<li>再次出现，了解，确定，用定冠词 the</li>
<li>那有一个人，这个人穿着蓝色的衣服，他是以为机械师</li>
<li>There is a man, the man is in blue. And he is a machanic</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>There be 句型<ol>
<li>构成： There be + 地点</li>
<li>用法：<ol>
<li>有 -&gt; 拥有  have</li>
<li>有 -&gt; 存在   There be …</li>
</ol>
</li>
<li>分类<ol>
<li>There is … + 单数名次</li>
<li>There are … +复数名次</li>
</ol>
</li>
<li>翻译<ol>
<li>There is one in my heart.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>Where 哪里</li>
<li>in  在…里面<ol>
<li>Where is it?</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 23</title>
    <url>/2020/06/08/Language/English/New%20Concept/Chapter1/lesson23/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>on: prep 在…之上<ol>
<li>on the table</li>
<li>on the floor</li>
</ol>
</li>
<li>shelf 架子、隔板<ol>
<li>shelves</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Which glasses?<ol>
<li>哪几个、哪些杯子？</li>
<li>which + 单数名词，表示哪个</li>
<li>which + 复数名词，表示哪些</li>
</ol>
</li>
<li>Give me some glasses.<ol>
<li>some : 一些 + 复数名词</li>
<li>some books</li>
<li>some cups</li>
<li>some boxes</li>
<li>some knifves</li>
<li>give me / him /her /us / them</li>
</ol>
</li>
<li>The ones on the shelf. 架子上的那些<ol>
<li>the ones [on the shelf] </li>
<li>介词短语后置，倒着翻译</li>
<li>the book on the desk</li>
<li>the cup on the table</li>
<li>the knife in the box</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>介词  prep<ol>
<li>介词：媒婆，连接两个词或词与句子</li>
<li>媒婆：on<ol>
<li>The book <strong>on</strong> the desk.  XXX</li>
<li>The book <strong>is on</strong> the desk.</li>
<li>使用介词时，不能忘记动词！</li>
</ol>
</li>
<li>那个玻璃杯在桌子上<ol>
<li>The glass is on the table.</li>
</ol>
</li>
<li>那个勺子在盘子上<ol>
<li>The spoon is on the table</li>
</ol>
</li>
<li>那个瓶子在盒子上<ol>
<li>The bottle is on the box.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>desk 课桌</li>
<li>table 桌子<ol>
<li>a bed table/ a tea table</li>
</ol>
</li>
<li>plate 盘子</li>
<li>cupboard 食厨</li>
<li>cigarette 香烟</li>
<li>television 电视机<ol>
<li>TV</li>
</ol>
</li>
<li>floor 地板<ol>
<li>It’s on the floor.</li>
</ol>
</li>
<li>dressing table 梳妆台</li>
<li>magazing 杂志</li>
<li>beg 床</li>
<li>newspaper 报纸<ol>
<li>news 新闻</li>
<li>paper 纸张</li>
</ol>
</li>
<li>stereo 立体声音响</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 21</title>
    <url>/2020/06/08/Language/English/New%20Concept/Chapter1/lesson21/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>give 给<ol>
<li>give me / her / him / them / us</li>
</ol>
</li>
<li>one 一个  pron(代词)<ol>
<li>the blue one = the blue coat</li>
<li>the short one = the short girl</li>
</ol>
</li>
<li>which 哪一个，哪一些<ol>
<li>Which book?</li>
<li>Which tourists?</li>
<li>哪本书好？ Which book is good?</li>
<li>哪些游客来此北京？ Which tourists are from Beijing?</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>You give me a book.<ol>
<li>主谓宾 宾</li>
</ol>
</li>
<li>This one? = This book?</li>
<li>Not that one. = Not that book.</li>
<li>The red one. = The red book.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>双宾语动词<ol>
<li>You give me a book.</li>
</ol>
</li>
<li>简单句的句型机构：<ol>
<li>主谓</li>
<li>主谓宾</li>
<li>主谓宾宾</li>
<li>主谓宾宾补</li>
<li>主系表</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li><p>empty 空的</p>
</li>
<li><p>full 满的</p>
<ol>
<li>I’m full. 我饱了</li>
<li>a full stop 句号</li>
<li>a full time job 一份全职工作</li>
</ol>
</li>
<li><p>large 大的（强调面积）</p>
<ol>
<li>China is a large country.</li>
<li>This room is large. 这房间很大</li>
</ol>
</li>
<li><p>little 小的</p>
<ol>
<li>a little gril  一个小女孩（可爱的）</li>
</ol>
</li>
<li><p>sharp 锋利的</p>
<ol>
<li>The knife is sharp. </li>
</ol>
</li>
<li><p>blunt 钝的</p>
<ol>
<li>The knife is blunt. </li>
<li>My English is blunt.</li>
</ol>
</li>
<li><p>small 小的</p>
<ol>
<li>Small world … 世界真小，又见面了。</li>
</ol>
</li>
<li><p>big 大的（体积）</p>
</li>
<li><p>box 盒子，箱子</p>
<ol>
<li>a small box</li>
<li>a big box</li>
</ol>
</li>
<li><p>glass 玻璃杯子</p>
</li>
<li><p>cup 茶杯</p>
</li>
<li><p>bottle 瓶子</p>
</li>
<li><p>tin 罐头瓶、易拉罐</p>
</li>
<li><p>knife 刀子</p>
</li>
<li><p>fork 叉子  forks</p>
</li>
<li><p>spoon 勺子</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 19</title>
    <url>/2020/06/07/Language/English/New%20Concept/Chapter1/lesson19/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>matter 事情<ol>
<li>What’s matter ?  wrong.</li>
<li>What’s the matter?  right.</li>
</ol>
</li>
<li>children  孩子们<ol>
<li>child 孩子</li>
<li>kid  -  kids  </li>
</ol>
</li>
<li>tired 累，疲乏<ol>
<li>I am tired.</li>
<li>Are you tired?</li>
<li>I am not tired.</li>
</ol>
</li>
<li>boy 男孩</li>
<li>thirsty 口渴的<ol>
<li>He’s thirsty.</li>
</ol>
</li>
<li>Mum 妈妈</li>
<li>sit down 坐下<ol>
<li>Sit down, please. Have a seat.</li>
</ol>
</li>
<li>right 好，可以<ol>
<li>All right.</li>
</ol>
</li>
<li>ice cream 冰激凌</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>又渴又累<ol>
<li>thirsty <strong>and</strong> tired</li>
</ol>
</li>
<li>又好看有善良<ol>
<li>Kind and beautiful</li>
</ol>
</li>
<li>又高又帅<ol>
<li>Tall and handsome</li>
</ol>
</li>
<li>又年轻又有钱<ol>
<li>young and rich</li>
</ol>
</li>
<li>高富帅<ol>
<li>tall, rich and handsome</li>
</ol>
</li>
<li>There’s an ice cream man.<ol>
<li>There be (is / are ) 句型</li>
<li>There’s a mailman.</li>
</ol>
</li>
<li>Two ice creams, please.</li>
<li>These ice creams are nice.</li>
<li>这个冰激凌真好吃</li>
<li>This ice cream is nice</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>复数 &amp; 句子<ol>
<li>Those children _ tired.</li>
<li>We _ thirsty.</li>
<li>This child _ very young.</li>
<li><strong>__</strong> children are tired.<ol>
<li>The  Those These</li>
</ol>
</li>
<li>__ mother is busy.<ol>
<li>My His Her Their</li>
</ol>
</li>
<li>__ friends are tall.<ol>
<li>My your his her our their</li>
</ol>
</li>
<li>__ brother is a taxi driver.<ol>
<li>My Your His Her</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>big 大的<ol>
<li>风大，雨大，雪大，heavy</li>
<li>声音大  loud</li>
<li>年纪大  old</li>
<li>面积大  large</li>
</ol>
</li>
<li>small 小的<ol>
<li>声音小  light</li>
<li>年龄小  young</li>
</ol>
</li>
<li>open 开着的<ol>
<li>The door is open.</li>
<li>The window is open.</li>
<li>Open the door.</li>
</ol>
</li>
<li>shut 关着的<ol>
<li>The windows is shut.</li>
</ol>
</li>
<li>light 轻的</li>
<li>heavy 重的</li>
<li>long 长的<ol>
<li>时间，东西</li>
</ol>
</li>
<li>shoe 鞋<ol>
<li>a shoe 一只鞋</li>
<li>a pair of shoes：一双鞋</li>
</ol>
</li>
<li>grandfather: 祖父，外祖父</li>
<li>grandmother  祖母，外祖母</li>
<li>you sister brother</li>
<li>mother father</li>
<li>husband   wife</li>
<li>son daughter</li>
<li>mother -&gt; uncle aunt</li>
<li>father -&gt; uncle aunt </li>
<li>father -&gt; grandmother grandfather</li>
<li>mother -&gt; 同</li>
<li>in- law  结婚后的亲属关系，后缀<ol>
<li>mother in-low</li>
<li>father in-low</li>
<li>sister in-low</li>
<li>brother in-low</li>
</ol>
</li>
<li>step 后的，继的    前缀<ol>
<li>step mother</li>
<li>step father</li>
<li>step sister</li>
</ol>
</li>
<li>ex- 前任的<ol>
<li>ex-girlfriend</li>
<li>ex-boyfriend</li>
<li>ex-wife</li>
<li>ex-husband</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 17</title>
    <url>/2020/06/07/Language/English/New%20Concept/Chapter1/lesson17/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>employee 雇员<ol>
<li>employ 雇佣</li>
<li>employer 雇佣者，雇主</li>
<li>-er  ..的人</li>
<li>-ee  被…的人</li>
<li>trainer  培训者</li>
<li>trainee 被培训的人</li>
</ol>
</li>
<li>hard-working 勤奋的<ol>
<li>构词：adj + doing</li>
<li>good-looking  好看的</li>
<li>easy-going 好相处的</li>
</ol>
</li>
<li>sales rep  推销员<ol>
<li>sales reps 复数</li>
<li>sales representative</li>
</ol>
</li>
<li>man  人，男人<ol>
<li>Hi, man!</li>
<li>men  复数</li>
</ol>
</li>
<li>office 办公室<ol>
<li>office buildings 办公大楼</li>
<li>office hours 办公时间</li>
</ol>
</li>
<li>assistant 助手<ol>
<li>an office assistant 办公室助理</li>
<li>a shop assistant 商场售货员</li>
<li>a classroom assistant 助教</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>打招呼<ol>
<li>Hello</li>
<li>How are you?</li>
<li>How are you doing?</li>
<li>How do you do?  幸会，使用场合非常正式</li>
<li>回答 —- How do you do.</li>
</ol>
</li>
<li>Come and meet …<ol>
<li>过来坐吧： Come and sit down.</li>
<li>过来喝一杯：Come and have a drink.</li>
<li>过来见见我的朋友：Come and meet my friend.</li>
</ol>
</li>
<li>What are their jobs?<ol>
<li>What is your job?</li>
<li>单词的复数 &amp; 句子的复数</li>
<li>This is my name.</li>
<li>These are their names.</li>
<li>That is her car.</li>
<li>Those are our cars.</li>
<li>He is an assistant.</li>
<li>They are assistant.</li>
<li>总结：句子的复数形式需要考虑代词，名词，动词的一致性。</li>
<li>Who is the young girl?</li>
<li>Who are the young girls?</li>
<li>What is your job?</li>
<li>What are their jobs?</li>
<li>He is a tourist.</li>
<li>They are tourists.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>名词的单复数<ol>
<li>books jobs</li>
<li>buses, boxes, brushes, benches, potatoes</li>
<li>wife-wifves, leaf-leaves</li>
<li>baby - babies</li>
<li>man-men  woman-women</li>
<li>foot-feet    tooth-teeth</li>
<li>child - children</li>
</ol>
</li>
<li>句子的复数<ol>
<li>单数名词 + is</li>
<li>复数名词 + are</li>
<li>Her passport _ green,</li>
<li>The men _ keyboard operators.</li>
<li>This assistant _ busy.</li>
<li>Our classroom _ large.</li>
<li>These umbrellas _ useful.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>What are their jobs?</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 15</title>
    <url>/2020/06/06/Language/English/New%20Concept/Chapter1/lesson15/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>customs 海关<ol>
<li>customer 顾客</li>
</ol>
</li>
<li>officer 官员<ol>
<li>customs officer 海关官员</li>
<li>CEO 首席执行官 Chief Executive Officer</li>
</ol>
</li>
<li>girl 女孩<ol>
<li>my girl</li>
</ol>
</li>
<li>Danish 丹麦人，丹麦的<ol>
<li>Denmark 丹麦</li>
<li>Chinese &amp; China</li>
</ol>
</li>
<li>friend 朋友<ol>
<li>a new friend / an old friend</li>
</ol>
</li>
<li>Norwegian 挪威人<ol>
<li>Norway 挪威</li>
</ol>
</li>
<li>passport 护照<ol>
<li>pass 通过</li>
<li>port 港口</li>
</ol>
</li>
<li>visa 签证</li>
<li>brown 棕色的<ol>
<li>brown tea 红茶</li>
<li>brown sugar 红糖</li>
</ol>
</li>
<li>tourist 旅游者<ol>
<li>-ist</li>
<li>artist  dentist</li>
<li>-er<ol>
<li>teacher worker driver</li>
</ol>
</li>
<li>-or<ol>
<li>doctor director</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Your passports, please.<ol>
<li>n. + please </li>
<li>点餐时</li>
<li>购物时</li>
<li>检票时</li>
</ol>
</li>
<li>We are Danish. 我们是丹麦人<ol>
<li>They are Norwegian. 他们是挪威人</li>
<li>我   I         am 我们   we  are</li>
<li>你  you     are 你们  you  are</li>
<li>他  he      is     他们  they  are</li>
<li>她  she    is     她们  they  are</li>
</ol>
</li>
<li>这些是你们的箱子么？<ol>
<li>Are these your cases?</li>
</ol>
</li>
<li>我们的箱子是棕色的<ol>
<li>Our cases are brown.</li>
<li>复数关乎整个句子，而非一个单词</li>
</ol>
</li>
<li>这是我的书。<ol>
<li>This is my book.</li>
</ol>
</li>
<li>这些是我们的书。<ol>
<li>These are our books.</li>
</ol>
</li>
<li>那是她的车。<ol>
<li>That is her car.</li>
</ol>
</li>
<li>那些是她们的车。<ol>
<li>Those are their cars.</li>
</ol>
</li>
<li>复数 物主代词<ol>
<li>我们的 our</li>
<li>他们的  their<ol>
<li>our books / their cars</li>
<li>our mum / school</li>
<li>their teacher / house</li>
</ol>
</li>
</ol>
</li>
<li>Here they are.</li>
<li>That’s fine.</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>名词的单数 &amp; 复数<ol>
<li>定义<ol>
<li>单数：1</li>
<li>复数：2 或 以上</li>
<li>a car - two cars</li>
<li>a bag - three bags</li>
</ol>
</li>
<li>规则<ol>
<li>一般的名字 +s<ol>
<li>a girl  —- girls</li>
<li>an officer —-  officers</li>
<li>a coat  —- coats</li>
</ol>
</li>
<li>以s , sh , x , ch 结尾的加  es <ol>
<li>a bus   —-  buses</li>
<li>a box   —-  boxes</li>
<li>a brush  —- brushes</li>
</ol>
</li>
<li>以 f ,  fe  结尾的变 f, fe —- ves<ol>
<li>a wife —- wives</li>
<li>a shelf —- shelves</li>
<li>a knife —- knives</li>
<li>a leaf —- leaves</li>
</ol>
</li>
<li>辅音字母+y结尾的名词，变y-i   + es<ol>
<li>a baby — babies</li>
<li>a lady —- ladies</li>
</ol>
</li>
<li>元音 + o  结尾  + s<ol>
<li>a zoo —- zoos</li>
<li>a radio  —- radios</li>
<li>辅音+o结尾 ， +  es</li>
<li>a hero —- heroes</li>
<li>a potato   —- patatoes</li>
<li>a tomato —- tomatoes</li>
</ol>
</li>
</ol>
</li>
<li>单数-复数名词在句子中<ol>
<li>单数  + is</li>
<li>复数 + are</li>
<li>The tourists  _ from Norway.</li>
<li>The teacher _ Aamercan.</li>
<li>These cars _ brown.</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>Russian  俄罗斯人<ol>
<li>Russia 俄罗斯</li>
</ol>
</li>
<li>Dutch 荷兰人<ol>
<li>Holland / Netherland 荷兰</li>
</ol>
</li>
<li>these  这些<ol>
<li>this  这个    these  这些</li>
<li>that  那个    those 那些</li>
<li>这是他的手表。  This is his watch. These are their watches..</li>
</ol>
</li>
<li>red 红色的</li>
<li>grey  灰色的<ol>
<li>gray</li>
<li>grey hair 花白的头发</li>
</ol>
</li>
<li>black  黑色的</li>
<li>black tea 红茶</li>
<li>black coffee 纯咖啡</li>
<li>yellow 黄色的</li>
<li>orange 橘黄色的</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 13-14</title>
    <url>/2020/06/02/Language/English/New%20Concept/Chapter1/lesson13/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>color / colour 颜色<ol>
<li>What color?</li>
<li>What color is it?</li>
</ol>
</li>
<li>green 绿色<ol>
<li>a green hand 新手</li>
<li>green tea 绿茶</li>
</ol>
</li>
<li>come 来<ol>
<li>come here 过来</li>
</ol>
</li>
<li>upstairs 楼上<ol>
<li>come upstairs 上楼来</li>
<li>go downstairs 下楼去</li>
</ol>
</li>
<li>smart 时髦的，漂亮的<ol>
<li>beautiful / smart</li>
</ol>
</li>
<li>same 相同的<ol>
<li>the same color / name / city</li>
</ol>
</li>
<li>lovely 可爱的，漂亮的<ol>
<li>beautiful / smart / lovely / nice</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>What color is your _?</li>
<li>Come and see her.<ol>
<li>Come and meet my mom.</li>
<li>Come and do it.</li>
<li>Come and sit down …</li>
</ol>
</li>
<li>here it is —— It is here.<ol>
<li>Here + 主语 + 动词</li>
<li>I am here.  Here I am.</li>
<li>He is here.  Here he is.</li>
<li>Here we go …</li>
</ol>
</li>
<li>漂亮 /  好看<ol>
<li>beautiful / lovely / nice</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>特殊疑问词<ol>
<li>语序：特殊疑问词 + be + n</li>
<li>你的名字是什么？</li>
<li>What is you name?</li>
<li>你的工作是什么？</li>
<li>What is you job?</li>
<li>你的外套是什么颜色的？</li>
<li>What color is your _?</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>case 箱子<ol>
<li>suitcase 手提箱</li>
</ol>
</li>
<li>carpet 地毯<ol>
<li>car 汽车 + pet 宠物</li>
</ol>
</li>
<li>dog 狗<ol>
<li>a lucky dog 幸运儿</li>
</ol>
</li>
<li>What color is your _?<ol>
<li>umbrella</li>
<li>car</li>
<li>shirt</li>
<li>coat</li>
<li>case </li>
<li>carpet</li>
<li>blouse</li>
<li>tie</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>docker一些参数修改</title>
    <url>/2020/06/02/Docker/docker%E5%8F%82%E6%95%B0%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>有时候需要修改docker的一些参数，如restart，或者command命令，但是不想重新构建容器，这时候可以这么做：</p><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/lib/docker/containers/ID/</span><br></pre></td></tr></table></figure>
<p>进入到ID对应目录，里面有两个文件config.v2.json  hostconfig.json，config.v2.json里可以修改command的相关命令，hostconfig.json可以修改端口绑定，地址映射等配置。</p>
<p>修改时需要stop掉，完事之后才start，才生效。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 11-12</title>
    <url>/2020/06/01/Language/English/New%20Concept/Chapter1/lesson11/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>whose 谁的<ol>
<li>what 什么</li>
<li>whose pen / whose shirt / whose car</li>
</ol>
</li>
<li>blue 蓝色<ol>
<li>忧郁的 You are blue today</li>
<li>不健康的 It’s blue book.</li>
<li>贵族的  blue blood</li>
</ol>
</li>
<li>perhaps 大概<ol>
<li>Perhaps it is. 可能是这样吧。</li>
<li>Perhaps so.</li>
<li>Perhaps not.</li>
</ol>
</li>
<li>white 白色<ol>
<li>the White House 白宫</li>
<li>white lie 善意的谎言</li>
</ol>
</li>
<li>catch 抓住，接着<ol>
<li>catch the thief</li>
<li>catch the ball</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Whose shirt is that?<ol>
<li>whose shirt / shose car / show friends</li>
<li>That is whose shirt?</li>
<li><strong>特殊疑问词 + be + 名词n</strong></li>
<li>Whose is that shirt?</li>
<li>Whose shirt is that?</li>
<li><strong>特殊疑问词 + 名词 + be + 代词</strong></li>
<li>这是谁的车？  Whose is this car? Whose car is this?</li>
<li>那是谁的包？ Whose is that bag? Whose bag is this?</li>
</ol>
</li>
<li>Is this your shirt, Dave?<ol>
<li>Excuse me , sir.</li>
<li>Hello, Mr. Lee.</li>
</ol>
</li>
<li>Here you are. 给你</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>谁谁谁的 <ol>
<li>我的：my</li>
<li>你的：your</li>
<li>Lucy的：Lucy’s</li>
<li>Lucy的朋友：Lucy’s frined</li>
<li>Lily的书：Lily’s book</li>
<li>我妈妈的包：my mother’s bag</li>
<li>司机的手表：the driver’s watch</li>
<li>医生的车：the doctor’s car</li>
<li>有生命的才能用’s</li>
<li>Jay’s son</li>
<li>Zhouxun’s daughter</li>
<li>Mr. Chen’s son</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>father 父亲<ol>
<li>day / daddy </li>
</ol>
</li>
<li>mother 母亲<ol>
<li>mom / mum / mummy</li>
</ol>
</li>
<li>blouse 女衬衫</li>
<li>sister 姐姐</li>
<li>tie 领带</li>
<li>brother 兄弟</li>
<li>his 他的</li>
<li>her 她的<ol>
<li>物主代词<ol>
<li>我的 my</li>
<li>你的 your</li>
<li>他的 his</li>
<li>她的  her</li>
</ol>
</li>
<li>my book</li>
<li>your house</li>
<li>his tie</li>
<li>Her sister is his girfriend.</li>
<li>His wife is her good friend.</li>
<li>His brother is her boss.</li>
</ol>
</li>
<li>Whose is this handbag?<ol>
<li>Whose handbag is this?</li>
</ol>
</li>
<li>Whose is this car?<ol>
<li>Whose car is this?</li>
</ol>
</li>
<li>Whose is this coat?<ol>
<li>Whose coat is this? It’s Sophies’</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 0-10</title>
    <url>/2020/05/31/Language/English/New%20Concept/Chapter1/lesson9/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>hello</li>
<li>hey</li>
<li>hi</li>
<li>how 如何，怎样<ol>
<li>How are you ?</li>
<li>How is your mother?</li>
<li>How is the weather?</li>
</ol>
</li>
<li>today 今天</li>
<li>tonight 今晚</li>
<li>well 身体好</li>
<li>thanks 感谢<ol>
<li>Thanks a lot.  非常感谢。</li>
<li>Thank you very much.</li>
</ol>
</li>
<li>good-bye 再见</li>
<li>see 看见<ol>
<li>See you.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>打招呼<ol>
<li>Hello</li>
<li>How are you?</li>
<li>How are you doing?</li>
</ol>
</li>
<li>How are you? 的回应<ol>
<li>Fine. Very well. Thank you, and you </li>
<li>Not bad.</li>
<li>very bad. Terrible.</li>
</ol>
</li>
<li>How are you 句型替换<ol>
<li>How _ your fater?</li>
<li>How _ Lucy?</li>
<li>How _ they?</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>冠词<ol>
<li>概念：待在名词头上的帽子，没有特殊情况不能摘<ol>
<li>国家，国际，人名，城市名</li>
</ol>
</li>
<li>读音<ol>
<li>an egg/ a dress / the student / the Italian car</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>fat 胖的<ol>
<li>a fat cat</li>
<li>a littne heavy</li>
</ol>
</li>
<li>woman 女人<ol>
<li>lady </li>
<li>an old woman</li>
<li>an old lady</li>
</ol>
</li>
<li>thin 瘦的<ol>
<li>slim 苗条的</li>
<li>You are so slim.</li>
</ol>
</li>
<li>tall 高的<ol>
<li>short 矮的</li>
</ol>
</li>
<li>dirty 脏的</li>
<li>clean 干净的</li>
<li>hot 热的<ol>
<li>It is hot today. </li>
<li>The girl is very hot.</li>
<li>Lady GaGa is hot now.</li>
</ol>
</li>
<li>cold 冷的<ol>
<li>It is very cold today. 今天天气很冷</li>
<li>I have a cold welcome. 我受到了冷遇</li>
</ol>
</li>
<li>old 老的，旧的<ol>
<li>He is an old man.</li>
<li>It is an old story.</li>
<li>That is my old book.</li>
</ol>
</li>
<li>young 年轻的<ol>
<li>He is a young man.</li>
</ol>
</li>
<li>busy 忙的<ol>
<li>It is a busy day.</li>
<li>He is very busy.</li>
</ol>
</li>
<li>lazy 懒惰的</li>
</ol>
<blockquote>
<p> 重点句型</p>
</blockquote>
<ol>
<li>Look at … 看<ol>
<li>meet you / him / her</li>
<li>look at &amp; see 看 &amp; 看见</li>
<li>Look at the man. He is very busy.</li>
<li>I see him in the street.<br>5.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 7-8</title>
    <url>/2020/05/31/Language/English/New%20Concept/Chapter1/lesson7/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>I 我<ol>
<li>me 我（宾格）</li>
<li>_ love English.</li>
<li>He loves _.</li>
</ol>
</li>
<li>am  be动词现在时第一人称单数<ol>
<li>be:  am / is / are</li>
</ol>
</li>
<li>are be动词现在时复数<ol>
<li>You are … = You’re</li>
<li>We are … = We’re</li>
</ol>
</li>
<li>is<ol>
<li>He is … = He’s</li>
<li>She is … = She’s</li>
<li>It is … = It’s</li>
</ol>
</li>
<li>name 名字<ol>
<li>my name / English name / Chinese name</li>
</ol>
</li>
<li>what 什么</li>
<li>nationality 国籍</li>
<li>job 工作（职业）<ol>
<li>a good job</li>
</ol>
</li>
<li>keyboard 电脑键盘<ol>
<li>key 钥匙</li>
<li>board 板子</li>
</ol>
</li>
<li>operator 操作人员<ol>
<li>director 导演</li>
</ol>
</li>
<li>engineer 工程师<ol>
<li>teacher 老师</li>
<li>worker 工作人员</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>I am a new student.</li>
<li>My name’s Robert.</li>
<li>Are you French?</li>
<li>I’m Italian</li>
<li>What nationality are you?<ol>
<li>My nationality is China.</li>
<li>I’m Chinese.</li>
</ol>
</li>
<li>What’s your job?<ol>
<li>I’m a worker.</li>
<li>I have no job. I’m a student.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般疑问句<ol>
<li>功能：询问</li>
<li>构成：is / am / are 置于句前</li>
<li>Are you French?  You are French.</li>
<li>Are you a teacher? You are a teacher.</li>
<li>She is a doctor. Is she a doctor?</li>
<li>He is a student. Is he a student?</li>
<li>I am Chinese. Are you Chinese?</li>
<li>This is my teacher. Is this my teacher?</li>
</ol>
</li>
<li>特殊疑问句<ol>
<li>什么、谁、谁的、哪个…</li>
<li>What…<ol>
<li>你的工作是什么？ </li>
<li>What is you job?</li>
<li>你的名字是什么？</li>
<li>What is your name?</li>
<li>你的电话号码是多少？</li>
<li>What’s you phone number?</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>policeman 警察</li>
<li>police 警方</li>
<li>police car 警车</li>
<li>policewoman 女警察</li>
<li>taxi driver 出租车司机<ol>
<li>taxi 出租车</li>
<li>cab 的士</li>
</ol>
</li>
<li>airhostess 空姐<ol>
<li>air 空气 / 航空</li>
<li>airline 航线 / 航空公司</li>
<li>host 主人</li>
<li>hostess 女主人</li>
<li>-ess 表示女性的后缀</li>
</ol>
</li>
<li>waiter 男服务员<ol>
<li>waitress 女服务员</li>
</ol>
</li>
<li>tiger 老虎<ol>
<li>tigress 母老虎</li>
</ol>
</li>
<li>actro 演员<ol>
<li>actress 女演员</li>
</ol>
</li>
<li>lion<ol>
<li>lioness 母狮子</li>
</ol>
</li>
<li>postman 邮递员<ol>
<li>post 邮政</li>
<li>mailman E-mail</li>
</ol>
</li>
<li>nurse 护士</li>
<li>mechanic 机械师</li>
<li>haredresser 理发师</li>
<li>housewife 家庭主妇<ol>
<li>house 房子</li>
<li>wife 妻子</li>
</ol>
</li>
<li>milkman 送牛奶的人<ol>
<li>man 标识人的后缀</li>
<li>policeman / superman / milkman</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 5-6</title>
    <url>/2020/05/31/Language/English/New%20Concept/Chapter1/lesson5/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>Mr. : 先生<ol>
<li>Miss 未婚女性</li>
<li>Mrs 已婚女性</li>
<li>王先生：Mr. Wang</li>
<li>李叔叔 Uncle Li</li>
</ol>
</li>
<li>good 好<ol>
<li>well 身体好</li>
</ol>
</li>
<li>morning 早晨<ol>
<li>Good morning.</li>
</ol>
</li>
<li>new 新的</li>
<li>old 旧的<ol>
<li>a new car/ a new coat/ a new house</li>
</ol>
</li>
<li>student 学生、</li>
<li>nice </li>
<li>meet 遇见<ol>
<li>meet you  / him / her / me</li>
</ol>
</li>
<li>too 也（肯定，疑问句末）</li>
<li>Frence 法国<ol>
<li>French 法国人，法语的，法国的</li>
<li>I am in France.</li>
<li>I can speak French.</li>
</ol>
</li>
<li>Germany 德国<ol>
<li>German 德国人，德语，德国的</li>
</ol>
</li>
<li>Japan 日本<ol>
<li>Janpanese 日本人，日语的，日本的</li>
</ol>
</li>
<li>Korea 韩国<ol>
<li>Korean 韩国人，韩语，韩国的</li>
</ol>
</li>
<li>China 中国<ol>
<li>Chinese 中国人，中国的，汉语</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>早上见面打招呼：<ol>
<li>Good morning.</li>
<li>Morning!</li>
<li>下午见面打招呼：<ol>
<li>Good afternoon.</li>
</ol>
</li>
<li>晚上见面打招呼<ol>
<li>Good evening</li>
</ol>
</li>
</ol>
</li>
<li>介绍认识：<ol>
<li>This is _.</li>
<li>Nice to meet you.</li>
</ol>
</li>
<li>详细介绍<ol>
<li>She is _.</li>
<li>He is _.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>冠词<ol>
<li>概念：戴在名词头上的帽子，没有<strong>特殊情况</strong>不能摘帽子。<ol>
<li>特殊情况：国家（简写）、国籍、人名、城市名</li>
</ol>
</li>
<li>a nice car/ a big house/ a good name</li>
<li>包括： a / an / the</li>
<li>意思：a \ an  一个，一间，一台，一…<ol>
<li>The 这，那，这些，那些</li>
<li>the student 这个</li>
<li>the students 这些</li>
</ol>
</li>
<li>分类<ol>
<li>定冠词 the —— 确定的、知道的</li>
<li>不定冠词 a \ an  —— 不确定的，不知道的<ol>
<li>There is a monk. 那有一个和尚</li>
<li>The monk is Jack.  那个和尚叫Jack</li>
</ol>
</li>
<li>a / an 的却别<ol>
<li>an + 元音发音开头的单词，其余用a<ol>
<li>an egg</li>
<li>an orange</li>
<li>an hour</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词句型</p>
</blockquote>
<ol>
<li>make 牌子<ol>
<li>What make is _?</li>
<li>What make is you car?</li>
<li>What make are you shoes?</li>
</ol>
</li>
<li>Sweden 瑞典<ol>
<li>Swendish 瑞典人，瑞典的</li>
</ol>
</li>
<li>England 英格兰<ol>
<li>English 英国的，英国人，英语</li>
</ol>
</li>
<li>America 美国<ol>
<li>American 美国人，美国的</li>
<li>The United States of America</li>
</ol>
</li>
<li>Italy 意大利<ol>
<li>Italian 意大利人，意大利语，意大利的</li>
</ol>
</li>
<li>This is a Swedish car.</li>
<li>This is a French car.</li>
<li>This is a German car.</li>
<li>This is Janpanese car.</li>
<li>This is an American car.</li>
<li>This an Italian car.<br>12.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA EntityManager的一个问题</title>
    <url>/2020/05/28/Spring%20Data%20JPA/EntityManager/</url>
    <content><![CDATA[<p>JPA实体生命周期有四种状态</p><ol>
<li><p>New：瞬时对象，尚未有id，还未和Persistence Context建立关联的对象。</p>
</li>
<li><p>Managed：持久化受管对象，有id值，已经和Persistence Context建立了关联的对象。</p>
</li>
<li><p>Datached：游离态离线对象，有id值，但没有和Persistence Context建立关联的对象。</p>
</li>
<li><p>Removed：删除的对象，有id值，尚且和Persistence Context有关联，但是已经准备好从数据库中删除</p>
</li>
</ol><a id="more"></a>

<p>由于JPAQuery绑定EntityManager，查询出来的实体还有ID，实际上是处于Managed状态，查询完毕之后，每一条都会执行一条update语句来更新数据库，比较浪费资源，如果不想这么做的话，可以使用new JPAQuery，而不是JPAQueryFactory，查询完毕，手动执行entityManager.clear()来讲对象改为Detached状态，这样，便不会每一条都执行一遍update操作。</p>
]]></content>
      <categories>
        <category>Spring Data JPA</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 3-4</title>
    <url>/2020/05/26/Language/English/New%20Concept/Chapter1/lesson3/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>umbrella 雨伞</li>
<li>please 请<ol>
<li>求你了</li>
<li>please do 拜托</li>
</ol>
</li>
<li>here 这里<ol>
<li>there 那里</li>
<li>where 哪里</li>
</ol>
</li>
<li>my 我的<ol>
<li>my school</li>
<li>my friend</li>
<li>This is my school.</li>
<li>This is my friend.</li>
</ol>
</li>
<li>your 你的<ol>
<li>your school</li>
<li>your friend</li>
</ol>
</li>
<li>ticket 票<ol>
<li>a train ticket</li>
<li>a move ticket</li>
</ol>
</li>
<li>number 号码<ol>
<li>No. one</li>
</ol>
</li>
<li>five 五</li>
<li>sorry 对不起</li>
<li>sir 先生</li>
<li>cloakroom 衣帽存放处</li>
</ol>
<blockquote>
<p> 课文</p>
</blockquote>
<ol>
<li>My coat and umbrella, please.<ol>
<li>请拿一下我的外套和雨伞</li>
<li>n. + please<ol>
<li>点餐时  A roast duck, please.</li>
<li>购物时  This shirt, please</li>
<li>进站时  Your ID card, please</li>
</ol>
</li>
</ol>
</li>
<li>Here is my ticket.<ol>
<li>My ticket is here.</li>
<li>我的票在这里</li>
</ol>
</li>
<li>Here’s your umbrella and your coat.<ol>
<li>这里是你的雨伞和外套</li>
<li>Your coat and your umbrella are here.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>否定句<ol>
<li>功能：说不</li>
<li>构成：is not/ am not/ are not</li>
<li>This is my name. This is not my name.</li>
<li>I am Venus. I am not Venus.</li>
<li>You are my friend. You are not my friend.</li>
<li>She is pretty. She is not pretty.</li>
<li>这不是我的车。This is not my car. </li>
<li>我不是老师。 I am not a techer.</li>
</ol>
</li>
<li>is not = isn’t<ol>
<li>She is not here.  She isn’t here.</li>
</ol>
</li>
<li>am not = ‘m not<ol>
<li>I am not Linda. I’m not Linda.</li>
</ol>
</li>
<li>are not = aren’t<ol>
<li>You are Tom. You aren’t Tom.</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>suit 一套衣服</li>
<li>school 学校<ol>
<li>小学： primary school</li>
<li>中学： middle school</li>
<li>大学：university</li>
</ol>
</li>
<li>teacher 老师<ol>
<li>王老师：Mr.Wang/ Miss Wang</li>
</ol>
</li>
<li>son 儿子</li>
<li>daughter 女儿<br>6.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念1 1-2</title>
    <url>/2020/05/24/Language/English/New%20Concept/Chapter1/lesson1/</url>
    <content><![CDATA[<blockquote>
<p>单词</p>
</blockquote>
<a id="more"></a>
<ol>
<li>excuse<ol>
<li>Excuse me<ol>
<li>对不起，打扰了</li>
<li>借过一下，让一让</li>
<li>失陪了</li>
<li>麻烦再说一遍</li>
</ol>
</li>
</ol>
</li>
<li>me <ol>
<li>主格  I   <ol>
<li>I</li>
<li>you </li>
<li>she </li>
<li>he </li>
<li>it</li>
</ol>
</li>
<li>宾格 me<ol>
<li>me</li>
<li>you</li>
<li>her</li>
<li>him</li>
<li>it</li>
</ol>
</li>
<li>简单句 并列句 从句</li>
<li>简单句句型结构<ol>
<li>主+谓</li>
<li>主+谓+宾<ol>
<li>I love you.</li>
<li>I love him.</li>
<li>You love me.</li>
</ol>
</li>
<li>主+谓+宾+宾</li>
<li>主+谓+宾+宾补</li>
<li>主+系（is, am, are）+表<ol>
<li>She is beautiful.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>yes 是的<ol>
<li>yes? 什么事？</li>
</ol>
</li>
<li>is （be动词现在时，第三人称单数）<ol>
<li>be  — is, am, are</li>
</ol>
</li>
<li>this <ol>
<li>this book 这本书</li>
<li>that student 那位学生</li>
</ol>
</li>
<li>your<ol>
<li>your friend 你的朋友</li>
<li>your name 你的名字</li>
</ol>
</li>
<li>handbag <ol>
<li>hand 手  bag 包</li>
</ol>
</li>
<li>pardon 原谅，再说一遍</li>
<li>it  代替物体、地方、天气<ol>
<li>It is a desk.</li>
<li>It is Beijing.</li>
<li>It is find today.</li>
</ol>
</li>
<li>thank you 感谢<ol>
<li>Thanks!</li>
<li>Thanks a lot!</li>
</ol>
</li>
<li>very much 非常地<ol>
<li>I love you very much. </li>
<li>Thank you very much.</li>
</ol>
</li>
</ol>
<blockquote>
<p>课文</p>
</blockquote>
<ol>
<li>Excuse me.<ol>
<li>对不起，打扰了</li>
<li>借过一下，让一让</li>
<li>失陪了</li>
<li>麻烦再说一遍</li>
</ol>
</li>
<li>Yes? 什么事？</li>
<li>Is this your handbag?</li>
<li>Pardon? 麻烦您再说一遍<ol>
<li>Sorry?</li>
<li>Excuse me?</li>
<li>Say it again.</li>
</ol>
</li>
</ol>
<blockquote>
<p>语法</p>
</blockquote>
<ol>
<li>一般疑问句<ol>
<li>功能：询问</li>
<li>构成：be动词置于句子前面</li>
<li>This is your name.  Is this your name?</li>
<li>I am nice.  Am I nice?</li>
<li>You are my friend. Are you my friend?</li>
<li>She is pretty.  Is she pretty?</li>
</ol>
</li>
</ol>
<blockquote>
<p>单词</p>
</blockquote>
<ol>
<li>pen 钢笔</li>
<li>pencil 铅笔</li>
<li>book 书<ol>
<li>an English book</li>
<li>a book store</li>
<li>book one, book two, book three, book four</li>
</ol>
</li>
<li>watch 手表<ol>
<li>look at my watch</li>
<li>Swatch</li>
</ol>
</li>
<li>coat 外套</li>
<li>dress 连衣裙</li>
<li>skirt 短裙</li>
<li>car 小车</li>
<li>bus 公共汽车</li>
<li>coach 长途汽车</li>
<li>house 别墅<ol>
<li>flat 公寓楼  英</li>
<li>apartment 公寓楼 美</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>新概念1</tag>
      </tags>
  </entry>
  <entry>
    <title>数词</title>
    <url>/2020/05/24/Language/English/New%20Concept/Word/Numeral/Numeral/</url>
    <content><![CDATA[<p>常见数词</p>
<a id="more"></a>
<blockquote>
<p>基数词</p>
</blockquote>
<ol>
<li>one 一</li>
<li>two 二</li>
<li>three 三</li>
<li>four 四</li>
<li>five 五</li>
<li>six 六</li>
<li>seven 七</li>
<li>eight 八</li>
<li>nine 九</li>
<li>ten 十</li>
<li>eleven 十一</li>
<li>twelve 十二</li>
<li>thirteen 十三</li>
<li>fourteen 十四</li>
<li>fifteen 十五</li>
<li>sixteen 十六</li>
<li>seventeen 十七</li>
<li>eighteen 十八</li>
<li>nineteen 十九</li>
<li>twenty 二十</li>
<li>thirty 三十</li>
<li>forty 四十</li>
<li>fifty 五十</li>
<li>sixty 六十</li>
<li>seventy 七十</li>
<li>eighty 八十</li>
<li>ninety 九十</li>
<li>hundred 百</li>
<li>thousand 千</li>
<li>million 百万</li>
<li>billion 十亿</li>
<li>twenty one 二十一</li>
<li>fifty nine 五十九</li>
<li>one hundred (and) thirty 一百三</li>
<li>two thousand, five hundred and eight.</li>
<li>six million, five hundred fourty three thousand, two hundred seventy eight.</li>
</ol>
<blockquote>
<p>序数词</p>
</blockquote>
<ol>
<li>first 第一</li>
<li>second 第二</li>
<li>third 第三</li>
<li>fourth 第四</li>
<li>fifth 第五</li>
<li>sixth 第六</li>
<li>seventh 第七</li>
<li>eighth 第八</li>
<li>ninth 第九</li>
<li>tenth 第十</li>
<li>eleventh 第十一</li>
<li>twelfth 第十二</li>
<li>thirteenth 第十三</li>
<li>fourteenth 第十四</li>
<li>fifteenth 第十五</li>
<li>sixteenth 第十六</li>
<li>seventeenth 第十七</li>
<li>eighteenth 第十八</li>
<li>nineteenth 第十九</li>
<li>twentieth 第二十</li>
<li>twenty first 第二十一</li>
<li>twenty second 第二十二</li>
<li>twenty third 第二十三</li>
<li>twenty fourth 第二十四</li>
<li>twenty fifth 第二十五</li>
<li>twenty sixth </li>
<li>twenty seventh</li>
<li>twenty eighth</li>
<li>twenty ninth</li>
<li>thirtieth 第三十</li>
<li>thirth first<br>32.</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>连词</title>
    <url>/2020/05/23/Language/English/New%20Concept/Word/Conjunction/Conjunction/</url>
    <content><![CDATA[<p>常见连词</p>
<a id="more"></a>
<ol>
<li>and 和，然后<ol>
<li>Do it slowly and carefully.</li>
<li>She came in and sat down.</li>
</ol>
</li>
<li>or 或者；否则<ol>
<li>Is the baby a boy or a girl?</li>
<li>Wear your coat or you’ll catch cold.</li>
</ol>
</li>
<li>but 但是<ol>
<li>It’s an old car, but it’s very good.</li>
<li>I’d like to go but I’m too busy.</li>
</ol>
</li>
<li>when 当…时<ol>
<li>It was raining when we arrived.</li>
<li>I loved history when I was at school.</li>
</ol>
</li>
<li>while 在…期间，当…时；然而<ol>
<li>He fell aslleep while (he was) doing his homework.</li>
<li>Tom is good at English while his brother doesn’t.</li>
</ol>
</li>
<li>as 当…时；想…一样；由于<ol>
<li>I saw Peter as I was getting off the bus.</li>
<li>They did as I had asked.</li>
<li>As you weren’t there I left a message.</li>
</ol>
</li>
<li>before 在…以前<ol>
<li>Do it before you forget.</li>
<li>Did she leave a message before she left?</li>
</ol>
</li>
<li>after 在…以后<ol>
<li>I’ll call you after I get off the plane.</li>
<li>They arrived shortly after I left.</li>
</ol>
</li>
<li>as soon as 一…就…<ol>
<li>As soon as I saw her, I knew there was something wrong.</li>
<li>He left as soon as he heard the news.</li>
</ol>
</li>
<li>since 自从…以来；既然<ol>
<li>Where have you been since I last saw you ?</li>
<li>Since we have money, we can buy a new car.</li>
</ol>
</li>
<li>until 直到<ol>
<li>Wait until the rain stops.</li>
<li>Don’t leave until I arrive.</li>
</ol>
</li>
<li>because 因为<ol>
<li>I decided to go with them, because I had nothing to do.</li>
<li>Why can’t I go? Because you’re not old enough.</li>
</ol>
</li>
<li>for 因为，由于<ol>
<li>I believed her, for she would not lie to me.</li>
<li>He had to give up smoking, for his wife was pregnant.</li>
</ol>
</li>
<li>so 因此<ol>
<li>The shops were closed so I didn’t get any milk.</li>
<li>I was hungry, so I made myself a sandwich.</li>
</ol>
</li>
<li>if 如果<ol>
<li>If it is necessary I will come at 6.</li>
<li>You can stay to dinner if you like.</li>
</ol>
</li>
<li>unless 除非<ol>
<li>He won’t go to sleep unless you tell him a story.</li>
<li>I can’t leave you unless I know you are all right.</li>
</ol>
</li>
<li>although 尽管，虽然</li>
<li>though<ol>
<li>Although we all tried our best, we lost the game.</li>
<li>Although he entered the game for fun, he won first prize.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>介词</title>
    <url>/2020/05/18/Language/English/New%20Concept/Word/Prepositions/Prepositions/</url>
    <content><![CDATA[<p>常见介词</p>
<a id="more"></a>
<ol>
<li>about  关于<ol>
<li>Tell me about it.</li>
<li>There’s nothing I can do about it.</li>
</ol>
</li>
<li>above 在…之上；超过<ol>
<li>We were flying above the clouds.</li>
<li>We don’t accept children above the age of 10.</li>
</ol>
</li>
<li>across 横穿；在…对面<ol>
<li>He swam across the river.</li>
<li>My house is just across the street.</li>
</ol>
</li>
<li>after 在…后面；在…以后<ol>
<li>After you.</li>
<li>We’ll leave after lunch.</li>
</ol>
</li>
<li>against 反对；紧靠<ol>
<li>Most people are against the plan.</li>
<li>He was leaning against a tree.</li>
</ol>
</li>
<li>alone 沿着<ol>
<li>We walked slowly along the road.</li>
<li>Houses were built along both sides of the river.</li>
</ol>
</li>
<li>among 在…中间<ol>
<li>He found it among a pile of old books.</li>
<li>She was the eldest among them.</li>
</ol>
</li>
<li>around 围绕；在附近；大约；到处<ol>
<li>The earth moves around the sun.</li>
<li>It’s somewhere around here.</li>
<li>See you around 7:30.</li>
<li>travel around the world</li>
</ol>
</li>
<li>as 作为；像<ol>
<li>You can use that glass as a vase.</li>
<li>They were all dressed as clowns.</li>
</ol>
</li>
<li>at 在<ol>
<li>They arrived at the airport.</li>
<li>We left at 2 o’clock.</li>
</ol>
</li>
<li>before 在…之前<ol>
<li>the day before yesterday</li>
<li>Larry arrived home before me.</li>
</ol>
</li>
<li>behind 在…的后面<ol>
<li>Who’s the girl standing behind Richard?</li>
<li>I hid behind a tree.</li>
</ol>
</li>
<li>below 在…下面，低于..<ol>
<li>Please do not write below this line.</li>
<li>The temperatures remained below zero all day.</li>
</ol>
</li>
<li>beside 在…旁边<ol>
<li>Sit beside your sister.</li>
<li>Put it on the table beside the bed.</li>
</ol>
</li>
<li>besides 除…之外（还有）<ol>
<li>We have lots of things in common besides music.</li>
<li>There will be five of us, besides John.</li>
</ol>
</li>
<li>between 在…之间<ol>
<li>Peter sat between Mary and Jane.</li>
<li>I don’t eat between meals.</li>
</ol>
</li>
<li>beyond 超过，越过<ol>
<li>It won’t go on beyound midnight.</li>
<li>The bicycle is beyond repair.</li>
</ol>
</li>
<li>but 除…之外<ol>
<li>Everyone was there but him.</li>
<li>Nobody but you could be so selfish.</li>
</ol>
</li>
<li>down 向下；沿着…向下<ol>
<li>The stone rolled down the hill.</li>
<li>Go down the road till you reach the traffic lights.</li>
</ol>
</li>
<li>during 在…期间<ol>
<li>During the summer she worked as a lifeguard.</li>
<li>He was taken to the hospital during the night.</li>
</ol>
</li>
<li>except 除…外<ol>
<li>They all came except Matt.</li>
<li>The restaurant is open every day except Monday.</li>
</ol>
</li>
<li>for 为，为了<ol>
<li>Is the present for me?</li>
<li>What can I do for you?</li>
</ol>
</li>
<li>from 从…;来自;<ol>
<li>We’re open from 8 to 7 every day.</li>
<li>Where are you from?</li>
</ol>
</li>
<li>in 在…里面，在…以内；进入；在…之后<ol>
<li>the highest mountain in the world</li>
<li>What have you got in your hand?</li>
<li>Throw it in the fire.</li>
<li>I’ll be back in two hours.</li>
</ol>
</li>
<li>inside 在（往）…里面<ol>
<li>Go inside the house.</li>
<li>There was a gold watch inside the box.</li>
</ol>
</li>
<li>into 进入…中<ol>
<li>There must be another way into the cave.</li>
<li>I nearly ran into a bus.</li>
</ol>
</li>
<li>like 像（某人/某事物），类似<ol>
<li>He’s like his father.</li>
<li>What’s she like?</li>
</ol>
</li>
<li>near 接近，靠近<ol>
<li>They live near London.</li>
<li>Don’t sit near the door.</li>
</ol>
</li>
<li>of 属于…的；关于；表示数量<ol>
<li>a friend of mine</li>
<li>the rights of man</li>
<li>a map of China</li>
<li>a piece of paper</li>
</ol>
</li>
<li>off 从…落下或离开<ol>
<li>Keep off the grass.</li>
<li>The ball rolled off the table.</li>
</ol>
</li>
<li>on 在…上；在…之时；在某一天<ol>
<li>Put the glasses on the table.</li>
<li>On hearing the news, she cried.</li>
<li>I was born on November 29th.</li>
</ol>
</li>
<li>outside 在…的外面；超出…的范围<ol>
<li>You can park your car outside our house.</li>
<li>The matter is outside my area of responsibility.</li>
</ol>
</li>
<li>over 越过；在…上面<ol>
<li>There is a bridge over the river.</li>
<li>There was a lamp over the table.</li>
</ol>
</li>
<li>past 在…之后；经过<ol>
<li>half past two</li>
<li>She walked past me without saying hi.</li>
</ol>
</li>
<li>since 自从<ol>
<li>I haven’t eaten since breakfast.</li>
<li>We’ve been waiting here since two o’clock.</li>
</ol>
</li>
<li>through 穿过<ol>
<li>He got in through the window.</li>
<li>The River Thames flows through London.</li>
</ol>
</li>
<li>throughout 遍及…；自始至终<ol>
<li>News spread throughout the country.</li>
<li>He remained in Paris throughout the war.</li>
</ol>
</li>
<li>till 直到<ol>
<li>We’re open till 6 o’clock.</li>
<li>The street is full of traffic from morning till night.</li>
</ol>
</li>
<li>to 向，朝着；到<ol>
<li>I’m on my way to the airport.</li>
<li>I’m free from Monday to Friday.</li>
</ol>
</li>
<li>towards 朝，向</li>
<li>toward<ol>
<li>All the windows face towards the river.</li>
<li>Two policemen were coming towards him.</li>
</ol>
</li>
<li>under 在…下面<ol>
<li>The cat was under the table.</li>
<li>Have you looked under the bed?</li>
</ol>
</li>
<li>until 直到<ol>
<li>Wait until tomorrow.</li>
<li>Until now I haven’t heard from him.</li>
</ol>
</li>
<li>with 和，跟；有；用<ol>
<li>She lives with her parents.</li>
<li>Do you see the girl with red hair?</li>
<li>Cut it with a knife.</li>
</ol>
</li>
<li>within 在…内<ol>
<li>You will receive a reply within seven days.</li>
<li>Is it within walking distance?</li>
</ol>
</li>
<li>without 没有<ol>
<li>Don’t go out without you coat.</li>
<li>He left without saying goodbye.</li>
</ol>
</li>
<li>worth 值得<ol>
<li>The house must be worth a lot of money now.</li>
<li>The film is well worth seeing.<br>3.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Security碰到的一些问题</title>
    <url>/2020/05/18/Spring%20Security/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/Problems/</url>
    <content><![CDATA[<p>2020-05-18 碰到的问题</p><p>添加了@PreAuthorize注解后，访问某些方法，在这些方法体内，对象无法自动注入，因此会直接抛出NullPointerException，经查，使用该注解的方法，必须为public，否则，无法自动注入。</p><a id="more"></a>

<p>原因为，SpringSecurity使用AOP来进行包装，而AOP，只能对公共方法进行运行时修改。</p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>代词</title>
    <url>/2020/05/17/Language/English/New%20Concept/Word/Pronoun/Pronoun/</url>
    <content><![CDATA[<p>常见代词</p>
<a id="more"></a>
<ol>
<li>I 我<ol>
<li>I moved to this city six years ago.</li>
<li>I am late again.</li>
</ol>
</li>
<li>me 宾格 我<ol>
<li>Give it to me.</li>
<li>Hello, it’s me.</li>
</ol>
</li>
<li>my determiner  我的<ol>
<li>He alaways forgets my birthday.</li>
<li>Where’s my hat?</li>
</ol>
</li>
<li>mine 我的<ol>
<li>That book is mine.</li>
<li>He’s a friend of mine.</li>
</ol>
</li>
<li>myself 我自己<ol>
<li>I can look after myself.</li>
<li>I cut myself with a knife.</li>
</ol>
</li>
<li>we 我们<ol>
<li>Shall we stop for a coffee?</li>
<li>We’ll move to Australia.</li>
</ol>
</li>
<li>us 宾格 我们<ol>
<li>Please help us.</li>
<li>My mother is coming to stay with us.</li>
</ol>
</li>
<li>our determiner 我们的<ol>
<li>When is our next meeting?</li>
<li>We’re expecting our first baby.</li>
</ol>
</li>
<li>ours 我们的<ol>
<li>I’ll show you to your room. Ours is next door.</li>
<li>Their house is very similar to ours.</li>
</ol>
</li>
<li>ourselves 我们自己<ol>
<li>We built the house ourselves.</li>
<li>Let’s just relax and enjoy ourselves.</li>
</ol>
</li>
<li>you 你，你们<ol>
<li>How are you?</li>
<li>I love you.</li>
</ol>
</li>
<li>your determiner 你的，你们的<ol>
<li>Do you like your new job?</li>
<li>Don’t worry. It’s not your fault.</li>
</ol>
</li>
<li>yours 你的，你们的<ol>
<li>Is that book yours?</li>
<li>My hair is thicker than yours.</li>
</ol>
</li>
<li>yourself 你自己<ol>
<li>Have you hurt yourself?</li>
<li>Go and buy yourself an ice cream.</li>
</ol>
</li>
<li>yourselves 你们自己<ol>
<li>Help yourselves.</li>
<li>You yourselves are the guilty ones.</li>
</ol>
</li>
<li>he 他<ol>
<li>Who is he?</li>
<li>He is my best friend.</li>
</ol>
</li>
<li>him 他<ol>
<li>Do you love him?</li>
<li>Don’t believe him.</li>
</ol>
</li>
<li>his determiner 他的<ol>
<li>I love his sense of humour.</li>
<li>My eyesight is better than his.</li>
</ol>
</li>
<li>himself 他自己<ol>
<li>He cut himself.</li>
<li>It must be true - he said so himself.</li>
</ol>
</li>
<li>she 她<ol>
<li>She is my cousin.</li>
<li>She looks like her mother.</li>
</ol>
</li>
<li>her determiner 她，她的<ol>
<li>I don’t know her.</li>
<li>She’s looking for her key.</li>
</ol>
</li>
<li>hers 她的<ol>
<li>The idea was hers.</li>
<li>The handbag must be hers.</li>
</ol>
</li>
<li>herself 她自己<ol>
<li>She hurt herself.</li>
<li>She must be proud of herself.</li>
</ol>
</li>
<li>it 它<ol>
<li>It’s such a cute puppy!</li>
<li>Did you see it?</li>
</ol>
</li>
<li>its 它的<ol>
<li>The dog had hurt its paw.</li>
<li>The hotel has its own pool.</li>
</ol>
</li>
<li>itself 它自己<ol>
<li>The cat licked itself all over.</li>
<li>The machine will start by itself in a few seconds.</li>
</ol>
</li>
<li>they 他们<ol>
<li>I’ve got two sisters. They’re both doctors.</li>
<li>They went for a walk.</li>
</ol>
</li>
<li>them 他们<ol>
<li>Tell them the news.</li>
<li>We needn’t worry about them.</li>
</ol>
</li>
<li>their determiner 他们的<ol>
<li>The twins spend all their time together.</li>
<li>Which is their house?</li>
</ol>
</li>
<li>theirs 他们的<ol>
<li>Our cat is dark gray, but theirs is black.</li>
<li>Your yard is big, but I think theirs is bigger.</li>
</ol>
</li>
<li>themselves 他们自己<ol>
<li>They seemed to be enjoying themselves.</li>
<li>The children can look after themselves for a couple of hours.</li>
</ol>
</li>
<li>this 这，这个<ol>
<li>Listen to this.</li>
<li>We must make sure this doesn’t happen again.</li>
</ol>
</li>
<li>that 那，那个<ol>
<li>Who’s that?</li>
<li>That’s a nice dress.</li>
</ol>
</li>
<li>these 这些<ol>
<li>These are my children.</li>
<li>I bought these shoes in HK.</li>
</ol>
</li>
<li>those 那些<ol>
<li>Those are nice paintings.</li>
<li>Who are those people?</li>
</ol>
</li>
<li>such 这样的事物（人）<ol>
<li>There is no such thing as a free lunch.</li>
<li>Reading is boring. Such is her opinion before she met Dan.</li>
</ol>
</li>
<li>so 如此，这样<ol>
<li>I think so.</li>
<li>Is that so?</li>
</ol>
</li>
<li>same 同一事物，同样的人<ol>
<li>Their ages are <strong>the same</strong>.</li>
<li>I’ll have a coffee. Same for me, please.</li>
</ol>
</li>
<li>who 谁<ol>
<li>Who is that woman?</li>
<li>Who are you calling?</li>
</ol>
</li>
<li>whom 谁<ol>
<li>Whom did they invite?</li>
<li>Whom are you talking about?</li>
</ol>
</li>
<li>whose 谁的<ol>
<li>Whose is this jacket?</li>
<li>That’s the man whose car is damaged.</li>
</ol>
</li>
<li>which 哪一个，哪一些<ol>
<li>Which book are you looking for?</li>
<li>Which way is quicker, by bus or by train?</li>
</ol>
</li>
<li>what 什么<ol>
<li>What did you say?</li>
<li>What does it mean?</li>
</ol>
</li>
<li>whoever 无论谁<ol>
<li>Whoever says that is a liar.</li>
<li>I’ll take whoever wants to go.</li>
</ol>
</li>
<li>whichever 无论哪个<ol>
<li>Whichever they choose, we must accept their decision.</li>
<li>Whichever you buy, I’ll pay for it.</li>
</ol>
</li>
<li>whatever 无论什么<ol>
<li>You can eat whatever you like.</li>
<li>Keep calm, whatever happens.</li>
</ol>
</li>
<li>one 一个，任何人<ol>
<li>I forget to bring a pen. Could you lend me one?</li>
<li>One is never too old to learn.</li>
</ol>
</li>
<li>some 一些<ol>
<li>I’ve just made a pot of coffee. Would you like some?</li>
<li>Some of the chairs are broken.</li>
</ol>
</li>
<li>any 任何，一些<ol>
<li>Have you got any?</li>
<li>She didn’t spend any of the money.</li>
</ol>
</li>
<li>each 每个<ol>
<li>Red or blue? I’ll take one of each, please.</li>
<li>We each have our own car.</li>
</ol>
</li>
<li>every 每一<ol>
<li>Every day seemed the same to him.</li>
<li>We enjoyed every minute of our stay.</li>
</ol>
</li>
<li>no 没有<ol>
<li>I’ve got no money.</li>
<li>There’s no bread left.</li>
</ol>
</li>
<li>many 很多<ol>
<li>Many of the students were from Japan.</li>
<li>How many do you want?</li>
</ol>
</li>
<li>much 很多<ol>
<li>I’ve got too much to do.</li>
<li>Is there any milk? Not much.</li>
</ol>
</li>
<li>few 很少<ol>
<li>Few of his books are worth reading.</li>
<li>Few can live to 100.</li>
</ol>
</li>
<li>little 很少<ol>
<li>I understood little of what he said.</li>
<li>We read a lot of poetry as school. I remember very little now.</li>
</ol>
</li>
<li>a few 少数，一点儿<ol>
<li>A few of the seats were empty.</li>
<li>I recognized a few of the guests.</li>
</ol>
</li>
<li>a little 很少<ol>
<li>There was a lot of ood but I only ate a little.</li>
<li>I’ve only read a little of the book.</li>
</ol>
</li>
<li>other 其他的（人或物）<ol>
<li>He walked from one side of the road to the other.</li>
<li>Have you told the others?</li>
</ol>
</li>
<li>another 另一个<ol>
<li>Can I have another?</li>
<li>Not another!</li>
</ol>
</li>
<li>all 全部，一切<ol>
<li>All of the toys were broken.</li>
<li>Not all of them were invited.</li>
</ol>
</li>
<li>both 二者都<ol>
<li>His parents are both dead.</li>
<li>Both of us want to go to the party.</li>
</ol>
</li>
<li>none 没有人（物）<ol>
<li>None of the guests wants to stay.</li>
<li>None of the money is mine.</li>
</ol>
</li>
<li>neither 两者都不<ol>
<li>Neither of them can cook.</li>
<li>Whick do you like ? Neithre. I think they’re both ugly.</li>
</ol>
</li>
<li>either 任何一个（两者之中）<ol>
<li>You can park on either side of the street.</li>
<li>Does either of you speak French?</li>
</ol>
</li>
<li>something 某物，某事<ol>
<li>I want something to eat.</li>
<li>There’s something in my eye.</li>
</ol>
</li>
<li>somebody 某人，有人</li>
<li>someone<ol>
<li>There’s somebody at the door.</li>
<li>Somebody from your office called.</li>
</ol>
</li>
<li>anything 任何东西<ol>
<li>You can buy anything you want.</li>
<li>Is there anything I can do to help?</li>
</ol>
</li>
<li>anybody 任何人</li>
<li>anyone<ol>
<li>Did anybody see you?</li>
<li>I didn’t tell anybody.</li>
</ol>
</li>
<li>everything 每件事物，一切<ol>
<li>Everything’s fine.</li>
<li>I decided to tell her everything.</li>
</ol>
</li>
<li>everybody 每人</li>
<li>everyone<ol>
<li>Everybody knows Tom.</li>
<li>Everybody likes birthday cake.</li>
</ol>
</li>
<li>nothing 没有东西<ol>
<li>There’s nothing in this box.</li>
<li>What’s that in your pocket? Oh, nothing.</li>
</ol>
</li>
<li>nobody 没有人</li>
<li>no one<ol>
<li>Nobody came to see me.</li>
<li>I knocked on the door but nobody answered.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>常见副词</title>
    <url>/2020/05/13/Language/English/New%20Concept/Word/Adverbs/Adverbs/</url>
    <content><![CDATA[<p>常见副词</p>
<a id="more"></a>
<ol>
<li><p>about 大约</p>
<ol>
<li>We left the restaurant at about 10:30.</li>
<li>They waited for about an hour.</li>
</ol>
</li>
<li><p>above 在上面；以上；上述</p>
<ol>
<li>Put it on the shelf above.</li>
<li>children aged 12 and above</li>
<li>Write to the address above for further information.</li>
</ol>
</li>
<li><p>abroad 到国外，在国外</p>
<ol>
<li>I’ve never lived abroad before.</li>
<li>She often goes abroad on business.</li>
</ol>
</li>
<li><p>across 横过，越过</p>
<ol>
<li>Can you swim across?</li>
<li>Why don’t you go across and say hello?</li>
</ol>
</li>
<li><p>actually 实际上，事实上</p>
<ol>
<li>I’ve known Lily for years. Since we were babies, actually.</li>
<li>Disappointed? No, autually I’m rather glad.</li>
</ol>
</li>
<li><p>ago 以前</p>
<ol>
<li>not long ago</li>
<li>Her husband died 14 years ago.</li>
</ol>
</li>
<li><p>almost 几乎，差不多</p>
<ol>
<li>It’s almost time to go.</li>
<li>Dinner’s almost ready.</li>
</ol>
</li>
<li><p>alone 单独地，独自地</p>
<ol>
<li>She lives alone.</li>
<li>You shouldn’t leave a child alone in the house.</li>
</ol>
</li>
<li><p>along 向前， 往前</p>
<ol>
<li>The policeman told the crowds to move along.</li>
<li>Come along or we’ll be late.</li>
</ol>
</li>
<li><p>aloud 高声，大声</p>
<ol>
<li>He read the letter aloud to us.</li>
<li>What did you say?  Sorry, I was just thinking aloud.</li>
</ol>
</li>
<li><p>absolutely 绝对的，完全地</p>
<ol>
<li>It’s absolutely impossible</li>
<li>You’re absolutely right.</li>
</ol>
</li>
<li><p>already 已经</p>
<ol>
<li>I’ve already seen that film.</li>
<li>You already told me that.</li>
</ol>
</li>
<li><p>also 也，并且</p>
<ol>
<li>He is young and good-looking and also very rich.</li>
<li>My boyfriend was also called Dave.</li>
</ol>
</li>
<li><p>always 总是，一直</p>
<ol>
<li>He always wear a tie.</li>
<li>I’ve always wanted to go to Paris.</li>
</ol>
</li>
<li><p>anytime 任何时候</p>
<ol>
<li>You can come and see me anytime you like.</li>
</ol>
</li>
<li><p>anywhere 任何地方</p>
<ol>
<li>I can’t see it anywhere.</li>
<li>We can go anywhere you like.</li>
</ol>
</li>
<li><p>around 大约；到处；在周围</p>
<ol>
<li>around 100 people</li>
<li>He traveled around in Europe for six weeks.</li>
</ol>
</li>
<li><p>back 回到以前的位置、状况或阶段；向后地</p>
<ol>
<li>Put the book back on the shelf.</li>
<li>I’ll be back by six o’clock.</li>
<li>Sit back in your chair.</li>
</ol>
</li>
<li><p>badly 坏地；非常，在很大程度上</p>
<ol>
<li>I did badly in my exams.</li>
<li>I miss you badly.</li>
<li>They wanted to win so badly.</li>
</ol>
</li>
<li><p>before 先前，以前</p>
<ol>
<li>Have we met before?</li>
<li>I’ve seen that film before.</li>
</ol>
</li>
<li><p>below 在下面，到下面</p>
<ol>
<li>They live on the floor below.</li>
<li>Captain Parker went below.</li>
</ol>
</li>
<li><p>besides 而且，此外</p>
<ol>
<li>I don’t really want to go. Besides, it’s too late now.</li>
</ol>
</li>
<li><p>carefully 小心地，仔细地</p>
<ol>
<li>Think carefully before you answer me.</li>
</ol>
</li>
<li><p>carelessly 粗心大意地</p>
<ol>
<li>He carelessly left the door unlocked.</li>
</ol>
</li>
<li><p>certainly 当然</p>
<ol>
<li>May I se you passport, Mr.Scott?  Certainly.</li>
<li>May I go? Certainly not!</li>
</ol>
</li>
<li><p>clearly 清楚的，明确的，显然的</p>
<ol>
<li>She explained everything very clearly.</li>
<li>Clearly, you should tell her the truth.</li>
</ol>
</li>
<li><p>directly 直接地，径直的</p>
<ol>
<li>He looked directly at me.</li>
<li>He drove her directly to her totel.</li>
</ol>
</li>
<li><p>down （做躺倒）下；向下</p>
<ol>
<li>Please sit down.</li>
<li>He had to go and lie down for a while.</li>
<li>Turn the music down!</li>
</ol>
</li>
<li><p>downstairs 在楼下，到楼下</p>
<ol>
<li>They’re waiting for us dwonstairs.</li>
<li>He fell downstairs and broke his leg.</li>
</ol>
</li>
<li><p>early 早</p>
<ol>
<li>We arrived early.</li>
<li>She went out early in the morning.</li>
</ol>
</li>
<li><p>easily 容易的，轻易地</p>
<ol>
<li>They won quite easily.</li>
<li>I can easily finish it tonight.</li>
</ol>
</li>
<li><p>either 也（否定句中）</p>
<ol>
<li>Pete can’t go and I can’t either.</li>
<li>I know a good Italian restaurant. It’s not far from here, either.</li>
</ol>
</li>
<li><p>else 其他</p>
<ol>
<li>Did you see anybody else?</li>
<li>Ask somebody else to help you.</li>
</ol>
</li>
<li><p>enough 足够的，充足的</p>
<ol>
<li>Tell them it’s just not good enough.</li>
<li>She’e old enough to decide for herself.</li>
</ol>
</li>
<li><p>especially 尤其的，专门的</p>
<ol>
<li>I love Beijing, especially in the spring.</li>
<li>I made it especially for you.</li>
</ol>
</li>
<li><p>even 甚至</p>
<ol>
<li>Even a child can understand the book.</li>
<li>It is cold there even in summer.</li>
</ol>
</li>
<li><p>eventually 最终，最后</p>
<ol>
<li>Eventually, she got a job and moved to London.</li>
<li>Did he pay you back? Yes, eventually.</li>
</ol>
</li>
<li><p>ever 曾经，永远</p>
<ol>
<li>Have you ever been to Pairs?</li>
<li>Nothing lasts for ever?</li>
</ol>
</li>
<li><p>everywhere 到处，处处</p>
<ol>
<li>I’ve looked everywhere but I can’t find my phone.</li>
<li>You must have seen the posters, they’re everywhere.</li>
</ol>
</li>
<li><p>exactly 精确地，确切地</p>
<ol>
<li>I know exactly how she felt.</li>
<li>Do exactly as I tell you.</li>
</ol>
</li>
<li><p>extremely 极端地，非常</p>
<ol>
<li>She found it extremely difficult to get a job.</li>
<li>I’m extremely sorry to have kept you waiting.</li>
</ol>
</li>
<li><p>far 有多远；到很大程度</p>
<ol>
<li>How far is it to London from here?</li>
<li>We didn’t go far.</li>
<li>How far can we trust him.</li>
</ol>
</li>
<li><p>fast 快，迅速地</p>
<ol>
<li>Slow down -you’re driving too fast.</li>
<li>My son grows up so fast these days.</li>
</ol>
</li>
<li><p>finally 最后，终于</p>
<ol>
<li>The plane finally took off an hour later.</li>
<li>And finally, I would like to thank you all for coming here today.</li>
</ol>
</li>
<li><p>first 最早，首次，首先</p>
<ol>
<li>Ladies first.</li>
<li>I’ll finish my work first.</li>
<li>When did you first meet him?</li>
<li>First, I’d like to thank everyone for coming.</li>
</ol>
</li>
<li><p>forever 永远</p>
<ol>
<li>I’ll love you forever!</li>
<li>It takes her forever to get dressed.</li>
</ol>
</li>
<li><p>free 免费的</p>
<ol>
<li>Children under four can travel free.</li>
<li>He offered to do the work for free.</li>
</ol>
</li>
<li><p>frequently 频繁的的，经常</p>
<ol>
<li>The questoin is frequently asked.</li>
</ol>
</li>
<li><p>happily 快乐的，幸福的</p>
<ol>
<li>Michael smiled happily.</li>
<li>So she married the prince, ant they lived happily ever after.</li>
</ol>
</li>
<li><p>hard 努力的，猛力的</p>
<ol>
<li>She has worked hard all her life.</li>
<li>It was raining very hard.</li>
</ol>
</li>
<li><p>hardly 几乎不</p>
<ol>
<li>I hardly know her.</li>
<li>I can hardly believe it.</li>
</ol>
</li>
<li><p>heavily 大量的</p>
<ol>
<li>It’s been raining heavily all day.</li>
<li>Paul was drinking heavily then.</li>
</ol>
</li>
<li><p>high 高的</p>
<ol>
<li>He kicked the ball high into the air.</li>
<li>I can’t jump any higher.</li>
</ol>
</li>
<li><p>highly 高度的，非常</p>
<ol>
<li>She speaks highly of you.</li>
<li>a highly successful move</li>
</ol>
</li>
<li><p>home 在家，回家</p>
<ol>
<li>He went home.</li>
<li>She’s on her way home.</li>
<li>I like to stay home in the evenings.</li>
</ol>
</li>
<li><p>how 怎样；以任何方式</p>
<ol>
<li>How are you?</li>
<li>How can i help you ?</li>
<li>How did you get here?</li>
</ol>
</li>
<li><p>however 然而；无论如何</p>
<ol>
<li>Later, however, he changed his mind.</li>
<li>You won’t move that stone, however strong you are.</li>
</ol>
</li>
<li><p>immediately 立即，马上</p>
<ol>
<li>The telephone rang, and he asnwered it immediately.</li>
<li>He left the party immediately.</li>
</ol>
</li>
<li><p>in 进入；在家，在工作处</p>
<ol>
<li>Come in.</li>
<li>Nobody was in when I called.</li>
<li>I’m afraid the manager isn’t in today.</li>
</ol>
</li>
<li><p>indeed 的确，确实</p>
<ol>
<li>Was he very angry? Indeed he was.</li>
<li>That is indeed remarkable!</li>
</ol>
</li>
<li><p>just 刚刚；仅仅；正好</p>
<ol>
<li>I just got home.</li>
<li>Don’t be too hard on him - he’s just a kid.</li>
<li>It’s just my size.</li>
</ol>
</li>
<li><p>largely 大部分的，主要的</p>
<ol>
<li>The country is largely desert.</li>
<li>I want to leave Beijing largely because of the weather.</li>
</ol>
</li>
<li><p>last 上一次；最后</p>
<ol>
<li>When did you last see him?</li>
<li>They arrived last of all.</li>
</ol>
</li>
<li><p>later 后来</p>
<ol>
<li>See you later.</li>
<li>She later became a doctor.</li>
</ol>
</li>
<li><p>little 少许，一点</p>
<ol>
<li>I slept very little last night.</li>
<li>I was a little surprised.</li>
</ol>
</li>
<li><p>luckily 幸运的</p>
<ol>
<li>Luckily, I was not at home.</li>
<li>Luckily for them, he stopped the car in time.</li>
</ol>
</li>
<li><p>mainly 大部分的，主要的</p>
<ol>
<li>Her illness was caused mainly by stress.</li>
<li>I didn’t come mainly because I didn’t feel very well.</li>
</ol>
</li>
<li><p>maybe 也许，有可能</p>
<ol>
<li>Maybe they’re right, but maybe not.</li>
<li>Is that true? Maybe, I’m not sure.</li>
</ol>
</li>
<li><p>mostly 大部分，多半</p>
<ol>
<li>Green teas are mostly from China or Japan.</li>
<li>There were about fifteen people at the party, mostly women.</li>
</ol>
</li>
<li><p>muc 非常；差不多；很多的</p>
<ol>
<li>Thatk you very much.</li>
<li>You worry too much.</li>
<li>She’s much better today.</li>
<li>The other car was much too expensive.</li>
</ol>
</li>
<li><p>nearby 在附近</p>
<ol>
<li>Do you live nearby?</li>
<li>The car is parked nearby.</li>
</ol>
</li>
<li><p>nearly 几乎，差不都</p>
<ol>
<li>We’re nearly there.</li>
<li>It’s nearly time to leave.</li>
</ol>
</li>
<li><p>necessarily 必要的，必须的</p>
<ol>
<li>That is not necessarily true.</li>
<li>Biggest doesn’t necessarily mean best.</li>
</ol>
</li>
<li><p>never 从不，从来没有</p>
<ol>
<li>He has never been abroad.</li>
<li>It is never too late to give up smoking.</li>
</ol>
</li>
<li><p>next 接下去；然后</p>
<ol>
<li>Who’s next?</li>
<li>What did you do next?</li>
</ol>
</li>
<li><p>no 不</p>
<ol>
<li>Just say yes or no.</li>
<li>Are you ready? No, I’m not.</li>
<li>She’s feeling no better this morning.</li>
</ol>
</li>
<li><p>not 不</p>
<ol>
<li>I did not see him.</li>
<li>Will she be there? I hope not.</li>
<li>Who did it? Not me.</li>
</ol>
</li>
<li><p>now 现在</p>
<ol>
<li>It’s too late now.</li>
<li>He’ll be home by now.</li>
<li>It’s broken. Now I’ll have to get a new one.</li>
</ol>
</li>
<li><p>nowadays 现在，当今</p>
<ol>
<li>Nowadays most kids prefer watching TV to reading.</li>
<li>Lots of people get divorced nowadays.</li>
</ol>
</li>
<li><p>obviously 明显的</p>
<ol>
<li>He was obviously drunk.</li>
<li>They’re obviously not coming.</li>
</ol>
</li>
<li><p>occasionally 偶尔，有时候</p>
<ol>
<li>We only see each other occasionally.</li>
<li>We occasionally meet for a drink after work.</li>
</ol>
</li>
<li><p>off 离开；关掉</p>
<ol>
<li>Take your coat off.</li>
<li>He ran off with the money.</li>
<li>Make sure the TV is off.</li>
</ol>
</li>
<li><p>often 常常，经常</p>
<ol>
<li>It often rains here in April.</li>
<li><strong>How often</strong> do you go to the cinema?</li>
</ol>
</li>
<li><p>on （穿，放，连接）上；（继续）下去；在接通或使用中</p>
<ol>
<li>Put on your coat.</li>
<li>She talked on for two hours without stopping.</li>
<li>The lights were all on.</li>
</ol>
</li>
<li><p>once 一次；曾经</p>
<ol>
<li>I’ve only been there once.</li>
<li>Once bitten, twice shy.</li>
<li>I once met your mother.</li>
</ol>
</li>
<li><p>only 只，仅仅</p>
<ol>
<li>It was only a joke.</li>
<li>It’s only eight o’clock.</li>
<li>Only in Paris do you find bars like this.</li>
</ol>
</li>
<li><p>out 离开某地；不在家，不在工作地点；表示某事物已经暴露，不在隐蔽</p>
<ol>
<li>Get out!</li>
<li>I called Sally but she was out.</li>
<li>The secret is out.</li>
</ol>
</li>
<li><p>outside 在外面；在户外</p>
<ol>
<li>Please wait outside.</li>
<li>It’s warm enough to eat outside.</li>
</ol>
</li>
<li><p>over 结束；倒下；从一边倒另一边；穿过，横过</p>
<ol>
<li>Their relationship is over.</li>
<li>Don’t knock that vase over.</li>
<li>Turn over the page.</li>
<li>I’m on my way over.</li>
</ol>
</li>
<li><p>partly 在一定程度上；部分的</p>
<ol>
<li>He was only partly responsible for the accident.</li>
<li>I didn’t enjoy the trip very much, partly beacuse of the weather.</li>
</ol>
</li>
<li><p>past 经过，超过</p>
<ol>
<li>I called out to him as he ran past.</li>
<li>A week went past and nothing had changed.</li>
</ol>
</li>
<li><p>perhaps 也许</p>
<ol>
<li>Perhaps it will snow tomorrow.</li>
<li>Perhaps we’ve met before.</li>
</ol>
</li>
<li><p>pretty 相当，挺</p>
<ol>
<li>I’m pretty sure he’ll say yes.</li>
<li>The twins are pretty much the same.</li>
</ol>
</li>
<li><p>probably 很可能</p>
<ol>
<li>It’s probably the best movie I have ever seen.</li>
<li>Is he going to be there? Probably not.</li>
</ol>
</li>
<li><p>quite 相当，很，完全</p>
<ol>
<li>The house is quite big.</li>
<li>I’m sorry. That’s quite impossible.</li>
</ol>
</li>
<li><p>rarely 很少</p>
<ol>
<li>She rarely complains.</li>
<li>We rarely see each other now.</li>
</ol>
</li>
<li><p>rather 有点，相当</p>
<ol>
<li>The book is rather long.</li>
<li>I didn’t fail the exam; in fact I did rather well.</li>
</ol>
</li>
<li><p>really 事实上，实际上，真正的</p>
<ol>
<li>I’m really, really sorry.</li>
<li>She’s going to resign. Really? Are you sure?</li>
</ol>
</li>
<li><p>recently 最近，近来</p>
<ol>
<li>I haven’t seen them recently.</li>
<li>I received a letter from him recently.</li>
</ol>
</li>
<li><p>right 正确的，正好，立即，马上</p>
<ol>
<li>Have I guessed right or wrong?</li>
<li>It’s there, right in front of you!</li>
<li>I’ll be right back.</li>
</ol>
</li>
<li><p>round 朝另一方向（相反）；转一整圈</p>
<ol>
<li>He turned round and looked at me.</li>
<li>She watched the clock hands go round.</li>
</ol>
</li>
<li><p>seriously 认真的，严肃的，uamside</p>
<ol>
<li>Seriously, I think Toby likes you.</li>
<li>Was she seriously hurt?</li>
</ol>
</li>
<li><p>shortly 马上，立刻，不久</p>
<ol>
<li>I will be back shortly.</li>
<li>She arrived shortly after us.</li>
</ol>
</li>
<li><p>simply 简单地；仅仅</p>
<ol>
<li>To put it simply, he was fired.</li>
<li>It’s not simply a question of money.</li>
</ol>
</li>
<li><p>since 以后，此后</p>
<ol>
<li>He left home two weeks ago and we haven’t heart from him since.</li>
<li>They went to the UK in 1974 and have lived there <strong>ever since</strong>.</li>
</ol>
</li>
<li><p>slightly 轻微地，有一点</p>
<ol>
<li>I feel slightly better today.</li>
<li>Are you worried? Only slightly.</li>
</ol>
</li>
<li><p>slowly 缓慢地，慢腾腾的</p>
<ol>
<li>He shook his head slowly.</li>
<li>That’s true, said Joe slowly.</li>
</ol>
</li>
<li><p>so 这么，那么，很（程度）</p>
<ol>
<li>It was so embarrassing!</li>
<li>He was so weak that he could hardly stand up.</li>
</ol>
</li>
<li><p>someday （将来）有一天</p>
<ol>
<li>Someday we’ll be together.</li>
<li>Someday he’ll be famous.</li>
</ol>
</li>
<li><p>sometime 在（将来或过去）某个时候</p>
<ol>
<li>I saw him sometime last summer.</li>
<li>Call me sometime next week.</li>
</ol>
</li>
<li><p>sometimes 有时候</p>
<ol>
<li>I sometimes have to work late.</li>
<li>He sometimes calls me.</li>
</ol>
</li>
<li><p>somewhere 在某处，到某处</p>
<ol>
<li>I’ve seen him somewhere before.</li>
<li>I’m going somewhere else this evening.</li>
</ol>
</li>
<li><p>soon 不久，很快</p>
<ol>
<li>He’ll be here very soon.</li>
<li>We soon got there.</li>
</ol>
</li>
<li><p>still 还，仍然</p>
<ol>
<li>I’m still hungry.</li>
<li>Do you still have Julie’s phone number?</li>
</ol>
</li>
<li><p>straight 径直，成直线的</p>
<ol>
<li>He went straight home after the meeting.</li>
<li>Sit up straight.</li>
</ol>
</li>
<li><p>suddenly 突然</p>
<ol>
<li>He stood up suddenly.</li>
<li>Suddenly the eagle opened its wings.</li>
</ol>
</li>
<li><p>then 那时，到时候；然后；那么</p>
<ol>
<li>Things were very different back then.</li>
<li>I’ll see you then.</li>
<li>Mix the flour and butter, then add the eggs.</li>
<li>If you don’t tell him, then I will.</li>
</ol>
</li>
<li><p>there 在那里，到那里</p>
<ol>
<li>We are nearly there.</li>
<li>Who’s that man over there?</li>
</ol>
</li>
<li><p>today 今天，现今</p>
<ol>
<li>What are we doing today?</li>
<li>Women today no longer accept such treatment.</li>
</ol>
</li>
<li><p>together 在一起</p>
<ol>
<li>Let’s go for a walk together.</li>
<li>We grew up togeter.</li>
</ol>
</li>
<li><p>tomorrow 明天</p>
<ol>
<li>See you tomorrow.</li>
<li>She’s getting married tomorrow.</li>
</ol>
</li>
<li><p>tonight 今晚</p>
<ol>
<li>It’s cold tonight</li>
<li>I think I’ll go to bed early tonight.</li>
</ol>
</li>
<li><p>too 也；太</p>
<ol>
<li>I’ve been to Paris too.</li>
<li>There are too many cars on the road.</li>
</ol>
</li>
<li><p>totally 完全</p>
<ol>
<li>That’s a totally different matter.</li>
<li>She’s so cute! Totally!</li>
</ol>
</li>
<li><p>twice 两次；两倍</p>
<ol>
<li>I have seen the film twice.</li>
<li>Cats sleep twice as much as people.</li>
</ol>
</li>
<li><p>up 在上面；起来</p>
<ol>
<li>John’n up in his bedroom.</li>
<li>It’s time to get up.</li>
</ol>
</li>
<li><p>upstairs 在楼上，到楼上</p>
<ol>
<li>I went upstairs and had a shower.</li>
<li>I was upstairs when it happened.</li>
</ol>
</li>
<li><p>usually 通常，经常</p>
<ol>
<li>Women usually live longer than men.</li>
<li>What time do you usually go to bed?</li>
</ol>
</li>
<li><p>very 很，非常</p>
<ol>
<li>Thank you very much.</li>
<li>It’s very kind of you to help.</li>
</ol>
</li>
<li><p>well 好</p>
<ol>
<li>Did you sleep well?</li>
<li>Well done!</li>
</ol>
</li>
<li><p>when 什么时候</p>
<ol>
<li>When are we leaving?</li>
<li>When can I see you again?</li>
</ol>
</li>
<li><p>where 在哪里，到哪里</p>
<ol>
<li>Where are you going?</li>
<li>where do they live?</li>
</ol>
</li>
<li><p>why 为什么</p>
<ol>
<li>Why were you late?</li>
<li>Do you know why the door is locked?</li>
</ol>
</li>
<li><p>yes 是</p>
<ol>
<li>Coffee? Yes, please.</li>
<li>Can I have a glass of water? Yes, of course.</li>
</ol>
</li>
<li><p>yesterday 在昨天</p>
<ol>
<li>What did you do yesterday?</li>
<li>Anna left yesterday afternoon.</li>
</ol>
</li>
<li><p>yet 还</p>
<ol>
<li><p>Are you ready? No, not yet.</p>
</li>
<li><p>I haven’t asked him yet.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>gson转换LocalDateTime时碰到的问题</title>
    <url>/2020/05/08/Work%20Record/CAAS/GsonTimeHandler/</url>
    <content><![CDATA[<p>当使用gson转换为LocalDateTime的属性时，因为LocalDateTime相当于是个数组，而元数据为 yyyy-MM-dd HH:mm:ss的字符串，转换时会发生错误，需要进行如下的配置</p><a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认日期时间格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DATE_TIME_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认日期格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DATE_FORMAT = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认时间格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TIME_FORMAT = <span class="string">"HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Gson <span class="title">gson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">            .registerTypeAdapter(LocalDateTime.class,</span><br><span class="line">                    (JsonDeserializer&lt;LocalDateTime&gt;) (json, type, jsonDeserializationContext)</span><br><span class="line">                            -&gt; LocalDateTime.parse(json.getAsString(), dateTimeFormatter))</span><br><span class="line">            .registerTypeAdapter(LocalDate.class,</span><br><span class="line">                    (JsonDeserializer&lt;LocalDate&gt;) (json, type, jsonDeserializationContext)</span><br><span class="line">                            -&gt; LocalDate.parse(json.getAsString(), dateFormatter))</span><br><span class="line">            .registerTypeAdapter(LocalTime.class,</span><br><span class="line">                    (JsonDeserializer&lt;LocalTime&gt;) (json, type, jsonDeserializationContext)</span><br><span class="line">                            -&gt; LocalTime.parse(json.getAsString(), timeFormatter))</span><br><span class="line">            .create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>常见形容词</title>
    <url>/2020/04/28/Language/English/New%20Concept/Word/Adjectives/Adjectives/</url>
    <content><![CDATA[<p>常见形容词</p>
<a id="more"></a>
<ol>
<li>broken 破碎的，打碎的<ol>
<li>a broken window</li>
<li>a broken leg</li>
<li>a broken heart</li>
</ol>
</li>
<li>busy 忙碌的<ol>
<li>She’s <strong>busy with</strong> her homework.</li>
<li>Rachel’s <strong>busy studying</strong> fro her exams.</li>
</ol>
</li>
<li>calm 镇定的；平静的<ol>
<li>Keep calm.</li>
<li>The sea was calm again.</li>
</ol>
</li>
<li>careful 仔细的，小心的<ol>
<li>Be careful -there’s broken glass on the floor!</li>
<li>Be careful not to wake the baby.</li>
</ol>
</li>
<li>careless 不小心的，粗心的<ol>
<li>a careless driver</li>
<li>It was careless of me to leave the door open.</li>
</ol>
</li>
<li>cautions 小心的，谨慎的<ol>
<li>a cautious driver</li>
<li>He was cautions about everything.</li>
</ol>
</li>
<li>certain 确信的，确定的<ol>
<li>One thing is certain: I’m not coming here again.</li>
<li>She saw me. I’m <strong>certain of</strong> that.</li>
</ol>
</li>
<li>charming 迷人的，有魅力的<ol>
<li>He’s a very charming man.</li>
<li>She gave him a charming smile.</li>
</ol>
</li>
<li>cheap 便宜的，廉价的；小气的<ol>
<li>A good education is not cheap.</li>
<li>Don’t be so cheap!</li>
</ol>
</li>
<li>cheerful 兴高采烈的，快乐的<ol>
<li>Youe’re very cheerful today.</li>
<li>He felt cheerful and full of energy.</li>
</ol>
</li>
<li>chief 主要的，首要的<ol>
<li>The chief thing is to be honet.</li>
<li>CEO: Chief Executive Officer</li>
</ol>
</li>
<li>chilly 寒冷的<ol>
<li>It’s chilly today.</li>
<li>The bathroom’s a bit chilly.</li>
</ol>
</li>
<li>Chinese 中国的<ol>
<li>He married a Chinese girl.</li>
</ol>
</li>
<li>clean 干净的，清洁的<ol>
<li>clean hands</li>
<li>clean air</li>
</ol>
</li>
<li>clear 清楚的，清晰的，清澈的<ol>
<li>a clear day</li>
<li>a clear voice </li>
<li>a clear mountain lake</li>
</ol>
</li>
<li>clever 聪明的<ol>
<li>Clever girl!</li>
<li>Lucky is quite clever and does well at school.</li>
</ol>
</li>
<li>cloudly 多云的，阴天的<ol>
<li>It will be cloudy tomorrow.</li>
</ol>
</li>
<li>cold 寒冷的；冷淡的<ol>
<li>He slept on the cold ground.</li>
<li>Dinner is getting cold.</li>
<li>Martin was really cold to me at the party.</li>
</ol>
</li>
<li>colorful 五颜六色的，多姿多彩的<ol>
<li>a colorful painting</li>
<li>My uncle had a long and colorful career.</li>
</ol>
</li>
<li>comfortable 舒适的；安逸的<ol>
<li>Sit down and make yourself comfortable.</li>
<li>She lives a comfortable life.</li>
</ol>
</li>
<li>common 普通的，常见的<ol>
<li>the common cold</li>
<li>common sense</li>
<li>Daisies are very common flowers.</li>
</ol>
</li>
<li>confused 迷惑的<ol>
<li>I’m totally confused. Could you explain that again?</li>
</ol>
</li>
<li>cool 凉爽的；冷静的；非常棒的<ol>
<li>The evening air was cool.</li>
<li>He has a cool head.</li>
<li>You look pretty cool with that new haircut.</li>
</ol>
</li>
<li>crazy 疯狂的，不理智的<ol>
<li>Are you crazy?</li>
<li>That noise is driving me crazy.</li>
<li>He’s <strong>crazy about</strong> her.</li>
</ol>
</li>
<li>creepy 令人毛骨悚然的，不寒而栗的<ol>
<li>a creepy ghost story</li>
<li>The whole place feels creepy.</li>
</ol>
</li>
<li>crowded 拥挤的<ol>
<li>crowded streets</li>
<li>The train was very crowded, and me had to stand.</li>
</ol>
</li>
<li>cruel 残忍的，残酷的<ol>
<li>Sometimes life seems cruel.</li>
<li>Don’t tease him about his weight - it’s cruel.</li>
</ol>
</li>
<li>curious 好奇的；爱管闲事的<ol>
<li>I’m curious to know what she said.</li>
<li>curious neighbors</li>
</ol>
</li>
<li>cute 可爱的，漂亮的<ol>
<li>The baby’s so cute.</li>
<li>Why are you so cute?</li>
</ol>
</li>
<li>daily 每日的，日常的<ol>
<li>daily life</li>
<li>a daily newspaper</li>
</ol>
</li>
<li>dangerous 危险的<ol>
<li>The dog is dangerous.</li>
<li>Air pollution has reached dangerous levels in some cities.</li>
</ol>
</li>
<li>dark 黑暗的；邪恶的；深色的<ol>
<li>The church was dark and quiet.</li>
<li>There was a dark side to his nature.</li>
<li>dark blue</li>
</ol>
</li>
<li>dazzling 耀眼的，光彩夺目的<ol>
<li>a dazzling white light</li>
<li>You look dazzling.</li>
</ol>
</li>
<li>dead 死的<ol>
<li>We didn’t know if she was dead or alive.</li>
<li>You are dead.</li>
</ol>
</li>
<li>dear 亲爱的，极为珍贵的<ol>
<li>my dear son</li>
<li>Her daughter is very dear to her.</li>
</ol>
</li>
<li>deep 深的；深奥的<ol>
<li>a deep well</li>
<li>This discussion’s getting deep for me.</li>
</ol>
</li>
<li>delicious 美味的<ol>
<li>Who cooked this? It’s delicious.</li>
<li>It smells delicious!</li>
</ol>
</li>
<li>dependent 依靠的，依赖的<ol>
<li>You can’t be <strong>dependent on</strong> you parents all your life.</li>
</ol>
</li>
<li>depressed 沮丧的；萧条的<ol>
<li>She felt lonely and depressed.</li>
<li>Britain’s depressed real estate market.</li>
</ol>
</li>
<li>different 不同的<ol>
<li>She is wearing a different dress every time i see her.</li>
<li>Her jacket’s different from mine.</li>
</ol>
</li>
<li>difficult 困难的<ol>
<li>It’s really difficult to read you writing.</li>
<li>That’s rather difficult for me to explain.</li>
</ol>
</li>
<li>dirty 肮脏的；下流的<ol>
<li>How did you get so dirty?</li>
<li>a dirty joke</li>
</ol>
</li>
<li>disgusting 令人厌恶的，恶心的<ol>
<li>You are disgusting.</li>
<li>Smoking is a really disgusting habit.</li>
</ol>
</li>
<li>dizzy 头晕的，眩晕的<ol>
<li>After another glass of whisky i began to feel dizzy.</li>
</ol>
</li>
<li>drunk 醉的<ol>
<li>You’re drunk.</li>
<li>She was too drunk to remember anything about the party.</li>
</ol>
</li>
<li>dry 干旱的，干燥的，干的<ol>
<li>Is my shirt dry yet?</li>
<li>The weather was hot and dry.</li>
<li>the dry season</li>
</ol>
</li>
<li>dull 钝的；迟钝的；枯燥的<ol>
<li>a dull knife</li>
<li>a dull girl</li>
<li>a dull movie</li>
</ol>
</li>
<li>eager 渴望的，热切地<ol>
<li>He’s a bright kid and eager to learn.</li>
<li>I am eager to go to Australia.</li>
</ol>
</li>
<li>early 早的，早期的<ol>
<li>The bus was ten minutes early.</li>
<li>She is in her early twenties.</li>
</ol>
</li>
<li>easy 容易的；舒适的<ol>
<li>The test was easy.</li>
<li>lead an easy life</li>
</ol>
</li>
<li>embarrassed 尴尬的，窘迫的<ol>
<li>I’ve never felt so embarrassed in my life.</li>
</ol>
</li>
<li>embarrassing 令人尴尬的<ol>
<li>She asked a lot of embarrassing questions.</li>
</ol>
</li>
<li>empty 空的；空虚的<ol>
<li>Your glass is empty.</li>
<li>empty streets</li>
<li>Her life felt empty and meaningless.</li>
</ol>
</li>
<li>energetic 精力充沛的，精力旺盛的<ol>
<li>You are so energetic.</li>
</ol>
</li>
<li>English 英国的<ol>
<li>I love the English countryside.</li>
</ol>
</li>
<li>equal 平等的，相等的<ol>
<li>All men are equal.</li>
<li>equal pay for equal work</li>
</ol>
</li>
<li>excellent 杰出的，优秀的<ol>
<li>She speaks excellent French.</li>
<li>What an excellent idea!</li>
<li>You can all come? Excellent!</li>
</ol>
</li>
<li>excited 兴奋地，激动地<ol>
<li>The children were <strong>excited about</strong> opening their presents.</li>
<li>I’m so excited that we’re going to New York.</li>
</ol>
</li>
<li>exciting 使人兴奋的，令人激动的<ol>
<li>I’ve got some very exciting news for you.</li>
<li>‘Julia and Paul are getting married!’ ‘Oh, how exciting!’</li>
</ol>
</li>
<li>expensive 昂贵的，豪华的<ol>
<li>Houses are very expensive in this area.</li>
<li>I can’t afford it, It’s too expensive.</li>
<li>an expensive restaurant</li>
</ol>
</li>
<li>exotic 异国的，有异国风情的<ol>
<li>exotic birds</li>
<li>He was attracted by her exotic beauty.</li>
</ol>
</li>
<li>fabulous 极好的，绝妙的<ol>
<li>You look fabulous!</li>
<li>Jane is a fabulous cook.</li>
</ol>
</li>
<li>fair 公平的；美丽的<ol>
<li>Life isn’t always fair.</li>
<li>London bridge is falling down, my fair lady.</li>
</ol>
</li>
<li>false 错误的；假的<ol>
<li>A whale is a fish. Ture or false?</li>
<li>The man gave a false name and address.</li>
</ol>
</li>
<li>familiar 熟悉的<ol>
<li>I’m not really <strong>familiar with</strong> her poetry.</li>
<li>Her poetry isn’t <strong>familiar to</strong> me.</li>
</ol>
</li>
<li>famous 著名的，出名的<ol>
<li>France is <strong>famous for</strong> its wine.</li>
<li>Many famous people have stayed in the hoital.</li>
</ol>
</li>
<li>fantastic 极好的，极大地<ol>
<li>I’ve passed my driving test. Fantastic!</li>
<li>Their wedding cost a fantastic amount of money.</li>
</ol>
</li>
<li>far 远的<ol>
<li>We can walk to my house from here. It isn’t far.</li>
</ol>
</li>
<li>fast 快的，迅速的<ol>
<li>He’s one of the fastest runners in the world.</li>
<li>I’m fast learner.</li>
</ol>
</li>
<li>fat 肥的，胖的<ol>
<li>If you eat too much chocolate you’ll get fat.</li>
<li>He’s got a rather fat face.</li>
</ol>
</li>
<li>few 很少的<ol>
<li>Few people live to be 100.</li>
<li>I have to by a few things at the supermarket.</li>
</ol>
</li>
<li>fine 好的<ol>
<li>We’re meeting at 8.30.  Okay, fine.</li>
<li>Hou are you?  Fine, thanks, how are you .</li>
<li>More coffee? No, I’m fine, thanks.</li>
</ol>
</li>
<li>flat 平的<ol>
<li>houses with flat roofs</li>
</ol>
</li>
<li>foolish 愚蠢的，傻的<ol>
<li>I was young and foolish at the time.</li>
<li>I was foolish enough to believe him.</li>
</ol>
</li>
<li>fortunate 幸运的<ol>
<li>I was fortunate to have a good teacher.</li>
</ol>
</li>
<li>free 自由的；免费的；空闲的<ol>
<li>He was a free man again.</li>
<li>free tickets</li>
<li>I’m free next weekend.</li>
</ol>
</li>
<li>fresh 新的，新鲜的<ol>
<li>Eat plenty of fresh fruit and vegetables.</li>
<li>We need some fresh ideas.</li>
</ol>
</li>
<li>friendly 友好的<ol>
<li>a friendly smile</li>
<li>Everyone was very friendly towards me.</li>
</ol>
</li>
<li>frightened 害怕的<ol>
<li>Don’t be frightened. We’re not going to hurt you.</li>
<li>I’m frightened of walking home alone.</li>
</ol>
</li>
<li>frighting 可怕的<ol>
<li>The noist is frighting.</li>
</ol>
</li>
<li>full 满的<ol>
<li>Don’t talk with you mouth full.</li>
<li>The kitchen was full of smoke.</li>
</ol>
</li>
<li>funny 有趣的，可笑的<ol>
<li>a funny story</li>
<li>What’s so funny?</li>
</ol>
</li>
<li>gentle 温和的，文雅的<ol>
<li>Be gentle with the baby.</li>
<li>Arthur was a very gentle person.</li>
</ol>
</li>
<li>giant 巨大的<ol>
<li>What a giant tree!</li>
</ol>
</li>
<li>good 好的<ol>
<li>Her English is very good.</li>
<li>It’s good to see you again.</li>
<li>He’s very good with children.</li>
</ol>
</li>
<li>graceful 优美的，优雅的<ol>
<li>The dancers were all tall and  graceful.</li>
</ol>
</li>
<li>grateful 感激的，感谢的<ol>
<li>I am grateful to you for your help.</li>
</ol>
</li>
<li>great 大的，重大的，好极的<ol>
<li>The movie was a great success.</li>
<li>The wedding was a great occasion.</li>
<li>It’s great to be home.</li>
</ol>
</li>
<li>greedy 贪婪地，贪吃的<ol>
<li>He stared at the diamonds with greedy eyes.</li>
<li>Have eaten them all, you greedy pig?</li>
</ol>
</li>
<li>handsome 英俊的，帅气的<ol>
<li>Sam was tall, dark and handsome.</li>
</ol>
</li>
<li>happy 幸福的，快乐的<ol>
<li>They had a very happy marriage.</li>
<li>I’m very happy for you.</li>
</ol>
</li>
<li>hard 困难的；努力的；硬的<ol>
<li>She found it hard to decide.</li>
<li>a hard worker</li>
<li>a hard wooden chair</li>
</ol>
</li>
<li>healthy 健康的<ol>
<li>a healthy baby boy</li>
<li>a healthy lifestyle</li>
</ol>
</li>
<li>heavy 重的；大量的<ol>
<li>The box is too heavy for me to carry.</li>
<li>He is a heavy smoker.</li>
</ol>
</li>
<li>helpful 给予帮助的，愿意帮忙的<ol>
<li>Thank you for your advice; it’s been very helpful.</li>
<li>I’m only trying to be helpful.</li>
</ol>
</li>
<li>high 高的<ol>
<li>How high is Mount Everest?</li>
<li>The wall is six feet high.</li>
</ol>
</li>
<li>homeless 无家可归的<ol>
<li>A forest fire made hundreds of people homeless.</li>
</ol>
</li>
<li>horrible 可怕的；糟糕的<ol>
<li>a horrible dream</li>
<li>The coffee tasted horrible.</li>
</ol>
</li>
<li>hot 热的；辣的；性感的<ol>
<li>It’s so hot in here.</li>
<li>She likes hot food.</li>
<li>The girls all think he’s hot.</li>
</ol>
</li>
<li>huge 巨大的<ol>
<li>a huge dog</li>
<li>The movie was a huge success.</li>
</ol>
</li>
<li>humorous 幽默的，风趣的<ol>
<li>He is quite humorous, and i like that about him.</li>
</ol>
</li>
<li>hungry 饥饿的，渴望的<ol>
<li>You must be hungry.</li>
<li>Stan was hungry to learn.</li>
</ol>
</li>
<li>ill 生病的；不好的，坏的<ol>
<li>He’s been ill for two weeks.</li>
<li>He can’t join the army because of ill health.</li>
</ol>
</li>
<li>important 重要的，重大的<ol>
<li>an important meeting</li>
<li>VIP: very important person</li>
<li>Happiness is more important than money.</li>
</ol>
</li>
<li>impossible 不可能的<ol>
<li>Mission impossible</li>
<li>I find it impossible to lie to her.</li>
</ol>
</li>
<li>incredible 不可思议的，难以置信的，非常好的<ol>
<li>What an incredible story!</li>
<li>The view is just incredible.</li>
</ol>
</li>
<li>innocent 无辜的，清白的<ol>
<li>Nobody would believe that i was innocent.</li>
</ol>
</li>
<li>interested 感兴趣的<ol>
<li>There’s a talk on Italian art - are you interested?</li>
<li>I’ve always been <strong>interested in</strong> music.</li>
</ol>
</li>
<li>interesting 令人感兴趣的，有趣的<ol>
<li>That’s an interesting question.</li>
<li>Did you meet any interesting people?</li>
</ol>
</li>
<li>kind 亲切的，和蔼的<ol>
<li>Ther’ve been very kind to me.</li>
<li>It was really kind of you to help me.</li>
</ol>
</li>
<li>large 大的<ol>
<li>He has a large house.</li>
<li>large sums of money</li>
</ol>
</li>
<li>last 最后的，上一个的<ol>
<li>She was the last one to arrive.</li>
<li>Did you see the game on TV last night?</li>
</ol>
</li>
<li>late 晚的，迟到的<ol>
<li>Sorry I’m late.</li>
<li>Dont’t be late for school.</li>
</ol>
</li>
<li>lazy 懒惰的<ol>
<li>He’s not stupid, just lazy.</li>
<li>We spent a lazy day at the beach.</li>
</ol>
</li>
<li>legal 法律的；合法的<ol>
<li>take legal action</li>
<li>What i have done is perfectly legal.</li>
</ol>
</li>
<li>light 轻的；浅色的<ol>
<li>You can carry this bag -it’s fairly light.</li>
<li>You look nice in light colors.</li>
</ol>
</li>
<li>little 小的，幼小的<ol>
<li>six little puppies</li>
<li>I didn’t have toys like this when i was little.</li>
</ol>
</li>
<li>lonely 孤独的，寂寞的<ol>
<li>a lonely old man</li>
<li>a lonely journey</li>
</ol>
</li>
<li>long 长的；长时间的<ol>
<li>You hair is longer than mine.</li>
<li>I haven’t been there for a long time.</li>
</ol>
</li>
<li>loud 响亮的，大声的<ol>
<li>That music’s too loud.</li>
<li>Who’s there?  asked David in a loud voice.</li>
</ol>
</li>
<li>lovely 可爱的，美丽的，令人愉快的<ol>
<li>You look lovely in that dress.</li>
<li>What a lovely house!</li>
<li>What a lovely day!</li>
</ol>
</li>
<li>low 低的，矮的<ol>
<li>a low wall</li>
<li>The river is very low today.</li>
</ol>
</li>
<li>lucky 幸运的<ol>
<li>You are so lucky!</li>
<li>You lucky dog!</li>
<li>Seven is my lucky number.</li>
</ol>
</li>
<li>married 已婚的<ol>
<li>Are you married or single?</li>
<li>They’ve been married for eight years.</li>
<li>We’re getting married next mouth.</li>
</ol>
</li>
<li>messy 凌乱的，散乱的<ol>
<li>Sorry my room is so messy.</li>
<li>The house was always messy.</li>
</ol>
</li>
<li>modern 现代的，当代的<ol>
<li>in the modern world</li>
<li>modern dance</li>
</ol>
</li>
<li>naive 幼稚的，天真的<ol>
<li>a naive young girl</li>
<li>Jim can be so naive sometimes.</li>
</ol>
</li>
<li>narrow 狭窄的，狭隘的<ol>
<li>a narrow bed</li>
<li>The road was too narrow for cars to pass.</li>
</ol>
</li>
<li>nasty 恶心的，令人讨厌的，不善良的<ol>
<li>a nasty smell</li>
<li>He has a nasty temper.</li>
<li>Don’t be nasty to you little brother.</li>
</ol>
</li>
<li>natural 自然的，天生的<ol>
<li>the natural world</li>
<li>My hair soon grew back to its natural color.</li>
</ol>
</li>
<li>naughty 顽皮的，淘气的<ol>
<li>You’re a very naughty boy!</li>
</ol>
</li>
<li>near 近的<ol>
<li>His flat’s very near.</li>
<li>Where’s the nearest bus-stop?</li>
</ol>
</li>
<li>neat 整洁的，干净的，好的<ol>
<li>His clothes were always neat and clean.</li>
<li>That’s a really neat idea.</li>
</ol>
</li>
<li>necessary 必要的，必须的<ol>
<li>Sleep is necessary for one’s health.</li>
<li>It’s not necessary to wear a tie.</li>
</ol>
</li>
<li>nervous 紧张的，焦虑的<ol>
<li>You’re making me nervous.</li>
<li>She was so nervous about her exams that she couldn’t sleep.</li>
</ol>
</li>
<li>new 新的，新到的<ol>
<li>Do you like my new dress?</li>
<li>They’ve just moved into their new house.</li>
</ol>
</li>
<li>nice 美好的，愉快的<ol>
<li>It’s such a nice day.</li>
<li>What a nice story!</li>
<li>You look nice in that suit.</li>
</ol>
</li>
<li>noisy 嘈杂的，喧闹的<ol>
<li>The kids have been really noisy today.</li>
<li>The bar was very noisy.</li>
</ol>
</li>
<li>normal 正常的<ol>
<li>It’s normal to feel nervous before an exam.</li>
<li>Her room was messy, but that was quite normal.</li>
</ol>
</li>
<li>odd 奇怪的，奇数的<ol>
<li>She gets odder as she grows older.</li>
<li>How odd!</li>
<li>odd numbers</li>
</ol>
</li>
<li>open 敞开的；公开的<ol>
<li>All the windows were wide open.</li>
<li>I was so sleepy, I couldn’t keey my eyes open.</li>
<li>It is an open secret.</li>
</ol>
</li>
<li>ordinary 普通的，平常的<ol>
<li>It’s just an ordinary camera.</li>
<li>The book is about ordinary people.</li>
<li>The meal was very ordinary.</li>
</ol>
</li>
<li>organic 有机的<ol>
<li>organic vegetables</li>
<li>The shop sells organic food.</li>
</ol>
</li>
<li>outstanding 杰出的，优秀的<ol>
<li>an outstanding student</li>
<li>His performance was outstanding.</li>
</ol>
</li>
<li>painful 痛苦的，疼的<ol>
<li>The divorce was painful for both of them.</li>
<li>Is you back still painful?</li>
</ol>
</li>
<li>past 过去的，以前的<ol>
<li>The past month has been a difficult one for him.</li>
<li>From past experience I’d say she was a liar.</li>
</ol>
</li>
<li>perfect 完美的，极好的<ol>
<li>That’s perfect!</li>
<li>His English was perfect.</li>
<li>Nobody is perfect.</li>
</ol>
</li>
<li>plain 清楚的；相貌平平的<ol>
<li>He made it plain that we should leave.</li>
<li>She had grown into a beautiful woman from a rather plain child.</li>
</ol>
</li>
<li>polite 有礼貌的<ol>
<li>She’s always very polite.</li>
<li>It’s not polite to talk with your mouth full.</li>
</ol>
</li>
<li>poor 贫穷的；可怜的<ol>
<li>He came from a poor family</li>
<li>Poor kid!</li>
</ol>
</li>
<li>possible 可能的<ol>
<li>Is it possible to get tickets for the game?</li>
<li>I need the monty as soon as possible.</li>
</ol>
</li>
<li>powerful 强大的；权力大的<ol>
<li>Jed was a powerful man.</li>
<li>a very powerful family</li>
<li>a powerful speech</li>
</ol>
</li>
<li>precious 宝贵的，珍贵的<ol>
<li>precious stones</li>
<li>You’re wasting precious time!</li>
</ol>
</li>
<li>present 目前的；出席的<ol>
<li>the present situation</li>
<li>Everyone is present.</li>
</ol>
</li>
<li>pretty 漂亮的<ol>
<li>a pretty little girl</li>
<li>What a pretty dress!</li>
</ol>
</li>
<li>previous 以前的<ol>
<li>He was there the previous day.</li>
<li>Do you have any previous experiene?</li>
</ol>
</li>
<li>private 私人的；秘密的；私立的<ol>
<li>This is a private house.</li>
<li>Don’t read that - it’s private.</li>
<li>a private hospital</li>
</ol>
</li>
<li>proud 骄傲的，自豪的<ol>
<li>I’m very <strong>proud of</strong> you.</li>
<li>You make me proud.</li>
</ol>
</li>
<li>public 公共的；公立的<ol>
<li>public places</li>
<li>public shcools</li>
</ol>
</li>
<li>quick 快的，迅速的<ol>
<li>Be quick!</li>
<li>Tax is are quicker than buses.</li>
<li>I had to make a quick decision.</li>
</ol>
</li>
<li>quiet 安静的，平静的<ol>
<li>Be quiet, please!</li>
<li>You’re very quiet, Tom -is anything the matter?</li>
<li>The sea looks quieter now.</li>
</ol>
</li>
<li>rainy 下雨的，多雨的<ol>
<li>a rainy morning</li>
<li>the rainy season</li>
</ol>
</li>
<li>ready 准备好的<ol>
<li>Are you ready?</li>
<li>Dinner is ready.</li>
<li>I’m not <strong>ready for</strong> the test yet.</li>
</ol>
</li>
<li>real 真的，真实的<ol>
<li>Tell me the real reason.</li>
<li>The children know that Santa Claus isn’t a real person.</li>
</ol>
</li>
<li>regular 有规律的，定期的<ol>
<li>regular meetings</li>
<li>our regular customers</li>
<li>His breathing was slow and regular.</li>
</ol>
</li>
<li>responsible 承担责任的，有责任感的<ol>
<li>I’ll find out who’s responsible.</li>
<li>He was <strong>responsible for</strong> the accident.</li>
</ol>
</li>
<li>rich 富有的，油腻的<ol>
<li>She was both beautiful and rich.</li>
<li>a rich cake</li>
</ol>
</li>
<li>right 右方的；正确的；合适的<ol>
<li>He had a knife in his right hand.</li>
<li>I think you’re right.</li>
<li>I’m glad you broke up. She wasn’t right for you.</li>
</ol>
</li>
<li>romantic 浪漫的<ol>
<li>How romantic!</li>
<li>romantic music</li>
</ol>
</li>
<li>round 圆形的<ol>
<li>a big round table</li>
<li>round cheeks</li>
</ol>
</li>
<li>sad 伤心的，难过的<ol>
<li>John is sad because his dog has died.</li>
<li>I’m sad you’re leaving.</li>
</ol>
</li>
<li>safe 安全的<ol>
<li>You are safe here.</li>
<li>You secret is safe with me.</li>
</ol>
</li>
<li>salty 含盐的，咸的<ol>
<li>salty food</li>
<li>The soup is a little bit salty.</li>
</ol>
</li>
<li>same 相同的，同样的<ol>
<li>He is <strong>the same</strong> age as his wife.</li>
<li>I bought <strong>the same </strong>car <strong>as</strong> yours.</li>
</ol>
</li>
<li>selfish 自私的<ol>
<li>selfish behavior</li>
<li>How can you be so selfish?</li>
</ol>
</li>
<li>serious 严肃的，认真的；严重的<ol>
<li>Are you serous?</li>
<li>This a very serious matter.</li>
</ol>
</li>
<li>sharp 锋利的；剧烈的<ol>
<li>a sharp knife</li>
<li>a sharp drop in prices</li>
</ol>
</li>
<li>shocked 震惊的<ol>
<li>He is shocked at what happened.</li>
<li>We were deeply shocked to hear of his death.</li>
</ol>
</li>
<li>shocking 令人震惊的<ol>
<li>shocking news</li>
<li>It is shocking that he was killed in the accident.</li>
</ol>
</li>
<li>short 短的；短缺的；矮的<ol>
<li>Winter is coming and the days are getting shorter.</li>
<li>I’m afraid I’m alittle <strong>short of</strong> money this month.</li>
<li>He’s a bit shorter than me.</li>
</ol>
</li>
<li>shy 害羞的<ol>
<li>Don’t be shy - come and say hello.</li>
<li>He was too shy to speak to her.</li>
</ol>
</li>
<li>sick 生病的；恶心的，病态的<ol>
<li>His mother’s very sick.</li>
<li>Emma has just called in sick.</li>
<li>You’re sick!</li>
</ol>
</li>
<li>silent 寂静的，无声的<ol>
<li>Alan was silent.</li>
<li>The children went out, and the room was silent.</li>
</ol>
</li>
<li>silly 愚蠢的，傻的<ol>
<li>Don’t be silly!</li>
<li>Stop asking silly questions.</li>
</ol>
</li>
<li>simple 简单的<ol>
<li>There is no simple answer to this question.</li>
<li>This machine is very simple to use.</li>
</ol>
</li>
<li>slow 慢的，迟钝的<ol>
<li>Oh you’re so slow; come on, hurry up!</li>
<li>My watch is five minutes slow.</li>
<li>He’s the slowest in the class.</li>
</ol>
</li>
<li>small 小的，少的<ol>
<li>The shirt was too small for him.</li>
<li>a small amount of money</li>
</ol>
</li>
<li>smart 聪明的；漂亮的，帅气的<ol>
<li>Smart boy!</li>
<li>You look very smart in your new suit.</li>
</ol>
</li>
<li>soft 软的，柔软的；温和的<ol>
<li>I like soft pillows.</li>
<li>a baby’s soft skin</li>
<li>His voice was softer now.</li>
</ol>
</li>
<li>sour 有酸味的，酸的；馊的<ol>
<li>This apple is really sour!</li>
<li>The milk’s turned sour.</li>
</ol>
</li>
<li>special 特殊的，特别的，专门的<ol>
<li>Are you doing anything special for Christmas?</li>
<li>She’s a very special friend.</li>
<li>a special train</li>
</ol>
</li>
<li>spicy 辛辣的<ol>
<li>Do you like spicy food?</li>
</ol>
</li>
<li>strange 奇怪的；陌生的<ol>
<li>It’s strange that we’ve never met before.</li>
<li>At first the place was <strong>strange to</strong> me.</li>
</ol>
</li>
<li>strong 强的，强壮的；坚强的；强烈的<ol>
<li>Jack was tall and strong.</li>
<li>I must be strong.</li>
<li>The temptation is very strong.</li>
</ol>
</li>
<li>stupid 愚蠢的<ol>
<li>I made a stupid mistake.</li>
<li>He understands - he’s not stupid.</li>
<li>This stupid car won’t start.</li>
</ol>
</li>
<li>successful 成功的<ol>
<li>The play was very successful on Broadway.</li>
</ol>
</li>
<li>super 极好的<ol>
<li>What a super idea!</li>
<li>You’ll like her. She’s super.</li>
</ol>
</li>
<li>sweet 甜的；温柔的，可亲的<ol>
<li>This tea is too sweet.</li>
<li>a sweet smile</li>
<li>How sweet of you to remember my birthday.</li>
</ol>
</li>
<li>tall 高的，高大的<ol>
<li>He was young and tall.</li>
<li>She’s a little taller than her sister.</li>
</ol>
</li>
<li>tasty 美味的，可口的<ol>
<li>This soup is very tasty.</li>
</ol>
</li>
<li>terrible 可怕的；糟糕的<ol>
<li>What terrible news!</li>
<li>He’s terrible driver.</li>
<li>I feel terrible - I think I’ll go to bed.</li>
</ol>
</li>
<li>terrific 极好的<ol>
<li>That’s a terrific idea.</li>
<li>You look terrific in that dress.</li>
</ol>
</li>
<li>thankful 感谢的，感激的<ol>
<li>I was thankful that the meeting didn’t last long.</li>
</ol>
</li>
<li>thick 厚的；浓的，茂密的<ol>
<li>a thick coat</li>
<li>a thick forest</li>
<li>thick hair</li>
</ol>
</li>
<li>thin 薄的；瘦的<ol>
<li>That ice is too thin to stand on.</li>
<li>He’s tall and thin.</li>
</ol>
</li>
<li>tidy 整洁的，整齐的<ol>
<li>Ellen’s room is always tidy.</li>
</ol>
</li>
<li>tight 紧的，绷紧的<ol>
<li>The drawer is so tight I can’t open it.</li>
<li>tight jeans</li>
</ol>
</li>
<li>tiny 极小的，微小的<ol>
<li>a <strong>tiny little</strong> baby</li>
<li>Through she was tiny, she had a very loud voice.</li>
</ol>
</li>
<li>tired 疲倦的；厌烦的<ol>
<li>I’m tired.</li>
<li>I’m <strong>tired of</strong> watching television; let’s go for a walk.</li>
</ol>
</li>
<li>true 真正的，真实的<ol>
<li>true love</li>
<li>This is a true story.</li>
<li>This is too good to be true.</li>
</ol>
</li>
<li>ugly 难看的，丑陋的<ol>
<li>an ugly face</li>
<li>The Ugly Duckling</li>
</ol>
</li>
<li>unable 不能的，无能力的<ol>
<li>She is <strong>unable to</strong> walk.</li>
<li>Some of the children were unable to read or wrote.</li>
</ol>
</li>
<li>upset 难过的，失望的，沮丧的<ol>
<li>Why are you so upset?</li>
<li>She feels upest that we didn’t tell her the truth.</li>
</ol>
</li>
<li>useful 有用的，有益的<ol>
<li>The book is full of useful information.</li>
<li>He might be useful to us.</li>
</ol>
</li>
<li>useless 无用的，无效的<ol>
<li>It was useless to complain.</li>
<li>All out efforts were useless.</li>
</ol>
</li>
<li>violent 暴力的<ol>
<li>Her husband was a violent man.</li>
<li>Children should not be allowed to watch violent movies.</li>
</ol>
</li>
<li>warm 暖和的，保暖的；热情的<ol>
<li>It’s nice and warm in here.</li>
<li>Take some warm clothes.</li>
<li>We received a warm welcome.</li>
</ol>
</li>
<li>weak 虚弱的，软弱的<ol>
<li>She is still weak after her illness.</li>
<li>a weak leader</li>
</ol>
</li>
<li>wealthy 富有的<ol>
<li>He’s a very wealthy man.</li>
<li>Early to bed, early to rise, makes a man healthy, wealthy and wise.</li>
</ol>
</li>
<li>wet 湿的；下雨的<ol>
<li>Try not to get your shoes wet.</li>
<li>a wet day</li>
</ol>
</li>
<li>wide 宽的；有某种宽度的<ol>
<li>a wide river</li>
<li>The garden is thirty feet wide.</li>
</ol>
</li>
<li>wild 野生的，野的<ol>
<li>wild animals</li>
<li>wild flowers</li>
</ol>
</li>
<li>windy 有风的<ol>
<li>a cold windy day</li>
<li>It’s too windy to go out today.</li>
</ol>
</li>
<li>wise 有智慧的，明智的<ol>
<li>a wise old man</li>
<li>a wise choice</li>
</ol>
</li>
<li>wonderful 极好的，精彩的<ol>
<li>We had a wonderful time last night.</li>
<li>It’s wonderful to see you!</li>
</ol>
</li>
<li>worried 担心的，焦虑的<ol>
<li>You look worried. What’s the matter?</li>
<li>I’m really <strong>worred about</strong> you.</li>
</ol>
</li>
<li>wrong 错误的，有毛病的<ol>
<li>Wrong answer</li>
<li>You are wrong.</li>
<li>Is anything wrong?</li>
<li>What’s wrong with you?<br>5.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>常见动词</title>
    <url>/2020/04/23/Language/English/New%20Concept/Word/Verb/Verb/</url>
    <content><![CDATA[<p>常见动词</p>
<a id="more"></a>
<ol>
<li>act 采取行动；演出<ol>
<li>We must act at once.</li>
<li>She first started acting when she was 12 years old.</li>
</ol>
</li>
<li>admit 承认<ol>
<li>I admit that I was wrong.</li>
<li>He admitted having stolen the car.</li>
</ol>
</li>
<li>advise 建议<ol>
<li>Ethan advised him to leave London.</li>
<li>We advised that they should start early.</li>
</ol>
</li>
<li>afford 负担得起<ol>
<li>You can’t afford the house.</li>
<li>I’d love to go on holiday but I can’t afford the time.</li>
</ol>
</li>
<li>agree 统一<ol>
<li>He agreed to let me go home early.</li>
<li>I couldn’t agree more.</li>
</ol>
</li>
<li>answer 回答，答复<ol>
<li>Think carefully before you answer.</li>
<li>He still hadn’t answered my question.</li>
</ol>
</li>
<li>apologize 道歉<ol>
<li>I think you should <strong>apologize to</strong> you brother.</li>
<li>I apologize for losing my temper.</li>
</ol>
</li>
<li>appear 出现<ol>
<li>A man suddenly appeared from behind at tree.</li>
</ol>
</li>
<li>appreciate 感激，欣赏<ol>
<li>I really appreciate your help.</li>
<li>Her family doesn’t appreciate her.</li>
</ol>
</li>
<li>arrive 到达<ol>
<li>They will <strong>arrive in</strong> New York at noon.</li>
<li>He arrived late as usual.</li>
</ol>
</li>
<li>ask 问<ol>
<li>Don’t be afraid of asking questions.</li>
<li>I asked them their names.</li>
</ol>
</li>
<li>be 是<ol>
<li>I am your new teacher.</li>
<li>Is there a God?</li>
<li>There are many such people.</li>
</ol>
</li>
<li>bear 忍受<ol>
<li>The pain was more than he could bear.</li>
<li>I can’t bear cats in the house.</li>
</ol>
</li>
<li>beat 打，打败，（心脏）跳动<ol>
<li>He was beaten.</li>
<li>Our team was easily beaten.</li>
<li>His heart stopped beating.</li>
</ol>
</li>
<li>become 变为，成为<ol>
<li>She became a doctor.</li>
<li>That child is to become a great leader.</li>
</ol>
</li>
<li>begin 开始<ol>
<li>The meeting will begin at nine.</li>
</ol>
</li>
<li>behave 表现<ol>
<li>He behaved like a child.</li>
<li>Behave yourself.</li>
</ol>
</li>
<li>believe 相信<ol>
<li>I don’t believe your.</li>
<li><strong>Believe it or not</strong>.</li>
</ol>
</li>
<li>bite 咬<ol>
<li>Does your dog bite?</li>
<li>Stop biting your nails.</li>
</ol>
</li>
<li>blame 职责，责备<ol>
<li>Don’t blame me  -it’s not my fault.</li>
</ol>
</li>
<li>book 预定<ol>
<li>I’d like to book a table for two for 8 o’clock tonight.</li>
<li>I’m sorry - we’re fully booked.</li>
</ol>
</li>
<li>borrow 借<ol>
<li>Can I borrow you pen for a minute?</li>
<li>You are allowed to borrow six books from the library at a time.</li>
</ol>
</li>
<li>break 打破，破碎<ol>
<li>I had to break a window to get into the house.</li>
<li>You broke my heart.</li>
<li>Glass breaks easily.</li>
</ol>
</li>
<li>breathe 呼吸<ol>
<li>Breathe deeply.</li>
<li>She’s still breathing.</li>
</ol>
</li>
<li>bring 带来<ol>
<li>I’ll bring a bottle of wine.</li>
<li>She brought her boyfriend to the party.</li>
</ol>
</li>
<li>build 建造<ol>
<li>He is building a house.</li>
<li>Rome wasn’t built in a day.</li>
</ol>
</li>
<li>burn 燃烧，烧毁<ol>
<li>Parts of the building are still burning.</li>
<li>The house was burnt to the ground.</li>
</ol>
</li>
<li>buy 买<ol>
<li>Where did you buy that coat?</li>
<li>Let me buy you a drink.</li>
</ol>
</li>
<li>call 喊叫，打电话<ol>
<li>I heard someone calling.</li>
<li>I’ll call you soon.</li>
</ol>
</li>
<li>can modal v. 能够<ol>
<li>He can speak French.</li>
<li>Can you cook?</li>
</ol>
</li>
<li>care 关系，在乎<ol>
<li>Of course I care about you.</li>
<li>I don’t care!</li>
<li>Who cares?</li>
</ol>
</li>
<li>carry 携带<ol>
<li>She carried her baby in her arms.</li>
<li>He always carries a knife to protect himself.</li>
</ol>
</li>
<li>catch 接住；捉住；赶上<ol>
<li>I threw a ball to her and she caught it.</li>
<li>Cats catch mice.</li>
<li>I’m catching a bus.</li>
</ol>
</li>
<li>change 改变<ol>
<li>Our plans have changed.</li>
<li>I won’t <strong>change my mind.</strong></li>
</ol>
</li>
<li>chat 聊天<ol>
<li>What are you <strong>chatting about</strong>?</li>
<li>You spend too much time <strong>chatting on line.</strong></li>
</ol>
</li>
<li>cheat 欺骗，作弊<ol>
<li>I feel cheated.</li>
<li>Don’t look at my cards - that’s <strong>cheating</strong>.</li>
</ol>
</li>
<li>check 检查<ol>
<li>Could you go and check if the baby’s asleep?</li>
<li>Check the oil and water before setting off.</li>
</ol>
</li>
<li>cheer 欢呼，高兴<ol>
<li>The crowd cheered loudly as the Queen appeared.</li>
<li>Cheer up!</li>
</ol>
</li>
<li>choose 选择<ol>
<li>Which one do you choose?</li>
<li>You chose wisely.</li>
</ol>
</li>
<li>clean 使…干净<ol>
<li>You shoes need cleaning.</li>
<li>You have to clean your own room.</li>
</ol>
</li>
<li>climb 攀登，爬<ol>
<li>The boy was climbing a tree.</li>
<li>She climbed up the stairs.</li>
</ol>
</li>
<li>close 关<ol>
<li>The door closed quietly.</li>
<li>Close your eyes.</li>
</ol>
</li>
<li>collect 收集，收藏<ol>
<li>to collect stamps</li>
<li>Annie collects teddy bears.</li>
</ol>
</li>
<li>consider 考虑<ol>
<li>We are considering going to Canada.</li>
</ol>
</li>
<li>continue 继续<ol>
<li>to be continued</li>
<li>He continued typing while he spoke.</li>
</ol>
</li>
<li>control 控制，管理<ol>
<li>Can’t you control you child?</li>
<li>By the age of 21 he controlled the cpmpany.</li>
</ol>
</li>
<li>cook 做饭<ol>
<li>Where did you learn to cook?</li>
<li>He cooked me lunch.</li>
</ol>
</li>
<li>copy 复制，抄写，模仿<ol>
<li>To copy a file, press F3.</li>
<li>He copied my answer.</li>
<li>Children often copy what they see on television.</li>
</ol>
</li>
<li>cost 花费<ol>
<li>How much does it cost?</li>
<li>The meal cost us 30 dollars.</li>
</ol>
</li>
<li>cover 覆盖<ol>
<li>Dan covered his face with his hands.</li>
<li>Much of the country is covered by snow.</li>
</ol>
</li>
<li>cry 哭，喊<ol>
<li>The child was crying for his mother.</li>
<li>‘Help! Help!’ he cried.</li>
</ol>
</li>
<li>cut 切，割，砍，剪<ol>
<li>Do you want me to cut the cake?</li>
<li>I am going to have my hair cut.</li>
</ol>
</li>
<li>dance 跳舞<ol>
<li>Would you like to dance?</li>
<li>He danced with her all night.</li>
</ol>
</li>
<li>decide 决定<ol>
<li>It’s up to you to decide.</li>
<li>I can’t decide what to wear.</li>
</ol>
</li>
<li>defeat 打败，难倒<ol>
<li>Newcastle were defeated by 3 goals to 2.</li>
<li>The last question defeated me.</li>
</ol>
</li>
<li>depend 依靠，取决于<ol>
<li>‘How long are you staying?’ ‘I don’t know; <strong>it depends.</strong>‘</li>
<li>I don’t want to depend too much on my parent.</li>
</ol>
</li>
<li>describe 描述，形容<ol>
<li>Words cannot describe the beauty of the scene.</li>
<li>Can you describe him to me?</li>
</ol>
</li>
<li>destory 摧毁，毁坏<ol>
<li>The school was completely destoryed by fire.</li>
<li>They’ve destoryed all the evidence.</li>
</ol>
</li>
<li>develop 发展<ol>
<li>Chicago developed into a big city.</li>
</ol>
</li>
<li>devote 奉献，致力于<ol>
<li>She devoted herself to her career.</li>
</ol>
</li>
<li>die 死亡<ol>
<li>He died in 1985 at the age of 76.</li>
<li>Flowers soon die without water.</li>
</ol>
</li>
<li>discover 发现<ol>
<li>Columbus discovered America.</li>
<li>She discovered that she was pregnant.</li>
</ol>
</li>
<li>discuss 讨论<ol>
<li>Have you discussed the problem with anyone?</li>
<li>I’m not prepared to discuss this on the phone.</li>
</ol>
</li>
<li>do 做<ol>
<li>What are you doing this evening?</li>
<li>What can i do for you?</li>
<li>Why can’t you do as you’re told?</li>
</ol>
</li>
<li>doubt 怀疑<ol>
<li>You can complain, but I doubt if it’ll make any difference.</li>
<li>‘Do you think there’ll be any tickets left?’ ‘I doubt it.’</li>
</ol>
</li>
<li>draw 绘画，拉<ol>
<li>She drew a house.</li>
<li>She drew me onto the balcony.</li>
</ol>
</li>
<li>dream 做梦；梦想<ol>
<li>I dreamt about you last night.</li>
<li>She dreamed of becoming a movie star.</li>
</ol>
</li>
<li>dress 穿衣<ol>
<li>Hurry up and <strong>get dressed!</strong></li>
<li>Is she old enough to <strong>dress herself?</strong></li>
<li>He <strong>was dressed in</strong> a blue jacket.</li>
</ol>
</li>
<li>drink 喝；喝酒<ol>
<li>What wold you like to drink?</li>
<li>Don’t drink and drive.</li>
</ol>
</li>
<li>drive 驾驶，开车<ol>
<li>Can you drive?</li>
<li>When did you learn to drive?</li>
</ol>
</li>
<li>drop 落下<ol>
<li>She dropped the torch.</li>
<li>The apples are beginning to drop from the trees.</li>
</ol>
</li>
<li>eat 吃，吃饭<ol>
<li>Would you like something to eat?</li>
<li>Where shall we eat tonight?</li>
</ol>
</li>
<li>enjoy 享受；从…获得乐趣<ol>
<li>Thanks for a great evening. I really enjoyed it.</li>
<li>They all enjoyed themselves at the party.</li>
</ol>
</li>
<li>expect 期望；预料<ol>
<li><strong>As expected</strong>, the whole family was shocked the news.</li>
<li>I didn’t expect him to stay so long.</li>
</ol>
</li>
<li>explain 解释<ol>
<li>Let me explain what i mean.</li>
<li>Wait! I can explain everything.</li>
</ol>
</li>
<li>face 面对，正视<ol>
<li>She turned and faced him.</li>
<li>She’s <strong>faced with</strong> a difficult decision.</li>
<li>Let’s <strong>face it</strong>, we’re not going to win.</li>
</ol>
</li>
<li>fail 失败；不及格<ol>
<li>Doctors <strong>failed to</strong> save the gril’s life.</li>
<li>He failed his driving-test.</li>
</ol>
</li>
<li>fall 落下；跌倒<ol>
<li>One of the kids fell into the river.</li>
<li>Rob fell down the stairs.</li>
</ol>
</li>
<li>feed 喂养<ol>
<li>Have you fed the chickens.</li>
</ol>
</li>
<li>feel 感觉<ol>
<li>How are you feeling today?</li>
<li>I’m feeling a little better today.</li>
</ol>
</li>
<li>fetch 接来，取来<ol>
<li>Quick! <strong>Go and fetch</strong> a doctor.</li>
<li>Please fetch the children from school.</li>
</ol>
</li>
<li>fight 打架，战斗<ol>
<li>Stop fighting, boys!</li>
<li>He fought in Vietnam.</li>
</ol>
</li>
<li>find 发现，找到<ol>
<li>Look what i’ve found.</li>
<li>I can’t find the car keys.</li>
</ol>
</li>
<li>finish 结束，完成<ol>
<li>Have you finished that book yet?</li>
<li>I’ve nearly finished.</li>
</ol>
</li>
<li>fire 开火<ol>
<li>The officer ordered his men to fire.</li>
</ol>
</li>
<li>fit 适合<ol>
<li>His clothes did not fit him very well.</li>
<li>I tried the dress on but it didn’t fit.</li>
</ol>
</li>
<li>fix 安装，修理<ol>
<li>He is fixing a shelf to the wall.</li>
<li>The car won’t start. Can you fix it?</li>
</ol>
</li>
<li>fly 飞<ol>
<li>A big bird flew past us.</li>
<li>She’s flying back to she States tomorrow.</li>
</ol>
</li>
<li>follow 跟随<ol>
<li>He followed her into the house.</li>
<li>Follow me please. I’ll show you the way.</li>
</ol>
</li>
<li>force 强迫<ol>
<li>I had to force myself to get up this morning.</li>
</ol>
</li>
<li>forget 忘记<ol>
<li>Sorry, I forgot.</li>
<li>He forgot her birthday.</li>
<li>Don’t forget to feed the cat.</li>
</ol>
</li>
<li>forgive 原谅，宽恕<ol>
<li>I’ll never forgive her for what she did.</li>
<li>Forgive and forget.</li>
</ol>
</li>
<li>get 得到，收到<ol>
<li>What did you get for Christmas?</li>
<li>I got a letter from Dave this morning.</li>
</ol>
</li>
<li>give 给<ol>
<li>Give me your hand.</li>
<li>I didn’t steal it! Maria gave it to me!</li>
</ol>
</li>
<li>go 去，走<ol>
<li>Go wash your hands.</li>
<li>Where are you going?</li>
<li>Let’s go home.</li>
<li>Let me go.</li>
</ol>
</li>
<li>grow 生长；种植<ol>
<li>A growing child needs plenty of sleep.</li>
<li>grow roses</li>
</ol>
</li>
<li>guess 猜<ol>
<li><strong>Guess what</strong>? I’m taking a day off tomorrow!</li>
<li>I don’t really know. I’m just guessing.</li>
<li>You guessed right.</li>
<li>You guessed wrong.</li>
</ol>
</li>
<li>hand 传递<ol>
<li>Please hand me that book.</li>
<li>Please hand that book to me.</li>
</ol>
</li>
<li>handle 处理，应付<ol>
<li>Leave it to me. I’ll handle it.</li>
<li>He doesn’t handle stress very well.</li>
</ol>
</li>
<li>happen 发生<ol>
<li>What happened next?</li>
<li>If anything <strong>happens to</strong> him, let me know.</li>
</ol>
</li>
<li>hate 讨厌，憎恨<ol>
<li>He hates his job.</li>
<li>I hate to see you unhappy.</li>
<li>I hate to say it, but I don’t think their marriage will last.</li>
</ol>
</li>
<li>have 有<ol>
<li>He has a good memory.</li>
<li>Do you have any pets?</li>
<li>They’ve got two cars.</li>
</ol>
</li>
<li>hear 听说；听见<ol>
<li>I couldn’t hear anything.</li>
<li>Did you hear him go out?</li>
<li>I’m getting married. So i’ve heard.</li>
</ol>
</li>
<li>help 帮助<ol>
<li>Can I help you?</li>
<li>He always <strong>helps with</strong> the housework.</li>
</ol>
</li>
<li>hide 隐藏，躲避<ol>
<li>Harry hid under the bed.</li>
<li>The sun was hidden by the clouds.</li>
</ol>
</li>
<li>hit 打，击<ol>
<li>She hit him on the head with a book.</li>
<li>His parents never hit him.</li>
<li>I was hit by a falling stone.</li>
</ol>
</li>
<li>hold 握住，保住，保持不变<ol>
<li>Hold my hand.</li>
<li>Mom, hold me.</li>
<li>Hold that pose.</li>
</ol>
</li>
<li>hope 希望<ol>
<li><strong>I hope so.</strong></li>
<li><strong>I hope not.</strong></li>
<li>Hope to see you soon.</li>
</ol>
</li>
<li>hunt 打猎；搜索<ol>
<li>Lions sometimes hunt alone.</li>
<li>The police are still hunting the killer.</li>
</ol>
</li>
<li>hurry 匆忙，赶紧<ol>
<li>Hurry up, we’re late!</li>
<li>She hurried away without saying goodbye.</li>
</ol>
</li>
<li>hurt 伤害；感到疼痛<ol>
<li>You are hurting me.</li>
<li>You hurt my heart.</li>
<li>Ouch, it hurts.</li>
<li>Where does it hurt?</li>
</ol>
</li>
<li>introduce 介绍<ol>
<li>Allow me to introduce my wife.</li>
<li>I don’t think we’ve been introduced.</li>
</ol>
</li>
<li>invent 发明<ol>
<li>Who invented the steam engine?</li>
<li>I wish mobile phones had never been invented.</li>
</ol>
</li>
<li>invite 邀请<ol>
<li>I’m afraid I wasn’t invited.</li>
<li>Who should we invite to the party?</li>
</ol>
</li>
<li>join 加入，参加<ol>
<li>Will you join us for lunch?</li>
<li>I decided to join the army.</li>
</ol>
</li>
<li>judge 审判，评判<ol>
<li>You should never judge a person by their looks.</li>
<li>Are you judgeing me?</li>
</ol>
</li>
<li>jump 跳<ol>
<li>Quick, jump! he shouted.</li>
<li>Fans were jumping up and down and cheering.</li>
</ol>
</li>
<li>last 持续<ol>
<li>This weather won’t last.</li>
<li>Whe war lasted for eight years.</li>
</ol>
</li>
<li>laugh 笑<ol>
<li>laugn out loud</li>
<li>He who laughs last laughs longest.</li>
<li>Don’t laugh, but I’ve decided to teach myself French.</li>
</ol>
</li>
<li>lead 领导，带领<ol>
<li>I’ll take part, but I don’t want to lead.</li>
<li>He led us into the house.</li>
</ol>
</li>
<li>learn 学习，学会<ol>
<li>He’s learning to dance.</li>
<li>I learned a lot from my father.</li>
<li>Watch and learn!</li>
</ol>
</li>
<li>leave 离开；使处于什么状态<ol>
<li>It’s time for us to leave.</li>
<li>When are you leaving?</li>
<li>Leave the door open.</li>
<li><strong>Leave me alone</strong>!</li>
</ol>
</li>
<li>lend 借给<ol>
<li>Can you lend me 5 dollars? I’ll pay you back tomorrow.</li>
<li>I’ve lent the car to a friend.</li>
</ol>
</li>
<li>let 让，允许<ol>
<li>Let me in.</li>
<li>Let me out.</li>
<li>Let me go.</li>
<li>Let’s go home.</li>
</ol>
</li>
<li>lie 躺；位于；撒谎<ol>
<li>Don’t lie in bed all morning!</li>
<li>The town lies on the coast.</li>
<li>He’s lying.</li>
</ol>
</li>
<li>lift 举起，抬起<ol>
<li>Lift me up, mommy. I can’t see.</li>
<li>The news lifted our spirits.</li>
</ol>
</li>
<li>light 点燃<ol>
<li>She lit a candle.</li>
<li>He stopped to light a cigarette.</li>
</ol>
</li>
<li>like 喜欢<ol>
<li>She likes him, but doesn’t love him.</li>
<li>She’s never liked swimming.</li>
<li>Would you like something to eat?</li>
</ol>
</li>
<li>listen 听<ol>
<li>Listen! Someone is knocking at the door.</li>
<li>I like listening to music.</li>
<li>I told him not to go, but he just wouldn’t listen.</li>
</ol>
</li>
<li>live 居住；生活<ol>
<li>Where do you live?</li>
<li>The doctors said he only had six months to live.</li>
<li>How long do elephants live?</li>
</ol>
</li>
<li>look 看<ol>
<li>Look! I’m sure that’s Brad Pitt.</li>
<li>She <strong>looked at</strong> me and smiled.</li>
<li>Are you still <strong>looking for</strong> a job?</li>
</ol>
</li>
<li>lose 丢失，失去<ol>
<li>I’ve lost my keys.</li>
<li>He’s lost his job.</li>
</ol>
</li>
<li>love 爱，热爱<ol>
<li>I love you.</li>
<li>I’ve always loved children.</li>
<li>I love my country.</li>
</ol>
</li>
<li>make 制造，做<ol>
<li><strong>made in</strong> France</li>
<li>She makes her own clothes.</li>
<li>I made a cake myself.</li>
</ol>
</li>
<li>marry 嫁，娶<ol>
<li>Will you marry me?</li>
<li>He married a German.</li>
</ol>
</li>
<li>may （modal v）可以；可能<ol>
<li>May I come in?</li>
<li>Thank you. You may go now.</li>
<li>I may be late, so don’t wait for me.</li>
</ol>
</li>
<li>mean 意思是<ol>
<li>What do you mean?</li>
<li>Do you know what i mean?</li>
<li>You mean we have to start all over again?</li>
</ol>
</li>
<li>meet 见面；遇见；人事<ol>
<li>I hope we’ll meet again soon.</li>
<li>I met her in the street.</li>
<li><strong>Nice to meet you .</strong></li>
</ol>
</li>
<li>mend 修理，修补<ol>
<li>It’s never too late to mend your fence.</li>
<li>Tim can mend any broken toy.</li>
</ol>
</li>
<li>mention 提到，提及<ol>
<li>Don’t mention it.</li>
<li>Sorry, I won’t mention it again.</li>
</ol>
</li>
<li>mind 介意；注意<ol>
<li>Would you mind my smoking here?</li>
<li>Mind your head!</li>
</ol>
</li>
<li>miss 想念；错过<ol>
<li>I miss you.</li>
<li>Did you miss me?</li>
<li>You can’t miss it.</li>
<li>What did I miss?</li>
</ol>
</li>
<li>move 移动；搬家<ol>
<li>Don’t move.</li>
<li><strong>Move on</strong>.</li>
<li>We are <strong>moving to</strong> Melbourne soon.</li>
</ol>
</li>
<li>must 必须<ol>
<li>I must go now.</li>
<li>Must you go so soon?</li>
</ol>
</li>
<li>need 需要<ol>
<li>What do you need?</li>
<li>I need your help.</li>
<li>You needn’t know it.</li>
</ol>
</li>
<li>nod 点头<ol>
<li>I aksed him if he would help me and he nodded.</li>
<li>She nodded to me as she walked by.</li>
</ol>
</li>
<li>notice 注意到<ol>
<li>I noticed that he left early.</li>
<li>I noticed them come in.</li>
</ol>
</li>
<li>pass 走过；通过；传递；不要<ol>
<li>She passed me without even saying hello.</li>
<li>Did you pass the exam?</li>
<li>Pass me the salt, please.</li>
<li>I’ll pass.</li>
</ol>
</li>
<li>pay 付款<ol>
<li>I’ll <strong>pay for</strong> the tickets.</li>
<li>How would you like to pay?</li>
</ol>
</li>
<li>permit 允许<ol>
<li>Dogs are not permitted in the building.</li>
<li>I’ll come tomorrwo, <strong>weather permitting</strong>.</li>
</ol>
</li>
<li>phone 打电话<ol>
<li>Did anybody phone?</li>
<li>I’ll phone you this evening.</li>
</ol>
</li>
<li>pick 采，摘；挑选<ol>
<li>Don’t pick flowers.</li>
<li>Stop <strong>picking you nose</strong>.</li>
<li>You can pick whichever you like.</li>
</ol>
</li>
<li>place 放置<ol>
<li>He placed his hand on her shoulder.</li>
<li>Here! Place it on the table.</li>
</ol>
</li>
<li>plan 计划；打算<ol>
<li>Everything went as planned.</li>
<li>When do you plan to take your holiday?</li>
</ol>
</li>
<li>plant 种植<ol>
<li>We’ve planted tomatoes and carrots in the garden.</li>
<li>Do you want to help us plant trees?</li>
</ol>
</li>
<li>play 玩耍；参加比赛；演奏<ol>
<li>You’ll have to play inside today.</li>
<li>Do you play football?</li>
<li>He’s learning to play the piano.</li>
</ol>
</li>
<li>point 指出，指向<ol>
<li>It’s rude to point.</li>
<li>She <strong>pointed a</strong>t a photo on the wall and said “That’s my mother”</li>
</ol>
</li>
<li>practice 练习<ol>
<li>You need to practice every day.</li>
<li>I need to practice my English.</li>
</ol>
</li>
<li>praise 称赞，赞赏<ol>
<li>Aaron was praised by his teacher.</li>
<li>He praised her for her courage.</li>
</ol>
</li>
<li>pray 祈祷，祷告<ol>
<li>I’ll pray for you.</li>
<li>Let us <strong>pray for</strong> peace.</li>
<li>Martha prayed to God for help.</li>
</ol>
</li>
<li>prefer 更喜欢<ol>
<li>There’s coffee and tea. Which yould you prefer?</li>
<li>I prefer jazz to rock music.</li>
<li>Would you prefer me to stay?</li>
</ol>
</li>
<li>prepare 准备<ol>
<li>I had no time to prepare.</li>
<li>He was in the kitchen preparing lunch.</li>
<li>The whole class is preparing for the exams.</li>
</ol>
</li>
<li>pretent 假装<ol>
<li>I’m tired of having to pretent all the time.</li>
<li>I pretended to be asleep.</li>
</ol>
</li>
<li>prevent 预防，阻止<ol>
<li>Nobody can prevent us getting married.</li>
<li>The accident could have been prevented.</li>
</ol>
</li>
<li>promise 答应，许诺<ol>
<li>I can’t promise, but I’ll do my best.</li>
<li>‘Promise me you won’t do any thing stupied’.  I promise.’</li>
</ol>
</li>
<li>protect 保护<ol>
<li>You need warm clothes to protect you against the cold.</li>
<li>Are we doing enough to protect the environment?</li>
</ol>
</li>
<li>prove 证明<ol>
<li>You’re wrong, and I can prove it.</li>
<li>Just give me a chance and I’ll prove it to you.</li>
</ol>
</li>
<li>pull 拉，扯<ol>
<li>You push and I’ll pull.</li>
<li>Stop pulling my hair!</li>
<li>She pulled open the door and hurried inside.</li>
</ol>
</li>
<li>punish 惩罚<ol>
<li>He was punished for refusing to answer theri questions.</li>
<li>My parents used to punish my by not letting watch TV.</li>
</ol>
</li>
<li>push 推<ol>
<li>Push hard when I tell you to.</li>
<li>I pushed the door open.</li>
<li>He tried to kiss her but she pushed him away.</li>
</ol>
</li>
<li>put 放<ol>
<li>She put the book on the table.</li>
<li>Did you put sugar in my tea?</li>
<li>It’s time to put the baby to bed.</li>
</ol>
</li>
<li>rain 下雨<ol>
<li>Is it raining?</li>
<li>It started to rain.</li>
<li>It had been raining hard all night.</li>
</ol>
</li>
<li>raise 举起；增加；养育<ol>
<li>Raise your hand if you know the right answer.</li>
<li>They raised their offer to $500.</li>
<li>I was raised in the countryside.</li>
</ol>
</li>
<li>reach 到达；伸手去拿<ol>
<li>We reached London late at night.</li>
<li>He reached for his gun.</li>
</ol>
</li>
<li>read 读<ol>
<li>She’s still learning to read.</li>
<li>She read us a story.</li>
<li>Go on = read it to us.</li>
</ol>
</li>
<li>realize 意识到<ol>
<li>I realized that she had been lying.</li>
<li>Do you realize you’re an hour late?</li>
</ol>
</li>
<li>receive 收到，接到<ol>
<li>Every child will receive a small gift.</li>
<li>We received a warm welcome.</li>
</ol>
</li>
<li>remember 记得，记住，回想起<ol>
<li>Do you remember Rose?</li>
<li>Remember to locak the door.</li>
<li>I’m sorry - I can’t remember your name.</li>
</ol>
</li>
<li>repair 修理，修补<ol>
<li>Dad was repairing the roof.</li>
<li>Where can i get my shoes repaired?</li>
</ol>
</li>
<li>rest 休息<ol>
<li>The doctor told me to rest.</li>
<li>Rest your eyes every half an hour.</li>
</ol>
</li>
<li>return 返回；归还<ol>
<li>I had to return to the store to look for my purse.</li>
<li>I must return some books to the library.</li>
</ol>
</li>
<li>ring 响；按铃；电话<ol>
<li>Just then, the doorbell rang.</li>
<li>I rang the bell but no one answered.</li>
<li>I’ll ring you tonight.</li>
</ol>
</li>
<li>rise 上升；起身，起立<ol>
<li>The sun rises in the east.</li>
<li>He rose to welcome me.</li>
<li>All rise!</li>
</ol>
</li>
<li>rob 抢劫<ol>
<li>to rob a bank</li>
<li>I was robbed.</li>
</ol>
</li>
<li>run 跑，跑步<ol>
<li>I had to run to catch the bus.</li>
<li>I often go running after work.</li>
</ol>
</li>
<li>take 拿，接受<ol>
<li>He took some keys out of his pocket.</li>
<li>Someone has taken my scarf.</li>
<li>Don’t give him money. He won’t take it.</li>
</ol>
</li>
<li>talk 谈话，交谈<ol>
<li>We talked for an hour.</li>
<li>He was talking to a friend.</li>
<li>What are they <strong>talking about</strong>?</li>
</ol>
</li>
<li>taste 尝起来，品尝<ol>
<li>Mmm! This tastes good!</li>
<li>I can’t really taste anything with this cold.</li>
</ol>
</li>
<li>teach 教书，教<ol>
<li>She teaches at out local shcool.</li>
<li>I teach English.</li>
</ol>
</li>
<li>tell 说，告诉<ol>
<li>Did she tell you her name？</li>
<li>He told everybody the news.</li>
<li>Are you telling the truth?</li>
</ol>
</li>
<li>thank 感谢<ol>
<li><strong>Thank you</strong> every much!</li>
<li>Thank God it’s over!</li>
</ol>
</li>
<li>think 想，考虑；认为<ol>
<li>I’ll think about it.</li>
<li>Do you think it’s going to rain? Yes, I think so.</li>
<li>I don’t think so.</li>
</ol>
</li>
<li>throw 扔，投<ol>
<li>Please throw me that towel.</li>
<li>Throw the ball to me.</li>
<li>Stop throwing stones at the dog!</li>
</ol>
</li>
<li>travel 旅行<ol>
<li>I love travelling.</li>
<li>When I finished college I went travelling for six months.</li>
</ol>
</li>
<li>trust 相信，信赖<ol>
<li>I just don’t trust him.</li>
<li>Don’t trust what the newspapers say.</li>
</ol>
</li>
<li>try 努力，尝试<ol>
<li>I don’t know if I can come, but I’ll try.</li>
<li>He tried to control his voice.</li>
<li>John isn’t here. Try phoning his home number.</li>
</ol>
</li>
<li>turn 转动；转身<ol>
<li>He turned the key in the lock.</li>
<li>Ricky turned and walked away.</li>
<li><strong>Trun right</strong> at the second crossing.</li>
</ol>
</li>
<li>understand 理解，明白<ol>
<li>She doesn’t understand English.</li>
<li>I’m sorry, I don’t understand.</li>
<li>I don’t want you to do that again. Do you understand?</li>
</ol>
</li>
<li>use 使用<ol>
<li>May I use your phone?</li>
<li>Have you ever used this software before?</li>
<li>If you don’t use your English you’ll forget it.</li>
</ol>
</li>
<li>visit 访问；探望；参观<ol>
<li>The Prime Minister is visiting Japan at the moment.</li>
<li>She doesn’t visit her parents very often.</li>
<li>Which cities did you visit in Spain?</li>
</ol>
</li>
<li>work 工作<ol>
<li>Where do you work?</li>
<li>She isn’t working now.</li>
<li>I’ve been working all day.<br>4.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>firewall</title>
    <url>/2020/04/22/Work%20Record/CAAS/Firewall/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=25/tcp --permanent</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
  </entry>
  <entry>
    <title>LocalDateTime的BUG</title>
    <url>/2020/04/22/Work%20Record/CAAS/LocalDateTimeBug/</url>
    <content><![CDATA[<p>记录一个BUG</p><p>SpringBoot Version : 2.1.0 Release</p><p>使用ResponseBody返回json时，如果有LocalDateTime等类型，返回会一直是数组类型，不是想要的结果，移除掉@EnableWebMvc就可以了，不知道为啥，等等Google下原因。</p><a id="more"></a>


<p>百度还是不靠谱。</p>
<p>查了下，在2以后的版本中，@EnableWebMvc会产生冲突。。。</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p>
<p>上面是Spring 官方文档的说明。</p>
<p>如果使用了@EnableMvc，会全面接管配置，导致默认配置失效。</p>
<p>最好是自己写个类，实现WebMvcConfig，然后自定义实现相关接口。</p>
<p>默认的Jackson的ObjectMapper，也有自己的AutoConfig，默认不用改，如果自定ObjectMapper的话，需要注意，@Transient注解标识的字段，默认是不会处理的。最好是继承之前的ObjectMapper，然后定义。不然的话，可能会有问题。</p>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
  </entry>
  <entry>
    <title>名词-其他</title>
    <url>/2020/04/12/Language/English/New%20Concept/Word/Noun/Other/</url>
    <content><![CDATA[<p>其他常见的一些名词</p>
<a id="more"></a>
<ul>
<li>meal 餐，饭<ul>
<li>breakfast, the first meal of the day</li>
<li>Why don’t you ask him out for a meal?</li>
<li>We must have a meal together some time.</li>
</ul>
</li>
<li>breakfast 早餐<ul>
<li>a light breakfast</li>
<li>a big breakfast</li>
<li>a working breakfast</li>
<li>I’m having breakfast.</li>
</ul>
</li>
<li>lunch 午餐<ul>
<li>What’s for lunch?</li>
<li>I’ll have soup for lunch.</li>
<li>I’m afraid he’s at lunch</li>
<li>I’ll take you out to lunch next time.</li>
</ul>
</li>
<li>supper 晚餐<ul>
<li>the Last Supper</li>
<li>We had supper in a small Italian place.</li>
<li>Why don’t you come over for supper on sunday?</li>
</ul>
</li>
<li>dinner 晚餐，正餐<ul>
<li>It’s time for dinner.</li>
<li>Have you had dinner yet?</li>
<li>Perhaps we should invite them to dinner.</li>
</ul>
</li>
<li>eye 眼睛<ul>
<li>She opened her eyes.</li>
<li>She closed her eyes.</li>
<li>I’ve got something in my eye!</li>
</ul>
</li>
<li>eyebrow 眉毛<ul>
<li>He’s got thick eyebrows.</li>
<li>eyebrow pencil</li>
<li>She is plucking her eyebrows.</li>
</ul>
</li>
<li>forehead 额头<ul>
<li>She’s got a high forehead.</li>
</ul>
</li>
<li>neck 脖子，颈<ul>
<li>Giraffes have very long necks.</li>
<li>Jean wore a string of pearis around he neck.</li>
</ul>
</li>
<li>shoulder 肩膀<ul>
<li>shrug one’s shoulders</li>
<li>a person with broad shoulders</li>
</ul>
</li>
<li>heart 心，心脏<ul>
<li>His heart stopped beating.</li>
<li>He has a kind heart.</li>
<li>You broke my heart.</li>
</ul>
</li>
<li>stomach 胃<ul>
<li>My stomach is completely full.</li>
</ul>
</li>
<li>stomachache 胃痛<ul>
<li>The baay-sister says she has a stomachache</li>
</ul>
</li>
<li>arm 胳膊<ul>
<li>left arm</li>
<li>right arm</li>
<li>Peter was carrying a box under his arm.</li>
<li>They walked alone the beach arm in arm.</li>
</ul>
</li>
<li>hand 手<ul>
<li>Go wash you hands.</li>
<li>The young couple were holding hands.</li>
<li>The two leaders shook hands.</li>
<li>Could you give me a hand?</li>
</ul>
</li>
<li>finger 手指<ul>
<li>Everyone has ten fingers.</li>
<li>We ate with our fingers.</li>
</ul>
</li>
<li>fingernail 指甲<ul>
<li>She had long red fingernails.</li>
</ul>
</li>
<li>thumb 大拇指<ul>
<li>The baby is sucking his thumb.</li>
</ul>
</li>
<li>forefinger 食指<ul>
<li>index finger</li>
</ul>
</li>
<li>middle finger 中指</li>
<li>ring finger 无名指</li>
<li>little finger 小指</li>
<li>waist 腰，腰部，腰围<ul>
<li>He put his arm around her waist.</li>
<li>She has a 26-inch waist.</li>
</ul>
</li>
<li>his 臀部<ul>
<li>He stood with his hands on his hips.</li>
</ul>
</li>
<li>leg 腿<ul>
<li>She fell and broke her leg.</li>
<li>a young boy with skinny legs</li>
</ul>
</li>
<li>knee 膝盖，膝<ul>
<li>He went down on one kenn and asked her to marry him.</li>
<li>Sit on my knee.</li>
</ul>
</li>
<li>foot 脚<ul>
<li>My foot hurts.</li>
<li>I’ve been on my feet all day.</li>
<li>It takes about 30 minutes on foot.</li>
</ul>
</li>
<li>toe 脚趾<ul>
<li>Can you touch your toes?</li>
</ul>
</li>
<li>bone 骨头<ul>
<li>This fish has a lot of bones in it.</li>
<li>She was all skin and bone.</li>
</ul>
</li>
<li>skin 皮，皮肤<ul>
<li>She has a dark skin.</li>
<li>a skin disease.</li>
</ul>
</li>
<li>hat 帽子<ul>
<li>Put on you hat.</li>
<li>Take off you hat.</li>
<li>Maria was wearing a beautiful new hat.</li>
</ul>
</li>
<li>scarf 围巾<ul>
<li>You need a scarf on such a cold day.</li>
</ul>
</li>
<li>coat 上衣，外套<ul>
<li>Billy! Put on your coat. It’s cold outside!</li>
</ul>
</li>
<li>shirt 衬衣<ul>
<li>a cotton shirt</li>
<li>I wear a shirt and tie at work.</li>
</ul>
</li>
<li>tie 领带<ul>
<li>black tie</li>
<li>white tie</li>
</ul>
</li>
<li>blouse 女衬衫<ul>
<li>She was wearing a skirt and blouse.</li>
</ul>
</li>
<li>sweater 针织套衫，羊毛套衫<ul>
<li>a V-necked sweater</li>
<li>Put a sweater on if you’re cold.</li>
</ul>
</li>
<li>trousers 裤子</li>
<li>pants 裤子<ul>
<li>a pair of pants</li>
</ul>
</li>
<li>jeans 牛仔裤<ul>
<li>a T-shirt and jeans</li>
<li>She was wearing a pair of tight blue jeans</li>
</ul>
</li>
<li>jacket 短上衣，夹克<ul>
<li>a black leather jacket</li>
</ul>
</li>
<li>dress 连衣裙<ul>
<li>Susan is wearing a long red dress.</li>
</ul>
</li>
<li>skirt 裙子<ul>
<li>a short skirt and high heels</li>
</ul>
</li>
<li>miniskrit 超短裙，迷你裙</li>
<li>suit 套装<ul>
<li>a business suit</li>
</ul>
</li>
<li>shoe 鞋<ul>
<li>a pair of shoes</li>
<li>I took off my shoes.</li>
</ul>
</li>
<li>sock 袜子<ul>
<li>a pair of socks</li>
<li>Put on your shoes and socks.</li>
</ul>
</li>
<li>stocking 长筒袜<ul>
<li>a pair of silk stockings</li>
</ul>
</li>
<li>glove 手套<ul>
<li>a paire of gloves</li>
<li>boxing gloves</li>
</ul>
</li>
<li>pajamas 睡衣裤<ul>
<li>pyjamas</li>
<li>Why are you still in your pajamas?</li>
</ul>
</li>
<li>cotton 棉花，棉布<ul>
<li>a white cotton shirt</li>
<li>100% cotton</li>
<li>cotton candy</li>
</ul>
</li>
<li>wool 羊毛<ul>
<li>a pure wool skirt</li>
<li>100% wool</li>
</ul>
</li>
<li>silk 丝<ul>
<li>a silk blouse</li>
<li>silk stockings</li>
<li>Her skin was as smooth as silk.</li>
</ul>
</li>
<li>leather 皮，毛皮<ul>
<li>leather shoes</li>
<li>a leather jacket</li>
</ul>
</li>
<li>family 家庭，家人<ul>
<li>a one-parent family</li>
<li>Do you know the family next door?</li>
</ul>
</li>
<li>mother 母亲，妈妈<ul>
<li>Good night, Mother.</li>
<li>His mother is a doctor.</li>
<li>mother cat</li>
</ul>
</li>
<li>mom 妈妈<ul>
<li>mommy</li>
<li>I miss my mom a lot.</li>
<li>Mom, I’m hungry.</li>
</ul>
</li>
<li>father 父亲，爸爸<ul>
<li>Ben’s a wonderful father.</li>
<li>My boss is a father of three.</li>
</ul>
</li>
<li>dad 爸爸<ul>
<li>daddy</li>
<li>Dad, will you help me?</li>
</ul>
</li>
<li>son 儿子<ul>
<li>He has a son and two daughters.</li>
</ul>
</li>
<li>daughters 女儿<ul>
<li>My daughter is three years old.</li>
</ul>
</li>
<li>grandfather 祖父<ul>
<li>His grandfather was a professor.</li>
</ul>
</li>
<li>grandmother 祖母<ul>
<li>My grandmother passed away two years ago.</li>
</ul>
</li>
<li>uncle 叔叔，伯父，舅父，姑父，姨夫<ul>
<li>Uncle Philip</li>
<li>Uncle sam</li>
</ul>
</li>
<li>aunt 姨妈，姑妈，伯母，舅妈<ul>
<li>auntie</li>
<li>Aunt Mary</li>
</ul>
</li>
<li>brother 兄，弟<ul>
<li>big brother</li>
<li>little brother</li>
</ul>
</li>
<li>sister 姐，妹<ul>
<li>big sister</li>
<li>little sister</li>
<li>Do you have any brothers or sisters?</li>
</ul>
</li>
<li>cousin 堂（表）兄弟姐妹<ul>
<li>She is my cousin.</li>
</ul>
</li>
<li>husband 丈夫<ul>
<li>This is my husband, Steve.</li>
<li>ex-husband 前夫</li>
</ul>
</li>
<li>wife 妻子<ul>
<li>She is a good wife and mother.</li>
<li>ex-wife 前妻</li>
</ul>
</li>
<li>boyfriend 男朋友<ul>
<li>He’s not my boyfriend - we’re just good friends!</li>
</ul>
</li>
<li>girlfriend 女朋友<ul>
<li>Does he have a girlfriend?</li>
</ul>
</li>
<li>friend 朋友<ul>
<li>We are good friends.</li>
</ul>
</li>
<li>plane 飞机<ul>
<li>The plane is aboud to land.</li>
<li>travel by plane</li>
<li>The plane will take off in twenty minutes.</li>
</ul>
</li>
<li>train 火车<ul>
<li>I went to Qingdao by train last year.</li>
<li>get on the train</li>
<li>get off the train</li>
</ul>
</li>
<li>bus 公共汽车<ul>
<li>Shall we walk or go by bus?</li>
<li>Hurry up or we’ll miss the bus!</li>
</ul>
</li>
<li>coach 长途公共汽车<ul>
<li>a coach station</li>
</ul>
</li>
<li>subway 地铁<ul>
<li>a subway train</li>
<li>a subway station</li>
</ul>
</li>
<li>taxi 出租汽车<ul>
<li>I <strong>took a taxi</strong> to the airport.</li>
<li>She arrived by taxi.</li>
</ul>
</li>
<li>bike 自行车<ul>
<li>They’ll come <strong>by bike</strong>.</li>
</ul>
</li>
<li>motorbike 摩托车<ul>
<li>She jumped on her motorbike.</li>
</ul>
</li>
<li>boat 小船<ul>
<li>a fishing boat</li>
<li>row a boat</li>
<li>We crossed the river <strong>by boat</strong>.</li>
</ul>
</li>
<li>ship 轮船<ul>
<li>She travelled to Japan by ship.</li>
</ul>
</li>
<li>ferry 渡船<ul>
<li>The ferry leaves for France at one o’clock.</li>
</ul>
</li>
<li>truck 卡车<ul>
<li>a truck driver</li>
</ul>
</li>
<li>car 小汽车<ul>
<li>I bought a new car.</li>
<li>He always goes to work by car.</li>
</ul>
</li>
<li>jeep 吉普车<ul>
<li>Is this a jeep or a truck?</li>
</ul>
</li>
<li>bus stop 公共汽车站<ul>
<li>She is waiting at the bus stop.</li>
</ul>
</li>
<li>railway station 火车站<ul>
<li>I’ll meet you at the railway statoin.</li>
</ul>
</li>
<li>subway station 地铁站<ul>
<li>Excuse me, how can i get on the subway station.</li>
</ul>
</li>
<li>airport 机场<ul>
<li>Her family went to see her off at the airport.</li>
</ul>
</li>
<li>teacher 教师<ul>
<li>I’m an English teacher.</li>
</ul>
</li>
<li>professor 教授<ul>
<li>Professor Stephen Hawking</li>
</ul>
</li>
<li>writer 作家，作者<ul>
<li>He is a writer of children’s stories.</li>
</ul>
</li>
<li>doctor 医生<ul>
<li>You’d better see a doctor.</li>
</ul>
</li>
<li>dentist 牙医<ul>
<li>I’m going to <strong>the dentist’s</strong> this afternoon.</li>
</ul>
</li>
<li>nurse 护士<ul>
<li>His aunt is a nurse.</li>
</ul>
</li>
<li>singer 歌手<ul>
<li>My favorite <strong>pop singer</strong> is Michael Jackson.</li>
</ul>
</li>
<li>dancer 舞蹈演员，舞者<ul>
<li>His ex-girlfriend was a dancer.</li>
</ul>
</li>
<li>painter 画家<ul>
<li>a famous painter</li>
</ul>
</li>
<li>lawyer 律师<ul>
<li>I want to see my lawyer before i say anything.</li>
</ul>
</li>
<li>engineer 工程师<ul>
<li>They’re sending an engineer to fix the telephone line.</li>
</ul>
</li>
<li>designer 设计师<ul>
<li>I want to be a fashion disigner.</li>
</ul>
</li>
<li>actor 演员<ul>
<li>You have to be a very good actor to play that part.</li>
</ul>
</li>
<li>actress 女演员<ul>
<li>She’s a great dramatic actress.</li>
</ul>
</li>
<li>waiter 服务员<ul>
<li>Waiter, could you bring me some water?</li>
</ul>
</li>
<li>waitress 女服务员<ul>
<li>I’ll ask the waitress for the bill.</li>
</ul>
</li>
<li>businessman 商人<ul>
<li>Her husband is a successful businessman.</li>
</ul>
</li>
<li>taxi driver 出租车司机<ul>
<li>He was once a taxi driver; now he is a college student.</li>
</ul>
</li>
<li>bus driver 公交车司机<ul>
<li>Why don’t you ask the bus driver?</li>
</ul>
</li>
<li>accountant 会计师<ul>
<li>Certified public accountant（CPA）</li>
</ul>
</li>
<li>cashier 出纳员<ul>
<li>She is a cashier in a supermarket.</li>
</ul>
</li>
<li>salesperson 售货员，推销员<ul>
<li>a car salesperson</li>
</ul>
</li>
<li>vet 兽医<ul>
<li>I’m going to take the dog to the vet’s tomorrow.</li>
</ul>
</li>
<li>worker 工人<ul>
<li>part-time workters</li>
<li>blue-collar workers</li>
<li>white-collar workers</li>
</ul>
</li>
<li>clerk 职员<ul>
<li>a bank clerk</li>
<li>an office clerk</li>
</ul>
</li>
<li>boss 老板<ul>
<li>I’ll have to ask my boss for a day off.</li>
<li>I’ll my own boss.</li>
</ul>
</li>
<li>model 模特<ul>
<li>a male model</li>
<li>a fashion model</li>
</ul>
</li>
<li>cook 厨师<ul>
<li>He works as a cook in a local restaurant.</li>
<li>Who was the cook?</li>
</ul>
</li>
<li>chef 大厨，厨师长<ul>
<li>He is one of the top chefs in China.</li>
</ul>
</li>
<li>farmer 农场主，农民<ul>
<li>a pig farmer </li>
</ul>
</li>
<li>pilot 飞机员<ul>
<li>Her husband is very good pilot.</li>
</ul>
</li>
<li>captain 船长，机长，队长<ul>
<li>Captain Cook</li>
<li>Captain American</li>
</ul>
</li>
<li>flight attendant 空中乘务员<ul>
<li>It’s not easy to be a good flight attendant.</li>
</ul>
</li>
<li>policeman 男警察<ul>
<li>That policeman’s waving to you.</li>
<li>policewoman</li>
</ul>
</li>
<li>firefighter 消防队员<ul>
<li>He wants to be a firefighter.</li>
</ul>
</li>
<li>dustman 清洁工<ul>
<li>Alf’s wife has never discovered that she married a dustman.</li>
</ul>
</li>
<li>hairdresser 理发师<ul>
<li>That hairdresser curled my hair.</li>
</ul>
</li>
<li>milkman 送牛奶的人<ul>
<li>Have you paid the milkman this month?</li>
</ul>
</li>
<li>postman 邮递员<ul>
<li>Has the postman come this morning?</li>
</ul>
</li>
<li>scientist 科学家<ul>
<li>When i was a kid, my dream was to be a scientist.</li>
</ul>
</li>
<li>baker 面包师傅<ul>
<li>I’m just going to the baker’s.</li>
</ul>
</li>
<li>mayor 市长<ul>
<li>the mayor of New York</li>
</ul>
</li>
<li>president 总统<ul>
<li>President Obama</li>
<li>Do you have any comment, Mr.President?</li>
</ul>
</li>
<li>priest 牧师，神父<ul>
<li>He had trained to be a Catholic priest.</li>
</ul>
</li>
<li>editor 编辑<ul>
<li>the editor of the Washington Post</li>
</ul>
</li>
<li>real estate agent 房产中介<ul>
<li>I spoke to a real estate agent about mu house.</li>
</ul>
</li>
<li>journalist 新闻记者<ul>
<li>a well-known journalist</li>
</ul>
</li>
<li>tour guide 导游<ul>
<li>A tour guide took us around the city.</li>
</ul>
</li>
<li>manager 经理<ul>
<li>a bank manager</li>
<li>a hotel manager</li>
<li>I’d like to speak to the manager.</li>
</ul>
</li>
<li>secretary 秘书<ul>
<li>My secretary will fax you all the details.</li>
</ul>
</li>
<li>sun 太阳<ul>
<li>The sun rises in the east and sets in the west.</li>
<li>The sun is shining and birds are singing.</li>
</ul>
</li>
<li>earth 地球<ul>
<li>The moon goes round the earth.</li>
<li>I must be the happiest person <strong>on the earch</strong>.</li>
</ul>
</li>
<li>moon 月球<ul>
<li>full moon</li>
<li>the Americans landed on the moon in 1969.</li>
</ul>
</li>
<li>star 星星<ul>
<li>The sky was filled with stars.</li>
<li>Twinkle, twinkle, little star, How i wonder what you are. Up above the world so high, Like a diamond in the sky.</li>
</ul>
</li>
<li>air 空气<ul>
<li>Let’s go outside and get some fresh air.</li>
<li>I’d prefer to travel <strong>by air</strong>.</li>
</ul>
</li>
<li>sky 天空<ul>
<li>a clear blue sky</li>
<li>There isn’t a cloud in the sky.</li>
</ul>
</li>
<li>cloud 云<ul>
<li>dark cloud</li>
<li>The sun went behind a cloud.</li>
</ul>
</li>
<li>tree 树<ul>
<li>As a kid, i loved to climb trees.</li>
<li>We planted a peach tree in the backyard.</li>
</ul>
</li>
<li>leaf 叶子，树叶<ul>
<li>fallen leaves</li>
<li>He was sweeping up leaves in his garden.</li>
</ul>
</li>
<li>branch 树枝<ul>
<li>She climbed the tree and hid in the branch.</li>
</ul>
</li>
<li>trunk 树干<ul>
<li>the trunk of an old oak tree</li>
</ul>
</li>
<li>root 根<ul>
<li>I pulled the plant up by the roots.</li>
<li>root vegetables</li>
</ul>
</li>
<li>grass 草<ul>
<li>Keep off the grass.</li>
<li>The dry grass caught fire.</li>
</ul>
</li>
<li>flower 花<ul>
<li>a flower garden</li>
<li>a flower show</li>
<li>She bent down and picked a flower.</li>
</ul>
</li>
<li>bud 花蕾，芽<ul>
<li>rose bug</li>
</ul>
</li>
<li>rose 玫瑰<ul>
<li>a bunch of red rose</li>
<li>a rose garden</li>
</ul>
</li>
<li>lily 百合花<ul>
<li>The are always fresh lilies on her desk.</li>
</ul>
</li>
<li>tulip 郁金香<ul>
<li>Tulip is the national flower of Holland.</li>
</ul>
</li>
<li>sunflower 向日葵<ul>
<li>sunflower seeds</li>
<li>A bee sits on a sunflower in the garden.</li>
</ul>
</li>
<li>daisy 雏菊<ul>
<li>A daisy is a small wild flower with a yellow center and white petals.</li>
</ul>
</li>
<li>road 路<ul>
<li>road signs</li>
<li>All roads lead to Rome.</li>
</ul>
</li>
<li>street 街道<ul>
<li>I met a friend <strong>in the street</strong>.</li>
<li>The bank is just <strong>across the street</strong>.</li>
</ul>
</li>
<li>way 道路，方法<ul>
<li>This way, please.</li>
<li>No way!</li>
<li>I’m sure he loves you, <strong>in his own way</strong>.</li>
</ul>
</li>
<li>building 建筑物，大楼<ul>
<li>They were on the upper floor of the building.</li>
</ul>
</li>
<li>floor 地板，楼层<ul>
<li>wooden floor</li>
<li>kitchen floor</li>
<li>We live on the eighth floor.</li>
</ul>
</li>
<li>basement 地下室<ul>
<li>Dad is working in the basement.</li>
</ul>
</li>
<li>ground 地面<ul>
<li>He lay on the ground and stared up at sky.</li>
<li>playground 操场</li>
</ul>
</li>
<li>door 门<ul>
<li>Could you <strong>open the door</strong> for me?</li>
<li>He quickly <strong>shut the door</strong>.</li>
<li>Someone is <strong>knocking at the door</strong>.</li>
</ul>
</li>
<li>gate 门<ul>
<li>Please wait <strong>at the gate</strong>.</li>
<li>Two guards are standing <strong>at the gate</strong>.</li>
</ul>
</li>
<li>window 窗户<ul>
<li>a broken window</li>
<li>I saw them through the window.</li>
<li>She looked out of the window.</li>
</ul>
</li>
<li>glass 玻璃<ul>
<li>a glass bowl</li>
<li>a piece of broken glass</li>
</ul>
</li>
<li>metal 金属<ul>
<li>a small black metal box</li>
<li>The gate is made of metal.</li>
</ul>
</li>
<li>rain 雨<ul>
<li>heavy rain</li>
<li>light rain</li>
<li>Don’t go out in the rain.</li>
</ul>
</li>
<li>rainbow 彩虹<ul>
<li>Oh look, a rainbow!</li>
<li>all the clolors of the rainbow</li>
</ul>
</li>
<li>snow 雪<ul>
<li>The snow began to fall.</li>
<li>Children were playing in the snow</li>
<li>snowman</li>
</ul>
</li>
<li>wind 风<ul>
<li>strong/heavy winds</li>
<li>a north wind</li>
<li><strong>A gust of wind</strong> blew my hat off.</li>
</ul>
</li>
<li>lightning 闪电<ul>
<li>a flash of lightning</li>
<li>The poor dog <strong>was struck by lightning</strong>.</li>
</ul>
</li>
<li>thunder 雷<ul>
<li><strong>a peal of thunder</strong></li>
<li>a storm with thunder and lightning</li>
</ul>
</li>
<li>storm 暴风雨，暴风雪<ul>
<li>a dust storm</li>
<li>A storm is coming.</li>
</ul>
</li>
<li>kindergarten 幼儿园<ul>
<li>Susie is in kindergarten now.</li>
</ul>
</li>
<li>school 学校<ul>
<li>a school bus</li>
<li>go to school</li>
<li>It’s <strong>time for school</strong>.</li>
</ul>
</li>
<li>primary school 小学<ul>
<li>elementary school</li>
<li>junior high school</li>
<li>senior high school</li>
</ul>
</li>
<li>college 大学，学院<ul>
<li>a college professor</li>
<li>King’s College, Cambridge</li>
<li>She’s at college.</li>
</ul>
</li>
<li>university 大学<ul>
<li>She hopes to <strong>go to university</strong> next year.</li>
<li>He studied Physics <strong>at university</strong>.</li>
</ul>
</li>
<li>grade 年级<ul>
<li>My son’s in the third grade.</li>
</ul>
</li>
<li>class 班级，课<ul>
<li>We were in the same class at scool.</li>
<li>I have a math class at 9 o’clock.</li>
</ul>
</li>
<li>classroom 教室<ul>
<li>She is in the classroom.</li>
</ul>
</li>
<li>classmate 同班同学<ul>
<li>The gril with long hair is my classmate.</li>
</ul>
</li>
<li>department 系，部门<ul>
<li>the Engligh department</li>
<li>the Educatoin Department</li>
</ul>
</li>
<li>subject 学科，话题<ul>
<li>Physics and math are my favouite subject.</li>
<li>an interesting subject of conversation</li>
<li>Chinese 语文</li>
<li>English 英语</li>
<li>math 数学</li>
<li>physics 物理</li>
<li>chemistry 化学</li>
<li>history 历史</li>
<li>geology 地理</li>
</ul>
</li>
<li>country 国家<ul>
<li>European countries</li>
<li>There will be rain in all parts of the country.</li>
<li>China 中国</li>
<li>America 美国</li>
<li>England 英国</li>
<li>France 法国</li>
<li>Germany 德国</li>
<li>Italy 意大利</li>
<li>Austria 奥地利</li>
<li>Turkey 土耳其</li>
<li>Spain 西班牙</li>
<li>Greece 希腊</li>
<li>Sweden 瑞典</li>
<li>Switzerland 瑞士</li>
<li>Russia 俄罗斯</li>
<li>Canada 加拿大</li>
<li>Australia 澳大利亚</li>
<li>New Zealand 新西兰</li>
<li>Japan 日本</li>
<li>Korea 朝鲜，韩国</li>
<li>India 印度</li>
<li>Vietnam 越难</li>
<li>Malaysia 马来西亚</li>
<li>Philippines 菲律宾</li>
</ul>
</li>
<li>time 时间<ul>
<li><strong>Long time no see.</strong></li>
<li>That will <strong>take time</strong>.</li>
<li><strong>Time heals all wounds.</strong></li>
</ul>
</li>
<li>year 年，年纪<ul>
<li>last year</li>
<li>this year</li>
<li>next year</li>
<li>My son is 4 <strong>years old</strong>.</li>
</ul>
</li>
<li>month 月<ul>
<li>She’ll be thirteen <strong>this month</strong>.</li>
<li>He’ll be away for two months.</li>
<li>I haven’t seen him <strong>for months</strong>.</li>
</ul>
</li>
<li>week 星期<ul>
<li>I can’t see you this weak.</li>
<li>See you next week.</li>
<li>Last week I was very busy.</li>
</ul>
</li>
<li>weekend 周末<ul>
<li>Have a nice weekend!</li>
<li>What are you doing <strong>on the weekend</strong>?</li>
</ul>
</li>
<li>day 一天，白天<ul>
<li>There are seven days in a week.</li>
<li>He has been working all day.</li>
</ul>
</li>
<li>night 夜晚，晚上<ul>
<li>Good night!</li>
<li>These animals only comt out <strong>at night</strong>.</li>
</ul>
</li>
<li>morning 上午，早晨<ul>
<li>Good morning!</li>
<li>I’ll see you <strong>tomorrow morning</strong>.</li>
<li>I prefer coffee <strong>in the morning</strong>.</li>
</ul>
</li>
<li>afternoon 下午<ul>
<li>Good afternoon, ladies and gentlemen!</li>
<li><strong>In the afternoon</strong> they went shopping.</li>
</ul>
</li>
<li>evening 晚上<ul>
<li>Good evening, everyone.</li>
<li>What do you usually do <strong>in the evening</strong>?</li>
</ul>
</li>
<li>tomorrow 明天<ul>
<li>See you tomorrow!</li>
<li>We’re meeting <strong>tomorrow evening</strong>.</li>
<li><strong>the day after tomorrow</strong></li>
</ul>
</li>
<li>yesterday 昨天<ul>
<li>Where were you yesterday morning?</li>
<li><strong>yeserday once more</strong></li>
<li><strong>the day before yesterday</strong></li>
</ul>
</li>
<li>hour 小时<ul>
<li>The movie lasts two hours.</li>
<li>I’ll be back in three hours.</li>
</ul>
</li>
<li>minute 分钟<ul>
<li>Just a minue.</li>
<li>Our guests will be here <strong>in a minute</strong>!</li>
<li>He returned <strong>a few minutes later</strong>.</li>
</ul>
</li>
<li>second 秒<ul>
<li>Hold you breath for six seconds.</li>
<li>I’ll be back in a second.</li>
<li>Just a second, I’ll come and help.</li>
</ul>
</li>
<li>moment 瞬间，片刻，时机<ul>
<li>Could you wait a moment, please?</li>
<li>I’ll be back <strong>in a moment</strong>.</li>
<li>Wait for the right moment.</li>
</ul>
</li>
<li>Monday 星期一<ul>
<li>last Monday</li>
<li>next Monday</li>
<li>They met <strong>on Monday</strong> and got married on Friday.</li>
</ul>
</li>
<li>Tuesday 星期二</li>
<li>Wednesday 星期三</li>
<li>Thursday 星期四</li>
<li>Friday 星期五</li>
<li>Saturday 星期六</li>
<li>Sunday 星期天</li>
<li>January 一月<ul>
<li>She started working there <strong>in January</strong>.</li>
</ul>
</li>
<li>February 二月</li>
<li>March 三月</li>
<li>April 四月</li>
<li>May 五月</li>
<li>June 六月</li>
<li>July 七月</li>
<li>August 八月</li>
<li>September 九月</li>
<li>October 十月</li>
<li>November 十一月</li>
<li>December 十二月</li>
<li>season 季节<ul>
<li>the dry season</li>
<li>the rainy season</li>
<li>Spring is my favorite season.</li>
</ul>
</li>
<li>spring 春季<ul>
<li>He was born <strong>in the spring</strong> of 1944.</li>
<li>There’s a feeling of spring in the air today.</li>
</ul>
</li>
<li>summer 夏天<ul>
<li><strong>In (the) summer</strong>, we often go on holiday,</li>
<li>We’re going to Italy <strong>next summer</strong>.</li>
</ul>
</li>
<li>autumn 秋天<ul>
<li>fall</li>
<li>in the early autumn</li>
<li>in the late autumn</li>
</ul>
</li>
<li>winter 冬天<ul>
<li>It usually snows here <strong>in the winter</strong>.</li>
</ul>
</li>
<li>holiday 假日，节日<ul>
<li>The school holidays start tomorrow.</li>
<li>I’m taking two weeks holiday.</li>
</ul>
</li>
<li>ocean 海洋<ul>
<li>the Pacific Ocean</li>
<li>the Atlantic Ocean</li>
<li>the Indian Ocean</li>
<li>the Arctic Ocean</li>
</ul>
</li>
<li>sea 大海<ul>
<li>travel <strong>by sea</strong></li>
<li>a cottage <strong>by the sea</strong></li>
</ul>
</li>
<li>beach 海滩<ul>
<li>a beautiful <strong>sandy beach</strong></li>
<li>I just want to lie <strong>on the beach</strong> in the sun.</li>
</ul>
</li>
<li>river 河流<ul>
<li>the Mississippi River</li>
<li>We went for a walk <strong>alone the river</strong>.</li>
</ul>
</li>
<li>lake 湖<ul>
<li>Lake geneva</li>
<li>We swam <strong>in the lake</strong>.</li>
</ul>
</li>
<li>mountain 山<ul>
<li>the Rocky Mountains</li>
<li>There is still snow on the mountain tops.</li>
</ul>
</li>
<li>hill 小山<ul>
<li>The house is on the side of a hill.</li>
</ul>
</li>
<li>land 陆地<ul>
<li>travel <strong>by land</strong></li>
<li>It was good to be back <strong>on land</strong>.</li>
</ul>
</li>
<li>island 岛<ul>
<li>a remote island</li>
</ul>
</li>
<li>cinema 电影院<ul>
<li>We dicided to <strong>go to the cinema</strong>.</li>
<li>It’s on <strong>at the</strong> local cinema.</li>
</ul>
</li>
<li>theater 剧场，戏院<ul>
<li>an open-air theatre</li>
</ul>
</li>
<li>library 图书馆<ul>
<li>a public library</li>
<li>Let’s meet outside the library.</li>
</ul>
</li>
<li>museum 博物馆<ul>
<li>the Natural History Museum</li>
<li>Night at the Museum</li>
</ul>
</li>
<li>park 公园<ul>
<li>Let’s go for a walk in the park.</li>
<li>They stopped and sat on a park bench.</li>
</ul>
</li>
<li>garden 花园<ul>
<li>Out house has a small garden.</li>
<li>Children are playing in the garden.</li>
</ul>
</li>
<li>hospital 医院<ul>
<li>He had to <strong>go to hospital.</strong></li>
<li>She spend two weeks <strong>in hospital.</strong></li>
</ul>
</li>
<li>church 教堂<ul>
<li>How often do you <strong>go to church</strong>?</li>
<li>We didn’t see you <strong>at church</strong> this morning.</li>
</ul>
</li>
<li>shopping mall 购物中心<ul>
<li>They are planning to build another <strong>shopping mall</strong> around here.</li>
</ul>
</li>
<li>post office 邮局<ul>
<li>You can buy your stamps at the post office.</li>
</ul>
</li>
<li>bank 银行<ul>
<li>a bank manager</li>
<li>a bank account</li>
</ul>
</li>
<li>market 市场<ul>
<li>I usually buy fruit and vegetables at the market.</li>
</ul>
</li>
<li>supermarket 超市<ul>
<li>Another supermarket opened last week.</li>
</ul>
</li>
<li>restaurant 餐厅<ul>
<li>a Chinese restaurant</li>
<li>We went out to a restaurant to celebrate.</li>
</ul>
</li>
<li>farm 农场<ul>
<li>farm workers</li>
<li>fresh farm produce</li>
</ul>
</li>
<li>castle 城堡<ul>
<li>a medieval castle</li>
</ul>
</li>
<li>place 地方<ul>
<li>public places</li>
<li>The place was full of screaming children.</li>
</ul>
</li>
<li>film 电影<ul>
<li>movie</li>
<li>What’s you favorite film?</li>
<li>Let’s <strong>watch a film</strong>.</li>
</ul>
</li>
<li>play 戏剧<ul>
<li>We are going to see a new play.</li>
</ul>
</li>
<li>game 游戏，比赛<ul>
<li>Game over</li>
<li>Did you see the game on TV last night?</li>
</ul>
</li>
<li>ball 球<ul>
<li>Go fetch the ball!</li>
</ul>
</li>
<li>football 足球，橄榄球</li>
<li>basket 篮子<ul>
<li>a shopping basket</li>
</ul>
</li>
<li>basketball 篮球</li>
<li>baseball 棒球<ul>
<li>a baseball bat</li>
<li>a baseball team</li>
</ul>
</li>
<li>tennis 网球<ul>
<li>a tennis player</li>
<li>a tennis club</li>
</ul>
</li>
<li>table tennis 乒乓球<ul>
<li>I’ve never played <strong>table tennis</strong> before.</li>
</ul>
</li>
<li>piano 钢琴<ul>
<li>a piano teacher</li>
<li>Do you <strong>play the piano</strong>?</li>
</ul>
</li>
<li>violin 小提琴<ul>
<li>I used to <strong>play the violin</strong>.</li>
</ul>
</li>
<li>guitar 吉他<ul>
<li>Her son <strong>plays the guitar</strong> in the rock band.</li>
</ul>
</li>
<li>flute 长笛</li>
<li>drum 鼓</li>
<li>person 人<ul>
<li>You are a very nice person.</li>
<li>I’m not really a city person.</li>
</ul>
</li>
<li>people 人们<ul>
<li>How many people were at the meeting?</li>
<li>I don’t care what people thinks.</li>
</ul>
</li>
<li>man 男人，男子汉<ul>
<li>Carson is a very busy man.</li>
<li>There are two men and a woman in the car.</li>
<li>Come on, be a man now. No more crying.</li>
</ul>
</li>
<li>gentleman 先生，绅士，君子<ul>
<li>Thank you. You’re a real gentleman.</li>
<li>Good morning, ladies and gentleman.</li>
</ul>
</li>
<li>woman 女人<ul>
<li>a single woman</li>
<li>married women</li>
<li>a woman driver</li>
</ul>
</li>
<li>lady 女士，淑女<ul>
<li>Ask that lady to help you.</li>
<li>She’s a real lady. She never loses her temper.</li>
</ul>
</li>
<li>boy 男孩，儿子<ul>
<li>The boys wanted to play football.</li>
<li>How old is your little boy?</li>
</ul>
</li>
<li>girl 女孩，女儿<ul>
<li>Good morning, girls and boys!</li>
<li>They have two girls and a boy.</li>
</ul>
</li>
<li>child 儿童，孩子<ul>
<li>I was very happy as a child.</li>
<li>She is married with three children.</li>
</ul>
</li>
<li>kid 小孩<ul>
<li>She’s alwasy loved animals since she was a little kid.</li>
<li>How are your wife and kids?</li>
</ul>
</li>
<li>baby 婴儿，宝贝<ul>
<li>The baby is crying.</li>
<li>Come here, baby.</li>
</ul>
</li>
<li>nieighbor 邻居<ul>
<li>my next-door neighbor</li>
<li>I’m you new neighbor.</li>
</ul>
</li>
<li>Mr. 先生<ul>
<li>Mr. and Mrs. Smith</li>
<li>Mr. President</li>
</ul>
</li>
<li>Mrs 夫人，太太<ul>
<li>Mrs. Brown</li>
</ul>
</li>
<li>Miss 小姐，女士<ul>
<li>That’s all, thank you, Miss Lipman.</li>
<li>Miss America</li>
<li>I know the answer, Miss.</li>
</ul>
</li>
<li>Ms. 女士</li>
<li>sir 先生<ul>
<li>Can i help you, sir?</li>
<li>Are you ready to order, sir?</li>
<li>Dear Sir</li>
</ul>
</li>
<li>madam 女士，夫人<ul>
<li>ma’am</li>
</ul>
</li>
<li>city 城市<ul>
<li>New York City</li>
<li>Beijing is China’s capital city.</li>
</ul>
</li>
<li>town 城镇<ul>
<li>The village where I was born is a town now.</li>
</ul>
</li>
<li>village 村子<ul>
<li>a fishing village</li>
<li>a mountain village</li>
</ul>
</li>
<li>color 颜色<ul>
<li>colour</li>
<li>What color are his eyes?</li>
<li>I love wearing bright colors.</li>
</ul>
</li>
<li>white 白色</li>
<li>black 黑色</li>
<li>red 红色</li>
<li>pink 粉色</li>
<li>purple 紫色</li>
<li>green 绿色</li>
<li>yellow 黄色</li>
<li>blue 蓝色</li>
<li>orange 橘色</li>
<li>brown 棕色</li>
<li>gray grey 灰色</li>
<li>silver 银色</li>
<li>question 问题<ul>
<li>Can I ask you a question?</li>
<li>I’m afraid I can’t answer that questoin.</li>
<li>Does anyone have any questions?</li>
</ul>
</li>
<li>answer 回答，答复，答案<ul>
<li>You don’t have to give them an answer now.</li>
<li>What is the <strong>answer to</strong> question 4?</li>
</ul>
</li>
<li>problem 问题<ul>
<li>No problem.</li>
<li>What is you problem?</li>
<li>That’s not my problem.</li>
<li>Do you have a problem with that?</li>
</ul>
</li>
<li>letter 字母，信<ul>
<li>Fill you answers in <strong>capital letters</strong>, not <strong>small letters</strong>.</li>
<li>I got a long <strong>letter from</strong> Melanie today.</li>
</ul>
</li>
<li>word 单词<ul>
<li>Write an essay of about five hundred words.</li>
</ul>
</li>
<li>sentence 句子<ul>
<li>It’s difficult to sum it up in one sentence.</li>
</ul>
</li>
<li>art 艺术，艺术品<ul>
<li>modern art</li>
<li>an art lover</li>
<li>an art exhibition</li>
</ul>
</li>
<li>beauty 美，美人儿<ul>
<li>the beauty of the sunset</li>
<li>She was a famous beauty in her youth.</li>
</ul>
</li>
<li>bell 铃，钟<ul>
<li>church bells</li>
<li>a bicycle bell</li>
<li>He rang the bell and waited for someone to answer the door.</li>
</ul>
</li>
<li>bridge 桥<ul>
<li>We walked across a wooden bridge.</li>
</ul>
</li>
<li>blood 血<ul>
<li>He lost a lot of blood in the accident.</li>
<li>I’m going to <strong>give blood</strong> this afternoon.</li>
</ul>
</li>
<li>business 生意<ul>
<li>He wants to be a doctor or <strong>go into business.</strong></li>
<li>We <strong>do business with</strong> a number of local companies.</li>
</ul>
</li>
<li>case 事例，实情，案例<ul>
<li>It’s a clear case of blackmail!</li>
<li>This is not alwasy <strong>the case</strong>.</li>
<li>a case of murder</li>
</ul>
</li>
<li>center 中心<ul>
<li>a shopping center</li>
<li>There was a large table <strong>in the center of</strong> the room.</li>
</ul>
</li>
<li>change 机会，可能性<ul>
<li>Give me a change.</li>
<li>There is no change that he will change his mind.</li>
</ul>
</li>
<li>Christmas 圣诞节<ul>
<li>a Christmas present</li>
<li>We’ll se you <strong>at Christmas</strong>.</li>
</ul>
</li>
<li>company 公司<ul>
<li>Which company do you work for?</li>
</ul>
</li>
<li>date 日期，约会<ul>
<li>What’s the date today?</li>
<li>I’ve got a date with David tomorrow night.</li>
</ul>
</li>
<li>death 死亡<ul>
<li>Her death was a shock to him.</li>
<li>Two men were burnt to death in the fire.</li>
</ul>
</li>
<li>dream 梦，梦想<ul>
<li>Good night, Sweet dreams!</li>
<li>I have a dream.</li>
</ul>
</li>
<li>duty 职责，义务，职责<ul>
<li>I feel it is my duty to help her.</li>
<li>I promise I will do my duty.</li>
</ul>
</li>
<li>exercise 练习，运动<ul>
<li>an exercise book</li>
<li>The doctor advised him to take more exercise.</li>
</ul>
</li>
<li>experience 经历，经验<ul>
<li>We all learn by experience.</li>
<li>It was her first experience of living alone.</li>
</ul>
</li>
<li>excuse 借口<ul>
<li>What’s your excuse for being late this time?</li>
<li>I’m tired of listening to his excuses.</li>
</ul>
</li>
<li>enemy 敌人<ul>
<li>Cats ant dogs have always been <strong>natural enemies</strong>.</li>
</ul>
</li>
<li>fact 事实<ul>
<li>I can’t believe the fact that he is married.</li>
<li><strong>In fact</strong>, i had dinner with her last week.</li>
</ul>
</li>
<li>field 田地，领域<ul>
<li>a field of wheat</li>
<li>Peter’s an expert in his field.</li>
</ul>
</li>
<li>forest 森林<ul>
<li>a forest fire</li>
<li>The children got lost in the forest.</li>
</ul>
</li>
<li>wood 木头<ul>
<li>Tables are usually made of wood.</li>
<li>You’d better <strong>knock on wood</strong>.</li>
</ul>
</li>
<li>factory 工厂<ul>
<li>a car factory</li>
<li>She works in a factory.</li>
</ul>
</li>
<li>future 未来，前途<ul>
<li>Who knows what will happen in the future?</li>
<li>Does this school have a future?</li>
</ul>
</li>
<li>fire 火<ul>
<li>The house is <strong>on fire</strong>!</li>
<li>It took firefighters serveral hours to <strong>put out the fire</strong>.</li>
</ul>
</li>
<li>gift 礼物<ul>
<li>present</li>
<li>a birthday gift</li>
<li>a wedding gift</li>
</ul>
</li>
<li>habit 习惯<ul>
<li>Jeff is <strong>in the habit of</strong> taking a walk after dinner.</li>
<li>Old habits die hard.</li>
</ul>
</li>
<li>hobby 业余爱好<ul>
<li>What are you hobbies?</li>
<li>My hobbies include swimming and travelling.</li>
</ul>
</li>
<li>health 健康<ul>
<li>Exercise is good for the health.</li>
<li>Smoking can seriously damage you health.</li>
</ul>
</li>
<li>home 家<ul>
<li>He left home at sixteen.</li>
<li>Last night we stayed <strong>at home</strong> and wathed TV.</li>
</ul>
</li>
<li>homework 家庭作业<ul>
<li>How much homework do you get?</li>
<li>I still haven’t <strong>done my homework</strong>.</li>
</ul>
</li>
<li>house 房子<ul>
<li>I bought a four-bedroom house with a beautiful garden.</li>
</ul>
</li>
<li>housework 家务活<ul>
<li>I spend all morning <strong>doing the housework.</strong></li>
</ul>
</li>
<li>hope 希望<ul>
<li>There is now hope of a cure.</li>
<li>Don’t raise your hopes too high, or you may be disappointed.</li>
</ul>
</li>
<li>help 帮助<ul>
<li>I need you help.</li>
<li>Thank you for your kind help.</li>
</ul>
</li>
<li>ice 冰<ul>
<li>Is the ice thick enough for skating?</li>
<li>Her hands were <strong>as cold as ice</strong>.</li>
</ul>
</li>
<li>idea 主意，想法<ul>
<li>I have an idea.</li>
<li>That’s a good idea.</li>
</ul>
</li>
<li>lesson 功课<ul>
<li>The first lesson in driving is how to start the car.</li>
<li>She geives piano lessons.</li>
</ul>
</li>
<li>job 工作<ul>
<li>Good job!</li>
<li>I’m looking for a new job.</li>
</ul>
</li>
<li>work<ul>
<li>He’s been <strong>out of work</strong> for two years.</li>
<li>My father <strong>started work</strong> when he was just 14.</li>
</ul>
</li>
<li>joy 喜悦，高兴<ul>
<li>the look of joy on her face</li>
<li>She wept <strong>for joy</strong>.</li>
</ul>
</li>
<li>king 国王<ul>
<li>King Edward VII</li>
<li>The lion is the king of the jungle.</li>
</ul>
</li>
<li>queue 女王，往后<ul>
<li>Queue Elizabeth II</li>
<li>At eighteen, Victoria <strong>was crown queen</strong>.</li>
</ul>
</li>
<li>prince 王子<ul>
<li>Prince William</li>
<li>the Prince of Wales</li>
</ul>
</li>
<li>princess 公主，王妃<ul>
<li>Lady Diana Spencer became Princess Diana when she married Prince Charles.</li>
</ul>
</li>
<li>kiss 吻<ul>
<li>Give me a kiss.</li>
<li>Do you remember your first kiss?</li>
</ul>
</li>
<li>kite 风筝<ul>
<li>Let’s go <strong>fly a kite.</strong></li>
</ul>
</li>
<li>knowledge 知识<ul>
<li>I have only limited knowledge of computers.</li>
</ul>
</li>
<li>language 语言<ul>
<li>How many languages do you speak?</li>
<li>Andrea’s <strong>native language</strong> is German.</li>
</ul>
</li>
<li>life 生命<ul>
<li>I’ve never been so embarrassed <strong>in my life</strong>.</li>
<li>I’ve known John <strong>all my life.</strong></li>
</ul>
</li>
<li>love 爱<ul>
<li>What these kids need is love and support.</li>
<li>Their love for each other grew deeper every day.</li>
</ul>
</li>
<li>machine 机器<ul>
<li>Is the <strong>washing machine</strong> working now?</li>
<li>The <strong>fax machine </strong> is broken.</li>
</ul>
</li>
<li>map 地图<ul>
<li>a street map of Beijing</li>
<li>According to the map we should turn left.</li>
</ul>
</li>
<li>matter 事情<ul>
<li>We have more important matters to discuss.</li>
<li>What’s the matter?</li>
</ul>
</li>
<li>medicine 药<ul>
<li>Don’t take too much medicine.</li>
</ul>
</li>
<li>meeting 会议<ul>
<li>We’re having a meeting next week.</li>
<li>Mr.Black is <strong>in a meeting</strong> at the moment.</li>
</ul>
</li>
<li>menu 菜单<ul>
<li>Could I have the menu, please?</li>
<li>Is there any fish <strong>on the menu</strong>?</li>
</ul>
</li>
<li>mile 海里<ul>
<li>We walked about half a mile.</li>
<li>He was driving at 70 <strong>miles per hour</strong>.</li>
</ul>
</li>
<li>mistake 错误<ul>
<li>I <strong>made a</strong> huge mistake.</li>
<li>Sorry, I took you bag <strong>by mistake.</strong></li>
</ul>
</li>
<li>money 钱<ul>
<li>Don’t spend all your money on the first day of you holiday!</li>
<li>Could you lend me some money?</li>
</ul>
</li>
<li>member 会员，成员<ul>
<li>He is a member of the local tennis club.</li>
<li>The other members of his family were against this marriage.</li>
</ul>
</li>
<li>coin 硬币<ul>
<li>two gold coins</li>
<li>Let’s <strong>toss a coin</strong> to see who goes first.</li>
</ul>
</li>
<li>dollar 美元<ul>
<li>It cost three dollars.</li>
</ul>
</li>
<li>pound 英镑，磅<ul>
<li>a pound of apples</li>
<li>a five-pound note</li>
</ul>
</li>
<li>music 音乐<ul>
<li>I often listen to music when I’m in the car.</li>
<li>What’s you favorite kind of music?</li>
</ul>
</li>
<li>name 名字<ul>
<li>What’s you name?</li>
<li>Can I have you name?</li>
</ul>
</li>
<li>nature 自然，天性<ul>
<li>I love the beauties of nature.</li>
<li>She is a very kind person <strong>by nature</strong>.</li>
</ul>
</li>
<li>news 消息，新闻<ul>
<li>What’s the latest news?</li>
<li>Have you heard the news? Mary has got a baby.</li>
</ul>
</li>
<li>notice 布告，通知<ul>
<li>I’ll <strong>put up a notice</strong> about the meeting.</li>
</ul>
</li>
<li>number 数字，号码<ul>
<li>Five was her lucky number.</li>
<li>Can I have you phone number?</li>
</ul>
</li>
<li>peace 和平，安静<ul>
<li>After years of war the people longed for peace.</li>
<li>May he <strong>rest in peace</strong>.</li>
</ul>
</li>
<li>path 小路<ul>
<li>We took the path across the fields.</li>
</ul>
</li>
<li>page 书页<ul>
<li>The answer is on <strong>page 15</strong>.</li>
<li>I <strong>turned the pages</strong> of a magazine impatiently.</li>
</ul>
</li>
<li>paint 油漆，颜料<ul>
<li>Wet paint.</li>
<li>He brought his paints with him.</li>
</ul>
</li>
<li>pleasure 快乐，乐事<ul>
<li>He smiled <strong>with pleasure.</strong></li>
<li>It’s a pleasure to meet you.</li>
<li>It’s my pleasure.</li>
</ul>
</li>
<li>power 能力，影响力<ul>
<li>It is beyond my power.</li>
<li>You have no power here.</li>
</ul>
</li>
<li>pair 一双，一对<ul>
<li>a pair of shoes</li>
<li>the happy pair</li>
</ul>
</li>
<li>couple 夫妻，情侣<ul>
<li>the couple next door</li>
<li>a newly married couple</li>
</ul>
</li>
<li>part 部分<ul>
<li>The front part of the car was damaged.</li>
<li>The best part of the holiday was the food.</li>
</ul>
</li>
<li>party 聚会<ul>
<li>a birthday party</li>
<li>I’m giving a party next Saturday night.</li>
</ul>
</li>
<li>pet 宠物<ul>
<li>pet food</li>
<li>He was bitten by his pet dog.</li>
</ul>
</li>
<li>pirce 价格<ul>
<li>What is the price of this table?</li>
<li>House prices in this area are falling.</li>
</ul>
</li>
<li>program 节目，程序<ul>
<li>What’s you favorite television program?</li>
<li>a computer program</li>
</ul>
</li>
<li>right 右边，权利<ul>
<li>The school is <strong>on you right.</strong></li>
<li>Who gives you the right to do that?</li>
</ul>
</li>
<li>seat 座位<ul>
<li>Please <strong>take a seat</strong>.</li>
<li>You can book seats online.</li>
</ul>
</li>
<li>sand 沙子<ul>
<li>I have sand in my shoe.</li>
</ul>
</li>
<li>seed 种子<ul>
<li>sunflower seeds</li>
<li>grass seed</li>
</ul>
</li>
<li>shape 形状<ul>
<li>What shape is the table?</li>
<li>The dining room was <strong>square in shape</strong>.</li>
</ul>
</li>
<li>smile 微笑<ul>
<li>Come on, <strong>give me a smile</strong>.</li>
<li>‘Oh, I’m fine’, Anna replied <strong>with a smile</strong>.</li>
</ul>
</li>
<li>side 边，面<ul>
<li>A man was watching me from <strong>the other side</strong> of the road.</li>
<li>There is a scar <strong>on the right side</strong> of his face.</li>
</ul>
</li>
<li>size 尺寸，大小<ul>
<li>Jason’s house is about the same size as ours.</li>
<li>The jacket was the wrong size.</li>
</ul>
</li>
<li>smell 气味<ul>
<li>The air was filled with the smell of flowers.</li>
<li>There’s a delicious smell coming from the kitchen.</li>
</ul>
</li>
<li>song 歌曲<ul>
<li>a love song</li>
<li>a pop song</li>
<li>We <strong>sang a song</strong> together.</li>
</ul>
</li>
<li>sound 声音<ul>
<li>the sound of the wind</li>
<li>the sound of the sea</li>
<li><strong>The Sound of Music</strong></li>
<li>I could hear the sound of voices.</li>
</ul>
</li>
<li>voice 声音，嗓音<ul>
<li>She has a sweet voice.</li>
<li>Keep your voice down.</li>
</ul>
</li>
<li>noise 噪音<ul>
<li>What’s that noise?</li>
<li>Don’t make so much noise.</li>
</ul>
</li>
<li>stream 小溪<ul>
<li>A small stream runs through the woods.</li>
</ul>
</li>
<li>stranger 陌生人，外地人<ul>
<li>Our dog barks at strangers.</li>
<li>‘Excuse me, where’s the railway statoins?’ ‘ Sorry, I’m a stranger here myself’</li>
</ul>
</li>
<li>space 空间<ul>
<li>The fridge takes up too much space.</li>
<li>There isn’t much space left for your luggage.</li>
</ul>
</li>
<li>south 南方，南部<ul>
<li>Which way is south?</li>
<li>The town is to <strong>the south of</strong> London.</li>
</ul>
</li>
<li>north 北方，北部</li>
<li>east 东方，东部</li>
<li>west 西方，西部</li>
<li>sport 运动<ul>
<li>Which sport do you like best?</li>
<li>My favorite sport is swimming.</li>
</ul>
</li>
<li>store 商店<ul>
<li>shop</li>
<li>a big department store</li>
<li>At Christmas the stores stay open late.</li>
</ul>
</li>
<li>story 故事<ul>
<li>a ture story</li>
<li>a fairy story</li>
<li>a ghost story</li>
<li>Mommy, will you <strong>read me a story?</strong></li>
</ul>
</li>
<li>surprise 惊讶，惊喜<ul>
<li>What a surprise to find you here!</li>
<li>Bill looked at him <strong>in surprise</strong>.</li>
</ul>
</li>
<li>team 队，小组<ul>
<li>Which team do you play for?</li>
<li>You need to choose a team leader.</li>
</ul>
</li>
<li>test 考试<ul>
<li>She passed her driving test when she was 17.</li>
<li>Did you get a good mark <strong>in the test</strong>?</li>
</ul>
</li>
<li>thing 事情<ul>
<li>You are doing the right thing.</li>
<li>First things first.</li>
</ul>
</li>
<li>truth 真相<ul>
<li>How do I know you’re <strong>telling the truth</strong>?</li>
<li>The truth is, I forgot about it.</li>
</ul>
</li>
<li>ticket 入场券，票<ul>
<li>I’d like to book two tickets to Berlin.</li>
<li>A <strong>return ticket</strong> to London, please.</li>
</ul>
</li>
<li>traffic 交通，路上的车辆<ul>
<li>a traffic accident</li>
<li>traffic lights</li>
<li>There’s usually a lot of traffic at this time of day.</li>
</ul>
</li>
<li>trip 旅行<ul>
<li>Have a nice trip!</li>
<li>Did you enjoy your trip?</li>
<li>We’re thinking of <strong>taking a trip</strong> to Taiwan.</li>
</ul>
</li>
<li>trouble 麻烦<ul>
<li>We’re having trouble with our new car.</li>
<li>You are in big trouble.</li>
</ul>
</li>
<li>unit 单元<ul>
<li>The book has twenty units.</li>
</ul>
</li>
<li>weather 天气<ul>
<li>What’s the weather like today?</li>
<li>The <strong>weather forecase</strong> said it would be fine all day.</li>
</ul>
</li>
<li>world 世界<ul>
<li>I want to travel around the world.</li>
<li>Students from <strong>all over the world</strong> come to study Oxford.</li>
</ul>
</li>
<li>wall 墙<ul>
<li>the Great Wall</li>
<li>I put up some pictures on the walls.</li>
</ul>
</li>
<li>wing 翅膀<ul>
<li>The brid flapped its wings excitedly.<br>-</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>名词-日用品</title>
    <url>/2020/04/04/Language/English/New%20Concept/Word/Noun/DailyNecessities/</url>
    <content><![CDATA[<p>日用品的一些名词</p>
<a id="more"></a>
<ul>
<li>refrigerator 冰箱<ul>
<li>fridge 简称</li>
<li>Don’t forget to put the milk back in the fridge.</li>
</ul>
</li>
<li>cooker 炉灶<ul>
<li>a gas cooker</li>
<li>an electric cooker</li>
<li>rice cooker 电饭锅</li>
<li>Damn! I forgot to turn on the rice cooker.</li>
</ul>
</li>
<li>oven 烤箱，烤炉<ul>
<li>a microwave oven</li>
<li>I took the cake out of the oven.</li>
<li>Perth in summer is like an oven.</li>
</ul>
</li>
<li>cupboard 柜橱，碗柜<ul>
<li>It’s in the kichen cupboard.</li>
<li>The cupboard doors are open.</li>
<li>a skeleton in the cupboard</li>
</ul>
</li>
<li>dish 盘子，碟子<ul>
<li>a glass dish</li>
<li>a large dish of pasta</li>
<li>I’ll do the dishes.</li>
</ul>
</li>
<li>plate 盘子，碟子<ul>
<li>paper plates</li>
<li>plastic plates</li>
<li>I ate a whole plate of French fries.</li>
</ul>
</li>
<li>bowl 碗<ul>
<li>I filled the bowl with water.</li>
<li>a bowl of soup</li>
<li>a bowl of rice</li>
</ul>
</li>
<li>spoon 匙，勺子<ul>
<li>a soup spoon</li>
<li>He stirred his coffee with spoon.</li>
<li>Two spoons of sugar, please.</li>
</ul>
</li>
<li>knife 刀<ul>
<li>a kitchen knife</li>
<li>a bread knife</li>
<li>You need a shark knife to cut the steak.</li>
</ul>
</li>
<li>fork 叉<ul>
<li>a knife and fork</li>
<li>Mark prefers to eat with a knife and fork.</li>
<li>Put the knives and forks on the table.</li>
</ul>
</li>
<li>chopstick 筷子<ul>
<li>bamboo chopsticks</li>
<li>We Chinese use chopsticks instead of knives and forks.</li>
</ul>
</li>
<li>pan 锅<ul>
<li>a frying pan</li>
<li>pots and pans</li>
<li>I cooked the dish in a large pan.</li>
</ul>
</li>
<li>wok 炒菜锅<ul>
<li>A wok is a metal pan shaped like a large bowl which is used for cooking Chinese food.</li>
</ul>
</li>
<li>pot 锅，罐，壶<ul>
<li>pots and pans</li>
<li>They’ve eaten a whole pot a of jam</li>
<li>Bring me another pot of coffee.</li>
</ul>
</li>
<li>teapot 茶壶<ul>
<li>Can you make the tea?<br>Sure. Where is the teapot.</li>
</ul>
</li>
<li>coffee pot 咖啡壶<ul>
<li>Is there any coffee in the coffee pot?</li>
</ul>
</li>
<li>flower pot 花盆<ul>
<li>You’ve poured too much water in the flower pot.</li>
</ul>
</li>
<li>steamer 蒸锅<ul>
<li>My mom makers steamed bread in a steamer.</li>
</ul>
</li>
<li>egg beater 打蛋器<ul>
<li>Do you have an egg beater at home?<br>Yes, in the drawer on you left.</li>
</ul>
</li>
<li>apron 围裙<ul>
<li>She doesn’t have an apron, because she doesn’t cook at all.</li>
</ul>
</li>
<li>cup 杯子<ul>
<li>a cup of tea</li>
<li>a cup of coffee</li>
<li>a paper cup</li>
<li>a cup and saucer</li>
</ul>
</li>
<li>glass 玻璃杯<ul>
<li>a glass of water</li>
<li>a glass of beer</li>
<li>a glass of wine</li>
<li>a glass of milk</li>
</ul>
</li>
<li>bottle 瓶子<ul>
<li>an empty bottle</li>
<li>a bottle of champagne</li>
<li>I drank a whole bottle of wine last night.</li>
</ul>
</li>
<li>chopping board 案板<ul>
<li>I bought a new wooden chopping board.</li>
</ul>
</li>
<li>dish washer 洗碗机<ul>
<li>I have a dish washer in the kitchen, bu i never use it.</li>
</ul>
</li>
<li>detergent 洗涤剂<ul>
<li>Rinse the detergent from the dishes.</li>
</ul>
</li>
<li>trash can 垃圾桶<ul>
<li>Always put the trash in the trash can.</li>
</ul>
</li>
<li>broom 扫帚<ul>
<li>Bill is sweeping the floor with a broom.</li>
</ul>
</li>
<li>table 桌子<ul>
<li>a dinling table</li>
<li>Robbie, would you set the table?</li>
<li>I’ve booked a table for two for six o’clock.</li>
</ul>
</li>
<li>tea table 茶几<ul>
<li>There is a tea table and two chairs on my balcony.</li>
</ul>
</li>
<li>drawer 抽屉<ul>
<li>She took a file from her dest drawer.</li>
<li>I opened the drawer and took out a brown envelope.</li>
</ul>
</li>
<li>chair 椅子<ul>
<li>a table and chairs</li>
<li>a garden chair</li>
<li>I had to sit on a hard wooden chair all day.</li>
</ul>
</li>
<li>rocking chair 摇椅<ul>
<li>He was rocking himself in a rocking chair.</li>
</ul>
</li>
<li>couch 沙发<ul>
<li>I can sleep on the couch.</li>
<li>Annie was lying on the couch, eating candy.</li>
</ul>
</li>
<li>telephone 电话<ul>
<li>phone</li>
<li>The telephone rang just as  i was leaving.</li>
<li>Sally is <u>on the phone.</u></li>
<li><u>Answer the phone</u> </li>
</ul>
</li>
<li>cushion 垫子<ul>
<li>I like the cushions on you couch.</li>
</ul>
</li>
<li>ashtray 烟灰缸<ul>
<li>Drop you cigarette ashes into the ashtray.</li>
<li>The ashtray is full of cigarette ends.</li>
</ul>
</li>
<li>TV 电视<ul>
<li>television </li>
<li>What’s on TV tonight?</li>
<li>I watched the movie on TV.</li>
<li>I’m watching TV.</li>
<li>a TV show</li>
<li>a TV actor</li>
<li>a TV <strong>commercial</strong></li>
</ul>
</li>
<li>lamp 灯<ul>
<li>a streep lamp</li>
<li>a desk lamp</li>
<li>a bedside lamp</li>
</ul>
</li>
<li>light 灯<ul>
<li>The room was dark, so i <u>turned on the light</u>.</li>
<li>Don’t forget to <u>turn off the lights</u> before you go to bed.</li>
</ul>
</li>
<li>tissue 纸巾<ul>
<li>a box of tissues.</li>
<li>Pass me a tissue.</li>
</ul>
</li>
<li>vase 花瓶<ul>
<li>a china vase</li>
<li>a vase of roses</li>
</ul>
</li>
<li>air conditioner 空调<ul>
<li>I can’t sleep without an air conditioner in summer.</li>
</ul>
</li>
<li>remote control 遥控器<ul>
<li>Give me the remote control.</li>
</ul>
</li>
<li>fan 扇子，风扇<ul>
<li>a ceiling fan</li>
<li>It’s so hot. Please turn on the fan.</li>
</ul>
</li>
<li>computer 计算机，电脑<ul>
<li>computer games</li>
<li>the latest computer software</li>
<li>The information is stored <u>on computer.</u></li>
</ul>
</li>
<li>laptop 笔记本电脑<ul>
<li>He won’t let anyone touch his laptop.</li>
</ul>
</li>
<li>desktop 台式电脑<ul>
<li>I’m thinking about what to do with my desktop when i’m moving.</li>
</ul>
</li>
<li>keyboard 键盘<ul>
<li>Suan is a <u>keyboard operator</u>.</li>
</ul>
</li>
<li>mouse 鼠标<ul>
<li>a wireless mouse</li>
<li>a mouse mat</li>
<li>Click the right mouse button.</li>
</ul>
</li>
<li>desk 书桌<ul>
<li>an office desk</li>
<li>a school desk</li>
<li>Marie is sitting at her desk.</li>
</ul>
</li>
<li>clock 时钟<ul>
<li>My clock stopped.</li>
<li>I hreard the clock strike six.</li>
<li>Mary set her alarm clock for 6:30 am.</li>
</ul>
</li>
<li>bookcase 书柜<ul>
<li>Please put the books back into the bookcase.</li>
<li>My three large bookcases are full of books.</li>
</ul>
</li>
<li>book 书<ul>
<li>children’s books</li>
<li>paperback books</li>
<li>hardback books</li>
</ul>
</li>
<li>dictionary 字典<ul>
<li>an English-Chinese dictionary</li>
<li>a Chinese-English dictionary</li>
</ul>
</li>
<li>washing machine 洗衣机<ul>
<li>It’s easy to <u>do the laundry</u> these days. Just put the clothes in the washing machine.</li>
</ul>
</li>
<li>mirror 镜子<ul>
<li>Mirror mirrror on the wall, who is the fairest of them all.</li>
<li>He spends hours in front of the mirror!</li>
</ul>
</li>
<li>toothpaste 牙膏<ul>
<li>a tube of toothpase</li>
</ul>
</li>
<li>tooehbrush 牙刷<ul>
<li>Little Aaron can’t use a toothbrush yet.</li>
</ul>
</li>
<li>soap 肥皂<ul>
<li>a bar of soap</li>
<li>There’s no soap in the bathroom!</li>
</ul>
</li>
<li>cleanser 洗面奶<ul>
<li>I use cleanser every night.</li>
</ul>
</li>
<li>lotion 乳液<ul>
<li>body lotion</li>
<li>suntan lotion</li>
</ul>
</li>
<li>cream 乳，霜<ul>
<li>face cream</li>
<li>hand cream</li>
</ul>
</li>
<li>toner 爽肤水<ul>
<li>This kind of toner can make your skin very soft and smooth.</li>
</ul>
</li>
<li>facial mask 面膜<ul>
<li>After cleaning, unpack the facial mask and apply it gently on your face, remove it 2 minutes late.</li>
</ul>
</li>
<li>foundation 粉底<ul>
<li>Make sure your foundation is the same color as you skin.</li>
</ul>
</li>
<li>blusher 腮红<ul>
<li>Put on some blusher.</li>
</ul>
</li>
<li>eye shadow 眼影<ul>
<li>You shouldn’t use eye shadow at you age.</li>
</ul>
</li>
<li>lipstick 口红<ul>
<li>She is wearing red lipstick.</li>
<li>Check out my new lipstick.</li>
</ul>
</li>
<li>perfume 香水<ul>
<li>a bottle of perfume</li>
<li>French perfume</li>
<li>What perfume are you wearing?</li>
</ul>
</li>
<li>shampoo 洗发水<ul>
<li>a bottle of shampoo</li>
<li>Don’t use too much shampoo.</li>
<li>What kind of shampoo do you use?</li>
</ul>
</li>
<li>conditioner 护发素<ul>
<li>I always use conditioner after washing my hair.</li>
</ul>
</li>
<li>comb 梳子<ul>
<li>I need a <u>comb</u> to <u>comb</u> my hair.</li>
<li>I carry a comb with me whereever i go.</li>
</ul>
</li>
<li>bathtub 浴缸，澡盆<ul>
<li>Clean up the bathtub when  you are done.</li>
</ul>
</li>
<li>shower cap 浴帽<ul>
<li>I always wear a shower cap to keep my hair dry in the shower.</li>
</ul>
</li>
<li>shower curtain 浴帘<ul>
<li>I’m cleaning the shower curtain.</li>
</ul>
</li>
<li>bath mat 浴室防滑垫<ul>
<li>There is a bath mat beside the bathtub on floor.</li>
</ul>
</li>
<li>towel 毛巾<ul>
<li>Have you got a clean towel?</li>
<li>Give me a towel.</li>
</ul>
</li>
<li>toilet 马桶，卫生间<ul>
<li>He <u>flushed the toilet</u>.</li>
<li>Excuse me, where is the toilet?</li>
</ul>
</li>
<li>toilet paper 卫生纸，手纸<ul>
<li>a roll of toilet paper</li>
</ul>
</li>
<li>sheet 床单<ul>
<li>white sheet</li>
<li>I’ll go find you a clean sheet.</li>
<li>I’m going to change the sheets.</li>
</ul>
</li>
<li>blanket 毯子<ul>
<li>It’s too cold. I need another blanket.</li>
</ul>
</li>
<li>quilt 被子<ul>
<li>A blanket is not warm enough. You need quilt.</li>
</ul>
</li>
<li>pillow 枕头<ul>
<li>a pillow <u>fight</u></li>
<li>I fell asleep as soon as my head hit the pillow.</li>
</ul>
</li>
<li>mattress 床垫<ul>
<li>I don’t like the hotel. Last time i got a <u>lumpu mattress</u>.</li>
</ul>
</li>
<li>mat 垫子<ul>
<li>a door mat</li>
<li>a bath mat</li>
<li>a yoga mat</li>
<li>Wipe your feet on the mat.</li>
</ul>
</li>
<li>carpet 地毯<ul>
<li>red carpet</li>
<li>lay a carpet</li>
<li>My bedroom carpet is dark green.</li>
</ul>
</li>
<li>rug 小块地毯<ul>
<li>I like sitting on the rug in front of the fireplace.</li>
</ul>
</li>
<li>vacuum cleaner 吸尘器<ul>
<li>I could hear the whirr of a vacuum cleaner.</li>
</ul>
</li>
<li>string 细绳，线<ul>
<li>He wrapped the package in brown paeer and tied with string.</li>
<li>a puppet on strings.</li>
</ul>
</li>
<li>tape 胶带<ul>
<li>a roll of tape</li>
<li>I stuck the note to the door with tape.</li>
</ul>
</li>
<li>iron 熨斗<ul>
<li>a steam iron</li>
<li>I need an iron to iron my dress.</li>
</ul>
</li>
<li>needle 针<ul>
<li>a needle and thread</li>
<li>Could you thread this needle for me.</li>
</ul>
</li>
<li>thread 线<ul>
<li>I’m looking for a needle and thread.</li>
<li>gold thread</li>
<li>sliver thread</li>
</ul>
</li>
<li>button 纽扣，按钮<ul>
<li>A button was missing from his shirt.</li>
<li>Press the ‘play’ button.</li>
</ul>
</li>
<li>zipper 拉链<ul>
<li>The zipper doesn’t look good.</li>
<li>I can’t open my bag - the zipper has stuck</li>
</ul>
</li>
<li>lighter 打火机<ul>
<li>Do you have a lighter?</li>
</ul>
</li>
<li>torch 手电筒，火炬<ul>
<li>flashlight 手电筒</li>
<li>Take a torch.  It’s dark outside.</li>
<li>the Olympic torch</li>
</ul>
</li>
<li>bulb 电灯泡<ul>
<li>I’ve never changed a buld.</li>
<li>a 60-watt bulb</li>
</ul>
</li>
<li>battery 电池<ul>
<li>The torch needs two batteries.</li>
<li>When the red light is on, you should chage batteries.</li>
</ul>
</li>
<li>lock 锁<ul>
<li>There isn’t a lock on the bathroom door.</li>
<li>He slowly turned the key in the lock.</li>
</ul>
</li>
<li>key 钥匙<ul>
<li>the car keys</li>
<li>a bunch of keys</li>
<li>the key to the front door</li>
<li>the spare key to the front door</li>
</ul>
</li>
<li>watch 表<ul>
<li>a pocket watch</li>
<li>a wrist watch</li>
<li>My watch is five minutes fast.</li>
<li>My watch is five minutes slow.</li>
</ul>
</li>
<li>backpack 背包<ul>
<li>I want to take my backpack and go on a trip alone.</li>
</ul>
</li>
<li>handbag 手提包<ul>
<li>purse</li>
<li>She carried a green leather hadnbag.</li>
<li>I bought a new handbag.</li>
</ul>
</li>
<li>suitcase 衣箱<ul>
<li>Have you packed you suitcase yet?</li>
<li>Could you keep an eye on my suitcase for a moment, please.</li>
</ul>
</li>
<li>jewel 珠宝<ul>
<li>precious jewels</li>
<li>She loves wearing priceless jewels.</li>
</ul>
</li>
<li>jewel case 珠宝盒<ul>
<li>There are many beautiful jewels in her jewel case.</li>
<li>She opened her jewel case and said: ‘Pick one’.</li>
</ul>
</li>
<li>ring 戒指<ul>
<li>a diamond ring</li>
<li>an engagement ring</li>
<li>a wedding ring</li>
</ul>
</li>
<li>earring 耳环<ul>
<li>gold errring</li>
<li>She was wearing a pair of beautiful diamond earrings.</li>
</ul>
</li>
<li>necklace 项链<ul>
<li>a peral necklace</li>
<li>a gold necklace</li>
<li>That necklace you borrowed from me wasn’t diamond necklace.</li>
</ul>
</li>
<li>bracelet 手镯，手链<ul>
<li>a gold bracelet</li>
<li>He bought her a new bracelet.</li>
</ul>
</li>
<li>brooch 胸针<ul>
<li>Excuse me, could you tell me how much this brooch costs?</li>
<li>She is wearing a gold brooch.</li>
</ul>
</li>
<li>pearl 珍珠<ul>
<li>a string of pearls</li>
<li>a peral necklace</li>
<li>Pearl Harbor</li>
</ul>
</li>
<li>diamond 钻石<ul>
<li>a diamond ring</li>
<li>a diamond necklace</li>
</ul>
</li>
<li>jade 玉，翡翠<ul>
<li>a jade vase</li>
<li>a jade necklace</li>
</ul>
</li>
<li>crib 婴儿床<ul>
<li>The baby is sleeping quietly in his crib.</li>
</ul>
</li>
<li>cradle 摇篮，发源地<ul>
<li>The mother rocked the baby to sleep in its cradle.</li>
<li>Greece, the cradle of Western culture.</li>
</ul>
</li>
<li>diaper 纸尿裤<ul>
<li>She was changing the baby’s diaper.</li>
<li>I knew William when he was still in diaper.</li>
</ul>
</li>
<li>stroller 婴儿车<ul>
<li>I saw her pushing a stroller down the street.</li>
<li>The baby was trying to get out of the stroller.</li>
</ul>
</li>
<li>razor 剃须刀<ul>
<li>an electric razor</li>
<li>a disposable razor</li>
</ul>
</li>
<li>umbrella 伞，雨伞<ul>
<li>a folding umbrella</li>
<li>put up an umbrella</li>
<li>take down an umbrella</li>
<li>Take an umbrella with you, in case it rains.</li>
<li>It started to rain, so i put up my umbrella.</li>
<li>The rain stopped, so i took down my umbrella.</li>
</ul>
</li>
<li>sun umbrella 太阳伞<ul>
<li>Chinese girls usually carry sun umbrellas in summer.</li>
</ul>
</li>
<li>stationery 文具<ul>
<li>I must go to the stationer’s to get some stationary.</li>
</ul>
</li>
<li>paper 纸，报纸<ul>
<li>a piece of paper</li>
<li>a sheet of paper</li>
<li>writing paper</li>
</ul>
</li>
<li>a paper bag<ul>
<li>I wrote down her phone number on a piece of apper.</li>
<li>Have you seen today’s paper?</li>
</ul>
</li>
<li>pen 笔，钢笔<ul>
<li>Do you have a pen and paper?</li>
<li>Please fill out the form in pen.</li>
<li>pen name</li>
<li>pen pal</li>
</ul>
</li>
<li>pencil 铅笔<ul>
<li>a sharp pencil</li>
<li>a box of coloured pencils</li>
<li>a note written in pencil</li>
</ul>
</li>
<li>ruler 尺子<ul>
<li>Do you have a ruler?</li>
</ul>
</li>
<li>eraser 橡皮，板擦<ul>
<li>May i borrow your erase?</li>
<li>If you write in pencil, you can always rub out your mistakes with an earser?</li>
</ul>
</li>
<li>glue 胶水<ul>
<li>a tube of glue</li>
<li>He sticks to her like glue.</li>
</ul>
</li>
<li>toy 玩具<ul>
<li>Annice was playing happily with her toys.</li>
<li>Put your toys away now - it’s time for bed.</li>
<li>Leave daddy’s camera alone - it isn’t a toy!</li>
</ul>
</li>
<li>bag 袋，包<ul>
<li>a paper bag</li>
<li>a plastic bag</li>
<li>a garbage bag</li>
<li>a shoppng bag</li>
</ul>
</li>
<li>box 盒子，箱子<ul>
<li>a tool box</li>
<li>a cardboard box</li>
<li>a box of chocolates</li>
<li>black box</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>名词-食物</title>
    <url>/2020/04/03/Language/English/New%20Concept/Word/Noun/Foods/</url>
    <content><![CDATA[<p>食物的一些名词</p>
<a id="more"></a>
<ul>
<li>food 食物<ul>
<li>Everyone needs food.</li>
<li>Fast food.</li>
<li>Junk food.</li>
</ul>
</li>
<li>fruit 水果<ul>
<li>Try to eat plenty of fresh furit.</li>
<li>Fruit and vegetables.</li>
<li>Fruit juice.</li>
</ul>
</li>
<li>apple 苹果<ul>
<li>apple pie.</li>
<li>an apple tree.</li>
<li>An apple a day keeps the doctor away.</li>
</ul>
</li>
<li>pear 梨<ul>
<li>I like apples , but not pears.</li>
</ul>
</li>
<li>peach 桃子<ul>
<li>I like fresh juicy peaches.</li>
</ul>
</li>
<li>banana 香蕉<ul>
<li>a bunch of bananas.</li>
<li>Look! The monkey is eating a banana.</li>
</ul>
</li>
<li>orange 柑橘，橙子<ul>
<li>orange juice</li>
<li>Peel the oranges.</li>
</ul>
</li>
<li>cherry 樱桃<ul>
<li>a cherry tree.</li>
<li>There is a cherry on the cake.</li>
</ul>
</li>
<li>strawberry 草莓<ul>
<li>The strawberry is my favorite fruit.</li>
</ul>
</li>
<li>blueberry 蓝莓<ul>
<li>blueberry pie</li>
<li>The blueberry is good for your eyes.</li>
</ul>
</li>
<li>lemon 柠檬<ul>
<li>a lemon tree</li>
<li>a slice of lemon</li>
</ul>
</li>
<li>lemonage 柠檬水</li>
<li>mango 芒果<ul>
<li>Some people are allergic（过敏） to mango.</li>
</ul>
</li>
<li>pineapple 菠萝<ul>
<li>pineapple juice</li>
</ul>
</li>
<li>grape 葡萄<ul>
<li>a bunch of grapes.</li>
<li>seedless grapes.</li>
</ul>
</li>
<li>plum 李子<ul>
<li>juicy ripe plums</li>
<li>a plum tree</li>
</ul>
</li>
<li>kiwi fruit 猕猴桃<ul>
<li>Kiwi fruit is rich in vitamin C.</li>
</ul>
</li>
<li>druian 榴莲<ul>
<li>I can’t bear the smell of a durain.</li>
</ul>
</li>
<li>coconut 椰子<ul>
<li>coconut mile 椰奶</li>
<li>I was hit by a coconut when i was sitting under a coconut palm.</li>
</ul>
</li>
<li>papaya 木瓜</li>
<li>pawpaw 木瓜<ul>
<li>pawpaw ointment 木瓜粥</li>
</ul>
</li>
<li>pomegranate 石榴<ul>
<li>pomegranate juice</li>
<li>pomegranate seeds</li>
</ul>
</li>
<li>persimmon 柿子<ul>
<li>A persimmon is a soft sweet fruit that looks like a large orange-colored tomata and grows on a persimmon tree.</li>
</ul>
</li>
<li>watermelon 西瓜<ul>
<li>In summer, out main fruit is watermelon.</li>
<li>Of all the fruits, I like watermelon most.</li>
</ul>
</li>
<li>lychee 荔枝<ul>
<li>We all know that Princess Yang Kwei-fei liked lychees.</li>
</ul>
</li>
<li>vegetable 蔬菜<ul>
<li>green vegetables</li>
<li>organic（有机） vegetables</li>
<li>You should eat more fruit and vegetables.</li>
</ul>
</li>
<li>tomato 西红柿<ul>
<li>tomato soup</li>
<li>Is the tomato a fruit or vegetables?</li>
<li>The tomato is a round soft read fruit <strong>eaten raw</strong>（生吃） or cooked as a vegetable.</li>
</ul>
</li>
<li>ketchup 番茄酱<ul>
<li>a bottle of ketchup</li>
<li>Do you want some ketchup with you hamburger?</li>
</ul>
</li>
<li>potato 土豆<ul>
<li>potato soup</li>
<li>Marie is pelling potatoes.</li>
<li>mashed potatoes.</li>
</ul>
</li>
<li>sweet potato 红薯<ul>
<li>A sweet potato is sweeter than a potato.</li>
</ul>
</li>
<li>cabbage 卷心菜<ul>
<li>Do you like cabbage?</li>
<li>Chinese cabbage.</li>
</ul>
</li>
<li>cucumber 黄瓜<ul>
<li>Have some cucumber.</li>
<li>cucumber salad.</li>
<li>sea cucumber 海参</li>
</ul>
</li>
<li>celery 芹菜<ul>
<li>a stick of celery.</li>
<li>I dont’t like eating celery. It’s like eating grass.</li>
</ul>
</li>
<li>leek 韭菜<ul>
<li>A leek tastes like an onion.</li>
</ul>
</li>
<li>carrot 胡萝卜<ul>
<li>carrot juice</li>
<li>Have some carrot.</li>
<li>We are like peas and carrots.</li>
</ul>
</li>
<li>pea 豌豆<ul>
<li>The twins are like two peas in a pod.</li>
<li>The Princess and the Pea.</li>
</ul>
</li>
<li>radish 萝卜<ul>
<li>I don’t like radished. Most of them are spicy.</li>
</ul>
</li>
<li>spinach 菠菜<ul>
<li>Popeye loves spinach.</li>
<li>spinach soup.</li>
</ul>
</li>
<li>mushroom 蘑菇<ul>
<li>wild mushroom</li>
<li>Some types of mushrooms are poisonous.</li>
</ul>
</li>
<li>eggplant 茄子<ul>
<li>My husband likes eggplant no matter how it cooked.</li>
</ul>
</li>
<li>bean 豆子<ul>
<li>soya beans.</li>
<li>bean curd.</li>
<li>Jack and the Beanstalk.</li>
</ul>
</li>
<li>pumpkin 南瓜<ul>
<li>pumpkin pie</li>
<li>pumpkin lanterns</li>
</ul>
</li>
<li>green pepper 青椒<ul>
<li>sharedded beef with green pepper.</li>
</ul>
</li>
<li>lettuce 生菜<ul>
<li>a lettuce and tomato salad.</li>
</ul>
</li>
<li>onion 洋葱<ul>
<li>I alaways cry when I’m chopping oinions.</li>
<li>There is too much onion is the salad.</li>
</ul>
</li>
<li>lotus root 莲藕<ul>
<li>Sister lotus</li>
</ul>
</li>
<li>noodle 面条<ul>
<li>egg noodles</li>
<li>instant noodles</li>
</ul>
</li>
<li>pasta 意大利面<ul>
<li>Every time i eat pasta, i eat a lot.</li>
</ul>
</li>
<li>rice 米，米饭<ul>
<li>rice fields</li>
<li>I like noodles more than rice.</li>
</ul>
</li>
<li>corn 玉米，谷物<ul>
<li>All their chickens are fed on corn.</li>
</ul>
</li>
<li>popcorn 爆米花<ul>
<li>It doesn’t feel like a moive without popcorn.</li>
</ul>
</li>
<li>sandwich 三明治<ul>
<li>a ham sandwich</li>
<li>He usually just has a sandwich for lunch.</li>
</ul>
</li>
<li>ham 火腿<ul>
<li>a slice of ham.</li>
</ul>
</li>
<li>sauasge 香肠<ul>
<li>garlic sausage.</li>
<li>pork sausage.</li>
</ul>
</li>
<li>bread 面包<ul>
<li>a slice of bread.</li>
<li>a loaf of bread.</li>
<li>bread and butter.</li>
</ul>
</li>
<li>steamed bread 馒头<ul>
<li>My dad eats steamed bread every day.</li>
</ul>
</li>
<li>biscuit 饼干<ul>
<li>chocolate biscuits.</li>
<li>a packet of biscuits.</li>
<li>We had tea and biscuits.</li>
</ul>
</li>
<li>cookie 曲奇，饼干<ul>
<li>I had a glass of mile and a cookie for breakfasf.</li>
<li>Don’t eat my cookie.</li>
</ul>
</li>
<li>dessert 餐后甜点<ul>
<li>Shall we move on to dessert?</li>
<li>I forgot to prepare dessert, so we had ice-cream.</li>
</ul>
</li>
<li>candy 糖果<ul>
<li>a candy shop</li>
<li>a box of candy</li>
<li>You had too much candy today.</li>
</ul>
</li>
<li>cake 蛋糕<ul>
<li>birthday cake</li>
<li>chocolate cake</li>
<li>fruit cake</li>
</ul>
</li>
<li>pizza 比萨饼<ul>
<li>Would you like some more pizza?</li>
<li>a slice of pizza.</li>
</ul>
</li>
<li>hamburger 汉堡包<ul>
<li>I hate eating hamburgers. I’d rather be hungry.</li>
</ul>
</li>
<li>French fries 炸薯条<ul>
<li>I usually have French fries with ketchup.</li>
</ul>
</li>
<li>potato chips 薯片<ul>
<li>When i feel blue, i like eating a lot of potato chips.</li>
</ul>
</li>
<li>flour 面粉<ul>
<li>I was busy mixing water and flour.</li>
</ul>
</li>
<li>oat 燕麦<ul>
<li>oat biscuits.</li>
<li>oatmeal</li>
</ul>
</li>
<li>butter 黄油<ul>
<li>bread and butter</li>
<li>Should i use oil or butter for frying the onions.</li>
</ul>
</li>
<li>cheese 奶酪<ul>
<li>a piece of cheese</li>
<li>a cheese sandwich</li>
<li>Say ‘cheese’!</li>
</ul>
</li>
<li>soup 汤<ul>
<li>vegetable soup</li>
<li>Chicken Soup for the Soul.</li>
<li>Would you like a bowl of soup?</li>
</ul>
</li>
<li>dumpling 饺子<ul>
<li>I miss the dumplings that my mom makes.</li>
</ul>
</li>
<li>salad 沙拉<ul>
<li>fruit salad</li>
<li>potato salad</li>
<li>Would you like some salad with you paste?</li>
</ul>
</li>
<li>egg 鸡蛋<ul>
<li>fresh eggs</li>
<li>fried eggs</li>
<li>I don’t like boiled eggs.</li>
</ul>
</li>
<li>meat 肉<ul>
<li>fresh meat</li>
<li>frozen meat</li>
<li>I gave up eating meat a few months ago.</li>
</ul>
</li>
<li>pork 猪肉<ul>
<li>portk sausages</li>
<li>pork chops</li>
</ul>
</li>
<li>beef 牛肉<ul>
<li>a beef sandwich</li>
<li>roast beef</li>
</ul>
</li>
<li>steak 牛排<ul>
<li>How would you like you steak cooked?</li>
<li>I’d like my steak rare.</li>
</ul>
</li>
<li>rare 三分熟</li>
<li>medium rare 四分熟</li>
<li>medium 五分熟</li>
<li>medium well 七八分熟</li>
<li>well-done 全熟</li>
<li>mutton 羊肉<ul>
<li>I perfer mutton to beef.</li>
</ul>
</li>
<li>lamb 羔羊肉<ul>
<li>lamb chops</li>
</ul>
</li>
<li>chicken 鸡肉<ul>
<li>chicken soup</li>
<li>fried chicken</li>
</ul>
</li>
<li>fish 鱼肉<ul>
<li>fresh fish</li>
<li>frozen fish</li>
<li>smoked fish</li>
</ul>
</li>
<li>vinegar 醋<ul>
<li>Would you like some vinegar with you dumplings?</li>
</ul>
</li>
<li>soy sauce 酱油<ul>
<li>Would you pass me the soy sauce?</li>
</ul>
</li>
<li>jam 果酱<ul>
<li>strawberry jam</li>
<li>a jar of jam</li>
</ul>
</li>
<li>salt 盐<ul>
<li>table salt</li>
<li>There is too much salt in the soup.</li>
</ul>
</li>
<li>sugar 糖<ul>
<li>white sugar</li>
<li>brown sugar</li>
<li>Dont’t eat too much sugar.</li>
</ul>
</li>
<li>oil 油<ul>
<li>cooking oil</li>
<li>olive oil</li>
<li>sunflower oil</li>
</ul>
</li>
<li>pepper 胡椒粉<ul>
<li>You can put some salt and papper in you soup if you like.</li>
</ul>
</li>
<li>ginger 姜<ul>
<li>ginger ale</li>
</ul>
</li>
<li>garlic 大蒜<ul>
<li>a clove of garlic</li>
</ul>
</li>
<li>spring onion 大葱<ul>
<li>I just hate the smell of spring onion and garlic.</li>
</ul>
</li>
<li>nut 坚果<ul>
<li>a pine nut</li>
<li>We were sitting around the fireplace cracking nuts.</li>
</ul>
</li>
<li>peanut 花生<ul>
<li>peanut oil</li>
<li>peanut butter</li>
</ul>
</li>
<li>chestnut 栗子<ul>
<li>A man in the street is selling roast chestnuts.</li>
<li>chestnut cake</li>
</ul>
</li>
<li>sesame 芝麻<ul>
<li>sesame seeds</li>
<li>sesame oil</li>
<li>open sesame</li>
</ul>
</li>
<li>chocolate 巧克力<ul>
<li>a bar of chocolate</li>
<li>a box of chocolate</li>
<li>Life is like a box of chocolate</li>
<li>dark chocolate</li>
<li>chocolate mousse</li>
<li>Would you like a chocolate?</li>
<li>I’ll have a hot chocolate, please.</li>
</ul>
</li>
<li>beverage 饮料<ul>
<li>foods and beverages</li>
<li>Hot beberages include tea, coffee and hot chocolate.</li>
</ul>
</li>
<li>milk 牛奶<ul>
<li>a bottle of mile</li>
<li>Would you like some milk in you tea?</li>
<li>breast milk.</li>
</ul>
</li>
<li>yoghurt 酸奶<ul>
<li>plain yoghurt</li>
<li>strawberry yoghurt</li>
<li>low-fat yoghurt</li>
</ul>
</li>
<li>wine 葡萄酒，果酒<ul>
<li>red wine</li>
<li>white wine</li>
<li>I love Australian wines.</li>
<li>Would you like to see the wine list, sir?</li>
</ul>
</li>
<li>champagne 香槟酒<ul>
<li>a glass of champagne</li>
<li>They celebrated their wedding anniversary with a bottle of champagne.</li>
</ul>
</li>
<li>beer 啤酒<ul>
<li>My brother has every dinner with beer.</li>
<li>Two beers, please.</li>
</ul>
</li>
<li>juice 果汁<ul>
<li>tomato juice</li>
<li>orange juice</li>
<li>apple juice</li>
</ul>
</li>
<li>tea 茶<ul>
<li>lemon tea</li>
<li>iced tea</li>
<li>Shall i make tea?</li>
<li>Would you like some tea?</li>
<li>I’d love a cup of tea, please.</li>
<li>How about a nice cup of tea? That’ll make you feel better.</li>
<li>afternoon tea</li>
</ul>
</li>
<li>coffee 咖啡<ul>
<li>coffee bean</li>
<li>coffee house</li>
<li>instant coffee</li>
<li>I’ll make some coffee.</li>
<li>Do you like your coffee white or black?</li>
<li>Two coffees, to go, please.</li>
</ul>
</li>
<li>water 水<ul>
<li>running water</li>
<li>drinking water</li>
<li>Fish live in water.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>名词-动物</title>
    <url>/2020/04/01/Language/English/New%20Concept/Word/Noun/Animals/</url>
    <content><![CDATA[<p>动物的一些名词</p>
<a id="more"></a>
<ul>
<li>dog 狗<ul>
<li>I love dogs;</li>
<li>Dogs are man’s best friends;</li>
<li>The dog is very cude;</li>
</ul>
</li>
<li>cat 猫<ul>
<li>I have a cat , the cat is white.</li>
<li>The cat likes sleeping.</li>
</ul>
</li>
<li>puppy 小狗</li>
<li>doggie 小狗</li>
<li>kitty 小猫</li>
<li>rooster 公鸡<ul>
<li>It’s hard to see a rooster in bi cities.</li>
<li>I saw a rooster this morning.</li>
<li>The rooaster is dead.</li>
</ul>
</li>
<li>hen 母鸡<ul>
<li>My sister keeps a few hens.</li>
<li>The hens lay eggs every day.</li>
<li>The eggs laid by these haes taste yummy.</li>
</ul>
</li>
<li>chicken 小鸡，鸡肉<ul>
<li>The chickens are very cute.</li>
<li>My son likes the chickens very much.</li>
<li>My friends gave me three chickens last week.</li>
</ul>
</li>
<li>duck 鸭子<ul>
<li>Peking Roast Duck</li>
</ul>
</li>
<li>duckling 小鸭子<ul>
<li>The ugly duckling.</li>
</ul>
</li>
<li>goose 鹅  复数：geese<ul>
<li>a goose is bigge than a duck.</li>
</ul>
</li>
<li>pig 猪<ul>
<li>He keeps pigs.I don’t like pigs.</li>
<li>You a such a pi.</li>
</ul>
</li>
<li>piggy 小猪</li>
<li>piggy bank 储蓄罐</li>
<li>cow 奶牛，母牛<ul>
<li>She is milking the cow.</li>
</ul>
</li>
<li>cowboy 西部牛仔，牧童</li>
<li>bull 公牛</li>
<li>horse 马<ul>
<li>I have never ridden a horse before.</li>
<li>I’s so hangry! I could eat a horse.</li>
<li>A horse race.</li>
</ul>
</li>
<li>donkey 驴<ul>
<li>I’ve never seen a donkey before.</li>
<li>you stupid a donkey.</li>
</ul>
</li>
<li>sheep 绵羊<ul>
<li>He is a sheep farmer.</li>
<li>A black sheep.</li>
</ul>
</li>
<li>goat 山羊<ul>
<li>Goat’s milk</li>
<li>Let me go ! You old goat.</li>
</ul>
</li>
<li>lamb 羊羔</li>
<li>lion 狮子<ul>
<li>Mark is as brave as a lion.</li>
</ul>
</li>
<li>lioness 母狮子</li>
<li>tiger 老虎<ul>
<li>I saw two tigers in the zoo today.</li>
<li>A paper tiger.</li>
</ul>
</li>
<li>tigress 母老虎</li>
<li>leopard 豹<ul>
<li>A leopard can’t change its spots.</li>
<li>Wanna see me be leopard.</li>
</ul>
</li>
<li>wolf 狼<ul>
<li>He is a wolf in sheeps clothiing.</li>
</ul>
</li>
<li>Wolf Totem 狼图腾</li>
<li>zebra 斑马<ul>
<li>Looking! There is a zebre .</li>
<li>Zebra crossing.</li>
</ul>
</li>
<li>bear 熊<ul>
<li>bear marker.</li>
<li>He gave me a bear-hug.</li>
</ul>
</li>
<li>polar bear 北极熊</li>
<li>panda</li>
<li>giant panda<ul>
<li>The panda is a national treasure of China.</li>
</ul>
</li>
<li>camel 骆驼<ul>
<li>Camels live in desserts.</li>
</ul>
</li>
<li>deer 鹿  复数 deer<ul>
<li>The deer eating grass.</li>
</ul>
</li>
<li>giraffe 长颈鹿<ul>
<li>A giraffe has a very long neck</li>
</ul>
</li>
<li>elephant 大象<ul>
<li>You can see many elephant in Thailand.</li>
<li>A white elephant.</li>
</ul>
</li>
<li>fox 狐狸<ul>
<li>Julie is as sly as a fox.</li>
<li>I don’t like that sly old fox.</li>
</ul>
</li>
<li>kangraoo 蜥蜴<ul>
<li>Kangraoo are found in Australia.</li>
</ul>
</li>
<li>koala 考拉<ul>
<li>I love koalas! They are just so cute!.</li>
</ul>
</li>
<li>ostrich 鸵鸟<ul>
<li>An ostrich can’t fly. but it can run vary fast.</li>
</ul>
</li>
<li>rabbit 兔子<ul>
<li>Bob keeps a rabbit as a pet.</li>
</ul>
</li>
<li>snake  蛇<ul>
<li>I am scared of snakes.</li>
<li>Steve wa bitten by a snake.</li>
<li>Stay awar from him. He is a snake.</li>
</ul>
</li>
<li>mouse 老鼠 鼠标  复数:mice<ul>
<li>Mickey Mouse</li>
<li>a mouse mat</li>
</ul>
</li>
<li>squirrel 松鼠<ul>
<li>Squirrels like eating nuts.</li>
<li>The squirrel in the movie <strong>Ice Age</strong> is very funny;</li>
</ul>
</li>
<li>monkey 猴子，顽皮的儿童<ul>
<li>Look at the monkey! It’s climbing up the tree so fast!</li>
<li>Stop that, you little monkey!</li>
</ul>
</li>
<li>turkey 火鸡，火鸡肉<ul>
<li>roast turkey</li>
<li>People eat turkey on Thanks-giving Day.</li>
</ul>
</li>
<li>lizard 蜥蜴<ul>
<li>A lizard is a reptile with shor legs and a long tail.</li>
</ul>
</li>
<li>penguin 企鹅<ul>
<li>A penguin is a type of sea bird. It can not fly but it can swim.</li>
</ul>
</li>
<li>swan 天鹅<ul>
<li>She is as graceful as a swan.</li>
<li>Swan Lake.</li>
</ul>
</li>
<li>frog 青蛙<ul>
<li>The Frog Prince</li>
</ul>
</li>
<li>frogman 蛙人，潜水员</li>
<li>crocodile 鳄鱼，鳄鱼皮<ul>
<li>A crocodile handbag</li>
<li>Crocodile tears</li>
</ul>
</li>
<li>rhinoceros(rhino) 犀牛</li>
<li>hippopotamus(hippo) 河马</li>
<li>gorilla 大猩猩<ul>
<li>A gorilla is very large ape(猿)</li>
</ul>
</li>
<li>peacock 孔雀<ul>
<li>Peter is as proud as a peacock.</li>
<li>Peacoke is blue.</li>
</ul>
</li>
<li>dinosaur 恐龙<ul>
<li>Boys usually like dinosaurs.</li>
<li>If you want to see dinosayrs, go to Beijing Museum of Natural History.</li>
</ul>
</li>
<li>ant 蚂蚁<ul>
<li>Ants live in large groups.</li>
<li>I hate to see ants in my house.</li>
</ul>
</li>
<li>spider 蜘蛛<ul>
<li>Many grils are afraid of spiders.</li>
</ul>
</li>
<li>Sipder-Man 蜘蛛侠</li>
<li>snail 蜗牛<ul>
<li>The snail came out of its shell.</li>
<li>The old woman crossed the street at a snail’s pace.</li>
</ul>
</li>
<li>cockroach 蟑螂<ul>
<li>I hate cockroaches. They are so disgusting.</li>
</ul>
</li>
<li>brid 鸟<ul>
<li>The early bird catches the worm.</li>
<li>You are an eraly bird.</li>
<li><strong>A little bird told me</strong> that you’ve got engaged（订婚）.</li>
</ul>
</li>
<li>parrot 鹦鹉<ul>
<li>I have a parrot named Henry.</li>
<li>The parrot can say ‘good morning’ and ‘Good night’.</li>
</ul>
</li>
<li>magpie 喜鹊，爱收集或贮藏东西的人<ul>
<li>Magpies are common birds in China.</li>
<li>She is quite a magpie.</li>
</ul>
</li>
<li>sparrow 麻雀<ul>
<li>There are serveral sparrows twittering outside my window.</li>
</ul>
</li>
<li>swallow 燕子<ul>
<li>One swallow does not make a summer.</li>
</ul>
</li>
<li>dove 鸽子</li>
<li>crow 乌鸦<ul>
<li>She thinks something bad is going to happen bacause she saw a crow this morning.</li>
</ul>
</li>
<li>owl 猫头鹰<ul>
<li>An owl ususlly sleeps with on eye open and the other closed.</li>
<li>A night owl.</li>
</ul>
</li>
<li>eagle 鹰<ul>
<li>An eagle is flying in the sky.</li>
<li>The teacher’s egale eye was always on us.</li>
<li>Hotel California  — Eagles</li>
</ul>
</li>
<li>bee 蜜蜂<ul>
<li>John is as busy as a bee.</li>
<li>I was stung（叮咬） by a bee.</li>
</ul>
</li>
<li>bumblebee 大黄蜂</li>
<li>dragonfly 蜻蜓</li>
<li>dragon 龙</li>
<li>butterfly 蝴蝶<ul>
<li>I saw many beautiful butterflies in Melbon Zoo.</li>
<li>The Butterfly Effect</li>
</ul>
</li>
<li>fly 苍蝇<ul>
<li>Is summer you can see many flies near the river.</li>
<li>My dog wouldn’t hurt a fly.</li>
</ul>
</li>
<li>mosquito 蚊子<ul>
<li>I was bitten by a mosquito.</li>
<li>There is one thing i don’t like about summer too many mosquitoes.</li>
</ul>
</li>
<li>bat 蝙蝠<ul>
<li>A bat can fly around at night.</li>
</ul>
</li>
<li>Batman</li>
<li>seagull 海鸥</li>
<li>fish 鱼 复数：fish<ul>
<li>fish and chips</li>
<li>A big fish in a little pond.</li>
<li>A cold fish.</li>
</ul>
</li>
<li>tuna 金枪鱼<ul>
<li>tuna fish sandwich</li>
</ul>
</li>
<li>dolphin 海豚<ul>
<li>a dolphin show</li>
<li>The dolphin is a smart animal.</li>
</ul>
</li>
<li>whale 鲸<ul>
<li>The whale is not a fish.</li>
<li>The whale is a kind of mamal.</li>
</ul>
</li>
<li>seal 海豹<ul>
<li>Do you know a sea lion is a large type of seal?</li>
</ul>
</li>
<li>sea lion 海狮<ul>
<li>There are sea lions and dolphins in Beijing Oceanarium.</li>
</ul>
</li>
<li>sea horse 海马<ul>
<li>A sea horse has a head that looks like the head of a horse.</li>
</ul>
</li>
<li>turtle 海龟</li>
<li>tortoise 陆龟<ul>
<li>That tortoise is fifty years old , but it looks small.</li>
</ul>
</li>
<li>shrimp 小虾<ul>
<li>Do you know a shrimp has ten legs?</li>
</ul>
</li>
<li>lobster 龙虾<ul>
<li>I bought several live lobsters. They are so expensive.</li>
</ul>
</li>
<li>crab 蟹<ul>
<li>Don’t touch the crab! It has two powerful claws.</li>
</ul>
</li>
<li>jellyfish 水母<ul>
<li>A jellyfish is swimming after you.</li>
<li>I can see thougn the jellyfish . It’s so funny.</li>
</ul>
</li>
<li>startfish 海星 复数 starfish<ul>
<li>I found a starfish on the beach.</li>
</ul>
</li>
<li>squid 鱿鱼，乌贼<ul>
<li>I’ve never seen a live squid before.</li>
</ul>
</li>
<li>walrus 海象<ul>
<li>A walrus also has two long teeth called tusks.</li>
</ul>
</li>
<li>shark 鲨鱼<ul>
<li>a great white shark.</li>
<li>The move <strong>Jaws</strong> is about a man-eating shark.</li>
</ul>
</li>
<li>octopus 章鱼<ul>
<li>There was an amazing octopus during the World Cup in 2010.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
  </entry>
  <entry>
    <title>回京</title>
    <url>/2020/03/24/Essay/2020/%E5%9B%9E%E4%BA%AC/</url>
    <content><![CDATA[<p>出发前，我妈非拉着我们拍了个抖音，配合着音乐又是哭又是唱，在我哥我爸的捣乱下，拍了两遍才杀青。等我到了车站候车的时候，手机响了，我以为是问我火车到了没。我猜对了，问了问我：火车到了么？还没到？你赶紧出来，你妈的抖音不小心删了，出来再补拍一个。。。拉着我拍完之后，挥了挥手，你走吧。。。我想，家里人应该是故意的吧，故意这样做，让离别的情景不那么伤感。</p><a id="more"></a>
<p>出发。看着故乡，不知道自己为了什么，要去远方。自己真的是有那么努力么？可能只是在随波逐流罢了。</p>
<p>听说高铁是隔开坐，我想，绿皮火车应该也是。上车才发现，只是不卖上铺的票了。卧铺差不多是满载。途中，人人都带着口罩，还有带着防护手套的，感觉一个个精神都很紧张，我只是口罩不舒服抽了几下鼻子，周围人们的脑袋刷的一下全扭过来了，至于么。。。</p>
<p>一晚未眠。</p>
<p>霍营下车的时候，看到日出了，想到一句诗：日出江花红胜火。</p>
<p>回到住处，二房东直接把门从外面反锁。。。看来14天连外卖都不能点。</p>
<p>一路回答问题，处理问题。本来想休息会，结果，事情压着，还是工作吧，工作完了睡得才能更香不是么。困啊，困怎么办，早晨7点到晚上7点，抽了半盒的烟，我觉得我应该买个保险。</p>
<p>想家。</p>
<p>睡前看了会今日头条，有篇文章叫做：我们没有见过市面的父母。看的我一把鼻涕一把泪。得好好规划一下，未来几年的路怎么走。未来，何去何从？</p>
<p>希望时光，你能慢点走。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Emmmm.......</title>
    <url>/2020/03/13/Essay/2020/Emmm/</url>
    <content><![CDATA[<p>很烦躁</p><p>工作的活实在是太多了，在家里上班，比在公司996都累，咖啡都喝完一罐了</p><p>不过，就算这样，领导应该还是会觉得进度慢，怎么写的这么慢，问题还这么多，交代下去就不能尽快弄完么？</p><a id="more"></a>


<p>这时候就感觉很郁闷了，我应该再懒一点</p>
<p>不想好，绝不动手</p>
<p>然后，能抽离的组件，方法，全部抽离出来，重复的代码，尽量不写第二遍</p>
<p>不过想得多了，写的就少了，然后再次开始这个循环</p>
<p>纠结</p>
<p>今天得好好睡一觉</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>docker部署jar包</title>
    <url>/2020/03/11/Work%20Record/CAAS/JDK8withDocker/</url>
    <content><![CDATA[<p>首先先docker search openjdk8，寻找到要使用的image。我使用的是adoptopenjdk/openjdk8这个。</p><a id="more"></a>
<p>然后基于该镜像构建容器。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -dit --name XXX -w /root  -v /etc/timezone:/etc/timezone:ro -v /etc/localtime:/etc/localtime -v /XXX:/root  -p 8888:8080 adoptopenjdk/openjdk8 sh -c <span class="string">"java -jar api.jar"</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年的todo list</title>
    <url>/2020/01/01/Essay/2020/TODO/</url>
    <content><![CDATA[<p>2020年的计划，一年之后再来看，看完成了多少。</p><ul>
<li>[x] 购买一台自己的MacBook Pro</li>
<li>[x] 每月一本书的阅读</li>
<li>[x] <del>每天英语单词打卡</del>  每天保持学习</li>
<li>[x] <del>新概念三册学完</del>  新概念一册学完</li>
<li>[x] 自己的Github每<del>周</del>月提交不少于<del>五</del>10次</li>
<li>[x] 每周一篇博客（平均）</li>
<li>[x] <del>和媳妇去看海</del>    看看七佛山算了</li>
<li>[x] <del>送媳妇一个她喜欢的东西</del>   喜欢钱</li>
<li>[x] <del>不睡懒觉</del>   不可能做得到</li>
<li>[x] <del>坚持锻炼，在忙，也得20个卷腹或者10个俯卧撑</del>  快乐的胖着不好么</li>
</ul>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>婚后复工第一天</title>
    <url>/2019/11/25/Essay/2019/%E5%A9%9A%E5%90%8E%E5%A4%8D%E5%B7%A5%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<p>今天是婚后第一天上班，怕地铁人太多，领着一袋子喜糖，提早很多去了公司。十天的假期眨眼即过，恍如昨日。只不过昨日的我还有女朋友，今日的我已为人夫，明日，可能为人父？</p><a id="more"></a>
<p>结婚的感觉，有紧张，有喜悦，有激动，有害怕。婚礼都结束了，都回来上班了，为什么是这种感觉？婚礼当天都不害怕，现在害怕什么？想了想，可能是自己太过于小心翼翼了，怕自己哪句话不小心伤害到别人或者别人伤害到自己，怕自己并不是自己想象中的那个样子，怕自己会在周围人的恭喜下惊慌失措。喜糖准备了60包，宁多不少，别人那里出问题没办法，但是我这里不能说这里不行那里不对，不是么？</p>
<p>同事，领导的一句句新婚快乐现在仿佛还萦绕耳旁，恭喜恭喜，这么小就结婚了啊，啥时候要孩子呢？是啊，啥时候要孩子呢？过两年吧。人总得扮演好生命中每个时期的角色，现在，还没有做好心理准备去当一个父亲，经济上也不允许。先扮演好自己一个丈夫的角色，扮演好一个男人的角色。</p>
<p>2009年，十年前，还在上高中，那会正是非主流横行的时候，许嵩，汪苏泷，徐良霸占了QQ音乐的前几名，现在距离那会已经十年了？都十年了？都结婚了，都复工了，还想什么呢。再想，时间也不会倒流回去，过去的已经过去，永远的停留在回忆里。之前很喜欢一句话，当然现在也喜欢：不乱于心，不困于情，不念过去，不畏将来。都结婚了，肩膀上可不是只有自己了，以前一个吃饱全家不饿，现在，还是要多考虑考虑自己的家人，未来的孩子，和一天天老去的父母，自己还是和以前一样的话，这些事情，会全部由他们扛起来，我舍不得，舍不得他们替我受苦受累，我想把他们肩上的东西转移到我的肩膀上，让他们休息休息，替我少操一点心。既然这么想，又何必故作古时候的文人骚客的状态呢。努力努力再努力，让家人不替自己操心，让自己给家里更多地帮助，生活才会更好。</p>
<p>工作，照常是不喜欢的，他日之因今日之果，可是在不喜欢，还是得做，还得做好。不然的话，循环一环一环，永远也跳不出去这个怪圈，优秀的越来越优秀，水平菜的越来越菜，直至被淘汰，去面对程序员的35岁危机。唯有解放自己生产力，投入更多的时间和精力，才可能在两年半之后，和别人站在同一个起跑线上。那时，再说休息，也不迟。</p>
<p>好几个同事，领导，说我变了，我想，应该不只是变胖吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Nexus打包碰到的问题</title>
    <url>/2019/11/01/Work%20Record/CAAS/Nexus/</url>
    <content><![CDATA[<p>打包如果打的是snapshot的包的话，包里只包含当前project下的文件，其他的依赖获取不到。</p><p>比如说，A依赖B，B依赖C，B打的是snapshot包，但是A想使用C的东西，获取不到，查看依赖，也看不到C。</p><a id="more"></a>

<p>两个解决办法：</p>
<ol>
<li>打release包，这样A依赖B的release版本，就能够获取到想要的东西</li>
<li>打fat-jar，但是这样，包的体积会非常大</li>
</ol>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>农科院</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-JVM篇章</title>
    <url>/2019/10/22/Interview/JVM/</url>
    <content><![CDATA[<p>JVM相关面试题</p>
<p>基于《深入理解JVM》这本书，如果说可能问的话，会问什么样的问题，又该如何去解答，如果连环炮的形势问的话，又该怎么去解答。如果没有足够理解的话，估计很难面对连环炮的形势。JVM实际工作中主要定位排查问题，性能优化，节省资源，但是一些理论还是要知道的，不然的话就成了高级技工了。有人说月薪3W以下的都不叫程序员，还是有点道理的，不过每个</p>
<p>码畜，总归是有点理想的吧。</p>
<a id="more"></a>
<ol>
<li><h4><span id="jvm运行时数据区分为哪几个部分分别是什么作用">JVM运行时数据区分为哪几个部分？分别是什么作用？</span></h4><p>分为程序计数器，<strong>Java虚拟机栈</strong>，本地方法栈，<strong>Java堆</strong>，方法区</p>
<p>程序计数器：</p>
<p>程序计数器的工作就是通过改变计数器的值来选取吓一跳需要执行的字节码指令，分支、循环、跳转、异常处理、县城回复等基础功能都依赖程序计数器来完成。Java虚拟机的多线程是<strong>通过线程轮流切换并分配处理器执行时间的方式来实现的</strong>，在任何一个确定的时刻，<strong>一个处理器（一个内核）都只会执行一条线程中的指令</strong>。因此为了线程切换后能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，<strong>互不影响，独立存储，线程私有</strong>，而且是唯一一个没有<strong>OutOfMemoryError</strong>情况的区域。</p>
<p>Java虚拟机栈：</p>
<p>线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型：<strong>每个方法在执行的同事都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程</strong>。局部变量表<strong>存放了编译期可知的各种基本数据类型（boolean,byte,char,short,int,float,long,double）、对象引用（reference类型，不是对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）</strong>。如果线程请求的栈深度大于虚拟机允许的深度，那么会StackOverflowError，如果扩展时无法申请到足够的内存，则会OutOfMemoryError。</p>
<p>本地方法栈：</p>
<p>为虚拟机使用的Native方法服务。</p>
<p>Java堆：</p>
<p>是Java虚拟机所管理的内存中最大的一块。被所有线程共享，存放对象实例，<strong>所有的对象实例以及数组都在堆上分配</strong>。是是垃圾收集器管理的主要区域，细分可分为<strong>新生代和老年代</strong>，再细分可以有：<strong>Eden空间、From Survivor空间、To Survivor空间。线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）</strong>。可以用-Xmx和-Xms来控制大小。无法扩展的时候，会抛出OutOfMemotyError。</p>
<p>方法区：</p>
<p>各个线程共享，存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。也叫做永久代。</p>
<p>运行时常量池：</p>
<p>是方法取得一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内存在类加载后进入方法区的运行时常量池存放。</p>
<p>直接内存：</p>
<p>独立于Java堆和Native堆，收到本机总内存的影响。</p>
<blockquote>
<p>可能延伸出的问题</p>
</blockquote>
<ul>
<li>既然说程序计数器是唯一一个没有OutOfMemory的区域，那么说说有哪些区域会有OutOfMemory？</li>
</ul>
<p>答：Java虚拟机栈，Java堆，本地方法栈，方法区。虚拟机栈的内存是可以动态扩展的，但是如果动态扩展时，申请不到足够的内存的话，那么会抛出OutOfMemory；Java堆如果达到了最大使用内存，那么再次开辟内存的时候，同样也会抛出OutOfMemory；本地方法栈如果调用Native方法没有足够内存或者没有释放的时候，那么也会抛出OutOfMemory；方法区中由于有运行时常量池的存在，这部分是最占内存的，如果没有足够内存的时候，同样会OutOfMemory。</p>
<ul>
<li><h5><span id="来说一下线程的生命周期">来说一下线程的生命周期</span></h5></li>
<li><h5><span id="局部变量表里存放是有哪些">局部变量表里存放是有哪些？</span></h5></li>
<li><h5><span id="说一下一个栈帧在虚拟机栈中入栈出栈的过程">说一下一个栈帧在虚拟机栈中入栈出栈的过程</span></h5></li>
<li><h5><span id="什么情况下会stackoverflowerror栈深度怎么算栈和堆所占内存比是多少">什么情况下会StackOverflowError？栈深度怎么算？栈和堆所占内存比是多少？</span></h5></li>
<li><h5><span id="eden空间-from-survivor空间-to-survivor空间内存占比怎么算">Eden空间、From Survivor空间、To Survivor空间内存占比怎么算？</span></h5></li>
<li><h5><span id="虚拟机加载类的过程是什么样的">虚拟机加载类的过程是什么样的？</span></h5></li>
<li><h5><span id="直接内存什么情况下会抛出outofmemoryerror">直接内存什么情况下会抛出<strong>OutOfMemoryError</strong>？</span></h5></li>
</ul>
</li>
<li><h4><span id="当new一个对象的时候对象的创建是怎么样一个过程">当new一个对象的时候，对象的创建是怎么样一个过程？</span></h4><p>虚拟机遇到一条new执行时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p>
<p>类加载检查通过后，虚拟机就会为对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。如果Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的放在一边，中间放着一个指针作为分界点的指示器，那分配内存就是仅仅把那个指针向空闲空间挪动一段与对象大小相等的距离，这种分配方式叫做指针碰撞（Bump the Pointer）。如果内存并不是规整的，已经使用内存和未使用的内存相互交错，这种情况下就没办法使用指针碰撞。那么Java虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式叫做空闲列表（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial，ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>但是在对象的创建是一个非常频繁的行为，并发情况下并不是线程安全的，有可能指针指向A，来没来得及修改，B就使用了原来的指针进行分配内存。为了避免这种情况，有两种处理方式，一种是对分配内存空间的操作进行同步处理，JVM采用CAS+失败重试的方式保证更新操作的原子性；另一种就是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并且分配新的TLAB时，才需要进行同步锁定。虚拟机是否使用TLAB，通过-XX:+/-UseTLAB。</p>
<p>内存分配完毕后，虚拟机就需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。<strong>这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对的零值</strong>。</p>
<p>然后对对象进行必要设置，如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息。<strong>这些信息存放在对象的对象头（Object Header）中</strong>。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>然后对象就已经产生了，但是知道虚拟机执行了init方法之后，把对象按照意愿进行初始化，这才算完成产生。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="来说一下类加载的过程是什么样">来说一下类加载的过程是什么样。</span></h5></li>
<li><h5><span id="如何确定一个对象所需内存大小">如何确定一个对象所需内存大小？</span></h5></li>
<li><h5><span id="内存是如何进行分配的">内存是如何进行分配的？</span></h5></li>
<li><h5><span id="如何确定内存分配方式">如何确定内存分配方式？</span></h5></li>
<li><h5><span id="哪种垃圾收集器带有压缩整理功能">哪种垃圾收集器带有压缩整理功能？</span></h5></li>
<li><h5><span id="有哪几种垃圾收集器分别有哪些特点采用的垃圾回收算法有哪几种分别是什么">有哪几种垃圾收集器？分别有哪些特点？采用的垃圾回收算法有哪几种？分别是什么？</span></h5></li>
<li><h5><span id="对象的创建过程是线程安全的么不是如何解决的">对象的创建过程是线程安全的么？不是？如何解决的？</span></h5></li>
<li><h5><span id="开启tlab的参数是什么默认是否使用tlab">开启TLAB的参数是什么？默认是否使用TLAB？</span></h5></li>
<li><h5><span id="对象头什么时候进行初始化包含哪些信息">对象头什么时候进行初始化？包含哪些信息</span></h5></li>
<li><h5><span id="对象头有哪几种不同的设置方式">对象头有哪几种不同的设置方式？</span></h5></li>
</ul>
</li>
</ol>
<ol>
<li><h4><span id="说一下对象的内存布局">说一下对象的内存布局</span></h4><p>在HotSpot虚拟机中，对象在内存中存储的的布局可以分为三个区域：<strong>对象头（Object Header），实例数据（Instance Data），对象填充（Padding）</strong>。</p>
<p>对象头包括两部分信息，<strong>第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。另一部分是类型指针，既对象指向它的的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</strong>。但是不是所有的虚拟机实现都必须在对象数据上保留类型指针。另外如果对象是一个Java数组，那在对象头中必须还有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p>
<p>实例数据存放的是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认），那么子类中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充不是必然存在，仅仅起到占位符的作用。因为HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。而对象头正好是8字节的整数倍，也就是实例部分没有对齐时，就需要用对齐填充来补全。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="哪个虚拟机实现不保留类型指针">哪个虚拟机实现不保留类型指针？</span></h5></li>
<li><h5><span id="虚拟机分配策略参数有哪些分配策略有哪些">虚拟机分配策略参数有哪些？分配策略有哪些？</span></h5></li>
<li><h5><span id="有没有可能子类的变量出现在父类变量之前">有没有可能子类的变量出现在父类变量之前？</span></h5></li>
</ul>
</li>
<li><h4><span id="说一下对象访问的时候是如何进行定位的">说一下对象访问的时候是如何进行定位的？</span></h4><p>访问对象是通过栈上的reference数据来操作具体对象，两种办法，直接指针和句柄访问。</p>
<p>句柄访问的话，会在Java堆中划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的地址信息。</p>
<p>直接指针的话，reference中存储的直接就是对象地址。</p>
<p>使用句柄访问的好处是，reference中存储的是句柄地址，在对象被于东的时候只会改变句柄中的实例数据地址，而reference本身则不需要修改。</p>
<p>直接指针的最好好处就是速度更快，节省了一次指针定位的时间开销。HotSpot主要使用直接指针。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li>直接指针和句柄访问各自有什么优缺点，哪个使用的比较多？</li>
</ul>
</li>
<li><h4><span id="什么情况下回oom写个代码使其抛出outofmemoryerror">什么情况下回OOM？写个代码，使其抛出OutOfMemoryError</span></h4><p>堆的话，可能会有内存泄露和内存溢出两种情况。如果一直新建对象，但是GC无法回收，超过了GC所允许的最大内存，那么就会产生OOM。</p>
<p>如果内存泄漏，那么就检查泄露对象到GC Roots的引用链是通过怎样的路径关联并导致垃圾收集器无法自动回收它们的。如果是内存溢出，那么就调大内存，然后检查代码中是否有某些对象生命周期过长，持有时间过长等情况。</p>
<p>栈的话，如果说请求栈的深度超过了允许的深度，会抛出StackoverFlow异常，但是如果栈无法申请到足够的内存的话，则会抛出OOM异常。</p>
<p>运行时常量池的话，一直添加字符串，将其固化到常量池填满，应该就会OOM。</p>
<p>方法区，由于方法区存放的是类的信息，那么构造足够多的类，将其撑爆就会OOM。</p>
<p>本机直接内存。直接或者间接使用NIO，总内存不够，则会抛出OOM。</p>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="什么是内存泄漏什么是内存溢出">什么是内存泄漏，什么是内存溢出？</span></h5></li>
<li><h5><span id="控制内存大小的参数是什么">控制内存大小的参数是什么？</span></h5></li>
</ul>
</li>
<li><h4><span id="判断对象是否存活的算法有哪几种各有什么特点">判断对象是否存活的算法有哪几种？各有什么特点？</span></h4><p>引用计数算法和可达性分析算法。</p>
</li>
</ol>
<blockquote>
<p>延伸问题</p>
</blockquote>
<ul>
<li><h5><span id="可作为gc-roots的对象包括哪几种">可作为GC Roots的对象包括哪几种？</span></h5></li>
</ul>
<ol>
<li><h4><span id="说一说java的引用">说一说Java的引用</span></h4></li>
<li><h4><span id="如何判断一个常量是否为废弃常量如何判断一个类是无用的类">如何判断一个常量是否为废弃常量？如何判断一个类是无用的类？</span></h4></li>
<li><h4><span id="说一下常用的垃圾收集算法">说一下常用的垃圾收集算法</span></h4></li>
<li><h4><span id="说一下有哪些垃圾收集器分别有什么用途各自用的什么算法">说一下有哪些垃圾收集器，分别有什么用途，各自用的什么算法？</span></h4></li>
<li><h4><span id="既然你说到了g1收集器那你说说g1收集器">既然你说到了G1收集器，那你说说G1收集器</span></h4></li>
<li><h4><span id="g1和cms有哪些区别">G1和CMS有哪些区别？</span></h4><p>​    </p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题收集-前言</title>
    <url>/2019/10/21/Interview/Perface/</url>
    <content><![CDATA[<p>工作如果能带来提升的话，那当然是最好不过的一件事情，但是如果不能呢？那就很尴尬了，当待得时间越来越长，<strong>自己的价值和竞争力就会越来越低</strong>。最后可能就会被抛弃，虽然应该也不至于和中兴程序员一样跳楼，然是忧患意识还是要有，日常学习不能少，但是，有些地方可能自己意识不到从而忽略，然后错失一次机会。因此，如果是我去面试的话，我会问的问题和我自己的答案，会放在这里。</p><a id="more"></a>
<p>采用连环炮的方式。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>中文数据中筛选出英文数据</title>
    <url>/2019/10/19/Work%20Record/CAAS/StringLength/</url>
    <content><![CDATA[<p>数据库表中，有字段为<strong><em>title</em></strong>，只存中文，但是英文数据混入，需要筛选出来将其放到英文库中。如何找出来，就成为了一个问题。</p><a id="more"></a>
<p>其实很简单，<strong>select id from xxx x where length(x.title) != char_length(title)</strong></p>
<p>因为说，MySQL在UTF-8的编码下，一个汉字字符占据三个字节，但是英文是一个字符一个字节，这就会导致说，如果title为英文，那么他的字符数和字节数是肯定能对上的，中文反之。</p>
<p>延伸一下，MySQL的varchar类型，并不是按照字节来算，而是字符，比如说，定义了一个varchar(10)，存“西门吹雪”是没有任何问题的，占用会是4，存”Jobs”也一样。MySQL对此作了优化。</p>
<p>再延伸一下，UTF-8一个汉字占据两三个字节，GBK一个汉字两个字节，部分汉字占据四个字节</p>
]]></content>
      <categories>
        <category>工作日常记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>农科院</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码</title>
    <url>/2019/08/25/Source%20code%20reading/JDK/Collection/ConcurrentHashMap/</url>
    <content><![CDATA[<blockquote>
<p>ConcurrentHashMap，可以进行并发读，写操作互斥。HashMap是线程不安全的。</p>
</blockquote>
<p>先翻译一下重点注释</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Overview:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The primary design goal of this hash table is to maintain</span></span><br><span class="line"><span class="comment"> * concurrent readability (typically method get(), but also</span></span><br><span class="line"><span class="comment"> * iterators and related methods) while minimizing update</span></span><br><span class="line"><span class="comment"> * contention. Secondary goals are to keep space consumption about</span></span><br><span class="line"><span class="comment"> * the same or better than java.util.HashMap, and to support high</span></span><br><span class="line"><span class="comment"> * initial insertion rates on an empty table by many threads.</span></span><br><span class="line"><span class="comment"> 这个主要设计目标是为了保证并发读的最小竞争性(主要是get方法，但是也支持迭代器相关方法)，第二个目标是为了和hashMap一致或者更好的空间消耗，并且支持多线程下的空表的高并发初始化插入速度。</span></span><br><span class="line"><span class="comment"> * The table is lazily initialized to a power-of-two size upon the</span></span><br><span class="line"><span class="comment"> * first insertion.  Each bin in the table normally contains a</span></span><br><span class="line"><span class="comment"> * list of Nodes (most often, the list has only zero or one Node).</span></span><br><span class="line"><span class="comment"> * Table accesses require volatile/atomic reads, writes, and</span></span><br><span class="line"><span class="comment"> * CASes.  Because there is no other way to arrange this without</span></span><br><span class="line"><span class="comment"> * adding further indirections, we use intrinsics</span></span><br><span class="line"><span class="comment"> * (jdk.internal.misc.Unsafe) operations.</span></span><br><span class="line"><span class="comment"> 这个table是在首次插入之后进行延迟初始化的，大小为2的次方数，每个table中的子节点通常都包含一个node的list(大多数情况下，这个list仅仅只有一个Node或者没有Node)。访问tabe需要volatile/atomic 读，写和CAS操作。因为这里没有其他方法可以再不使用间接指令的情况下安排table，所以我们使用内在函数(Unsafe)操作。</span></span><br><span class="line"><span class="comment"> * We use the top (sign) bit of Node hash fields for control</span></span><br><span class="line"><span class="comment"> * purposes -- it is available anyway because of addressing</span></span><br><span class="line"><span class="comment"> * constraints.  Nodes with negative hash fields are specially</span></span><br><span class="line"><span class="comment"> * handled or ignored in map methods.</span></span><br><span class="line"><span class="comment"> //我们使用Node参与hash的字段的top位来达到控制的目的，由于地址约束的存在，它无论如何都是欧东可用的，Node的辣鸡hash 字段会被在map的方法里面特殊处理或者直接丢弃</span></span><br><span class="line"><span class="comment"> * Insertion (via put or its variants) of the first node in an</span></span><br><span class="line"><span class="comment"> * empty bin is performed by just CASing it to the bin.  This is</span></span><br><span class="line"><span class="comment"> * by far the most common case for put operations under most</span></span><br><span class="line"><span class="comment"> * key/hash distributions.  Other update operations (insert,</span></span><br><span class="line"><span class="comment"> * delete, and replace) require locks.  We do not want to waste</span></span><br><span class="line"><span class="comment"> * the space required to associate a distinct lock object with</span></span><br><span class="line"><span class="comment"> * each bin, so instead use the first node of a bin list itself as</span></span><br><span class="line"><span class="comment"> * a lock. Locking support for these locks relies on builtin</span></span><br><span class="line"><span class="comment"> * "synchronized" monitors.</span></span><br><span class="line"><span class="comment"> 在一个空桶中的首个node的插入操作(通过put或者它的变种方法)中，是通过CAS操作进行的。对于大多数的key/value分布情况下，这是最普通最常见的情况。其他修改操作需要锁(insert,delete,replace)，我们不去浪费空间在每个桶中挂上不同独立的锁，所以使用桶中第一个节点来作为锁，这些锁的锁定支持，依赖于内置的“同步”监视器。</span></span><br><span class="line"><span class="comment"> * Using the first node of a list as a lock does not by itself</span></span><br><span class="line"><span class="comment"> * suffice though: When a node is locked, any update must first</span></span><br><span class="line"><span class="comment"> * validate that it is still the first node after locking it, and</span></span><br><span class="line"><span class="comment"> * retry if not. Because new nodes are always appended to lists,</span></span><br><span class="line"><span class="comment"> * once a node is first in a bin, it remains first until deleted</span></span><br><span class="line"><span class="comment"> * or the bin becomes invalidated (upon resizing).</span></span><br><span class="line"><span class="comment"> 使用list中的首个节点来作为锁并不能够满足条件：当一个node被锁的时候，任何修改都必须在锁定之后进行首节点验证，验证它仍然是首节点。而且如果不是首节点就重新验证。因为时新的node通常都是添加到list里，第一次的时候node是桶里的第一个元素，它会保持第一知道删除或者桶变成不可用的状态（调整大小后）。</span></span><br><span class="line"><span class="comment"> * The main disadvantage of per-bin locks is that other update</span></span><br><span class="line"><span class="comment"> * operations on other nodes in a bin list protected by the same</span></span><br><span class="line"><span class="comment"> * lock can stall, for example when user equals() or mapping</span></span><br><span class="line"><span class="comment"> * functions take a long time.  However, statistically, under</span></span><br><span class="line"><span class="comment"> * random hash codes, this is not a common problem.  Ideally, the</span></span><br><span class="line"><span class="comment"> * frequency of nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment"> * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment"> * parameter of about 0.5 on average, given the resizing threshold</span></span><br><span class="line"><span class="comment"> * of 0.75, although with a large variance because of resizing</span></span><br><span class="line"><span class="comment"> * granularity. Ignoring variance, the expected occurrences of</span></span><br><span class="line"><span class="comment"> * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The</span></span><br><span class="line"><span class="comment"> * first values are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0:    0.60653066</span></span><br><span class="line"><span class="comment"> * 1:    0.30326533</span></span><br><span class="line"><span class="comment"> * 2:    0.07581633</span></span><br><span class="line"><span class="comment"> * 3:    0.01263606</span></span><br><span class="line"><span class="comment"> * 4:    0.00157952</span></span><br><span class="line"><span class="comment"> * 5:    0.00015795</span></span><br><span class="line"><span class="comment"> * 6:    0.00001316</span></span><br><span class="line"><span class="comment"> * 7:    0.00000094</span></span><br><span class="line"><span class="comment"> * 8:    0.00000006</span></span><br><span class="line"><span class="comment"> * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lock contention probability for two threads accessing distinct</span></span><br><span class="line"><span class="comment"> * elements is roughly 1 / (8 * #elements) under random hashes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 当桶上锁时，桶中其他节点的其他操作会中止，比如使用equals或者mapping的方法将会执行很长时间。然后在统计中，在随机hash值的情况下，这不是一个常见的问题。理想情况下，在给定阈值给0.75的时候，桶中节点的分布遵循平均值约为0.5的泊松分布，尽管会因为resizing粒度具有较大方差，忽略方差，list的期望大小k为(exp(-0.5) * pow(0.5, k) / factorial(k))</span></span><br><span class="line"><span class="comment"> 两个线程访问不同的元素，锁竞争的概率大约为 1 / (* elements)</span></span><br><span class="line"><span class="comment"> * Actual hash code distributions encountered in practice</span></span><br><span class="line"><span class="comment"> * sometimes deviate significantly from uniform randomness.  This</span></span><br><span class="line"><span class="comment"> * includes the case when N &gt; (1&lt;&lt;30), so some keys MUST collide.</span></span><br><span class="line"><span class="comment"> * Similarly for dumb or hostile usages in which multiple keys are</span></span><br><span class="line"><span class="comment"> * designed to have identical hash codes or ones that differs only</span></span><br><span class="line"><span class="comment"> * in masked-out high bits. So we use a secondary strategy that</span></span><br><span class="line"><span class="comment"> * applies when the number of nodes in a bin exceeds a</span></span><br><span class="line"><span class="comment"> * threshold. These TreeBins use a balanced tree to hold nodes (a</span></span><br><span class="line"><span class="comment"> * specialized form of red-black trees), bounding search time to</span></span><br><span class="line"><span class="comment"> * O(log N).  Each search step in a TreeBin is at least twice as</span></span><br><span class="line"><span class="comment"> * slow as in a regular list, but given that N cannot exceed</span></span><br><span class="line"><span class="comment"> * (1&lt;&lt;64) (before running out of addresses) this bounds search</span></span><br><span class="line"><span class="comment"> * steps, lock hold times, etc, to reasonable constants (roughly</span></span><br><span class="line"><span class="comment"> * 100 nodes inspected per operation worst case) so long as keys</span></span><br><span class="line"><span class="comment"> * are Comparable (which is very common -- String, Long, etc).</span></span><br><span class="line"><span class="comment"> * TreeBin nodes (TreeNodes) also maintain the same "next"</span></span><br><span class="line"><span class="comment"> * traversal pointers as regular nodes, so can be traversed in</span></span><br><span class="line"><span class="comment"> * iterators in the same way.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">   * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">   * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">   * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">   * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">   * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">   * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">   * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">   * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>
<p>这里就发现，所有的变量都是volatile的，而volatile这个关键字的作用，就是首先保证可见性，然后禁止指令重排序，单次读写的原子性</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap源码</title>
    <url>/2019/08/19/Source%20code%20reading/JDK/Collection/TreeMap/</url>
    <content><![CDATA[<blockquote>
<p>Map的另一种有序实现，上一种是LinkedHashMap</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Red-Black tree based &#123;<span class="doctag">@link</span> NavigableMap&#125; implementation.</span></span><br><span class="line"><span class="comment"> * The map is sorted according to the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment"> * ordering&#125; of its keys, or by a &#123;<span class="doctag">@link</span> Comparator&#125; provided at map</span></span><br><span class="line"><span class="comment"> * creation time, depending on which constructor is used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation provides guaranteed log(n) time cost for the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> containsKey&#125;, &#123;<span class="doctag">@code</span> get&#125;, &#123;<span class="doctag">@code</span> put&#125; and &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment"> * operations.  Algorithms are adaptations of those in Cormen, Leiserson, and</span></span><br><span class="line"><span class="comment"> * Rivest's &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//简单翻译一下，摘录主要的东西，基于红黑树的实现，这个map的key是自然有序的，或者自定义实现在使用构造方法创建的时候使用Comparator</span></span><br><span class="line"><span class="comment">//这个实现支持log(n)级别的时间复杂度，包裹containsKey,get,put,remove等操作。后面是算法改编自XXX。</span></span><br><span class="line"><span class="comment">//这个map是不同步的，如果想多线程使用，需要使用Collections.syschronizedSortedMap包装</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty tree map, ordered according to the given</span></span><br><span class="line"><span class="comment">     * comparator.  All keys inserted into the map must be &lt;em&gt;mutually</span></span><br><span class="line"><span class="comment">     * comparable&lt;/em&gt; by the given comparator: &#123;<span class="doctag">@code</span> comparator.compare(k1,</span></span><br><span class="line"><span class="comment">     * k2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k1&#125; and &#123;<span class="doctag">@code</span> k2&#125; in the map.  If the user attempts to put</span></span><br><span class="line"><span class="comment">     * a key into the map that violates this constraint, the &#123;<span class="doctag">@code</span> put(Object</span></span><br><span class="line"><span class="comment">     * key, Object value)&#125; call will throw a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comparator the comparator that will be used to order this map.</span></span><br><span class="line"><span class="comment">     *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment">     *        ordering&#125; of the keys will be used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//比较关键的一个代码，创建的时候，指定排序方式，再插入的时候进行排序，如果为null，那就会使用默认的排序方式</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new tree map containing the same mappings and</span></span><br><span class="line"><span class="comment">     * using the same ordering as the specified sorted map.  This</span></span><br><span class="line"><span class="comment">     * method runs in linear time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  m the sorted map whose mappings are to be placed in this map,</span></span><br><span class="line"><span class="comment">     *         and whose comparator is to be used to sort this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException | ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个代码交待我们，如果构造方法传入的另一个TreeMap的话，那么排序方式会继承之前的map</span></span><br><span class="line"><span class="comment">//containsKey，containsValue,get,put这些全部是基于红黑树，没必要说，懂了红黑树的数据结构，就自然明白了</span></span><br><span class="line"><span class="comment">//非HashMap，不是基于hash算法</span></span><br><span class="line"><span class="comment">//感觉没啥写的了。。。红黑树现在感觉也不难。。。简直了</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>アイネクライネ (Eine kleine)</title>
    <url>/2019/08/11/Essay/2019/%E3%82%A2%E3%82%A4%E3%83%8D%E3%82%AF%E3%83%A9%E3%82%A4%E3%83%8D%20(Eine%20kleine)/</url>
    <content><![CDATA[<p>第一次听这首歌是赶来北京的时候，一个日本小姑娘翻唱的，最近重新听，发展越听越上瘾，听到这首歌，会有一种初恋般的感觉，于是乎自己也想学一学怎么唱。</p><a id="more"></a>
<p>不过外语歌都比较费劲，原因就是说，不会外语，哈哈。英语好歹还勉强能看看，日语这就尴尬了，看看不懂，听听不懂，但是想学这首歌怎么办？两种办法吧</p>
<ol>
<li>跟着罗马音学</li>
<li>学五十音</li>
</ol>
<p>罗马音，那就纯粹是记旋律，然后哼着自己也不知道什么意思的歌词，学完这首，等到了下一首，再次重来，这样的话，感觉太费劲。不如说学五十音，万丈高楼平地起，到时候再想学Lemon这些的话，应该相对来说会简单一点，不知道意思就不知道意思呗，知道怎么读了，能说得出来，就还行。</p>
<p>于此开始，等到完了之后，再上传一份，估计催吐功能会比较强。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap源码</title>
    <url>/2019/07/18/Source%20code%20reading/JDK/Collection/LinkedHashMap/</url>
    <content><![CDATA[<p>写在前面</p>
<p>HashMap是无序的，那么说，Map接口有没有说有序的实现？有，两种，一种LinkedHashMap，一种就是TreeMap，先来看看LinkedHashMap。</p>
<a id="more"></a>
<p>照旧，先来翻译一下LinkedHashMap的注释。好长啊，Map的注释怎么就这么长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Hash table and linked list implementation of the &#123;<span class="doctag">@code</span> Map&#125; interface,</span></span><br><span class="line"><span class="comment"> * with predictable iteration order.  This implementation differs from</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> HashMap&#125; in that it maintains a doubly-linked list running through</span></span><br><span class="line"><span class="comment"> * all of its entries.  This linked list defines the iteration ordering,</span></span><br><span class="line"><span class="comment"> * which is normally the order in which keys were inserted into the map</span></span><br><span class="line"><span class="comment"> * (&lt;i&gt;insertion-order&lt;/i&gt;).  Note that insertion order is not affected</span></span><br><span class="line"><span class="comment"> * if a key is &lt;i&gt;re-inserted&lt;/i&gt; into the map.  (A key &#123;<span class="doctag">@code</span> k&#125; is</span></span><br><span class="line"><span class="comment"> * reinserted into a map &#123;<span class="doctag">@code</span> m&#125; if &#123;<span class="doctag">@code</span> m.put(k, v)&#125; is invoked when</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> m.containsKey(k)&#125; would return &#123;<span class="doctag">@code</span> true&#125; immediately prior to</span></span><br><span class="line"><span class="comment"> * the invocation.)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * Map散列表和链表的实现，具有可预测的特性。这个实现和HashMap不同的地方在于它维护了一个贯穿所有实体的双向链表，这个链表定义了其迭代顺序，每个key再插入map之后都是有序的。如果一个key已经插入到了map中，再次插入的时候，是不影响其在map中的顺序的。（当一个key重新插入map的时候，如果在m.containsKey(k) 在调用之前将要return true的时候调用m.put(k,v)。）</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation spares its clients from the unspecified, generally</span></span><br><span class="line"><span class="comment"> * chaotic ordering provided by &#123;<span class="doctag">@link</span> HashMap&#125; (and &#123;<span class="doctag">@link</span> Hashtable&#125;),</span></span><br><span class="line"><span class="comment"> * without incurring the increased cost associated with &#123;<span class="doctag">@link</span> TreeMap&#125;.  It</span></span><br><span class="line"><span class="comment"> * can be used to produce a copy of a map that has the same order as the</span></span><br><span class="line"><span class="comment"> * original, regardless of the original map's implementation: </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  这个实现避免了像HashMap和HashTable的实现一样不确定，难以预测。并且不需要像TreeMap一样一直增加的消耗。它可以复制一个map来使用，它会和原先的map一样有同样的顺序，而不用管之前源map的实现。就像下面这样</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     void foo(Map m) &#123;</span></span><br><span class="line"><span class="comment"> *         Map copy = new LinkedHashMap(m);</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * This technique is particularly useful if a module takes a map on input,</span></span><br><span class="line"><span class="comment"> * copies it, and later returns results whose order is determined by that of</span></span><br><span class="line"><span class="comment"> * the copy.  (Clients generally appreciate having things returned in the same</span></span><br><span class="line"><span class="comment"> * order they were presented.)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 这个技巧是非常有用的，如果一个模块获得了个map，然后复制它，过一会就回返回一个顺序已经被定义的副本(用户通常中意一件事像原先那样发展)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A special &#123;<span class="doctag">@link</span> #LinkedHashMap(int,float,boolean) constructor&#125; is</span></span><br><span class="line"><span class="comment"> * provided to create a linked hash map whose order of iteration is the order</span></span><br><span class="line"><span class="comment"> * in which its entries were last accessed, from least-recently accessed to</span></span><br><span class="line"><span class="comment"> * most-recently (&lt;i&gt;access-order&lt;/i&gt;).  </span></span><br><span class="line"><span class="comment"> 	一个特殊的构造方法被提供来创建一个Linked hash map，其迭代顺序是其entry上次访问的顺序，从最近的访问到最多的访问(访问排序)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> This kind of map is well-suited to</span></span><br><span class="line"><span class="comment"> * building LRU caches.  Invoking the &#123;<span class="doctag">@code</span> put&#125;, &#123;<span class="doctag">@code</span> putIfAbsent&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get&#125;, &#123;<span class="doctag">@code</span> getOrDefault&#125;, &#123;<span class="doctag">@code</span> compute&#125;, &#123;<span class="doctag">@code</span> computeIfAbsent&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> computeIfPresent&#125;, or &#123;<span class="doctag">@code</span> merge&#125; methods results</span></span><br><span class="line"><span class="comment"> * in an access to the corresponding entry (assuming it exists after the</span></span><br><span class="line"><span class="comment"> * invocation completes). The &#123;<span class="doctag">@code</span> replace&#125; methods only result in an access</span></span><br><span class="line"><span class="comment"> * of the entry if the value is replaced.  The &#123;<span class="doctag">@code</span> putAll&#125; method generates one</span></span><br><span class="line"><span class="comment"> * entry access for each mapping in the specified map, in the order that</span></span><br><span class="line"><span class="comment"> * key-value mappings are provided by the specified map's entry set iterator.</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;No other methods generate entry accesses.&lt;/i&gt;  In particular, operations</span></span><br><span class="line"><span class="comment"> * on collection-views do &lt;i&gt;not&lt;/i&gt; affect the order of iteration of the</span></span><br><span class="line"><span class="comment"> * backing map.</span></span><br><span class="line"><span class="comment"> * 这种类型的map非常适合于构建一个LRU缓存(Least Recently Used),使用put,putIfAbsent,get,getOrDefault,apmpute,aomputeIfAbsent,aomputeInfPresent</span></span><br><span class="line"><span class="comment"> merge等方法来记录访问缓存(在调用完成之后记录)。如果value被替换的话，replace方法仅仅返回entry中被访问过的对象，putAll方法生成一个访问记录给每个在这个map里的entry，在这种情况下，这个key-value映射将会被支持于map的set iterator，没有其他方法生成entry 访问记录。通常情况下，集合视图的操作不会修改map的iterator的顺序。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@link</span> #removeEldestEntry(Map.Entry)&#125; method may be overridden to</span></span><br><span class="line"><span class="comment"> * impose a policy for removing stale mappings automatically when new mappings</span></span><br><span class="line"><span class="comment"> * are added to the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> removeEldestEntry这个方法可能被重载来在remove的时候或者在新的映射添加到map的时候。安全自动的使用</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class provides all of the optional &#123;<span class="doctag">@code</span> Map&#125; operations, and</span></span><br><span class="line"><span class="comment"> * permits null elements.  Like &#123;<span class="doctag">@code</span> HashMap&#125;, it provides constant-time performance for the basic operations (&#123;<span class="doctag">@code</span> add&#125;, &#123;<span class="doctag">@code</span> contains&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove&#125;), assuming the hash function disperses elements</span></span><br><span class="line"><span class="comment"> * properly among the buckets. </span></span><br><span class="line"><span class="comment"> LinkedHashMap支持Map的所有操作，并且允许null元素。像HashMap，假设这个hash方法均匀分布key的话，它的add，contains，remove等基础操作拥有稳定的性能。</span></span><br><span class="line"><span class="comment"> * Performance is likely to be just slightly</span></span><br><span class="line"><span class="comment"> * below that of &#123;<span class="doctag">@code</span> HashMap&#125;, due to the added expense of maintaining the</span></span><br><span class="line"><span class="comment"> * linked list, with one exception: Iteration over the collection-views</span></span><br><span class="line"><span class="comment"> * of a &#123;<span class="doctag">@code</span> LinkedHashMap&#125; requires time proportional to the &lt;i&gt;size&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * of the map, regardless of its capacity.  Iteration over a &#123;<span class="doctag">@code</span> HashMap&#125;</span></span><br><span class="line"><span class="comment"> * is likely to be more expensive, requiring time proportional to its</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;capacity&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> 	LinkedHashMap的性能仅仅稍微比HashMap低一点，由于添加操作使用的是Linked list，所以性能消耗全在这里，除了一个情况，迭代LinkedHashMap的集合试图需要O(map.size)，不管他的capacity多大。而迭代HashMap的时候与它很像，但是需要更多的花费，需要O(map.capacity)的花费。</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A linked hash map has two parameters that affect its performance:</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  They are defined precisely</span></span><br><span class="line"><span class="comment"> * as for &#123;<span class="doctag">@code</span> HashMap&#125;.  Note, however, that the penalty for choosing an</span></span><br><span class="line"><span class="comment"> * excessively high value for initial capacity is less severe for this class</span></span><br><span class="line"><span class="comment"> * than for &#123;<span class="doctag">@code</span> HashMap&#125;, as iteration times for this class are unaffected</span></span><br><span class="line"><span class="comment"> * by capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	一个LinkedHashMap有连个参数影响他的性能(initial capacity , load factor),他们在HashMap中被精确定义。但是需要注意的是，相对于HashMap来说，选择一个非常大的initial capacity的值产生的影响是非常小的，LinkedHashMap的迭代时间并不受capacity的影响。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * If multiple threads access a linked hash map concurrently, and at least</span></span><br><span class="line"><span class="comment"> * one of the threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be</span></span><br><span class="line"><span class="comment"> * synchronized externally.  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	注意：这个实现并不是线程安全的，如果两个以上的线程并发访问LinkedHashMap，同时至少有一个线程修改了map的结构，外部操作必须是线程安全的，这通常使用某个对象的同步操作来包装这个map。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * If no such object exists, the map should be "wrapped" using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span></span><br><span class="line"><span class="comment"> * method.  This is best done at creation time, to prevent accidental</span></span><br><span class="line"><span class="comment"> * unsynchronized access to the map:&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *   Map m = Collections.synchronizedMap(new LinkedHashMap(...));&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 如果没有对象存在的话，那么这个map应该使用Collections.synchronizedMap来包装。它最好在创建的时候使用，来防止线程不安全的访问。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * A structural modification is any operation that adds or deletes one or more</span></span><br><span class="line"><span class="comment"> * mappings or, in the case of access-ordered linked hash maps, affects</span></span><br><span class="line"><span class="comment"> * iteration order.  In insertion-ordered linked hash maps, merely changing</span></span><br><span class="line"><span class="comment"> * the value associated with a key that is already contained in the map is not</span></span><br><span class="line"><span class="comment"> * a structural modification.  &lt;strong&gt;In access-ordered linked hash maps,</span></span><br><span class="line"><span class="comment"> * merely querying the map with &#123;<span class="doctag">@code</span> get&#125; is a structural modification.</span></span><br><span class="line"><span class="comment"> * &lt;/strong&gt;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	添加，删除一个或者多个元素都会修改结构，并且在这些情况中都会影响LinkdHashMap的迭代顺序。如果只是修改一个存在的key-value的映射关系的话并不会修改结构。在LinkedHashMap中，仅仅使用get是一种结构修改。</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The iterators returned by the &#123;<span class="doctag">@code</span> iterator&#125; method of the collections</span></span><br><span class="line"><span class="comment"> * returned by all of this class's collection view methods are</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after</span></span><br><span class="line"><span class="comment"> * the iterator is created, in any way except through the iterator's own</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove&#125; method, the iterator will throw a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span></span><br><span class="line"><span class="comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span></span><br><span class="line"><span class="comment"> * arbitrary, non-deterministic behavior at an undetermined time in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 	由该类的所有集合视图中返回的iterator都会有fail-fast：如果map创建之后，结构被除了iterator的remove外的方法修改，这个iterator将会抛出ConcurrentModificationException。因此，当面对并发修改的时候，iterator会快速失败并清空，而不会在未来不确定的时间内进行不确定的有风险的行为。</span></span><br><span class="line"><span class="comment"> 	下面的不翻译了</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The spliterators returned by the spliterator method of the collections</span></span><br><span class="line"><span class="comment"> * returned by all of this class's collection view methods are</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally report &#123;<span class="doctag">@link</span> Spliterator#ORDERED&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href="&#123;<span class="doctag">@docRoot</span>&#125;/java.base/java/util/package-summary.html#CollectionsFramework"&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment"> * The spliterators returned by the spliterator method of the collections</span></span><br><span class="line"><span class="comment"> * returned by all of this class's collection view methods are created from</span></span><br><span class="line"><span class="comment"> * the iterators of the corresponding collections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     HashMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     TreeMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Hashtable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Implementation note.  A previous version of this class was</span></span><br><span class="line"><span class="comment">     * internally structured a little differently. Because superclass</span></span><br><span class="line"><span class="comment">     * HashMap now uses trees for some of its nodes, class</span></span><br><span class="line"><span class="comment">     * LinkedHashMap.Entry is now treated as intermediary node class</span></span><br><span class="line"><span class="comment">     * that can also be converted to tree form. The name of this</span></span><br><span class="line"><span class="comment">     * class, LinkedHashMap.Entry, is confusing in several ways in its</span></span><br><span class="line"><span class="comment">     * current context, but cannot be changed.  Otherwise, even though</span></span><br><span class="line"><span class="comment">     * it is not exported outside this package, some existing source</span></span><br><span class="line"><span class="comment">     * code is known to have relied on a symbol resolution corner case</span></span><br><span class="line"><span class="comment">     * rule in calls to removeEldestEntry that suppressed compilation</span></span><br><span class="line"><span class="comment">     * errors due to ambiguous usages. So, we keep the name to</span></span><br><span class="line"><span class="comment">     * preserve unmodified compilability.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The changes in node classes also require using two fields</span></span><br><span class="line"><span class="comment">     * (head, tail) rather than a pointer to a header node to maintain</span></span><br><span class="line"><span class="comment">     * the doubly-linked before/after list. This class also</span></span><br><span class="line"><span class="comment">     * previously used a different style of callback methods upon</span></span><br><span class="line"><span class="comment">     * access, insertion, and removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//继承自HashMap的node，区别就是多了个前驱节点和后继节点，也就是从单链表变成了双向链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//双向链表的头结点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//为节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The iteration ordering method for this linked hash map: &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * for access-order, &#123;<span class="doctag">@code</span> false&#125; for insertion-order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//true为访问排序，false为插入排序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal utilities</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// link at the end of list</span></span><br><span class="line">    <span class="comment">//将entry放入到链表最后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply src's links to dst</span></span><br><span class="line">    <span class="comment">//两个链表合并为一个</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = dst;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overrides of HashMap hook methods</span></span><br><span class="line">		<span class="comment">//重新初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.reinitialize();</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的node，并且放入链表最后</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将next放到p的后面</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap.Entry&lt;&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//treenode entry 在这里其实一样</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//同上</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//下面三个方法，在HashMap中只是一个钩子，实现在LinkedHashMap，元素删除后的回调方法，删除e节点的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//插入元素后的回调，evict为true的话，会删除链表最老的元素，但是，这个removeEldestEntry方法，里面永久返回的是false，因此，如果想删除老的元素的话，需要重写这个方法。删除老的元素，有两种策略，按照访问，按照插入，上面又说。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            K key = first.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//元素访问后的回调，如果在构造方法中设置了按照访问排序的话，那么这里会执行。其实也就是将当前元素e，将其在链表中的位置后移一下而已</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">            s.writeObject(e.key);</span><br><span class="line">            s.writeObject(e.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance</span></span><br><span class="line"><span class="comment">     * with the specified initial capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//构造方法，默认accessOrder为false，也就是插入排序，下面都一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance</span></span><br><span class="line"><span class="comment">     * with the specified initial capacity and a default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance</span></span><br><span class="line"><span class="comment">     * with the default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an insertion-ordered &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance with</span></span><br><span class="line"><span class="comment">     * the same mappings as the specified map.  The &#123;<span class="doctag">@code</span> LinkedHashMap&#125;</span></span><br><span class="line"><span class="comment">     * instance is created with a default load factor (0.75) and an initial</span></span><br><span class="line"><span class="comment">     * capacity sufficient to hold the mappings in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> LinkedHashMap&#125; instance with the</span></span><br><span class="line"><span class="comment">     * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  accessOrder     the ordering mode - &#123;<span class="doctag">@code</span> true&#125; for</span></span><br><span class="line"><span class="comment">     *         access-order, &#123;<span class="doctag">@code</span> false&#125; for insertion-order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     * specified value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//从此看出，LinkedHashMap的containsValue速度并不会很快，数据量大的话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">            V v = e.value;</span><br><span class="line">            <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//和HashMap的区别就是，当accessOrder为true的话，会执行afterNodeAccess的回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//这个没啥写的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> defaultValue;</span><br><span class="line">       <span class="keyword">if</span> (accessOrder)</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">       <span class="keyword">return</span> e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this map should remove its eldest entry.</span></span><br><span class="line"><span class="comment">     * This method is invoked by &#123;<span class="doctag">@code</span> put&#125; and &#123;<span class="doctag">@code</span> putAll&#125; after</span></span><br><span class="line"><span class="comment">     * inserting a new entry into the map.  It provides the implementor</span></span><br><span class="line"><span class="comment">     * with the opportunity to remove the eldest entry each time a new one</span></span><br><span class="line"><span class="comment">     * is added.  This is useful if the map represents a cache: it allows</span></span><br><span class="line"><span class="comment">     * the map to reduce memory consumption by deleting stale entries.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Sample use: this override will allow the map to grow up to 100</span></span><br><span class="line"><span class="comment">     * entries and then delete the eldest entry each time a new entry is</span></span><br><span class="line"><span class="comment">     * added, maintaining a steady state of 100 entries.</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *     private static final int MAX_ENTRIES = 100;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span></span><br><span class="line"><span class="comment">     *        return size() &amp;gt; MAX_ENTRIES;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method typically does not modify the map in any way,</span></span><br><span class="line"><span class="comment">     * instead allowing the map to modify itself as directed by its</span></span><br><span class="line"><span class="comment">     * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify</span></span><br><span class="line"><span class="comment">     * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> false&#125; (indicating that the map should not attempt any</span></span><br><span class="line"><span class="comment">     * further modification).  The effects of returning &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * after modifying the map from within this method are unspecified.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation merely returns &#123;<span class="doctag">@code</span> false&#125; (so that this</span></span><br><span class="line"><span class="comment">     * map acts like a normal map - the eldest element is never removed).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>    eldest The least recently inserted entry in the map, or if</span></span><br><span class="line"><span class="comment">     *           this is an access-ordered map, the least recently accessed</span></span><br><span class="line"><span class="comment">     *           entry.  This is the entry that will be removed it this</span></span><br><span class="line"><span class="comment">     *           method returns &#123;<span class="doctag">@code</span> true&#125;.  If the map was empty prior</span></span><br><span class="line"><span class="comment">     *           to the &#123;<span class="doctag">@code</span> put&#125; or &#123;<span class="doctag">@code</span> putAll&#125; invocation resulting</span></span><br><span class="line"><span class="comment">     *           in this invocation, this will be the entry that was just</span></span><br><span class="line"><span class="comment">     *           inserted; in other words, if the map contains a single</span></span><br><span class="line"><span class="comment">     *           entry, the eldest entry is also the newest.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>   &#123;<span class="doctag">@code</span> true&#125; if the eldest entry should be removed</span></span><br><span class="line"><span class="comment">     *           from the map; &#123;<span class="doctag">@code</span> false&#125; if it should be retained.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//注释比较简单，不翻译了，就是想删除比较老的元素，就重写它，put和putAll的时候回调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &#123;<span class="doctag">@code</span> remove&#125; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Iterator.remove&#125;, &#123;<span class="doctag">@code</span> Set.remove&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> removeAll&#125;, &#123;<span class="doctag">@code</span> retainAll&#125;, and &#123;<span class="doctag">@code</span> clear&#125;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &#123;<span class="doctag">@code</span> add&#125; or &#123;<span class="doctag">@code</span> addAll&#125;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     * Its &#123;<span class="doctag">@link</span> Spliterator&#125; typically provides faster sequential</span></span><br><span class="line"><span class="comment">     * performance but much poorer parallel performance than that of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> HashMap&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the keys contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//获取map中所有key的驶入，支持Iterator的操作，不支持add和addAll，顺序执行的性能更快，但是，并发执行不如hashmap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> LinkedKeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                            Spliterator.ORDERED |</span><br><span class="line">                                            Spliterator.DISTINCT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">                action.accept(e.key);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator's own &#123;<span class="doctag">@code</span> remove&#125; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &#123;<span class="doctag">@code</span> Iterator.remove&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Collection.remove&#125;, &#123;<span class="doctag">@code</span> removeAll&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> retainAll&#125; and &#123;<span class="doctag">@code</span> clear&#125; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &#123;<span class="doctag">@code</span> add&#125; or &#123;<span class="doctag">@code</span> addAll&#125; operations.</span></span><br><span class="line"><span class="comment">     * Its &#123;<span class="doctag">@link</span> Spliterator&#125; typically provides faster sequential</span></span><br><span class="line"><span class="comment">     * performance but much poorer parallel performance than that of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> HashMap&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//同上，不翻译了，也没啥可问的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> LinkedValues();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValues</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                            Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">                action.accept(e.value);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &#123;<span class="doctag">@code</span> remove&#125; operation, or through the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> setValue&#125; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &#123;<span class="doctag">@code</span> Iterator.remove&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Set.remove&#125;, &#123;<span class="doctag">@code</span> removeAll&#125;, &#123;<span class="doctag">@code</span> retainAll&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> clear&#125; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> add&#125; or &#123;<span class="doctag">@code</span> addAll&#125; operations.</span></span><br><span class="line"><span class="comment">     * Its &#123;<span class="doctag">@link</span> Spliterator&#125; typically provides faster sequential</span></span><br><span class="line"><span class="comment">     * performance but much poorer parallel performance than that of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> HashMap&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> LinkedEntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                Object key = e.getKey();</span><br><span class="line">                Object value = e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                            Spliterator.ORDERED |</span><br><span class="line">                                            Spliterator.DISTINCT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">                action.accept(e);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map overrides</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.key, e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            e.value = function.apply(e.key, e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">        <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">        LinkedHashIterator() &#123;</span><br><span class="line">            next = head;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            current = e;</span><br><span class="line">            next = e.after;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            removeNode(p.hash, p.key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeyIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().getKey(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较简单啊，除了双向链表和访问排序以外，好像没什么可以问的。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码</title>
    <url>/2019/07/17/Source%20code%20reading/JDK/Collection/HashSet/</url>
    <content><![CDATA[<p>Set和List的区别就是，List是有序的，可重复的，而Set是无序的，不可重复的，但是为什呢，从来没有看过，这次来看下源码，看源码中是怎么来实现的</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &#123;<span class="doctag">@code</span> HashMap&#125; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真简单。。。本来还想得说不定也得和HashMap一样写那么多，弄了半天就这么一句话就解释了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment">     * More formally, adds the specified element &#123;<span class="doctag">@code</span> e&#125; to this set if</span></span><br><span class="line"><span class="comment">     * this set contains no element &#123;<span class="doctag">@code</span> e2&#125; such that</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Objects.equals(e, e2)&#125;.</span></span><br><span class="line"><span class="comment">     * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment">     * unchanged and returns &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment">     * element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用的是HashMap，key实际上就是set里存的值，value就是一个object。而键值对是一一对应的，也就解释了为什么Set的值是不可重复的。</p>
<p>而由于说Set继承于Collection，而Collection接口又继承了Iterator接口，所以说，Set也是支持迭代器操作的，也就支持Foreach操作。</p>
<p>至于说为什么无序，因为HashMap的key并不能保证有序。hashmap按照散列值进行存储，读取的顺序还真不一定是插入的顺序。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2019/07/14/Data%20Struct/RBT/</url>
    <content><![CDATA[<p>红黑树操作图示<img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/RBT/02.png" alt="红黑树操作图示">：</p><p>红黑树插入操作详细图示：</p><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/RBT/01.png" alt="插入操作"></p><p>红黑树删除操作图示</p><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/RBT/03.png" alt="删除操作"></p>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码问题解读</title>
    <url>/2019/06/30/Source%20code%20reading/JDK/Collection/HashMap_Question/</url>
    <content><![CDATA[<blockquote>
<p>HashMap相关问题放这里，带着问题看，自己的思路解答也会放这里</p>
</blockquote>
<a id="more"></a>
<p>问题记录：</p>
<ol>
<li><p>DEFAULT_INITIAL_CAPACITY为啥默认是16，为什么必须是2的倍数？</p>
<p>解答：</p>
<p>16可能是一个折中的选项，来避免说设置太小，稍微放一点数据，就进行扩容了，产生不必要的空间浪费。至于说2的倍数，因为底层计算的时候，都是通过cpu移位来进行计算，而2的倍数的话，只需要进行左移一位即可，不然的话，如果是什么加减乘除取模，全部都是cpu进行的加法运算，浪费效率。</p>
</li>
<li><p>最大容量能否进行更改？达到最大容量的时候会浪费多少的容量？</p>
<p>解答：</p>
<p>不能通过构造方法更改，如果手动将其更改为比1&lt;&lt;30（1&lt;&lt;31的话，会超出整型的最大值，也就是Integer.MAX_VALUE）更大的数字的话，tableSizeFor()这个方法会重新将值设置为16。如果经过resize()方法扩容了很多次，那么，它的最大容量，实际上汇编成为Integer.MAX_VALUE。如果达到了最大容量，由于说hashmap的阈值范围是threshold * loadFactor，所以首先说，会有1/4的容量，是完全被浪费掉了的。</p>
</li>
<li><p>默认加载因子是0.75，如果是其他的值会有什么影响？为什么是0.75？</p>
<p>解答：</p>
<p>threshold = capacity * 0.75，初始默认情况下，这个值为12，也就是说，刚开始map的capacity是16，threshold为12，而当容量达到12的时候就会进行扩容。如果loadFactor为0.5的话，那么容量到了8的时候就会扩容，如果等于1的话，那map里的用完之后才会进行扩容。</p>
<p>由API注释可知，桶的分布满足于泊松分布，参数在在默认阈值0.75的条件下，平均数为0.5，会产生比较良好的分布。再问泊松分布的话，就不会了。。。。MLGJ</p>
</li>
<li><p>树化的阈值为什么是8？树退化为链表的阈值为什么是6？达到阈值6和8的时候分别会产生什么效果？</p>
<p>解答：</p>
<p>因为hashmap是数组+链表，达到阈值后，会变成数组+红黑树。链表的复杂度为O(n)，红黑树的复杂度为O(logn)。假设长度为8的话，那么，红黑树的复杂度就是O(log8) = 3，链表的复杂度是O(8)，红黑树&gt;链表。假设长度为6的话，那么，红黑树的复杂度就是O(log6) = 2.585，链表的复杂度是O(6)，但是红黑树对应的需要有平衡的操作，相对来说，这些操作没有链表来的复杂性小点，没有必要使用红黑树。所以说，树化阈值为8的时候，是最合适的一个值。</p>
</li>
<li><p>最小树化容量不是64么，为什么源码注释里写的是4*8=32？如果是32会怎么样？</p>
<p>解答：</p>
<p>不知道</p>
</li>
<li><p>hashcode的集合仅仅在当前掩码变化的时候将会一直碰撞冲突？如果不异或呢。会怎么个冲突法？这个需要自己实现来验证。</p>
</li>
<li><p>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，为什么要这么做？hashcode为何要与code无符号右移16位后的数字做异或？</p>
<p>解答：</p>
<p>先不关注hashCode的实现方式，这个东西，后面再说吧。先看看为什么要这么做，好处在哪。</p>
<p>hashcode右移16位，然后进行和原值进行异或。然后，由于是整型(int)，int的取值范围为0x00000000-0xFFFFFFFF，也就是说，是32位的二进制数据，如果这时候hashcode进行右移16位，那就是说，hashCode的高16位和低16位进行异或。至于为什么这么做，hashCode的值，用到高16位的情况，太少了，可能是为了减少hash碰撞吧，因为如果hashcode值比较小的话，那么产生相同的hashcode的可能性相对来说是比较高的一个情况，所以用高位和低位来异或，加快速度，减少hash碰撞。</p>
</li>
<li><p>tableSizeFor方法的作用是什么，为什么要这么写？</p>
<p>解答：</p>
<p>Returns a power of two size for the given target capacity。</p>
<p>意思为：返回给定目标容量的2次方幂的数字。实际上，是返回一个比指定整数大，且是接近2次方幂的一个整数。</p>
<p>因为移位的速度是最快的，能够以很高的效率来获取。看到是看明白了，这个是怎么推出来的？百思不得其解啊。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//capacity默认值为16，以默认情况来看</span></span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认情况，i==2^4-1;</span></span><br><span class="line">  <span class="comment">// HD, Count leading 0's    HD是啥意思？应该是计算前导数的0有多少了吧</span></span><br><span class="line">  <span class="comment">//由此可见，i的最小值为0。</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">31</span>;</span><br><span class="line">  <span class="comment">//i &gt;= 2^16</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">  <span class="comment">//i &gt;= 2^8</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">  <span class="comment">//i &gt;= 2^4</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">  <span class="comment">//i &gt;= 2^2</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况（initial_capacity = 16）会进入下面的判断(i == 2^4 - 1)，此时，n=29，而i无符号右移两位之后，会从15(1111)-&gt;3(0011)，在return语句中，i再次进行无符号右移，变为(0001)，这时，n-i的值就为28。然后再看tableSizeFor，使用-1无符号右移28位。而-1的二进制表示为11111111111111111111111111111111(因为负数的二进制表示为：1的二进制表示，取反码，然后补码)，移位之后结果就变成了00000000000000000000000000001111，如果没有大于MAXIMUM_CAPACITY，则+1，变为了16，2^4</li>
<li>换种情况，68983，当它进入numberOfLeadingZeros的时候，便成为68982。首先会进入i &gt;= 1&lt;<16，此时n-=16=15。i>&gt;&gt;16之后，会变为(0001)，下面三个判断都进不去，这时候return语句再次右移，就成0了，然后，n=15-0=15，最后，-1无符号右移15位，过程不进行叙述，最后结果为2^17，而68983是大于2^16的。</16，此时n-=16=15。i></li>
</ul>
</li>
<li><p>初始容量和负载因子如果在构造方法中改变的话，会有什么影响？</p>
<ul>
<li>和上面的tableSizeFor方法相关，上面已经说了一部分了，如果修改了initial_capacity的话，会将这个值赋值给threshold，因为hashmap的扩容方法是触发threshold才会进行，也就是达到了capacity<em>loadFactor。如果赋值的是20，根据tableSizeFor方法，容量会变成为2^5(32)，当容量到了32之后，才会进行扩容，而不是说32\</em>0.75之后才扩容。</li>
<li>如果loadFactor修改为1，那么，首先来说，当所有容量用完了，才会进行扩容；如果修改的太小了，那么数据刚扩容相对来说就会非常快（假设为0.1，到了十分之一就扩容和到了四分之三扩容，这个不言而喻）；还有个问题，hashmap是基于hash分布，如果说loadFactor设置太高的话，那么所有bucket都会被利用，不利于良好的hash分布，hash冲突就会增大，hashmap查询性能就会降低，如果太小，bucket空间又浪费太多。0.75是比较合适的一个值。结合上面的一起。</li>
</ul>
</li>
<li><p>Float.isNaN = return v != v ，为什么这么写？</p>
<p>isNaN接收的参数是一个float，而该方法判断这个值是否是一个数字，NaN(Not a Number)，而查看float的源码，里面有个常量，float NaN = 0.0f/0.0f。而hashmap源码里，会先进行判断，loadFactor&lt;=0，如果这里满足的话，因该是不会进行后面的操作的，可能是因为hashmap不是线程安全的，虽然刚开始loadFactor是正确的值，然后被其他线程修改之后，就变成了0.0f/0.0f，就会变成一个not a number的数。</p>
</li>
<li><p>tab[(n - 1) &amp; hash]，这个操作是什么意思？</p>
<p>是用来定位数组位置的，上面说了这个hash值是自身的hashcode的高16位与低16位进行异或产生的结果，而n-1是当前hashmap的长度，通过(length-1) &amp; hash的话，就能够得到所需要查找的下标，然后就可以通过index来获取到需要get或者说需要put的数据。</p>
<p>hash算法最主要的就是说让元素均匀分布，而很多hash算法都是使用的取模运算，但是hashmap用的是(n-1) &amp; hash，首先，&amp;的运算速度是大于%的，然后length是2的倍数，x%length == (length-1) &amp; x，求x。</p>
<ul>
<li>假设length=8,x=5，(8-1) &amp; 5 == 0111 &amp; 0101 ==5，结果正确</li>
<li>假设length=4,x=21，(4-1) &amp; 21 == 0011 &amp; 10101 == 1，结果正确</li>
<li>假设length=3,x=20，(3-1) &amp; 20 == 1000 &amp; 10100 == 0，结果错误</li>
</ul>
<p>由此可知，x%length == (length-1) &amp; x这个公式是正确的，然后看下这个公式怎么推出来。</p>
<p>一个十进制数用二进制方法表示：$X<em>nX</em>{n-1}X<em>{n-2}…X_1X_0$ == $X_n*2^n + X</em>{n-1}<em>2^{n-1} + X_{n-2}</em>2^{n-2} … +X_1<em>2^1 + X_0</em>2^0 $</p>
<p>由于分配率的规定，由上面的公式可知，length为2的倍数，$X/2^k$的余数就为取模的值，那就看怎么取这个余数：$X/2^k ==  X<em>n*2^n/2^k + X</em>{n-1}<em>2^{n-1}/2^k + X_{n-2}/2^k</em>2^{n-2}/2^k … +X_1<em>2^1/2^k + X_0</em>2^0/2^k  $</p>
<ul>
<li>如果k&gt;n的话，余数就是整个十进制数</li>
<li>如果0&lt;=k&lt;=n，因为比k大的，都能被k整除，所以说，余数就为$X<em>k*2^k + X</em>{k-1} <em> 2^{k-1} + … X_k </em> 2^1 + X_k * 2^0 $</li>
<li>特么的，这个公式《数据结构与算法》这本书上有</li>
</ul>
<p>一个十进制数对$2^n$的数进行取余，就是说，十进制数转换为二进制数后，向右进行移位，移掉的这n位数，就为余数，比如说，10 % 8  ==  2。1000 向右移位2位的话是 0010 == 2，结果正确。然后是怎么获取这个n位数：$2^0…2^n$ 用二进制表示为0001,0010,0100,1000…如果我们将$2^n-1$的话，就会变成为0000，0001，0011，0111，1111…然后用十进制数和该数字进行&amp;操作，得到的数字，就是需要移位的数字。</p>
<p>嗯。就是这些。</p>
</li>
<li><p>resize()这个方法初次执行的时候大小是多少？后续执行的时候，大小会如何变化？</p>
<p>resize初次执行的时候大小为默认值1 &lt;&lt; 4，后续执行的时候，大小会翻倍。</p>
</li>
<li><p>hashmap扩容的话，会怎么进行变化？</p>
<p>扩容的话，桶里的链表或者红黑树没什么变化，但是说，数组里的元素的位置会发生改变，会重新计算元素在数组中的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>换工作的一些思考</title>
    <url>/2019/05/23/Essay/2019/Thinking%20of%20change%20job/</url>
    <content><![CDATA[<p>新入职了一个公司</p><p>外派</p><p>时间是2019-05-15</p><p>身为一个打工的，最看重的可能就是三件事：成长性，钱，环境。新单位外派，不知道到底会怎么样，不过钱的稳定性应该是有保证，成长性应该就是为0了吧。可能也会比较好？但是就之前在太原工作的经历来看，高成长性的可能微乎其微。环境，就朋友极力阻止我这件事上来看，估计也很一般。不过答应了的事情，还是要做的。先待一段时间看看。</p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码</title>
    <url>/2019/05/10/Source%20code%20reading/JDK/Collection/HashMap/</url>
    <content><![CDATA[<blockquote>
<p>阅读源码之前还是应该阅读注释</p>
</blockquote><p>API文档：</p><p>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><a id="more"></a>


<p>HashTable是Map的基础实现，这个实现支持map的所有操作，而且允许null的value和key（HashMap除了它支持null且线程不安全外和Hashtable差不多），HashMap不保证map里的有序性，在一些情况，它不保证一段时间内的有序性。</p>
<p>This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.</p>
<p>HashMap的get和put拥有常数时间的性能，假定hash函数将元素均匀分散于桶(bucket)之间，迭代集合需要有和HashMap实例的capacity(容量，桶的容量)+map的大小（key-&gt;value映射的数量）成比例的时间。因此，如果性能是非常重要的话，将初始容量(initial capacity)设置的不要太高是非常重要的一件事，</p>
<p>An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p>
<p>HashMap的示例有两个参数影响它的性能：初始容量和加载因子（initial capacity and load factor），这个容量是hash table里桶（bucket）的数量。然后这个初始容量（initial capacity）仅仅是在hash table创建的时候的容量。这个加载因子(load factor)是hash table在它的容量自动增加之前测量增加量的一个关键参数。当hash table中的entry的数量超过(load factor * current capacity)的时候，hash table 会进行重新hash(意思是，内部的数据结构会重新构建)，构建之后这个hash table 的桶的数量差不多有之前桶的数量的两倍</p>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
<p>在一般的条件下，默认的加载因子在时间和空间消耗之间做了很好的权衡。负载因子的值变高了之后会减少空间的消耗，但是会增加查找的开销(表现在HashMap中的大部分操作，包括get和set)。map里entries的数量和加载因子在初始容量被设置的时候就应该被考虑到。所以减少rehash的次数。如果初始化容量大于entries的数量除以负载因子，那么不会发生rehash操作。</p>
<p>If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. </p>
<p>如果很多映射被存储于HashMap实例。那么创建一个有足够大的容量的实例将会比让它自动去执行rehash来扩大表来进行映射存储来的的更高效（efficientily 有效，有效率，效率高）。</p>
<p>Note that using many keys with the same hashCode() is a sure way to slow down performance of any hash table. </p>
<p>注意：任何HashTable如果很多key有了相同的hashCode的话将会降低其性能。</p>
<p>To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties.</p>
<p>如果改善其影响的话，当key是可比较的时候，这个类也许可以使用key之间的比较关系来帮助打破关系</p>
<p>Note that this implementation is not synchronized. If multiple threads access a hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) </p>
<p>注意：这个实现是线程不安全的，如果很多线程同时访问一个hash map的话，并且至少有一个线程修改了该map 的结构，那么它在外部必须是线程安全的操作。(结构改变是指任何添加或删除一个或者多个映射的操作。仅仅修改一个实例里key相关的value的话，已经包含的并不是结构修改)</p>
<p>This is typically accomplished by synchronizing on some object that naturally encapsulates the map.</p>
<p>这通常由一些对象的同步操作来完成自然封装的的map。</p>
<p> If no such object exists, the map should be “wrapped” using the Collections.synchronizedMap method. </p>
<p>如果没有任何对象存在，这个map应该使用Collections.synchronizedMap来进行包装。</p>
<p>This is best done at creation time, to prevent accidental unsynchronized access to the map:</p>
<p>​     Map m = Collections.synchronizedMap(new HashMap(…));</p>
<p>最好是在创建的时候完成这个操作，以防止意外线程不安全的访问该map</p>
<p>The iterators returned by all of this class’s “collection view methods” are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove method, the iterator will throw a ConcurrentModificationException. </p>
<p>这个迭代器范回的是collection的映射元素，会抛出fail-fast异常。如果这个map结构被修改于任何时间在迭代器被创建之后，用任何方式除了迭代器自己的remove方法，这个迭代器都会抛出 快速失败异常</p>
<p>Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</p>
<p>因此。面对并发修改的时候，迭代器会快速而清晰的失败，而不是顶着是任意的风向和不确定的的行为在未知的时间</p>
<p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. </p>
<p>注意：迭代器的fail-fast行为不能像这样得到保障，一般来说，不可能硬性保证其一定出现在线程不安全的并发修改下</p>
<p>Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.</p>
<p>迭代器的Fail-fast尽最大努力在抛出ConcurrentModificationException，因此，为了正确性，需要编写一个程序，依赖于这个异常，来检验其错误。迭代器的fail-fast行为应该仅仅用于发现bug</p>
<p>This class is a member of the Java Collections Framework.</p>
<p>HashMap是Java集合框架下的成员。</p>
<p>————————————————————————————————————————————————————</p>
<p>分割线</p>
<p>Implementation notes.</p>
<p>This map usually acts as a binned (bucketed) hash table, but when bins get too large, they are transformed into bins of<br>TreeNodes, each structured similarly to those in java.util.TreeMap. </p>
<p>这个map通常为用桶（bucketed）实现的hash table，但是当桶的数量太大的时候，它们会转换成TreeNode，每个数据结构都与TreeMap类似。</p>
<p>Most methods try to use normal bins, but relay to TreeNode methods when applicable (simply by checking<br>instanceof a node).  Bins of TreeNodes may be traversed and used like any others, but additionally support faster lookup when overpopulated. </p>
<p>大多数方法都尽量使用普通的桶，但是当可以的时候（仅仅检查bin是否能够 instaneof node），就会转变成为TreeNode。桶或TreeNodes应该可以遍历而且用起来和其他的一致，但是进一步的支持快速的循环当数据过多的时候。</p>
<p>However, since the vast majority of bins in normal use are not overpopulated, checking for existence of<br>tree bins may be delayed in the course of table methods.</p>
<p>然后，通常桶的大多数使用都是在数据不多的时候。在使用table的方法的时候可能延迟检查桶是否存在</p>
<p>Tree bins (i.e., bins whose elements are all TreeNodes) are ordered primarily by hashCode, but in the case of ties, if two<br>elements are of the same “class C implements Comparable<c>“, type then their compareTo method is used for ordering. (We conservatively check generic types via reflection to validate this — see method comparableClassFor).  </c></p>
<p>树桶(桶里所有的元素都是TreeNodes)主要是根据hashCode排序的，但是在关联的情况下，如果两个元素是同样的类，都实现了Comparable接口，然后他们进行排序(我们保守检查类的类型通过反射来验证—see method comparableClassF-or)。</p>
<p>The added complexity of tree bins is worthwhile in providing worst-case O(log n) operations when keys either have distinct hashes or are orderable, Thus, performance degrades gracefully under accidental or malicious usages in which hashCode() methods return values that are poorly distributed, as well as those in which many keys share a hashCode, so long as they are also Comparable. (If neither of these apply, we may waste about a factor of two in time and space compared to taking no precautions. But the only known cases stem from poor user programming practices that are already so slow that this makes little difference.)</p>
<p>当key有不同的hashCode或者说是已排序的话，树桶（翻译很别扭，有时间看看别人怎么翻译的）的添加操作的最坏时间复杂度是O(log n)。然后，在hashCode()的意外或异常执行，产生不均匀的分布的话，性能将会平缓降级，除此之外，许多key共享一个hashCode，只要是可比较的。(如果两种情况都无法匹配的话，我们将会浪费factor两倍的时间和空间性能相对于不采取预防措施。但是这种仅知的情况来源于糟糕的用户代码实践，它们已经非常缓慢了，所以基本没有什么去呗)</p>
<p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). </p>
<p>因为TreeNodes的大小事普通节点的两倍，我们仅仅在桶里包含足够的节点的时候去保证使用它(参见 树化阈值—TREEIFY_THRESHOLD)</p>
<p>And when they become too small (due to removal or resizing) they are converted back to plain bins.</p>
<p>然后当它是比较小的时候(由于删除或者大小改变)，它将退化为普通箱。</p>
<p>  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a<br>parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of<br>resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The first values are:</p>
<p>0:    0.60653066<br>1:    0.30326533<br>2:    0.07581633<br>3:    0.01263606<br>4:    0.00157952<br>5:    0.00015795<br>6:    0.00001316<br>7:    0.00000094<br>8:    0.00000006<br>more: less than 1 in ten million</p>
<p>在拥有良好分布的hashCode的时候，树桶很少被使用。通常情况，在随机的hashCode情况中，树桶的节点分布遵循于Poisson distribution 分布方式（泊松分布），参数在在默认阈值0.75的条件下，平均数为0.5，尽管因为重新调整粒度有很大的方差变化。预计list的大小k公式是：<script type="math/tex">10^{-0.5} 0.5^k/k!</script></p>
<p>概率小于千万分之一</p>
<p>The root of a tree bin is normally its first node.  However, sometimes (currently only upon Iterator.remove), the root might be elsewhere, but can be recovered following parent links (method TreeNode.root()).</p>
<p>树桶的root节点通常都是它的第一个节点。然而，有些时候(当前已知的情况就是Interator的remove)，root可能会不是第一个节点，但是可以被父链接节点所恢复(TreeNode.root())</p>
<p>All applicable internal methods accept a hash code as an argument (as normally supplied from a public method), allowing them to call each other without recomputing user hashCodes. Most internal methods also accept a “tab” argument, that is normally the current table, but may be a new or old one when resizing or converting.</p>
<p>所有可使用的内部方法接受hash code作为参数(还有被支持的公开方法)，允许他们互相调用，且不进行重新计算hashCode。大多数内部方法通常接受tab这个参数，通常代表当前table，但是也可能是新的或者旧的当大小改变或者被覆盖的时候。</p>
<p>When bin lists are treeified, split, or untreeified, we keep them in the same relative access/traversal order (i.e., field<br>Node.next) to better preserve locality, and to slightly simplify handling of splits and traversals that invoke iterator.remove. When using comparators on insertion, to keep a total ordering (or as close as is required here) across<br>rebalancings, we compare classes and identityHashCodes as tie-breakers.</p>
<p>当桶的列表为树，分隔，或者非树的时候，我们保证他们在相同的访问/遍历顺序时能更好的保留位置。并且简单的处理split和遍历在调用iterator.remove的时候。当在插入的时候使用比较器，来在重新平衡的过程中保证总体是有序的(或者按要求关闭？)，我们使用类和hashcode作为连接断开器。</p>
<p>The use and transitions among plain vs tree modes is complicated by the existence of subclass LinkedHashMap. See<br>below for hook methods defined to be invoked upon insertion,removal and access that allow LinkedHashMap internals to otherwise remain independent of these mechanics. (This also requires that a map instance be passed to some utility methods that may create new nodes.)</p>
<p>由于存在子类LinkedHashMap，普通模式和树模式之间的使用和转变会变得复杂。参考钩子方法定义在了调用插入，删除和访问的时候，来允许LinkedHashMap使用其他方式来保证独立性(也同样需要这一个映射实例来传递一些有用的可能创建新节点的方法)。</p>
<p>The concurrent-programming-like SSA-based coding style helps avoid aliasing errors amid all of the twisty pointer operations.</p>
<p>这个并行编码方式用于SSA的编码风格的话有助于避免混乱错误在一些指针操作上面。</p>
<p>————————————————————————————————————————————————————</p>
<p>分割线。最长的注释就在上面，现在开始代码的阅读，产生的问题，会收集在另一篇文章里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//默认初始化大小必须为1左移4位，也就是2^4，也就是16，必须是2的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//最大容量，如果需要更大的容量，需要在构造方法中通过参数定义，必须是2的倍数，并且&lt;= 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//当构造方法不进行指定的时候，默认加载因子为0.75f</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用树而不是使用桶的数量的阈值。当在有很多元素的桶里最后添加一个元素的时候，桶会转换为树。这个值必须大于2而且应该最少有8个，以符合树移除元素后压缩转换为普通箱的假定</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//再重新设定大小操作的时候，何时进行树的分割退化操作的阈值。应该小于TREEIFY_THRESHOLD，然后最多6个匹配的在删除操作之后的收缩检测</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//每个可能被树化的桶的最小的链表的容量（或者说桶里的表的重新分配大小并且有太多节点的时候）</span></span><br><span class="line"><span class="comment">//应该至少有32的空间阈值来避免在重新分配大小和树化的时候产生的hash冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//基本hash桶节点，被大多数实体使用。看下面的TreeNode子类和LinkedHashMap都是Entry的子类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    V oldValue = value;</span><br><span class="line">    value = newValue;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">      Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">      <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">          Objects.equals(value, e.getValue()))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">   * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">   * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">   * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">   * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">   * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">   * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">   * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">   * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">   * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">   * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">   * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">   * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">   * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//又是一大段注释，真不想翻译这些，不想翻译吧，有些代码又看不懂，妈的还是自己太菜了。专八在乎这？</span></span><br><span class="line">  <span class="comment">//计算key的hashcode，然后高位和低位进行异或。因为链表使用了两倍的掩码，hashcode的集合仅仅在当前掩码变化的时候将会一直碰撞冲突。(已知的例子,一组浮点数会在小点的表里保持连续整数。)所以我们使用异或来将高位的冲撞向下传播。这是比特扩展在速度，功能和质量之间的折中。因为许多内容hash的集合是已经合理分布了的（所以不会从扩散中受益），而且因为我们使用树来处理桶中的大量元素，我们用一个比较便宜的方法来降低系统性能损耗，就是使用异或来转换一些bit。除此之外，包含最高位的bit位，因为表边界的原因，将不会使用计算过的下标，来归并高位的碰撞。</span></span><br><span class="line">  <span class="comment">//也不知道翻译对不对，哪里来个大佬带带我~~~</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//卧槽嘞，这个就更尼玛看不懂了啊，注释倒是很简单，返回两倍目标容量的大小，最大值是MAXIMUM_CAPACITY，最小值是1，这个numberOfLeadingZeros留岛问题里解答吧</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">   * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">   * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">   * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">//这个table在第一次使用的时候初始化，然后大小一定会改变。当进行分配空间的时候，大小通常都会是2的倍数(我们也会允许启动执行的机器上当前非必须的一些操作，它大小为0)</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">   * for keySet() and values().</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//entrySet的缓存，记录AbstractMap字段里keySet和values方法的使用</span></span><br><span class="line">  <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//key-value映射在map里的大小</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//modCount是HashMap发生变化或者修改了内部结构的时候（rehash），会改变这个数字，这个字段在iterator的集合视图操作的时候会产生 快速失败</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//下一个值当大小改变的时候(容量 * 负载因子)</span></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//hashtable 的负载因子</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//注释没什么翻译的，从这里能看出来，初始化的时候，容量最大为MAXIMUM_CAPACITY，不过话说Float.isNaN这个方法没看懂啊，先记下来，等等再看</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">      initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//也没什么翻译的，就是修改默认初始容量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &#123;<span class="doctag">@code</span> HashMap&#125; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//更加没什么翻译的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &#123;<span class="doctag">@code</span> HashMap&#125; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &#123;<span class="doctag">@code</span> Map&#125;.  The &#123;<span class="doctag">@code</span> HashMap&#125; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &#123;<span class="doctag">@code</span> Map&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//也没啥翻译的，下面的方法看起来比较重要</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">     * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//实现了Map的putAll方法和构造器，由此可见，map的putAll方法也是用的这个putMapEntries方法，等等到下面的时候验证下</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">        <span class="comment">//size/loadFactor + 1，他为什么要ft命名啊，特么的。先解释一下，因为所hashmap的capacity = threshold * loadFactor  ，所以用 size/loadFactor+1 就能得到threshold</span></span><br><span class="line">        <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">        <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">        <span class="comment">//这里会判断capacity是否大于threshold，大于的话，毫无一人，threshold扩容吧。。。</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">          threshold = tableSizeFor(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//和上面一样，不重复写了</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">      <span class="comment">//capacity和threshold确定之后，通过put方法进行设置</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">        K key = e.getKey();</span><br><span class="line">        V value = e.getValue();</span><br><span class="line">        putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//map的重头方法，get和put，这里到了get了，来翻一下。</span></span><br><span class="line">  <span class="comment">//返回value当key被映射的时候，如果不包含则返回null。通常情况下，map的key可以为null，有则返回value，没有则返回null，这里最多返回一个映射(value)。</span></span><br><span class="line">  <span class="comment">//当这个map不包含这个key的时候，返回null并不是必须的情况，这个key通常有可能就是为null，然后containsKey操作可能在使用的时候返回两种情况。distinguish是啥意思。。。擦泪</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//重头戏就是这个getNode了，下面解释</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//实现了map接口的get方法和relate方法</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//hashmap是数组加链表的实现方式，所以说，现根据hashcode获取到第一个链表的节点，等于null的话说明没有呗，[(n - 1) &amp; hash]得专门解读一下。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//每次都检测第一个链表节点，为了下面的递归或者说while循环做准备</span></span><br><span class="line">      <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">          ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="comment">//循环链表进行查找，找到到的话，就返回去，不然null呗</span></span><br><span class="line">      <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//链表在达到阈值(8)之后会转换为树节点，这个树是红黑树，树是怎么获取的，下面再写吧。</span></span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">     * specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">     * key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//不解释</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//重头戏之二，put方法。</span></span><br><span class="line">  <span class="comment">//将key和value的关联放到这个map，如果key之前已经有值，将会被替换。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//难怪叫hashmap啊，都是需要根据hash进行操作的，所以，重写hashcode方法是多么的重要，对不对</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//实现了Map的put方法和related方法，related是啥意思，重新延迟？</span></span><br><span class="line">  <span class="comment">//onlyIfAbsent是ture的话，不改变已经存在的value，应该是会被某些包装方法使用</span></span><br><span class="line"> <span class="comment">//evict如果是false，这个table将会是创建模式</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n是用来记录hashmap大小的，tab是内部table，p是当前节点。i是当前hash对应数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//如果这个hashmap初始化后还从未使用过，那么就用resize进行初始化操作</span></span><br><span class="line">      n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//先根据hash看数组是否有值，没有值得话，直接将新节点放进去。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">      tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如若不然，就开始链表(红黑树)的遍历，</span></span><br><span class="line">      Node&lt;K,V&gt; e; K k;</span><br><span class="line">      <span class="comment">//会先看当前链表首个元素的key和即将放入的key是否相等，相等的话，就不进行后面的遍历了。直接对它进行处理。不然的话，需要整体遍历去看hash是否有对应的节点存储。</span></span><br><span class="line">      <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">          ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">      <span class="comment">//当链表的元素的个数大于一定阈值的话，会转换为红黑树，所以，这里看节点是否已经变为了红黑树，如果已经变了，那么久按照红黑树的标准进行元素的插入，putTreeVal，后面看的时候在进行解释。</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非红黑树，那就普通链表遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">          <span class="comment">//因为说第一个元素已经进行过判断，所以直接next就可以。然后到了链表的最后一个位置，将val放到最后</span></span><br><span class="line">          <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//这里会看链表中的值是否已经到了树化的阈值，到了之后，会将链表转换为红黑树。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">              <span class="comment">//treeifyBin放到下边说</span></span><br><span class="line">              treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果key已经存在的话，那就直接break返回去。</span></span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          p = e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//不为null的话，说明key已经存在，那么进行覆盖，新值覆盖，旧值返回。</span></span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        <span class="comment">//onlyIfAbsent猜测是为了某些工具类的方便而使用的，后面验证</span></span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">          e.value = value;</span><br><span class="line">        <span class="comment">//linkedHashMap的回调，到时候再看吧</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//put会触发modCount的变化。</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//size变化，如果超过阈值的话，那么hashmap进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">      resize();</span><br><span class="line">    <span class="comment">//linkedHashMap's callback ，后面说</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//用于初始化或者表空间扩张(双倍)，如果是null的话，分配的空间是initial capactiy * threshold，另外，因为我们使用的是两倍膨胀，table里的每个元素都必须待在同样的下表下，或者两倍位移在新的table中。</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果table不为null</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果容量已经达到了最大的话，那么，不进行扩容，直接return</span></span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果newCapactiy &lt; oldCap/2 &amp;&amp; &lt; max_cap &amp;&amp; &gt;= inital_cap，那么，表进行双倍扩充</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">               oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">//double</span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//threshold不为0的话，那么，capacity = threshold</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">      newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">      <span class="comment">//都没初始化，那就取默认值，capacity == 1 &lt;&lt; 4 == 16，</span></span><br><span class="line">      <span class="comment">//threshold == 0.75f * 16 == 12</span></span><br><span class="line">      <span class="comment">//也就是说，阈值是总容量的3/4，也就是说，hashmap中，有至少四分之一的容量是被浪费了的</span></span><br><span class="line">      newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">      newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有capacity设置了，但是threshold没设置的话，会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//这里其实结果还是12，ft的意思应该是float_threshold</span></span><br><span class="line">      <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">      <span class="comment">//判断是否超出了最大值，然后阈值设置</span></span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// threshold setting</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//设置新的node数组大小</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//然后将table指向新的table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果hashmap没值得话，那就直接return，大小为初始化的值，如果不然，就进行数据迁移</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//循环数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">//如果数组的内容不为null的话，进行处理</span></span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//将oldTab数组对应的值设置为null，方便GC回收</span></span><br><span class="line">          oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//进行链表首个节点的判断</span></span><br><span class="line">          <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是treeNode的话，需要进行红黑树的扩容，至于这个split，后面碰到的话，再进行解释吧。</span></span><br><span class="line">            ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">          <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            <span class="comment">//还是挺反感这种命名方式的。写全点还是来的更直观一点。lo=low,hi=high。</span></span><br><span class="line">            <span class="comment">//low,high头尾节点，将单向链表变为双向链表。</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">//do-while进行链表的遍历操作</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              next = e.next;</span><br><span class="line">              <span class="comment">//这个e.hash &amp; oldCap是什么操作。。。</span></span><br><span class="line">              <span class="comment">//因为前面的hash方法没看，这里往下的东西，就看不懂了。。。</span></span><br><span class="line">              <span class="comment">//把hash方法看完回来了。e.hash是通过hash()方法获取到的值，在put的时候存放进去得，并不是说这个node本身的hashcode，这个还是得注意下。在另一篇文章里说了：hash &amp; (length-1)得到的是该元素对应的数字下标值，至于为什么(length-1)，是因为length是2的倍数，转换为二进制的话就是0010,0100,1000,10000等，所以需要-1变成为0001,0011,0111,1111来方便进行&amp;的操作。但是如果不-1的话，那么就是用最高位的1进行&amp;的操作（oldCap就是tableLength），也就是说，e.hash &amp; oldCap得到的值，如果hash是小于oldCap的话，那么一定是0，也就是说，随着oldCap的变化（2的倍数增长），e.hash &amp; oldCap的值就不一定一直为0了，比如说，14 &amp; 16，为0，17 &amp; 16 为1，但是随着oldCap变化为32的时候，再次到了这里，14 &amp; 31 == 0 ，但是17 &amp; 31 就也等于0了。</span></span><br><span class="line">              <span class="comment">//如果等于0的话，那么该hash是值比较小的，那么用lowTail来存储</span></span><br><span class="line">              <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                  loHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  loTail.next = e;</span><br><span class="line">                loTail = e;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//否则的话，说明hash&gt;=oldCap，值相对来说大一点，所以用highTail来存储</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                  hiHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  hiTail.next = e;</span><br><span class="line">                hiTail = e;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//hash值相对来说小点的node节点，用lowTail链表来存储，而大于oldCap的，用highTail存储，而且由于 hash &amp; oldCap != 0 ，因此，在扩容之后，该节点并不在原先数组的下标中存放。而是进行等量平移</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">              loTail.next = <span class="keyword">null</span>;</span><br><span class="line">              newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">              hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">              newTab[j + oldCap] = hiHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面这一段前移节点的代码，意思理解，但是为啥这么写，为啥用这种写法，还是不太理解。等自己实现一遍hashmap，应该说就能懂了吧。</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//根据得到的hash替换桶里的所有link node，除非表非常小，这种情况的话，用resize操作来代替</span></span><br><span class="line">  <span class="comment">//试一下windows是不是比较卡，好想确实比较卡啊</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果说tab的长度小于最小树化阈值的话，那么只改变大小，否则，进行树化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//首先根据hash获取到当前下边的元素</span></span><br><span class="line">      <span class="comment">//这个hd是Head ...的意思，tl 是tail ..的意思，能不用简写嘛</span></span><br><span class="line">      TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//返回一个tree node ，也就是将链表的节点换为红黑树的节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//然后进行关系的连接，虽然是tree node，但是这里，只是将单向链表转换为了双向链表</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">          hd = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          p.prev = tl;</span><br><span class="line">          tl.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tl = p;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//根据index获取到数组的元素，且设置为头结点，如果不为null的话，那么从头结点开始进行树化</span></span><br><span class="line">      <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//转换为红黑树</span></span><br><span class="line">        hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">      next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">      x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//如果root节点尚未设置的话，那么先指向root节点</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        x.parent = <span class="keyword">null</span>;</span><br><span class="line">        x.red = <span class="keyword">false</span>;</span><br><span class="line">        root = x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//然后根据hash值，进行左右节点的设置，然后进行红黑树的平衡</span></span><br><span class="line">        K k = x.key;</span><br><span class="line">        <span class="keyword">int</span> h = x.hash;</span><br><span class="line">        Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">          <span class="keyword">int</span> dir, ph;</span><br><span class="line">          K pk = p.key;</span><br><span class="line">          <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                   (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">          TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">          <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = xp;</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">              xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              xp.right = x;</span><br><span class="line">            root = balanceInsertion(root, x);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>英语短语</title>
    <url>/2019/04/29/Language/English/Phrase/</url>
    <content><![CDATA[<p>is simply ：不过，仅仅，根本，简直</p><p>take into account：考虑到；把…..计算在内</p><a id="more"></a>

<p>so as to：= in order to 以便；为使</p>
<p>be divided by：除以</p>
<p>ever occur：发生</p>
<p>in the face of：面对</p>
<p>rather than：而不是</p>
<p>generally speaking：一般来说</p>
<p>vast majority：绝大多数</p>
<p><a href="https://fanyi.baidu.com/#en/zh/as well as" target="_blank" rel="noopener">as well as</a>：既…又…; 除…之外; 此外</p>
<p>so long as：只要。“as/so long as”的变体</p>
<p>little difference：相差不大，没什么区别</p>
<p>due to ：由于</p>
<p>rather than：而不；与其…倒不如…</p>
<p>conflicts：冲突</p>
<p><a href="https://fanyi.baidu.com/#en/zh/in accord with" target="_blank" rel="noopener">in accord with</a>：一致; 相符</p>
<p>performed by：由……执行</p>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语短语</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList源码</title>
    <url>/2019/04/27/Source%20code%20reading/JDK/Collection/LinkedList/</url>
    <content><![CDATA[<blockquote>
<p>LinkedList是基于链表，是Java中线性表的链表实现。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>LinkedList实现了Deque接口，而Deque又继承自Queue，说明Linked是支持双/单向队列相关操作。</li>
</ul>
<p>问题：</p>
<ul>
<li>ArrayList继承于AbstractList，而LinkedList继承于AbstractSequentialList，这两个类区别在哪？(<strong>问题1</strong>)</li>
<li>ArrayList实现了RandomAccess接口，这个接口作用是什么？为什么实现？LinkedList为什么没有实现？(<strong>问题2</strong>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">      <span class="keyword">this</span>.item = element;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">      <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>由上可知，Node不仅指向了它的下一个节点，也有其上一个节点的指针。由此说明，LinkedList是双向循环链表，而非单向。</li>
<li>由于有first和last的引用，所以，使用queue相关操作会很方便。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>由于是链表，没有ArrayList的数组扩容和数组移动相关操作。数据多的情况下，add的性能优于ArrayList</li>
<li>指定位置add的话，如果是非最后一个位置添加元素，则需要根据下标先找到原先元素，在其之前进行操作。真是想方设法优化速度。。。</li>
<li>node()并不是完全从头开始遍历获取。而是根据index是否小于size的一半，来决前序遍历还是后序遍历。这里应该还能继续优化一次，用二分的话，一次次缩小区间，这样岂不是更小了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">  <span class="comment">//node方法在上面有</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>get需要循环遍历list的1/2。性能肯定比不上数组（ArrayList）的直接获取。</li>
<li>set方法并没有增加modCount。那么，循环中可以放肆的set….</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>remove方法可以看出，移除的是从头开始遍历里第一个匹配的元素。</li>
<li>indexOf也是如此，不贴代码了</li>
<li>lastIndexOf还是是从尾到头进行遍历，其他一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &#123;<span class="doctag">@code</span> null&#125; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &#123;<span class="doctag">@code</span> null&#125; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the last element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null last node l.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>Deque相关操作，peek,element,poll都是获取头部元素，区别在于：peek()如果没有的话，返回的是null，不进行删除；element如果没有，则是抛出NoSuchElementException，不进行删除；poll则是弹出，会移除头部元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>remove删除的是第一个元素，因为队列是FIFO。删除不掉，则抛出noSuchException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element as the tail (last element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque operations</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerFirst&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerLast&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>于队头或者队尾添加元素，没啥解释的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops an element from the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, removes and returns the first element of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #removeFirst()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the front of this list (which is the top</span></span><br><span class="line"><span class="comment"> *         of the stack represented by this list)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>LinkedList惊现Stack的操作，看了下源码这两个操作是在Deque接口定义的。</li>
</ul>
<p>问题解读：</p>
<ol>
<li>Sequentia意思为：顺序，连续。AbstractSequentialList继承于AbstractList，主要看AbstractSequentiaList实现了什么方法。图就不上了，实现的方法，都是通过Iterator来进行的实现（大量用到了策略模式），而AbstractList中，使用for循环来实现的。<strong>迭代器模式是为了提供方法访问聚合对象的元素，但是不暴露对象的内部表示</strong>。由注释可知<strong>This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a “sequential access” data store (such as a linked list). For random access data (such as an array), AbstractList should be used in preference to this class.</strong>  LinkedList使用该类会有更好的性能，而如果是支持随机访问的数据，比如ArrayList，应该优先使用AbstractList，会有更好的性能。</li>
<li>LinkedList不实现RandomAccess的原因有：使用AbstractSequentialList会有更好的性能。RandomAccess对于支持随机访问的(如ArrayList)有更好的性能。与Collections的indexedBinarySearch可以看到。对于实现了RandomAccess的接口，可以用二分方法进行更好的排序，拥有更好的性能。</li>
<li>总之，实现了RandomAccess 的接口，使用for i 循环会有更好的性能。而没有实现的，链表操作的，使用interator会有更好的性能。</li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读-前言</title>
    <url>/2019/04/26/Source%20code%20reading/Preface/</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><p>以前倒是也看过源码，但是看了就忘，很尴尬，用博客记录一下，加深一下印象。</p><p>源码版本为JDK12。</p><p>先进行集合类相关源码阅读。</p>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>前言</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码</title>
    <url>/2019/04/26/Source%20code%20reading/JDK/Collection/ArrayList/</url>
    <content><![CDATA[<blockquote>
<p> ArrayList是基于数组，是Java中线性表的顺序实现。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default initial capacity.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">   * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">   * first element is added.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">   * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">   * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">   * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>ArrayList的默认初始容量是10</li>
<li>内部数据是由一个Object[]来进行存储的，默认则是一个空数组</li>
</ul>
<p>问题：</p>
<ul>
<li>elementData是声明为transient的。这就意味着，它是不参与序列化的，但是用的时候并没有感觉，先往下看源码，等等找出来这个问题的答案。（<strong>问题1</strong>）</li>
<li>空数组是如何进行扩容？（<strong>问题2</strong>）</li>
<li>Object类型的数组是如何根据<em>泛型</em>来返回自定的数据格式？如果数据元素不一致会有什么情况？（<strong>问题3</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// defend against c.toArray (incorrectly) not returning Object[]</span></span><br><span class="line">        <span class="comment">// (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>为啥有两个Object[]？注释里说的很清楚：We distingush this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added。主要是区别于EMPTY_ELEMENTDATA以方便于知道第一个元素添加进去后数组是如何膨胀的。</li>
<li>如果说传入了一个collection，那么会将其转为Object[]</li>
</ul>
<p>问题：</p>
<ul>
<li>第一个元素添加后数组是如何膨胀的？（<strong>问题5</strong>）</li>
<li>看源码，是可以传入自定义初始大小的，那么自定义初始容量和默认容量如果不同的话，区别在哪里？（<strong>问题6</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum size of array to allocate (unless necessary).</span></span><br><span class="line"><span class="comment"> * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment"> * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment"> * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>list数组最大容量，如果超过了虚拟机允许的范围，那么会抛出<strong>OutOfMemoryError</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError if minCapacity is less than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a capacity at least as large as the given minimum capacity.</span></span><br><span class="line"><span class="comment"> * Returns the current capacity increased by 50% if that suffices.</span></span><br><span class="line"><span class="comment"> * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span></span><br><span class="line"><span class="comment"> * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError if minCapacity is less than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>grow是数组扩容的方法，扩容大小通过newCapacity来保证，其确保其至少能保存minimum capacity容量的元素。默认的扩容会在当前size的基础上加1后进行。</li>
<li>newCapacity保证返回的元素至少与minCapacity相等，每次在允许范围内扩容50%，但是不会大于MAX_ARRAY_SZE，除非给定的值已经大于它了。如果溢出的话，就返回最小值回去。</li>
<li>扩容的公式为 new = old + old &gt;&gt; 1，也就是上述的扩容50%的由来</li>
<li>如果new&lt;Int.max_size - 8的话，就看是否移除，否，直接返回int.max作为数组最大值，从此也能得知，list最大值就是int最大值，而Java中int无符号，也就是21亿。如果溢出，直接OutOfMemory。</li>
</ul>
<p>问题：</p>
<ul>
<li>minimum capacity是怎么定义的？每次是如何变化的？（<strong>问题7</strong>）</li>
<li>是什么时候触发的扩容？（<strong>问题8</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this list contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns &#123;<span class="doctag">@code</span> true&#125; if and only if this list contains</span></span><br><span class="line"><span class="comment"> * at least one element &#123;<span class="doctag">@code</span> e&#125; such that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Objects.equals(o, e)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this list is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Objects.equals(o, get(i))&#125;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOfRange(o, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>contains只能判断是否知道有一个元素在当前list中，多了不行。indexOf同样，只会返回第一个相等的元素的index。</li>
<li>contains需要循环整个list</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the highest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Objects.equals(o, get(i))&#125;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOfRange(o, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfRange</span><span class="params">(Object o, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>和indexOf相反</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns a shallow copy of this &#123;<span class="doctag">@code</span> ArrayList&#125; instance.  (The</span></span><br><span class="line"><span class="comment">  * elements themselves are not copied.)</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a clone of this &#123;<span class="doctag">@code</span> ArrayList&#125; instance</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">         v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">         v.modCount = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">return</span> v;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns an array containing all of the elements in this list</span></span><br><span class="line"><span class="comment">  * in proper sequence (from first to last element).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The returned array will be "safe" in that no references to it are</span></span><br><span class="line"><span class="comment">  * maintained by this list.  (In other words, this method must allocate</span></span><br><span class="line"><span class="comment">  * a new array).  The caller is thus free to modify the returned array.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This method acts as bridge between array-based and collection-based</span></span><br><span class="line"><span class="comment">  * APIs.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> an array containing all of the elements in this list in</span></span><br><span class="line"><span class="comment">  *         proper sequence</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>ArrayList的克隆为浅克隆，toArray也是浅克隆。所以可以放心大胆的删除，但是修改会导致有问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] es, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) es[index];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     Objects.checkIndex(index, size);</span><br><span class="line">     <span class="keyword">return</span> elementData(index);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Replaces the element at the specified position in this list with</span></span><br><span class="line"><span class="comment">  * the specified element.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">     Objects.checkIndex(index, size);</span><br><span class="line">     E oldValue = elementData(index);</span><br><span class="line">     elementData[index] = element;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>因为是基于数组实现，所以说，get和set一个元素速度极快。越界的话则会OutOfBounds。</li>
<li>由于是JDK12，checkIndex的方法放入到Objects下了。</li>
<li>由于get 和 set方法并没有修改modCount，所以，这两个方法可以放心大胆的于循环中使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This helper method split out from add(E) to keep method</span></span><br><span class="line"><span class="comment"> * bytecode size under 35 (the -XX:MaxInlineSize default value),</span></span><br><span class="line"><span class="comment"> * which helps when add(E) is called in a C1-compiled loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>直接添加的话，会添加到数组最后面，开销很小，如果容量不足，会进行扩容</li>
<li>指定下标添加的话，会进行数组间的元素复制，如果复制的元素很多，开销会比较大。如果指定的index&gt;size，不会进行扩容，而是抛出OutOfBounds。</li>
</ul>
<p>问题：</p>
<ul>
<li>modCount是干嘛的？有什么用？为什么要用？（<strong>问题9</strong>）</li>
<li>add方法里的s为什么是final的？（<strong>问题10</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E oldValue = (E) es[index];</span><br><span class="line">    fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = size = <span class="number">0</span>; i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>删除同样会导致modCount++。</li>
<li>如果删除的是最后一个元素，那么不会进行数组之前的复制操作。</li>
<li>clear会将数组里每个元素设置为0，但是数组并没有进行缩容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's Iterator.  The behavior of this operation is</span></span><br><span class="line"><span class="comment"> * undefined if the specified collection is modified while the operation</span></span><br><span class="line"><span class="comment"> * is in progress.  (This implies that the behavior of this call is</span></span><br><span class="line"><span class="comment"> * undefined if the specified collection is this list, and this</span></span><br><span class="line"><span class="comment"> * list is nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element from the</span></span><br><span class="line"><span class="comment"> *              specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = s - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index,</span><br><span class="line">                         elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>addAll如果在数组容量不够的情况下，才会进行扩容。</li>
<li>指定位置addAll的话，需要先将元素后移之后，在进行添加</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes from this list all of the elements whose index is between</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive.</span></span><br><span class="line"><span class="comment"> * Shifts any succeeding elements to the left (reduces their index).</span></span><br><span class="line"><span class="comment"> * This call shortens the list by &#123;<span class="doctag">@code</span> (toIndex - fromIndex)&#125; elements.</span></span><br><span class="line"><span class="comment"> * (If &#123;<span class="doctag">@code</span> toIndex==fromIndex&#125;, this operation has no effect.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if &#123;<span class="doctag">@code</span> fromIndex&#125; or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> toIndex&#125; is out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> fromIndex &lt; 0 ||</span></span><br><span class="line"><span class="comment"> *          toIndex &gt; size() ||</span></span><br><span class="line"><span class="comment"> *          toIndex &lt; fromIndex&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                outOfBoundsMsg(fromIndex, toIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    shiftTailOverGap(elementData, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Erases the gap from lo to hi, by sliding down following elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftTailOverGap</span><span class="params">(Object[] es, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(es, hi, es, lo, size - hi);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = (size -= hi - lo); i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>区间删除的操作会触发modCount++，以及，会锁容，这是和单纯的remove不同的地方。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Saves the state of the &#123;<span class="doctag">@code</span> ArrayList&#125; instance to a stream</span></span><br><span class="line"><span class="comment"> * (that is, serializes it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.io.IOException if an I/O error occurs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &#123;<span class="doctag">@code</span> ArrayList&#125;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &#123;<span class="doctag">@code</span> Object&#125;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioral compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitutes the &#123;<span class="doctag">@code</span> ArrayList&#125; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserializes it).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException if the class of a serialized object</span></span><br><span class="line"><span class="comment"> *         could not be found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.io.IOException if an I/O error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elementData = elements;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Invalid size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>其实通过这两个方法，来控制序列化。而为什么不适用transient，是因为trainsien会让elementData整个都进行序列化，而如果正好扩容的话，那岂不是尴尬了。50%的空间都被浪费掉了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">      subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;E&gt; root;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> SubList&lt;E&gt; parent;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<ul>
<li>list的sublist方法，返回的是一个内部类，相当于一个视图。但是这里有个惊天大坑，特么的SubList没有实现序列化的接口，这意味着他是不可序列化的。<strong>大坑！！！</strong></li>
</ul>
<p>问题解答：</p>
<ol>
<li>elementData虽然声明为transient，不参与序列化，但是实际上是为了性能考虑，ArrayList实现了writeObejct和readObject这两个方法，而Stream会通过这两个方法来进行对象的序列化。</li>
<li>当添加一个元素发现容量不足以添加，且没有超过最大值-8的时候，则进行扩容。最大值为Int.max</li>
<li>get的时候，通过强转来进行类型转换。如果不加泛型的话，那么get到的，都是Object类型的数据，需要自己手动强转，可控性会变弱，出错概率会很高。</li>
<li>忘记啥问题了</li>
<li>不膨胀，只有达到了elementData的容量之后才会进行扩容</li>
<li>默认容量是10，自定义容量就随意了。自定义容量适合于情况限制死的条件，比如说天上只有一个太阳一个月亮，那么capacity设置为2是合理的。但是如果说天上多少颗星星，还是默认的合适。如果说定义的过大，玩意有雾霾了，就会导致空间的浪费。</li>
<li>如果说使用add方法，那么minCapacity每次是size+1，但是如果使用的addAll，那么minCapacity的值就会加上collection的size之后在进行变化</li>
<li>容量达到了elementData的上限的时候，触发扩容</li>
<li>modCount会在iterator循环迭代的时候被拿去判断，如果使用了涉及到修改了modCount的方法，那么modCount的值会变化，而iterator会记录循环开始之前的值，一旦对比不通过，则会抛出ConcurrentModificationException。</li>
<li>final修饰的对象，是线程安全的。</li>
</ol>
<p>ArrayList还是比较简单的一个类，不过其中涉及到iterator的源码并没有看，还是需要抽时间看一下，然后进行补充。</p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2019/04/18/Data%20Struct/Sorting/</url>
    <content><![CDATA[<p>插入排序：</p><ul>
<li>直接插入</li>
<li>折半插入</li>
<li>2路插入</li>
<li>表插入</li>
<li>上面其实就是查找方式不同而已，操作还是一致的</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/InsertSort01.png" alt="插入排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/InsertSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/InsertSorting.java</a></li>
</ul><a id="more"></a>

<p>冒泡排序：</p>
<ul>
<li>类似于冒泡泡，每次将最大值浮到表面，浮动完毕之后，排序结束</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/BumbleSort01.png" alt="冒泡排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BumbleSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BumbleSorting.java</a></li>
</ul>
<p>快速排序：</p>
<ol>
<li>寻找一个基准点（pointer），进行循环，将比它小的放其左边，将比其大的放右边</li>
<li>然后对左右两个数组重复1的过程，最终结果就为排序后的结果</li>
<li>数组越大，速度越快。因为最快情况：基准点左侧只有一个元素，而剩下的元素全在基准点右侧，而去随机数的话，假设10W个元素，最坏情况的可能性为十万分之一。</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/QuickSort01.png" alt="算法图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/QuicklySorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/QuicklySorting.java</a></li>
</ol>
<p>希尔排序：</p>
<ul>
<li>缩小增量排序</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/ShellSorting01.png" alt="希尔排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/ShellSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/ShellSorting.java</a></li>
</ul>
<p>选择排序：</p>
<ul>
<li>类似于冒泡排序，不过每次讲最小值放入已排序的数组</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/SelectSort01.png" alt="选择排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/SelectSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/SelectSorting.java</a></li>
</ul>
<p>堆排序：</p>
<ul>
<li><p>构建一个堆，然后首尾互换，除了尾节点之外，再次构建堆，这就是堆排序的过程</p>
</li>
<li><p>堆排序，最主要的就是构建一个堆，而构建堆，需要知道最后一个非叶节点的位置。</p>
<ul>
<li>假设节点数目为n，最后一个非叶节点为i。</li>
<li>分两种情况<ul>
<li>由完全二叉树的性质可知：i的左子节点为2i+1，i的右子节点为2i+2</li>
<li>只有左子节点，那么该节点下标为n-1，那么，2i+1=n-1，可以推出i=n/2 -1 </li>
<li>有左/右子节点，那么左子节点下标则为n-2，右子节点下标为n-1，2i+2=n-1，i= (n-3)/2=n/2-3/2。由于二叉树最后一个节点为左孩子，那么该二叉树的节点数为偶数，反之，则为奇数。再因为java中，除不尽则向下取整，因此，i=n/2-1</li>
</ul>
</li>
<li>i=n/2-1得证</li>
</ul>
</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/HeapSort01.png" alt="堆排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/HeapSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/HeapSorting.java</a></li>
</ul>
<p>归并排序：</p>
<ul>
<li>采用分而治之的思想（divide-and-conquer），拆分成最小单元进行排序后，一步一步进行合并</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/MergeSort01.png" alt="归并排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/MergeSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/MergeSorting.java</a></li>
</ul>
<p>基数排序：</p>
<ul>
<li>也比较简单，个位开始，依次开始对比，放入对应的bucket中</li>
<li>然后十位，百位，以此类推，到了某一位，所有数字都没有的话，排序结束，输出结果则为排序后的内容</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/RadixSort01.png" alt="基数排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/RadixSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/RadixSorting.java</a></li>
</ul>
<p>桶排序：</p>
<ul>
<li>和上面基数排序很像，不过桶排序的<strong>映射函数</strong>为<script type="math/tex">f=array[i]/k，k^2=n</script>。n为所有元素个数</li>
<li>然后设置一个定量的桶，将元素放到对应的桶里，然后对每个非空的桶进行排序（插入，选择等）</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/BucketSort01.png" alt="桶排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BucketSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/BucketSorting.java</a></li>
</ul>
<p>计数排序：</p>
<ul>
<li>最快的排序，类似于桶排序和基数排序。</li>
<li>给每个元素一个桶</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Sort/CountingSort01.png" alt="计数排序图解"></li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/CountSorting.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/sorting/CountSorting.java</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>目前系统中的问题</title>
    <url>/2019/04/17/Essay/2019/Some%20Error%20in%20APlus%20System/</url>
    <content><![CDATA[<p>项目有如下几个（后端）：</p><ul>
<li>jx</li>
<li>yx</li>
<li>yy</li>
</ul><p>问题如下：</p><ol>
<li><p>项目名称</p>
<ul>
<li><p>如果有新项目，缩写也是yy，则会有冲突，就会变成yy1或者yy-sfdsf，无法见名知意，影响效率。</p>
</li>
<li><p>沟通之间难以顺畅交流。</p>
</li>
</ul>
</li>
<li><p>数据字典</p>
<ul>
<li>无法见名知意，影响开发，维护的效率，比如说：ZYYWZC006-TF003，谁能看得懂。</li>
<li>网络IO消耗较大，于jx,yx之前的旧代码中(前期代码风格来源于yx)，一个列表20个字段，其中5个是字典项，则一行数据会走5次数据字典的请求，一页20行，则会走20<em>5=100次请求。假设一次耗时100ms，100 </em> 100ms=10000ms=10s。后期代码，加了统一的JSON转译，编写复杂度有所下降，且一行数据只请求一次，网络IO耗时下降。</li>
<li>一些代码(前端 or 后端)，直接将字典值写死与项目中，后期维护难度加大，效率降低。</li>
<li>查看测试环境，107和108和yx三个库，每个都有数据字典的表，用的哪个，还是说全部都在用？若数据字典修改，产品可能只修改yx的，但是其他的没有修改，开发，维护，沟通都会受到阻碍。效率降低。</li>
<li>省市区存在于数据字典中，且取的是ID，若想去国家统一区域代码，需要统一（前后端）进行二次处理。耗费性能耗费时间耗费精力。</li>
</ul>
</li>
<li><p>服务划分边界</p>
<ul>
<li>服务划分是按照产品的模块进行划分，不合理，如A &amp; B，应该为一个服务才对，但是技术却按照产品原型划分，不考虑后期，不考虑前期，外包风格。由于A &amp; B不应分开，导致开发，维护，效率低下。</li>
<li>服务边界随意制定，没有进行充分考虑。如，X 应属于A服务，但是产品将其放置于B服务，然后不进行考虑，随着产品原型放入B。后期产品意识到了这个问题，将其改回去A服务，技术由于相关原因，知道不合理，却无法迁移回去。</li>
<li>目前虽然是所谓的微服务，但是由于设计原因，却是将服务当成service来用。代码之间耦合性极大，没有起到微服务高内聚低耦合的效果。服务界限非常模糊。</li>
</ul>
</li>
<li><p>使用MyBatis存在的问题</p>
<ul>
<li>项目中很多都是like %%，索引无法应用，查询速度会降低非常多。</li>
<li>sql全部手写，且大部分都是单表操作，开发效率极低</li>
<li>产品经常修改，导致mapper,entity,resultmap,wiki,db，全都都需要修改，效率极低，BUG率极高</li>
<li>微服务，但是MyBatis不进行多表查询，且没有DBA，无法发挥出MyBatis的优势</li>
</ul>
</li>
<li><p>安全问题</p>
<ul>
<li>各个服务之间，目前仅仅能限制登录访问。更细粒度的访问控制，目前没有</li>
<li>所谓的菜单权限，只是前端无法看见而已，如果浏览器地址栏直接输入，基本什么数据都能返回的回去，菜单安全只是假安全</li>
<li>用户体系混乱，这个大部分是产品设计问题</li>
<li>密码为MD5加密且无盐，基本等同于没有加密，且浏览器地址栏直接调用用户查询的话，所有用户用密码什么的全部都会返回回去</li>
</ul>
</li>
<li><p>注释问题(也可以说复杂度的问题)</p>
<ul>
<li>实体的注释，wiki的注释，db的注释，swagger的注释，改一个，所有地方都要改，效率低下</li>
<li>由于用的数据字典，entity用的String，根本不知道什么意思</li>
</ul>
</li>
<li><p>项目测试问题</p>
<ul>
<li>无单元测试，导致，随便一个问题，比如说加了个字段，都需要整体回归测试一遍</li>
<li>test环境无法使用，且uat环境构建极慢，测试及其困难，压力变相集中在测试人员身上。加大测试人员工作量，增加沟通成本。</li>
</ul>
</li>
<li><p>产品存在的问题(重点问题)</p>
<ul>
<li>先说一下，说白了，开发人员都是搬砖的，只是其中有技术员，建造师，首席建造师，可能还有科学家等等。而产品是设计师，是艺术家，是乔布斯。设计的不好，考虑的不周，根源就很难改变。</li>
<li>列表页<ul>
<li>假设有A，其中有id,name,phone,address三个字段，有B，其中有,orderedTime,orderCode,content三个字段。</li>
<li>A的列表页，只展示A的属性，B的列表页，除了B的属性之外，还展示了A的name,phone属性。但是另一个地方，又有一个C，这个地方不仅展示了A的name和phone，还展示了address。又有一个D，展示的更多。</li>
<li>微服务架构（现在勉强算）下，都是单表操作，因此会冗余字段在表里，如果设计不统一，冗余字段越来越多，难以维护（这其中有MyBatis的锅）。如果不冗余，每次都查询其他表，封装DTO，则会导致工作量的加大。同时，参考对数据字典的描述，对性能影响也会很大。</li>
</ul>
</li>
<li>详情页<ul>
<li>详情页很多其他页面的列表页嵌套。</li>
<li>列表页统计项很多，且统计项加入查询。</li>
<li>有专门的统计页面可以干，何必每个地方都放一份</li>
<li>权限不好弄，而且，界面模糊，用的人不知道从哪到底能看，只记得哪都能看，极大的可能就会每个详情都点进去看有没有。</li>
</ul>
</li>
<li>固定条件项(数据字典)<ul>
<li>比如说，准驾车型。众所周知，中国准驾车型包含有——A1,A2,A3,B1,B2,C1,C2,C3,C4,C5,D,E,F,M。这些应该只有一套在系统里，这些都是通用的，如果说，A页面只想用A1,A2，B页面只想用C1,C2，产品要求只显示这么几个，就会导致数据字典(或者说枚举)里存在多个字典项，一个为最全的，一个为A1,A2，一个为C1,C2。开发，维护复杂度激增。且代码无法复用，效率影响很大。不应该觉得说我这就只能C1或者C2，不现实。太原市电动车执行新国标，如果说，电动车速到了25KM每小时，视为机动车辆，这时候，如果没有增加E或者F驾照的话，视为违章处理，直接扣车。以至于，太原市驾校报考摩托车驾照的人数激增。</li>
<li>能通用的条件应尽量通用，如：培训科目有四个：科目一，科目二，科目三，科目四。所有用到科目这个字段的地方，应当也是这四个科目，而不应该说，只有科目一或者科目二等等。</li>
</ul>
</li>
<li>修改所导致的问题，事故的预判<ul>
<li>比如，A服务修改，但是使用到A服务的，可能有B,C,D,E等等，极端情况下，这些地方都需要修改一次。产品应做好预判。同时，技术也应该做好预判。</li>
</ul>
</li>
</ul>
</li>
</ol><a id="more"></a>



<p>建议解决办法如下：</p>
<ol>
<li>项目名称用统一代表标识(比如说，eclipse前年的版本号为Oxygen，一看就知道是什么版本，什么时候发布的)，不推荐每个release过程都一个代号，但是每个项目应该有一个代号来代称。</li>
<li>全面抛弃数据字典，统一使用枚举进行相关工作。随之而来的就是一堆问题：<ol>
<li>MyBatis对枚举支持不友好。如果换成枚举，则ORM框架应当变更为Spring Data JPA。</li>
<li>yx,jx所有列表页，详情页等等，后端代码需要重写，同时，前端代码，需要重新联调，耗时很长。有些地方，甚至需要产品层面进行相应变更。</li>
<li>地区，应按照国标进行存储，数据库只存code，提供统一接口进行处理，而非code以及含义全部入库，如学员，现在更简单，全部存到address这个字段上，如有变化或者新的需求，效率太低。</li>
<li>合库合表</li>
</ol>
</li>
<li>抛弃微服务，业务不了解，技术不了解，边界区分不了，且目前微服务是当成service来用，发挥不出优势，应抛弃，整合，然后资源足够，业务成熟的情况，进行微服务拆分。</li>
<li>需与产品进行沟通，按照产品的风格，选择MyBatis or Spring Data JPA。</li>
<li>应当根据现在的情况，以后以后的可能性，重新设计Security系统，需要产品同时进行规划RBAC。</li>
<li>面向对象，而不面向数据库，注释只存在一份即可，wiki能自动生成最好。</li>
<li>单元测试添加，环境隔离。</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>清静经</title>
    <url>/2019/04/17/Essay/2019/%E6%B8%85%E9%9D%99%E7%BB%8F/</url>
    <content><![CDATA[<p><strong>老君曰：</strong>大<a href="http://www.zxuew.cn/daodejing/" target="_blank" rel="noopener">道</a>无形，生育天地；大道无情，运行日月；大道无名，长养万物；吾不知其名，强名曰道。夫道者：有清有浊，有动有静；天清地浊，天动地静；男清女浊，男动女静；降本流末，而生万物。清者浊之源，动者静之基；人能常清静，天地悉皆归。</p><a id="more"></a>
<p>夫，人神好清，而心扰之；人心好静，而欲牵之。常能遣其欲，而心自静；澄其心，而神自清；自然六欲不生，三毒消灭。所以不能者，为心未澄，欲未遣也，能遣之者：内观其心，心无其心；外观其形，形无其形；远观其物，物无其物；三者既无，唯见於空。观空亦空，空无所空；所空既无，无无亦无；无无既无，湛然常寂。寂无所寂，欲岂能生；欲既不生，即是真静。真常应物，真常得性；常应常静，常清静矣。如此清静，渐入真道；既入真道，名为得道；虽名得道，实无所得；为化众生，名为得道；能悟之者，可传圣道。</p>
<p><strong>老君曰：</strong>上士无争，下士好争。上<a href="http://www.zxuew.cn/daodejing/" target="_blank" rel="noopener">德</a>不德，下德执德，执著之者，不明道德。众生所以不得真道者，为有妄心，既有妄心，即惊其神，既惊其神，即著万物，既著万物，即生贪求，既生贪求，即是烦恼，烦恼妄想，忧苦身心，便遭浊辱，流浪生死，常沉苦海，永失真道。真常之道，悟者自得；得悟道者，常清静矣！</p>
<p><strong>仙人葛翁曰：</strong>吾得真道，曾诵此经万遍。此经是天人所习，不传下士。吾昔受之於东华帝君，东华帝君受之於金阙帝君，金阙帝君受之於西王母。西王母乃口口相传，不记文字。吾今於世，书而录之。上士悟之，升为天官；中士修之，南宫列仙；下士得之，在世长年。游行三界，升入金门。</p>
<p><strong>左玄真人曰：</strong>学道之士，持诵此经者，即得十天善神，拥护其身。然後玉符保神，金液炼形。形神俱妙，与道合真。</p>
<p><strong>正一真人曰：</strong>人家有此经，悟解之者，灾障不干，众圣护门。神升上界，朝拜高真。功满德就，相感帝君。诵持不退，身腾紫云。</p>
]]></content>
      <categories>
        <category>别人写的</category>
      </categories>
      <tags>
        <tag>静心</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2019/04/16/Data%20Struct/Graph/</url>
    <content><![CDATA[<ol>
<li>图的概念<ul>
<li>基本概念：图结构中，任意两个节点之间的关系是任意的，途中任意两个数据元素之间都可能相关。</li>
<li>ADT：<ul>
<li>数据对象V：数据元素集合，顶点集；</li>
<li>数据关系R：<ul>
<li>R={VR}</li>
<li>VR={<v,w>| <script type="math/tex">v,w \in V</script> 且P(v,w)，<v,w>表示从v到w的弧，P(v,w)定义了弧<v,w>的意义或者信息}</v,w></v,w></v,w></li>
</ul>
</li>
</ul>
</li>
<li>顶点：图中的数据元素</li>
<li>弧：<v,w>表示从v到w的一条弧;v是顶点的集合；vr是两个顶点之间关系的集合<ul>
<li>有向图<ul>
<li><script type="math/tex"><v,w> \in VR</script>，v为弧尾，w为弧头</li>
</ul>
</li>
<li>无向图<ul>
<li>若<script type="math/tex"><v,w> \in VR</script>，必有<script type="math/tex"><w,v> \in VR</script>，用(v,w)表示一条边</li>
</ul>
</li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Graph/01.png" alt="有向图和无向图图例"></li>
</ul>
</v,w></li>
<li>定点数n和弧的数目e：<ul>
<li>无向图：<script type="math/tex">0 \le e \le {\frac 1 2} n(n-1)</script></li>
<li>有向图：<script type="math/tex">0 \le e \le  n(n-1)</script></li>
</ul>
</li>
<li>完全图：有n(n-1)/2条边的无向图</li>
<li>有向完全图：有n(n-1)条弧的有向图</li>
<li>稀疏图：边或弧很少的图</li>
<li>稠密图：边或弧较多的图</li>
<li>子图：<script type="math/tex">G=(V,{E})，G1=(V1,{E1})</script>，若<script type="math/tex">V1 \subseteq V</script>，且<script type="math/tex">E1 \subseteq E</script>，则称G1为G的子图</li>
<li>邻接点：无向图中，<script type="math/tex">(V,V1) \in E</script>，则v,v1互为邻接点</li>
<li>顶点v的度：与v相关联的边的数目，TD(v)</li>
<li>有向图中，若<v,v1> \in A，则顶点v邻接到顶点v1，而顶点v1邻接自v<ul>
<li>出度：以v为尾的弧的数目，OD(v)</li>
<li>入度：以v为头的弧的数目，ID(v)</li>
<li>TD(v) = OD(v) + ID(v)</li>
</ul>
</v,v1></li>
<li>路径<ul>
<li>无向图中顶点v到v1的路径：一个顶点序列</li>
<li>有向图中，路径也是有向的</li>
<li>回路</li>
<li>简单路径：顶点序列中顶点不重复的路径</li>
</ul>
</li>
<li>连通图、连通分量、强连通图、强连通分量<ul>
<li>无向图中：顶点v到顶点v1有路径，则v和v1是连通的</li>
<li>如果图G中任意两个点都是连通的，则图G就是连通图</li>
<li>连通分量：无向图中的极大连通子图</li>
<li>有向图中：若任意的顶点vi到vj都有路径，则为强连通图</li>
<li>强连通分量：有向图中的极大连通子图</li>
</ul>
</li>
<li>一个连通图的生成树：一个极小连通子图，含有途中全部节点，但只有足以构成一棵树的n-1条边。<ul>
<li>一棵有n个顶点的生成树有且仅有n-1条边</li>
<li>但有n-1条变得图不一定是生成树</li>
</ul>
</li>
<li>有向图<ul>
<li>如果有一个顶点的入度为0，其余顶点的入度都为1，则是一个有向树。</li>
</ul>
</li>
</ul>
</li>
<li>图的存储结构<ul>
<li>数组表示：两个数组分别存放顶点信息和弧信息<ul>
<li>代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/graph/ArrayGraph.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/graph/ArrayGraph.java</a></li>
</ul>
</li>
<li>链式结构：为途中没一个顶点创建一个单链表，其中的节点表示与依附于顶点的边<ul>
<li>链表存储</li>
<li>十字链表——有向图</li>
<li>邻接多重表——无向图</li>
</ul>
</li>
<li>遍历方式<ul>
<li>深度优先</li>
<li>广度优先</li>
<li>比较简单，类似于树的先序遍历和中序遍历</li>
</ul>
</li>
</ul>
</li>
</ol>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2019/04/12/Data%20Struct/Tree/</url>
    <content><![CDATA[<p><strong>树的定义</strong>：</p><ul>
<li>一棵树是一些节点的集合。这个集合可以是空集；若的不是空集，则树由称作<strong>根（root）</strong>的节点<script type="math/tex">r</script>以及0个或者多个非空的(子)树<script type="math/tex">T_0，T_1…..，T_k</script>组成，这些子树中每一棵的根都被来自根<script type="math/tex">r</script>的一条有向的<strong>边（edge）</strong>所连结。</li>
<li>一棵树是<script type="math/tex">N</script>个结点和<script type="math/tex">N-1</script>条边的集合，其中的一个节点叫做根。</li>
<li>没有儿子的结点成为<strong>树叶（leaf）</strong>，叶节点。</li>
<li>具有相同父亲的节点为<strong>兄弟（siblings）</strong>节点</li>
<li>从节点<script type="math/tex">n_1</script>到<script type="math/tex">n_k</script>的<strong>路径（path）</strong>定义为节点<script type="math/tex">n_1，n_2，……，n_k</script>的一个序列，使得对于<script type="math/tex">1\le i \lt k</script>的节点<script type="math/tex">n_i</script>是<script type="math/tex">n_i+1</script>的父亲。这条路径的<strong>长（length）</strong>是位该路径上的边的条数，即<script type="math/tex">k-1</script>。从每一个节点到它自己都有一条边长为0的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。</li>
<li>对任一节点<script type="math/tex">n_i，n_i</script>的<strong>深度（depth）</strong>为从根到<script type="math/tex">n_i</script>的唯一的路径的长。因此，根的深度为0。<script type="math/tex">n_i</script>的<strong>高（height）</strong>是从<script type="math/tex">n_i</script>到一片树叶的最长路径的长。因此所有的树叶的高都是0。一棵树的高等于它的根的高。一棵树的深度等于它的最深的树叶的深度；该深度总是等于这棵树的高。</li>
<li>如果存在从<script type="math/tex">n_1</script>到<script type="math/tex">n_2</script>的一条路径，那么<script type="math/tex">n_1</script>是<script type="math/tex">n_2</script>的一位<strong>祖先（ancestor）</strong>而<script type="math/tex">n_2</script>是<script type="math/tex">n_1</script>的一个<strong>后裔（descendant）</strong>。如果<script type="math/tex">n_1 \neq n_2</script>，那么<script type="math/tex">n_1</script>是<script type="math/tex">n_2</script>的<strong>真祖先（proper ancestor）</strong>而<script type="math/tex">n_2</script>是<script type="math/tex">n_1</script>的<strong>真后裔（proper descendant）</strong>。</li>
</ul><a id="more"></a>

<p><strong>满二叉树</strong>：一棵深度为k且有2^k-1个节点的二叉树</p>
<p><strong>完全二叉树</strong>：深度为k有n个节点的二叉树，并且仅当其每一个节点都与深度为k的满二叉树中编号从1至n的节点一一对应时，成为完全二叉树。</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/01.png" alt="树图"></p>
<p><strong>二叉树的性质</strong>：</p>
<ul>
<li>在二叉树的第i层上至多有<script type="math/tex">2^i+1 个</script>结点(<script type="math/tex">i>=1</script>)</li>
<li>深度为k的二叉树至多有<script type="math/tex">2^k -1</script>个结点(<script type="math/tex">k>=1</script>)</li>
<li>对任何一棵二叉树T，如果其终端节点数为<script type="math/tex">n_0</script>，度为2的结点数为<script type="math/tex">n_2</script>，则<script type="math/tex">n_0=n_2+1</script></li>
<li>具有n个结点的完全二叉树的深度为<script type="math/tex">(log_2n) + 1</script></li>
<li>如果有一棵有n个结点的完全二叉树(其深度为<script type="math/tex">(log_2n)+1</script>层，每层从左到右)，则对任一结点i(<script type="math/tex">1 \le i \le n</script>)，有：<ul>
<li>如果i=1，则节点i是二叉树的根，无双亲；若i&gt;1，则其parent(i)是节点 i/2</li>
<li>如果2i&gt;n，则节点i无左孩子(节点i为叶子节点)；否则其做孩子leftChild(i)是节点2i</li>
<li>如果2i+1&gt;n，则节点i无右孩子；否则其有孩子rightChild(i)是节点2i+1</li>
</ul>
</li>
</ul>
<p>二叉树的<strong>顺序存储</strong>：</p>
<ul>
<li>就是将完全二叉树上编号为i的节点元素存储在数组对应的下标中。</li>
<li>利用二叉树的最后一条性质，可以快速定位到二叉树的左右子节点和父节点。</li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/ArrayBinTree.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/ArrayBinTree.java</a></li>
</ul>
<p>树的<strong>遍历方式</strong>（模板为上图的完全二叉树）：</p>
<ul>
<li>先序（根）遍历<ul>
<li>对节点的处理工作是在它的诸儿子节点被处理之前进行的</li>
<li>遍历结果为 1   2   4   8   9   2   10   11   3   6   12   13   7   14   15 </li>
</ul>
</li>
<li>中序（根）遍历<ul>
<li>中序遍历左子树，然后访问根节点，然后中序遍历右子树</li>
<li>遍历结果为 8   4   9   2   10   2   11   1   12   6   13   3   14   7   15</li>
</ul>
</li>
<li>后序（根）遍历<ul>
<li>一个结点初的工作是在它的诸儿子节点被计算后进行的</li>
<li>遍历结果为  8   9   4   10   11   2   2   12   13   6   14   15   7   3   1 </li>
</ul>
</li>
<li>示例代码地址：<a href="https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/LinkedBinTree.java" target="_blank" rel="noopener">https://github.com/wenslo/data_struct_java/blob/master/src/main/java/com/github/wenslo/ds/tree/LinkedBinTree.java</a></li>
</ul>
<p><strong>线索二叉树</strong>：</p>
<ul>
<li><p>对二叉树进行中序排序，将所有的节点右子节点为空的指针指向它的后继节点，将所有的节点左子节点为空的指针指向它的前驱节点。如下图所示</p>
</li>
<li><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/02.png" alt="线索二叉树"></p>
</li>
</ul>
<p>树的<strong>存储结构</strong>：</p>
<ul>
<li>双亲表示法：除了根节点之外，每个节点都会指向其双亲</li>
<li>孩子表示法：每个节点，如果有子节点，则都会指向其子节点</li>
<li><strong>孩子兄弟表示法：两个链域，左链域指向其第一个子节点，右链域指向其第一个兄弟节点</strong></li>
<li><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/03.png" alt="树表示法图例"></li>
</ul>
<p>森林：就是好多棵树</p>
<p>森林/树与二叉树的互相转换：</p>
<ul>
<li><p>森林转换为二叉树</p>
<ul>
<li><script type="math/tex; mode=display">F={T_1,T_2……T_m}$$是森林，转为二叉树$$B=(root,LB,RB)</script></li>
<li>若<script type="math/tex">F</script>为空，则m=0，B为空</li>
<li>若<script type="math/tex">F</script>非空，则B的根root是森林中的第一棵树的根<script type="math/tex">ROOT(T_1)</script>；B的左子树LB是从<script type="math/tex">T_1</script>中根节点的子树森林<script type="math/tex">F1={T_1,T_2……T_m}</script>转换而成的二叉树；B的右子树RB是从森林<script type="math/tex">F2={T_1,T_2……T_m}</script>转换而成的二叉树 </li>
</ul>
</li>
<li><p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/Tree/04.png" alt="森林，树，二叉树相互转换图"></p>
</li>
</ul>
<p>最优二叉树(哈弗曼树)：</p>
<ul>
<li><strong>概念：带权路径长度最短的树</strong></li>
<li><strong>路径长度：结点之间的树枝的总数</strong></li>
<li><strong>树的路径长度：从根到每一结点的路径长度之和</strong></li>
<li><strong>树的带权路径长度：叶子结点的带权路径长度之和。设有</strong> <strong>n</strong> <strong>片叶子，它们的权值分别为<script type="math/tex">w_1,w_2,…w_n</script>相应的路径长度分别为<script type="math/tex">l_1,l_2,…,l_n</script></strong>，则树的带权路径长度（Weight Path Length）可记为：<script type="math/tex">WPL=\sum_{k-1}^n w_k l_k</script></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis VS Hibernate</title>
    <url>/2019/04/11/Essay/2019/MyBatis%20VS%20Hibernate/</url>
    <content><![CDATA[<p>&emsp;&emsp;很多公司招聘的时候都会说，掌握SSH/SSM其中一种。H指的就是Hibernate，M就是MyBatis。现在大部分的选择其实就是这两种。但是这两种框架有什么优缺点？选型的时候该如何进行选择？这其实是一个比较值得深究一下的问题。</p><a id="more"></a>
<p>&emsp;&emsp;从几个角度来对比一下他们之间的区别，先从<strong>开发效率</strong>的角度来说说。</p>
<p>&emsp;&emsp;如果数据库频繁改动，比如说某张表加字段了，需要自己去alter table修改，加一个字段改一次，如果创业初期，业务不明确，那么，修改字段的情况，是经常可能会发生的，那就意味着，需要在维护上付出很多的成本，而Hibernate在这方面，自动管理，手动维护的情况比较少，因此，<strong>数据库表频繁改动的情况下，Hibernate完胜</strong>。如果数据库表不频繁改动，比如说接项目的，或者说外包，合同里已经把所有的可能的字段都给描述清楚了，<strong>在项目周期比较长的话，且不考虑二期甚至更后的情况下，Hibernate和MyBatis五五开吧</strong>。但是说，没有哪个程序员，愿意把时间花费在这些琐碎的事情上（建表，加字段，加数据库字段注释）吧，至少说我不愿意，时间是有限的，精力也是有限的，这些无意义或者意义比较小的事情，对精力损耗非常大，因此，<strong>我个人倾向于Hibernate</strong>。</p>
<p>&emsp;&emsp;日常开发中，MyBatis的优点就是：<strong>SQL全都都是手写，定制型极强，非常能体现出使用者的SQL水平</strong>；写起来非常自由，各种表关联随心所欲，各种查询条件组合随心所欲；如果公司配置的有DBA的话，查询效率能够得到很大的保障。但是缺点的话也比较明显：参数返回一般就是两种，ResultMap和ResultType，前者返回一个map，使用者从map中取自己想要的数据，后者返回一个DTO，使用者需要自己定义Bean，同时，mapper.xml中也需要定义map映射，相对来说，比较费劲，工作量会比较大一点。<strong>Hibernate在复杂查询方面，被MyBatis完爆；不过Hibernate在单表操作的话，完胜MyBatis。</strong>虽然说MyBatis也有插件(Mybatis Plus ，MyBatis Plugin)等来生成对应的简单CURD，但是，还是上面说的，一旦字段改动频繁，那就是一个噩梦。</p>
<p>&emsp;&emsp;再从<strong>执行效率</strong>上对比一下。</p>
<p>&emsp;&emsp;MyBatis的天花板很高，地板也很低。天花板的话，就是DBA甚至更高。能够对每一个字段的效率控制到极致；地板的话，就是各种CV，直接select *的这种，各种嵌套查询，慢SQL。其实和数据库了解程度有点关系，但是说MyBatis里写SQL有两种方式，第一种写mapper.xml里，第二种就是写注解里，项目小而简单的话还好，一旦有了点复杂度，写的还不规范，估计没人想看，间接会导致成本增加。</p>
<p>&emsp;&emsp;Hibernate的话，如果不做配置，每次查询，都是所有字段全部查询出来，如果表里有大字段(TEXT)，那速度和MyBatis只查某些具体字段，压根没得比。也就是说，Hibernate需要了解的东西更多，如果不了解，只单纯最基本的用的话，执行效率和MyBAtis差不多，但是随着字段变大变多，如果不做配置，肯定不如说按需查询所来的速度快。当然，如果有足够的知识储备的话，Hierbnate速度并不慢。</p>
<p>&emsp;&emsp;再从<strong>学习成本</strong>对比一下。</p>
<p>&emsp;&emsp;MyBatis的一大特点就是：上手速度极快，看几眼，就能够直接上手，门槛极低。而Hibernate相对来说，难一点。但是并不是说Hibernate就死难学，只是有一定的曲线而已，毕竟Hibernate是全自动ORM，而MyBatis是半自动ORM。</p>
<p>&emsp;&emsp;我的结论是：如果是外包这种，查询，插入数据量大，表关联复杂，MyBatis来的合适。如果是微服务这种，单表操作比较多，Hibernate来的合适。如果说数据库确定不会迁移，需要用到数据库底层功能，那么MyBatis来的合适，就比如说Oracle。如果说屏蔽数据库底层细节，那么Hibernate来的合适。</p>
<p>&emsp;&emsp;不过两者有个共同点，那就是数据库相关只是得熟。从零开始的项目的话，我会选择Hibernate(JPA)，如果说遗留项目，用的MyBatis，那就继续用吧，写的好的话，后来人写的也舒服。有DBA的话，用MyBatis不要太爽，没有的话，就只能看开发人员水平。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>串的模式匹配算法</title>
    <url>/2019/04/09/Data%20Struct/StringMatcher/</url>
    <content><![CDATA[<blockquote>
<p>面试常见题</p>
</blockquote><p>&emsp;&emsp;给定一个串，然后给其一个子串，获取<strong>子串在串中的下标</strong>，LeetCode也收录了这个问题。</p><a id="more"></a>

<p>&emsp;&emsp;解法一：贪婪法</p>
<p>&emsp;&emsp;假设有两个串，主串A，子串B。首先说循环A，然后循环B，判断子串中的值和主串中的是否完全一致，如果不一致的话，A开始下一次循环，继续这个过程。最欢情况的话，就是O(m*n)。这个是最容易想到的，也是最简单的一个，同时也是最慢的一个。</p>
<p>&emsp;&emsp;解法二：KMP算法</p>
<p>&emsp;&emsp;如下图所示，如果T[2] != P[2]，按照贪婪法，应该是T移动到1，P移动到0，然后重新开始匹配。而KMP算法的目的，就是说跳过无用的匹配，使其无用操作变少。</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/01.jpg" alt="KMP示例"></p>
<p>&emsp;&emsp;KMP算法的核心，就是next数组，需要通过next数组，来获取其移位的长度。<strong><em>next[i]，i从1开始计算，则表示，除去第i个数，在一个字符串里面从第一个数到第(i-1)字符串前缀和后缀最长重复的个数</em></strong>。而这个个数，就是子串移位的长度。</p>
<p>&emsp;&emsp;公式(图片来源于网络)如下</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/02.png" alt="next函数公式"></p>
<p>&emsp;&emsp;举例说明前缀和后缀，在”abcd”中，前缀为”abc”，后缀为”bcd”。</p>
<p>&emsp;&emsp;举例模式串为：<strong>ABAAAABC</strong>，用大写看起来舒服点。</p>
<p>&emsp;&emsp;子串说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>各个子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最大公共元素长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>无</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>AB</td>
<td>A</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>ABA</td>
<td><font color="red">A</font>；AB</td>
<td><font color="red">A</font>；BA</td>
<td>1</td>
</tr>
<tr>
<td>ABAA</td>
<td><font color="red">A</font>；AB；ABA</td>
<td><font color="red">A</font>；AA；BAA</td>
<td>1</td>
</tr>
<tr>
<td>ABAAA</td>
<td><font color="red">A</font>；AB；ABA；<br>ABAA</td>
<td><font color="red">A</font>；AA；AAA；<br>BAAA</td>
<td>1</td>
</tr>
<tr>
<td>ABAAAA</td>
<td><font color="red">A</font>；AB；ABA；<br>ABAA；ABAAA</td>
<td><font color="red">A</font>；AA；AAA；<br>AAAA；BAAAA</td>
<td>1</td>
</tr>
<tr>
<td>ABAAAAB</td>
<td>A；<font color="red">AB</font>；ABA；<br>ABAA；ABAAA；ABAAAA</td>
<td>B；<font color="red">AB</font>；AAB；<br>AAAB；AAAAB；<br>BAAAAB</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;用一张图来表示next函数的执行过程：</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/03.png" alt="next函数执行过程"></p>
<p>接下来简述一下next函数的执行过程，我们用P来代表上面的子串。</p>
<ol>
<li><p>第一步，i=j=0，第一步没有可比较对象，所以<strong>next[0]=0，i++</strong>。</p>
</li>
<li><p>第二步，i=1，j=0。P[i]!=P[j]。next[1]=0，i++**。</p>
</li>
<li>第三步，i=2，j=0。P[i]==P[j]。next[2]=next[j]+1=1，i++，j++**。</li>
<li><p>第四步，i=3，j=1。P[i]!=P[j]。j = next[j-1]，再次进行对比，P[i]==P[j-1]，j = j-1+1，i++。</p>
</li>
<li><p>第五步，同上</p>
</li>
<li>第六步，同上</li>
<li>第七步，同上</li>
<li>第八步，同上</li>
</ol>
<p>next函数的代码如下，写的并不严谨，只表示主要思路，仅供参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取滑动位的算法，这个算法思路很简单。就是对比前缀和后缀，看其中重复的子串的长度，则就是next[]函数的值</span></span><br><span class="line"><span class="comment">  * 但是要注意的是，前缀必须从头开始算，后缀必须从最后一个数开始算</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(String expression, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//第一个已经固定死为0了。</span></span><br><span class="line">     <span class="keyword">while</span> (i &lt; expression.length()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">             next[i] = <span class="number">0</span>;</span><br><span class="line">             i++;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果相等的话</span></span><br><span class="line">         <span class="keyword">if</span> (Objects.equals(expression.charAt(i), expression.charAt(j))) &#123;</span><br><span class="line">             System.out.println(<span class="string">"expression.charAt(i) is "</span> + expression.charAt(i) + <span class="string">"  expression.charAt(j) is "</span> + expression.charAt(j));</span><br><span class="line">             next[i] = j + <span class="number">1</span>;</span><br><span class="line">             j++;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                 j = next[j - <span class="number">1</span>];</span><br><span class="line">                 System.out.println(<span class="string">"expression.charAt(i) is "</span> + expression.charAt(i) + <span class="string">"  expression.charAt(j) is "</span> + expression.charAt(j));</span><br><span class="line">                 <span class="keyword">if</span> (Objects.equals(expression.charAt(i), expression.charAt(j))) &#123;</span><br><span class="line">                     next[i] = j + <span class="number">1</span>;</span><br><span class="line">                     j++;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">"i --------&gt; "</span> + i + <span class="string">" j-------------&gt;"</span> + j + <span class="string">"  next["</span> + i + <span class="string">"] = "</span> + next[i]);</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; next.length; k++) &#123;</span><br><span class="line">         System.out.print(next[k] + <span class="string">"  "</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;至此，next数组就已经全部获取到了。接下来就是，利用这个next数组，来查询子串是否存在并且返回下标。如下图所示：</p>
<p><img src="https://wenslo-blog.oss-cn-beijing.aliyuncs.com/Data%20Structures%20and%20Algorithms/StringMatcher/04.png" alt="next数组使用"></p>
<p>执行过程描述：</p>
<ol>
<li><p>第一次执行，匹配到S[i] != P[j]的时候，从next数组中获取其前一位的值（next[j-1] = 0）</p>
<p>于是能够知道，下一次对比，是从P[0]开始，OK。j=0，i++。</p>
</li>
<li><p>第二次执行，匹配到S[i] != P[j]的时候，从next数组中获取其前一位的值（next[j-1] = 2）</p>
<p>于是能够知道，下一次对比，是从P[2]开始，OK。j=2，i=i+k。</p>
</li>
<li><p>第三次执行。全部匹配，OK，退出，返回下标。</p>
</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(String common, String expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] commonCharArray = common.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] expressionCharArray = expression.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[expression.length()];</span><br><span class="line">        next(expression, next);</span><br><span class="line">        <span class="keyword">int</span> commonLength = common.length();</span><br><span class="line">        <span class="keyword">int</span> patternLength = expression.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; commonLength) &#123;</span><br><span class="line">            <span class="keyword">int</span> incrementValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; patternLength) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(commonCharArray[i + incrementValue], expressionCharArray[k])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k == patternLength - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i - (k - incrementValue);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                        incrementValue++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = k + i;</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">                        k = next[k - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用栈实现中缀转后缀</title>
    <url>/2019/04/08/Data%20Struct/StackAlgorithm1/</url>
    <content><![CDATA[<p>&emsp;&emsp;代码比较长，就不写了，写一写思路。举例：2+1-5+(5-8)*2</p><ol>
<li>常规数字，直接输出，碰到符号的话，对比优先级，然后判断是否出栈，优先级高的话，入栈，否则，出栈，小括号()优先级最高</li>
<li>输出2 +入栈</li>
<li>输出1，由于+和-的优先级相同，+出栈，-入栈 21+</li>
<li>输出5，由于+和-的优先级相同，-出栈，+入栈 21+5-</li>
<li>输出5 碰到小括号，优先级最大，(入栈，21+5-5</li>
<li>输出8，栈里已经有了小括号，所以说，-直接输出 21+5-58-</li>
<li>碰到小括号，优先级最大。所以小括号出栈，碰到<em>号，优先级大于栈里的+，所以</em>入栈，输出2，21+5-58-2</li>
<li>已经没东西了，栈里的依次出栈输出，结果为21+5-58-2*+</li>
</ol><a id="more"></a>

<p>&emsp;&emsp;其实应该说配几张图的。。。但是hexo图片还没想好到底要不要存阿里或者腾讯。好了再补，估计是不补了，写的应该足够</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈和队列</title>
    <url>/2019/04/07/Data%20Struct/StackQueue/</url>
    <content><![CDATA[<p>&emsp;&emsp;<strong>栈（Last In First Out）</strong>和<strong>队列（First In First Out）</strong></p><a id="more"></a>
<p>&emsp;&emsp;细分的话，可以分为<strong>顺序栈</strong>，<strong>链栈</strong>，<strong>顺序队列</strong>，<strong>链队</strong>。也就是一个用<strong>数组</strong>实现，一个用<strong>链表</strong>实现，区别的话，也就是顺序存储和链式存储的区别。而JDK中util下的Stack，<strong>实现是顺序栈</strong>。</p>
<p>&emsp;&emsp;栈一般有两个指针，<strong>top和base</strong>，top指向栈顶，base指向栈底。这样的话，<strong>top==base</strong>，说明栈空，<strong>top-base&gt;=stacksize</strong>的话，则说明栈满。</p>
<p>&emsp;&emsp;JDK的Stack的pop实现，是先进行peek()，然后remove()。这就说明了pop和peek的区别，pop是<strong>弹出栈顶元素</strong>，peek，顾名思义，偷看，<strong>只查看栈顶元素</strong>。JDK中是<strong>并没有</strong>提供链栈的实现的，没有说和List一样，提供一个接口，然后提供ArrayList和LinkedList两种实现。只有一个Stack的类，继承与Vector。但是看源码能够知道，util的LinkedList包含有peek，pop，push这些方法。也就是说<strong><em>LinkedList完全可以将其当成是链栈来用</em></strong>！LinkedList支持栈的操作，那么同理，ArrayList应该也支持栈的操作。毕竟都是线性表么。因此，区别的话就能知道：<strong>ArrayList和LinkedList不是线程安全，而Stack是线程安全的</strong>。</p>
<p>&emsp;&emsp;补充一下，ArrayList和LinkedList都实现的栈和队列的方法。</p>
<p>&emsp;&emsp;现代化的计算机将栈作为它的指令系统的一部分，也就是说，<strong>栈很可能是计算机科学中除了数组之后的最基本的数据结构</strong>。</p>
<p>&emsp;&emsp;用栈来实现进制转换很容易，除以n，然后余数压入栈中，依次进行，最后依次出栈。</p>
<p>&emsp;&emsp;<strong>递归</strong>实际上就是利用栈来实现的，自调用，层层入栈，层层出栈。</p>
<p>&emsp;&emsp;队列一般<strong>长度固定</strong>，然后实现是<strong>循环队列</strong>。这样的话，能够合理利用空间。用front指向队头，用tail指向队尾。front==tail的时候，就说明队列为空。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2019/04/06/Data%20Struct/List/</url>
    <content><![CDATA[<p>&emsp;&emsp;线性表分大致两种实现：<strong>顺序实现</strong>，<strong>链表实现</strong>。</p><p>&emsp;&emsp;对于顺序实现来说，特点有这么几个：1、<strong>基于数组</strong>，2、<strong>Locate是常数时间O(1)</strong>，3、<strong>插入和删除要移动大量元素，最坏情况为O(N)，平均情况为线性时间，最好情况是O(1)</strong></p><a id="more"></a>

<p>&emsp;&emsp;对于链表实现来说，特点是这么几个：1、<strong>元素不连续存储</strong>，2、<strong>Locate是线性时间</strong>，3、<strong>插入、删除开销小</strong>。</p>
<p>&emsp;&emsp;链表分类有：<strong>单向链表</strong>，<strong>循环链表</strong>，<strong>双向链表</strong>，<strong>双向循环链表</strong>。单向链表的话，只有一个next指针指向下一个元素；循环链表的话，tail.next-&gt;head；双向链表的话，一个next指针，一个prev指针；双向循环链表的话，head-&gt;tail，tail-&gt;head;</p>
<p>&emsp;&emsp;对于顺序实现的插入和删除，实现步骤如下：<strong>插入的时候</strong>，需要看其原先的位置有没有元素，如果没有，则直接赋值即可。但是如果有值的话，则需要将该位置之后的元素通通向后后移一位。<strong>删除的时候</strong>同理，删除了元素之后，该元素之后的数据，需要通通向前移动一位。</p>
<p>&emsp;&emsp;对于链式存储的插入和删除，实现步骤如下：<strong>插入的时候</strong>，看位置有没有元素，没有，直接赋值进去，同时看有没有上一个元素，有的话，prev指向上一个元素，否则，自己作为头结点。如果有元素，麻烦一点，首先得看这个元素是不是头节点，是头结点，那插入之后，自己的next需要指向之前的头结点。不是头结点的话，自己的next指到上一个元素的next，那上一个元素的next指向自己，自己的prev指到上一个元素。<strong>删除的时候</strong>，和插入的判断差不多，不想写了，意思差求不多。</p>
<p>&emsp;&emsp;用list实现多项式的相加，也就是<strong>合并多项式</strong>，写一下思路吧，代码不写了，和归并差不太多，多了一层判断，也就是比较大小的时候，需要对比多项式<strong>指数部分</strong>是否相等，相等的话，合并多项式，就完了。多项式相减也是同理。</p>
<p>&emsp;&emsp;写LinkedList的时候，参考了一下jdk的源码，发现个有意思的事情。在jdk中，getElement的时候，做了一层优化，<strong>根据下标，判断是否小于size/2，小于的话，则从前开始遍历，否则，从后往前开始遍历。</strong>这样的话，减少了不必要的遍历。而且，获取node的时候，这通常第一就会想到递归。但是，jdk并不是用递归进行的处理，而是用的循环，这样性能上相对于递归来说更好。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;又发现个有意思的事情，jdk的LinkedList，是<strong>双链表</strong>，记录有头尾节点，因此，添加元素直接对尾节点进行操作就可以，速度很快。而C语言描述中，是<strong>单链表</strong>，则添加为O(n)。先往后看看，可能刚开始只是用单链表演示而已。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-前言</title>
    <url>/2019/04/05/Data%20Struct/Preface/</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><blockquote>
<p> 程序=数据机构+算法</p>
</blockquote><p>&emsp;&emsp;如果主要是写企业级应用的话，其实绝大多数都是JAVA，算法的作用，相对来说不是那么大。因为说，C，C++这种的更加偏重于算法。而JAVA这种，难就难在生态的庞大。但是说，不能说数据结构和算法都不用学了，那和码农有什么区别？没有哪个程序员说是想一辈子写业务性的CURD的吧？面试，如果有算法的话，能刷掉至少百分之九十的人，我们为何不成为那百分之十的人？</p><a id="more"></a>

<p>&emsp;&emsp;之前这写一点笔记，那写一点笔记，三天打鱼两天晒网，完了之后自己还是啥也不会，其实不太好。这样并不是一个持续性成长的过程，可能过了一年之后，发现自己啥也不会。也有可能发现自己啥都会，哈哈，然后随随便便往深了一问，得，扑街。</p>
<p>&emsp;&emsp;其实应该用C来写的，但是C写起来着实是麻烦。先用Java写吧，等完了之后，看《深入理解计算机系统》这本书的时候，再用C搞搞，理解还能更深刻一点。</p>
<p>&emsp;&emsp;Here we go!</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>前言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/04/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Spring Security记录1</title>
    <url>/2019/04/05/Spring%20Security/Step1/</url>
    <content><![CDATA[<blockquote>
<p>Spring Security 官方推荐的安全控制框架</p>
</blockquote>]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
</search>
